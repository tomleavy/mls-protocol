{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2022-01-06T01:14:19.881626+00:00",
  "repo": "mlswg/mls-protocol",
  "labels": [
    {
      "name": "bug",
      "description": "",
      "color": "ce373a"
    },
    {
      "name": "duplicate",
      "description": "",
      "color": "ffffff"
    },
    {
      "name": "enhancement",
      "description": "",
      "color": "95c9f4"
    },
    {
      "name": "help wanted",
      "description": "",
      "color": "73e29a"
    },
    {
      "name": "invalid",
      "description": "",
      "color": "ffffff"
    },
    {
      "name": "question",
      "description": "",
      "color": "d4dd54"
    },
    {
      "name": "wontfix",
      "description": "",
      "color": "ffffff"
    },
    {
      "name": "editorial",
      "description": "",
      "color": "ffc6d6"
    },
    {
      "name": "security",
      "description": "",
      "color": "ce373a"
    },
    {
      "name": "recommendation",
      "description": "",
      "color": "f7c9b7"
    },
    {
      "name": "work in progress",
      "description": "",
      "color": "08768e"
    },
    {
      "name": "terminology",
      "description": "",
      "color": "ffc6d6"
    },
    {
      "name": "weekly-digest",
      "description": "",
      "color": "ffffff"
    },
    {
      "name": "privacy",
      "description": "",
      "color": "ce373a"
    },
    {
      "name": "performance",
      "description": "",
      "color": "2c52aa"
    },
    {
      "name": "? stall",
      "description": "",
      "color": "FFFFFF"
    },
    {
      "name": "discussion",
      "description": "",
      "color": "08768e"
    },
    {
      "name": "functionality",
      "description": "",
      "color": "95c9f4"
    },
    {
      "name": "? follow-up",
      "description": "",
      "color": "ffffff"
    },
    {
      "name": "ready to merge",
      "description": "",
      "color": "08768e"
    },
    {
      "name": "ready for review (by editors)",
      "description": "",
      "color": "08768e"
    },
    {
      "name": "? invalid",
      "description": "",
      "color": "ffffff"
    },
    {
      "name": "build",
      "description": "",
      "color": "fcd058"
    },
    {
      "name": "today! (?)",
      "description": "Things that can probably be dispatched on today's call",
      "color": "c2e0c6"
    },
    {
      "name": "key schedule",
      "description": "",
      "color": "0052cc"
    },
    {
      "name": "analysis",
      "description": "",
      "color": "ce373a"
    },
    {
      "name": "interoperability",
      "description": "",
      "color": "2c52aa"
    }
  ],
  "issues": [
    {
      "number": 7,
      "id": "MDU6SXNzdWUyOTA0NjMwNzM=",
      "title": "Discuss all the *ART deletion options",
      "url": "https://github.com/mlswg/mls-protocol/issues/7",
      "state": "CLOSED",
      "author": "katrielalex",
      "authorAssociation": "MEMBER",
      "assignees": [
        "jmillican"
      ],
      "labels": [
        "functionality",
        "wontfix"
      ],
      "body": "We talked about quite a number of different ways to do deletion in *ART groups. Give at least a high-level overview of the main ones, and mention their pros and cons. These include:\r\n\r\n- just rebuild the tree\r\n  - Pros: simple, easy, no extra operations\r\n  - Cons: inefficient, puts the deleter in a trusted position in the group until _every_ remaining member has updated\r\n- update deletee's key to blank\r\n  - Pros: fairly simple, no extra operations\r\n  - Cons: puts the deleter in a trusted position until the sibling or cousin of the deletee has updated\r\n- send a delete secret over pairwise channels\r\n  - Pros: no trusted positions\r\n  - Cons: O(N), leaves a potentially-compromised leaf node in the tree\r\n- send a delete secret by KEMing to everyone else\r\n  - Pros: no trusted positions, efficient\r\n  - Cons: leaves a potentially-compromised leaf node in the tree, multiple deletes interact in a complex way",
      "createdAt": "2018-01-22T13:20:52Z",
      "updatedAt": "2019-12-17T10:42:13Z",
      "closedAt": "2019-01-07T22:55:25Z",
      "comments": [
        {
          "author": "katrielalex",
          "authorAssociation": "MEMBER",
          "body": "I don't quite follow the deletion algorithm that's in there at the moment. Does it require double-join bookkeeping, @bifurcation? If so I can add a note about that.",
          "createdAt": "2018-01-29T15:50:07Z",
          "updatedAt": "2018-01-29T15:50:07Z"
        },
        {
          "author": "jmillican",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm going to look at clarifying deletion in the doc; but essentially we're going for replace-then-blank in this initial draft. Keeping punctured trees is an option we should discuss once it's out there.",
          "createdAt": "2018-01-30T01:12:55Z",
          "updatedAt": "2018-01-30T01:12:55Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@katrielalex I think the algorithm in #59 is explicitly double-joined.  When I get time, I'll file another PR to move to the delete-without-double-join algorithm I posted to the list (i.e., puncture the tree).",
          "createdAt": "2018-09-10T22:10:45Z",
          "updatedAt": "2018-09-10T22:10:45Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Since we're no longer using ART, I think this issue is no longer relevant.",
          "createdAt": "2019-01-07T22:55:25Z",
          "updatedAt": "2019-01-07T22:55:25Z"
        }
      ]
    },
    {
      "number": 21,
      "id": "MDU6SXNzdWUyOTMyNDk0NjM=",
      "title": "Trivial DoS by a malicious client",
      "url": "https://github.com/mlswg/mls-protocol/issues/21",
      "state": "CLOSED",
      "author": "katrielalex",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "? follow-up",
        "functionality"
      ],
      "body": "At the end of the London meetup we discussed a potential problem: malicious clients can send a bad copath (e.g. just random group elements), which will totally screw up the group state of anyone who processes the update. This was not considered a valid attack in ART, which does not consider malicious clients or DoS, but is more of a problem here. In particular, one can imagine a group with the convention \"invite anybody, delete people who misbehave\" (e.g. like many IRC channels).\r\n\r\nThere are a few ways to handle this:\r\n\r\n- Ignore it: if you add someone malicious and they screw up your group state, well, you shouldn't have done that.\r\n- Wait for confirmation: when you receive a copath, don't trust it until someone else from the other part of the tree has sent an update, proving that they know the new DH value.\r\n- Something else",
      "createdAt": "2018-01-31T17:40:36Z",
      "updatedAt": "2019-12-17T10:41:26Z",
      "closedAt": "2019-10-30T21:51:36Z",
      "comments": [
        {
          "author": "cascremers",
          "authorAssociation": "COLLABORATOR",
          "body": "I think as Richard suggested in the London meeting, there may be a\r\nrelatively simple way to leverage log N zero knowledge proofs here. From\r\nthe top of my head, at the lowest level, the thing to prove is that a\r\nkey on the copath is in fact g^(a b') for a secret new b' and known g^b'\r\nand g^a, without revealing b'. If we can make this work, it probably can\r\nbe made to work for the whole copath.\r\n",
          "createdAt": "2018-01-31T23:35:36Z",
          "updatedAt": "2018-02-01T06:53:20Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Since the model for TreeKEM is \"replace the public key for node X by encrypting the new private key to one of the child public keys\", you could prevent malicious key updates with publicly verifiable key escrow. The Delivery Service would verify the escrow and could then discard the proof -- users don't need to check it.\r\n\r\nThere's a construction for non-ECC Diffie-Hellman [here](https://link.springer.com/content/pdf/10.1007/3-540-68339-9_17.pdf). I was also looking at [NTRUEncrypt](https://en.wikipedia.org/wiki/NTRUEncrypt) and you could probably do key escrow like this:\r\n\r\n1. Encrypt the new private key `(f, g)` to public key `h` in two separate ciphertexts:\r\n    `e_1 = r_1*h + f` and `e_2 = r_2*h + g`\r\n    and publish the new public key:\r\n    `h' = p * f_q * g`\r\n2. User provides Pedersen commitments on an Elliptic Curve to the coefficients of `r_1` and `r_2`.\r\n3. User proves that the commitments are all to small values, -1 / 0 / 1.\r\n4. DS can use knowledge of `e_{1,2}` and `h` to derive commitments to `f` and `g`.\r\n5. User proves that these commitments are all to small values as well.\r\n6. DS derives a secondary commitment to `g` by following `g = f * (1/p) * h'` with its commitment to `f`.\r\n7. User proves that the two commitments to `g` are equivalent.\r\n\r\nSecond encryption of the same private key to a different public key:\r\n1. User provides Pedersen commitments on an Elliptic Curve to the coefficients of `r_3` and `r_4`.\r\n2. DS uses knowledge of `e_{3,4}` and `h_2` to derive commitments to `f` and `g`.\r\n3. User proves that these commitments are the same as the first commitments to `f` and `g`.\r\n\r\nI think proof size is around 200-300kb. Pedersen commitments are computationally binding and perfectly hiding, so I can't *currently* forge a proof and a *future* quantum computer can't use the commitments to decrypt the private key.",
          "createdAt": "2018-10-08T20:47:33Z",
          "updatedAt": "2018-10-08T20:47:33Z"
        },
        {
          "author": "grittygrease",
          "authorAssociation": "NONE",
          "body": "Another option that was discussed at the second interim is to use message franking to achieve a weaker property: the ability to prove to the server and other group members that a bad update was sent retroactively.  This doesn't allow the server to block broken updates from being distributed but does allow a broken member to report that the group has been split. This has the downside that there is no good general recovery strategy other than tearing down the group.\r\n\r\nNote: This would only protect against KEMing the wrong secret key to the correct public key (The DoS scenario), not KEMing to the wrong public key.",
          "createdAt": "2019-01-15T22:45:23Z",
          "updatedAt": "2019-01-15T22:45:23Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "On further discussion, two options:\r\n\r\n* ECIES uses committing AEAD, and the reporting party reveals the ephemeral symmetric key\r\n* Add a DLEQ proof of the ephemeral symmetric key\r\n* If the public key encryption scheme is determinstic given some randomness, you could reveal the randomness\r\n\r\nIn either case, the reporting party reveals the (incorrect) secret that was ECIES encrypted to it.",
          "createdAt": "2019-01-15T23:00:00Z",
          "updatedAt": "2019-01-15T23:05:42Z"
        },
        {
          "author": "grittygrease",
          "authorAssociation": "NONE",
          "body": "I sat down and white-boarded this with some colleagues and I *think* we came up with something that works. I would love someone to poke a hole in it immediately. I came up with one attack below and a potential mitigation.\r\n\r\nModifications to the protocol:\r\n- Every update message for a node should additionally include a salted hash of the secret value of that node (e.g. H(H(k), salt) or H(H^5(k), salt)). Given an \"incorrect\" node secret value, a verifier can use this to find an inconsistent node message.\r\n- Adding a Schnorr NIZK of knowledge (RFC 8235) of the random value *r* with every ECIES ciphertext \r\n\r\nSay node A with the private key *a* (and public key *aP) was given an incorrect update consisting of an ECIES ciphertext: (c, rP), where *c* is the encryption of the node secret, *r* is the random value and *P* is the public group point. Node A can provide a proof that this value is inconsistent with the other updates in the tree without revealing their private key with the following reveal:\r\n\r\narP, DLEQ(arP:rP :: P:aP)\r\n\r\nWith this information, any validator would compute k = KDF(arP), decrypt *c* with *k*, then know the node secret that was encrypted to node A. Since this node secret is bogus, they would hash it upwards with the public salt and compare with the salted hashes provided with the other updates until the discrepancy is found.\r\n\r\n\r\nWhy the Schnorr NIZK is necessary:\r\nAt first look, this seemed to be a valid solution since the DLEQ proof prevented A from lying about their ECIES key in the computation of k. However, while writing this down, I came up with a potential adversarial construction that makes this reveal more dangerous. A crafty adversary could choose the random value *r* to be related to a previously used random value in such a way that revealing arP would compromise a previous group state. For example, say that a previous update to A used the random value *r* (and therefore rP is public). The attacker B could choose the random value rP that they would include as part of their ECIES ciphertext to be rP+P = (r+1)P and a random ciphertext c. In this case, party A would be forced to reveal a(r+1)P, which anyone can subtract a known public value for aP to get arP, which was used to protect previous group state. This makes it far less likely that A would report the attack since doing so would reveal the previous group state and compromise confidentiality. The Schnorr NIZK proves that an rP chosen by the attacker can't just be a manipulation of previous r values. They really have to know r. The caveat here is that the attacker can still choose the same r as in a previous message and break confidentiality, but repeated r values should be strictly disallowed anyway.\r\n",
          "createdAt": "2019-01-18T01:16:58Z",
          "updatedAt": "2019-01-18T01:16:58Z"
        }
      ]
    },
    {
      "number": 35,
      "id": "MDU6SXNzdWUyOTM2OTU4OTU=",
      "title": "Fix Terminology alignment",
      "url": "https://github.com/mlswg/mls-protocol/issues/35",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [
        "beurdouche"
      ],
      "labels": [
        "terminology"
      ],
      "body": "We need to discuss and agree on consistent definitions and terminology across documents.\r\nI'll implement the changes for -02",
      "createdAt": "2018-02-01T21:49:39Z",
      "updatedAt": "2019-12-17T10:41:05Z",
      "closedAt": "2018-10-14T12:25:44Z",
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "The Architecture document is moving to use the same terminology as the Protocol document\r\nhttps://github.com/mlswg/mls-architecture/pull/40\r\n\r\nClosing here.",
          "createdAt": "2018-10-14T12:25:44Z",
          "updatedAt": "2018-10-14T12:25:44Z"
        }
      ]
    },
    {
      "number": 47,
      "id": "MDU6SXNzdWUzMDI5Nzk4NDU=",
      "title": "Possible typo in diagram?",
      "url": "https://github.com/mlswg/mls-protocol/issues/47",
      "state": "CLOSED",
      "author": "sylph01",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Please correct me if my understanding is wrong:\r\n\r\n* The diagram of \"user-initiated join\" shows `UserAdd(.->D)` and `state.add(D)` initiated by user `Z`. Isn't it `UserAdd(.->Z)` and `state.add(Z)`?\r\n* The diagram of Update shows `Update(A)` message from server telling A and B to `state.upd(D)` and Z to `state.upd(A)`. Shouldn't all of them be `state.upd(A)`, because A initiated the update?",
      "createdAt": "2018-03-07T06:30:37Z",
      "updatedAt": "2019-12-17T10:40:54Z",
      "closedAt": "2018-07-16T16:50:11Z",
      "comments": [
        {
          "author": "josephlhall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 I was going to fix this with a PR today but some of these ladder diagrams are just mysterious enough to make it probably something @bifurcation should look at in his copious free time.",
          "createdAt": "2018-07-15T13:56:40Z",
          "updatedAt": "2018-07-15T13:56:40Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Fixed in https://github.com/ekr/mls-protocol/commit/c81dd324d4e8a894766d5965c78f6d4ad68907ad ...\r\nThanks ! :)",
          "createdAt": "2018-07-16T16:50:11Z",
          "updatedAt": "2018-07-16T16:50:30Z"
        }
      ]
    },
    {
      "number": 57,
      "id": "MDU6SXNzdWUzNTM5ODY0NTk=",
      "title": "When can we use it?",
      "url": "https://github.com/mlswg/mls-protocol/issues/57",
      "state": "CLOSED",
      "author": "cbwang2016",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "question"
      ],
      "body": "I can't wait to see the implementations. ",
      "createdAt": "2018-08-25T05:52:41Z",
      "updatedAt": "2019-12-17T10:40:44Z",
      "closedAt": "2018-09-10T22:09:25Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the enthusiasm, but I don't think this is a spec issue :)\r\n\r\n",
          "createdAt": "2018-09-10T22:09:25Z",
          "updatedAt": "2018-09-10T22:09:25Z"
        }
      ]
    },
    {
      "number": 70,
      "id": "MDU6SXNzdWUzNjk4NTc5NzU=",
      "title": "s5.1. _subtree_ definition",
      "url": "https://github.com/mlswg/mls-protocol/issues/70",
      "state": "CLOSED",
      "author": "seanturner",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "I think there's something missing from the following sentence in s5.1:\r\n\r\n    A _subtree_ of a tree is the tree given by the descendants of any\r\n    node, the _head_ of the subtree The _size_ of a tree or subtree is\r\n    the number of leaf nodes it contains.",
      "createdAt": "2018-10-14T01:34:41Z",
      "updatedAt": "2019-01-07T22:54:30Z",
      "closedAt": "2019-01-07T22:54:30Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "It's a missing period.  This is fixed in master now, not sure which commit.",
          "createdAt": "2019-01-07T22:54:30Z",
          "updatedAt": "2019-01-07T22:54:30Z"
        }
      ]
    },
    {
      "number": 76,
      "id": "MDU6SXNzdWUzNzMwMzk4MjQ=",
      "title": "Retry considerations",
      "url": "https://github.com/mlswg/mls-protocol/issues/76",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement",
        "performance",
        "recommendation"
      ],
      "body": "We have some text about how Handshake messages need to be sequenced, but clients will need some retry logic to deal with cases where there's a gap between the premise for their action and the state of the group when the action can be taken.  We should describe the logic a client should follow for retrying with each of the available operations.  For example, Update can just be retried, but Add and Remove should be checked for duplication before retrying.",
      "createdAt": "2018-10-23T14:44:39Z",
      "updatedAt": "2020-01-31T15:13:53Z",
      "closedAt": "2020-01-31T15:13:53Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Notes from interim 2019-01:\r\n* Unclear whether this should be done in the protocol or the architecture document.\r\n* For cases where the server assists / rejects messages, should that be part of the protocol?",
          "createdAt": "2019-01-14T18:21:14Z",
          "updatedAt": "2019-01-14T18:21:14Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this issue falls under the same general conclusion as #92 (handle in a follow-on specification).",
          "createdAt": "2020-01-31T15:13:52Z",
          "updatedAt": "2020-01-31T15:13:52Z"
        }
      ]
    },
    {
      "number": 86,
      "id": "MDU6SXNzdWUzOTg2MDk1MzQ=",
      "title": "Add-in-Place / Garbage Collection",
      "url": "https://github.com/mlswg/mls-protocol/issues/86",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bifurcation"
      ],
      "labels": [
        "performance"
      ],
      "body": "Currently, the tree only ever grows:\r\n\r\n* When you add someone, you have to add them at the right edge, even if there are blank leaves\r\n* When you remove someone, the tree never shrinks\r\n\r\nWe should enable reclaiming of blank leaves and automatically reduce the size of the tree to the minimum necessary size.",
      "createdAt": "2019-01-13T01:35:29Z",
      "updatedAt": "2019-12-17T10:40:25Z",
      "closedAt": "2019-03-06T08:44:27Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "After discussion at 2019-01 interim: Agreement that this seems OK as long as we can verify that the tree invariant holds when you truncate the tree.",
          "createdAt": "2019-01-15T22:38:41Z",
          "updatedAt": "2019-01-15T22:38:41Z"
        }
      ]
    },
    {
      "number": 87,
      "id": "MDU6SXNzdWUzOTg2MTE1MzI=",
      "title": "Allow server to cache the roster / tree",
      "url": "https://github.com/mlswg/mls-protocol/issues/87",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "? follow-up",
        "performance",
        "privacy"
      ],
      "body": "Currently, clients are expected to cache the entire roster and tree (of size `n` and `2n-1`, respectively), and the `Welcome` message provides these to the new joiner by value.  In principle it's possible to create a scheme where:\r\n\r\n* The members of the group agree on a commitment to the roster / tree instead of the objects themselves\r\n* Each Handshake message includes the information necessary to update the commitment\r\n* ... and a proof of the signer's inclusion in the roster, relative to the current roster commitment\r\n\r\nFor example, if the roster were committed as a Merkle tree root, an Add message could come with (1) an inclusion proof for the signer's public key, relative to the prior tree root; and (2) a consistency proof between the prior tree root and the updated root.\r\n\r\nThis would open up a spectrum of options for how much state the clients have to cache (note that the client has to cache its direct path in any case, to be able to decrypt TreeKEM encryptions).  The current draft would be on one end, with clients storing everything.  The other end would have clients store nothing and handshake messages just carrying new entropy and updating commitments.\r\n\r\nAs an example of an intermediate state, if you assume that Updates are more common than Adds/Removes, you could require each client to cache its own copath.  Then Add/Remove/Update messages would have to provide enough information about the tree to allow the other clients to update their copaths (in addition to updating the commitments).\r\n",
      "createdAt": "2019-01-13T02:14:46Z",
      "updatedAt": "2019-12-17T10:40:04Z",
      "closedAt": "2019-10-30T21:51:37Z",
      "comments": []
    },
    {
      "number": 88,
      "id": "MDU6SXNzdWUzOTg2MTE4Mzc=",
      "title": "\"Pre-warm\" trees with some double-joined nodes",
      "url": "https://github.com/mlswg/mls-protocol/issues/88",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "raphaelrobert"
      ],
      "labels": [
        "performance",
        "security"
      ],
      "body": "In the current draft, creating a group is done with `n` Add messages, which just place the members of the group at the leaves of the tree.  This means that newly-created trees have some \"warm up\" time during which early operations are roughly linear size, gradually converging to log size.\r\n\r\nThis state of affairs is unavoidable if we are not going to have double joins.  However, it might be tolerable to have double joins, so long as (1) they only happen at group creation time and (2) they resolve relatively quickly.\r\n\r\nFor example, you might create a special `Init` message, distinct from Add, which initializes a tree with the members at the leaves, but also some intermediate nodes filled in by the creator (and thus double-joined).  These nodes would be overwritten as members update, but the double-joins would only be fully resolved once all members update (or `1/2^{k}` of the members if `k` lower layers are not double-joined).",
      "createdAt": "2019-01-13T02:20:33Z",
      "updatedAt": "2019-12-17T10:39:33Z",
      "closedAt": "2019-10-02T08:26:42Z",
      "comments": [
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing until deployment shows we need this.",
          "createdAt": "2019-10-02T08:26:42Z",
          "updatedAt": "2019-10-02T08:26:42Z"
        }
      ]
    },
    {
      "number": 89,
      "id": "MDU6SXNzdWUzOTg2MTI1NjA=",
      "title": "Encryption of Welcome messages",
      "url": "https://github.com/mlswg/mls-protocol/issues/89",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "privacy",
        "security"
      ],
      "body": "This was resolved in #80, but recording it in this issue for posterity.  A Welcome message carries the `init_secret` value for the group, and so it needs to be encrypted for the new joiner.\r\n\r\nThe struct proposed in the revised draft wraps the information in the Welcome in an ECIES ciphertext, and adds enough information to enable the joiner to identify the private key it needs to decrypt the Welcome message.\r\n\r\n```\r\nstruct {\r\n  opaque group_id<0..255>;\r\n  uint32 epoch;\r\n  optional<Credential> roster<1..2^32-1>;\r\n  optional<PublicKey> tree<1..2^32-1>;\r\n  opaque transcript_hash<0..255>;\r\n  opaque init_secret<0..255>;\r\n} WelcomeInfo;\r\n\r\nstruct {\r\n  opaque user_init_key_id<0..255>;\r\n  CipherSuite cipher_suite;\r\n  ECIESCiphertext encrypted_welcome_info;\r\n} Welcome;\r\n```",
      "createdAt": "2019-01-13T02:34:51Z",
      "updatedAt": "2019-12-17T10:39:24Z",
      "closedAt": "2019-01-15T22:44:04Z",
      "comments": []
    },
    {
      "number": 90,
      "id": "MDU6SXNzdWUzOTg2MTI3NTU=",
      "title": "Simplify the key schedule",
      "url": "https://github.com/mlswg/mls-protocol/issues/90",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bifurcation",
        "beurdouche"
      ],
      "labels": [
        "enhancement"
      ],
      "body": "Currently, the whole GroupState object is folded into the key schedule, via the `DeriveSecret` function.  Could this be simplified?  For example:\r\n\r\n* Hash the GroupState object once, and use it for all `DeriveSecret` calls, as opposed to passing it by value each time\r\n\r\n* Hash in the roster and tree as a commitment (cf #87) rather than by value\r\n\r\nOther suggestions welcome.",
      "createdAt": "2019-01-13T02:38:23Z",
      "updatedAt": "2019-12-17T10:42:51Z",
      "closedAt": "2019-05-01T01:14:03Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we can get away with using the transcript hash if we put a little more information in the transcript.  In particular, the Welcome message needs to be included to assure that the new joiner and the group have the same view of the group state bits in the Welcome message.",
          "createdAt": "2019-01-15T22:43:07Z",
          "updatedAt": "2019-01-15T22:43:07Z"
        }
      ]
    },
    {
      "number": 91,
      "id": "MDU6SXNzdWUzOTg2MTM2NTg=",
      "title": "User-Initiated Add",
      "url": "https://github.com/mlswg/mls-protocol/issues/91",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement",
        "work in progress"
      ],
      "body": "Currently, in order for a new member to join a group, an existing member needs to add them to the group.  Certain use cases work more naturally if a new joiner can initiate the add process.  I think that broadly speaking we want a process here where someone outside the group can (1) request to be added and (2) send to the group, but cannot receive from the group until added.\r\n\r\nSome things to consider here:\r\n\r\n* Anything that is revealed to a joiner that joins this way is effectively public.  Should they be able to see, e.g., the roster?\r\n\r\n* How should these interactions relate to the key schedule?  Assuming there's some `AddRequest` message, should it be included into the transcript at Add time?\r\n\r\n* What happens if there are multiple parallel requests?",
      "createdAt": "2019-01-13T02:56:32Z",
      "updatedAt": "2020-06-19T12:53:42Z",
      "closedAt": "2020-06-19T12:53:42Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "At the 2019-01 interim, we discussed a \"reversed Add\" flow, where:\r\n\r\n* Group publishes an InitKey\r\n* The new joiner sends a UIK to the group and establishes a shared secret with the group\r\n* This initiates a period where the new joiner can send, but nobody in the group can\r\n* Before anyone in the group can send, they have to send a Welcome for the new joiner\r\n* ... which initiates an epoch where they are fully joined",
          "createdAt": "2019-01-15T22:48:10Z",
          "updatedAt": "2019-01-15T22:48:10Z"
        },
        {
          "author": "ipmipest",
          "authorAssociation": "NONE",
          "body": "In certain use cases, such as enterprise messaging there may/could/might be a problem if \"**Any** member of the group can download an ClientInitKey for a new client and broadcast an Add message\". An enterprise may wish to enforce access restrictions for certain information such as ClientInitKey. Just thinking about security related issues that may be most easily noticed by corp IT types.\r\n\r\nOn the other hand this may be best dealt with outside the protocol scope.\r\n",
          "createdAt": "2019-06-27T21:41:54Z",
          "updatedAt": "2019-06-27T21:41:54Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "@bifurcation I think this is fixed by #240 correct? A user can propose to Add herself.",
          "createdAt": "2019-11-14T17:41:49Z",
          "updatedAt": "2019-11-14T17:41:49Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Partly addressed by #240.  To complete the story, we need a \"send-to-group-from-outside\" mechanism.  Leaving this open until we have that.",
          "createdAt": "2019-11-14T18:25:49Z",
          "updatedAt": "2019-11-14T18:25:49Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think a \"send-to-group-from-outside\" mechanism will be possible, given that we try quite hard to prevent any key material from inside the group from ever being published.",
          "createdAt": "2020-05-30T03:54:57Z",
          "updatedAt": "2020-05-30T03:54:57Z"
        }
      ]
    },
    {
      "number": 92,
      "id": "MDU6SXNzdWUzOTg2MTM3NzI=",
      "title": "ACK / NACK",
      "url": "https://github.com/mlswg/mls-protocol/issues/92",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement"
      ],
      "body": "In early discussions around MLS, people expressed interest in specifying how to do ACKs / NACKs on messages.  Questions to address:\r\n\r\n* How are ACKs / NACKs encoded?\r\n* How are they cryptographically protected? (signed, encrypted, MAC'ed, etc.)\r\n* When should they be sent?\r\n* Do they apply to handshake messages?  application messages?  both?",
      "createdAt": "2019-01-13T02:58:54Z",
      "updatedAt": "2020-01-31T15:11:28Z",
      "closedAt": "2020-01-31T15:11:27Z",
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "We should discuss that today",
          "createdAt": "2019-10-01T07:06:28Z",
          "updatedAt": "2019-10-01T07:06:28Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "This was discussed at the January 2020 interim.  The conclusion there was that error recovery is a sufficiently complex topic that it merits a separate specification, which may extend the protocol, e.g., to add an Ack message or a Resync proposal.",
          "createdAt": "2020-01-31T15:11:27Z",
          "updatedAt": "2020-01-31T15:11:27Z"
        }
      ]
    },
    {
      "number": 93,
      "id": "MDU6SXNzdWUzOTg2MTM5ODA=",
      "title": "State resync",
      "url": "https://github.com/mlswg/mls-protocol/issues/93",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement",
        "security",
        "work in progress"
      ],
      "body": "Sometimes a client falls out of sync with the rest of the group, and it is necessary to re-initialize it.  What protocol mechanisms are necessary to make this possible? \r\n\r\n* How do endpoints discover that they have lost sync?\r\n* How do they resync?\r\n* Who can provide resync data?  the server?  other clients?\r\n\r\nPerhaps it would be useful to look at the state of the art with regard to how desync occurs and how it repaired.",
      "createdAt": "2019-01-13T03:03:12Z",
      "updatedAt": "2020-01-31T15:14:24Z",
      "closedAt": "2020-01-31T15:14:23Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "* Effectively Remove+Add, either in-group or server-initiated\r\n  * Without Proposals, would probably want a \"Re-add\" message\r\n  * With proposals, this can just comprise Remove + Add proposals\r\n* Might want to suppress UX in such cases, i.e., don't show \"X left.  X joined.\"\r\n* Desirable to provide some proof of prior membership in the group\r\n  * Unclear if there's a plausible story for how the proof would be stored\r\n ",
          "createdAt": "2019-10-02T11:28:18Z",
          "updatedAt": "2019-10-02T11:28:18Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this issue falls under the same general conclusion as #92 (handle in a follow-on specification).",
          "createdAt": "2020-01-31T15:14:23Z",
          "updatedAt": "2020-01-31T15:14:23Z"
        }
      ]
    },
    {
      "number": 95,
      "id": "MDU6SXNzdWUzOTkwMzE3OTg=",
      "title": "Decouple curves from symmetric+hash identifiers",
      "url": "https://github.com/mlswg/mls-protocol/issues/95",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "beurdouche"
      ],
      "labels": [
        "editorial",
        "functionality"
      ],
      "body": "* Enable, e.g., P-256 with both AES-GCM and ChaChaPoly\r\n* Re-use code points from TLS",
      "createdAt": "2019-01-14T19:09:54Z",
      "updatedAt": "2019-12-17T10:39:09Z",
      "closedAt": "2019-11-14T17:17:23Z",
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "We should discuss that today",
          "createdAt": "2019-10-01T07:07:08Z",
          "updatedAt": "2019-10-01T07:07:08Z"
        }
      ]
    },
    {
      "number": 96,
      "id": "MDU6SXNzdWUzOTkwMzMyOTY=",
      "title": "Clarify uniqueness constraints on UIK IDs",
      "url": "https://github.com/mlswg/mls-protocol/issues/96",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "beurdouche"
      ],
      "labels": [
        "recommendation",
        "security"
      ],
      "body": "Consumers should not assume that UIK IDs are unique across users.",
      "createdAt": "2019-01-14T19:14:03Z",
      "updatedAt": "2019-12-17T10:38:57Z",
      "closedAt": "2019-03-11T06:37:19Z",
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "The current text says:\r\n```\r\nUserInitKeys also contain an identifier chosen by the client, which the client\r\nMUST assure uniquely identifies a given UserInitKey object among the\r\nset of UserInitKeys created by this client.\r\n```\r\n\r\nWould it be realistic to say that the Delivery Service MUST check when storing a key that the UIK identifier is not used by another key ? @bifurcation @raphaelrobert ",
          "createdAt": "2019-03-10T12:32:29Z",
          "updatedAt": "2019-03-10T12:33:36Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I'd be fine with that requirement for the DS.",
          "createdAt": "2019-03-10T16:33:50Z",
          "updatedAt": "2019-03-10T16:33:50Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Given that arch PR and the fact that the doc already says \"the client MUST assure uniquely identifies a given UserInitKey object among the set of UserInitKeys created by this client\", I think we can call this fixed.",
          "createdAt": "2019-03-11T06:37:16Z",
          "updatedAt": "2019-03-11T06:37:16Z"
        }
      ]
    },
    {
      "number": 97,
      "id": "MDU6SXNzdWUzOTkwMzM1MTg=",
      "title": "CIK rotation",
      "url": "https://github.com/mlswg/mls-protocol/issues/97",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "beurdouche"
      ],
      "labels": [
        "enhancement"
      ],
      "body": "Security considerations should provide guidance about how often to rotate, last resort, etc.",
      "createdAt": "2019-01-14T19:14:41Z",
      "updatedAt": "2019-12-20T16:32:54Z",
      "closedAt": "2019-12-20T16:32:54Z",
      "comments": []
    },
    {
      "number": 98,
      "id": "MDU6SXNzdWUzOTkwMzM4MTQ=",
      "title": "Handshake message encryption",
      "url": "https://github.com/mlswg/mls-protocol/issues/98",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "privacy",
        "security"
      ],
      "body": "As proposed on the list, we should re-use the encrypted-message framing for encrypted handshake messages.  For better key separation, we might derive a separate set of keys for this purpose (the academics prefer this).\r\n\r\nIf we do key separation, we should have a separate sequence number space.  In any case, a type field will be needed to distinguish.",
      "createdAt": "2019-01-14T19:15:30Z",
      "updatedAt": "2019-12-17T10:38:41Z",
      "closedAt": "2019-05-02T17:46:12Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Note that adding handshake encryption might make analysis significantly more complicated.",
          "createdAt": "2019-01-15T23:57:17Z",
          "updatedAt": "2019-01-15T23:57:17Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Technically, this will be done via the common framing layer, but we should have some discussion of how to apply it / what the trade-offs are.",
          "createdAt": "2019-03-20T15:47:33Z",
          "updatedAt": "2019-03-20T15:47:33Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #155 ",
          "createdAt": "2019-05-02T17:46:12Z",
          "updatedAt": "2019-05-02T17:46:12Z"
        }
      ]
    },
    {
      "number": 100,
      "id": "MDU6SXNzdWUzOTkxMTgzMzY=",
      "title": "Allow multiple Proposals and/or one Commit in an MLSPlaintext",
      "url": "https://github.com/mlswg/mls-protocol/issues/100",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bifurcation"
      ],
      "labels": [
        "functionality",
        "performance",
        "security"
      ],
      "body": "This allows combo operations -- multiple adds, moves, resyncs -- without having to worry about getting interrupted mid-operation.",
      "createdAt": "2019-01-14T23:16:11Z",
      "updatedAt": "2019-12-17T10:38:05Z",
      "closedAt": "2019-11-14T18:24:44Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "On discussion at the interim 2019-01: It may be better to do not just throw a blind combo layer in here, but rather to have more operation types.  That way, we can fully think through the implications of each one.",
          "createdAt": "2019-01-16T00:04:50Z",
          "updatedAt": "2019-01-16T00:04:50Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Deferred for further discussion on the mailing list.",
          "createdAt": "2019-01-16T00:05:05Z",
          "updatedAt": "2019-01-16T00:05:05Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Repurposing this issue for combo moves with regard to Proposals and Commits.  We should cover the following cases:\r\n\r\n* One or more Proposals with no Commit\r\n* A Commit with no Proposals\r\n* One or more Proposals bundled with a Commit\r\n\r\nIt seems like something like the following would be appropriate:\r\n\r\n```\r\nstruct{\r\n  Proposal proposals<0..2^16-1>;\r\n  optional<Commit> commit;\r\n} Handshake;\r\n```\r\n\r\n... together with a requirement that at least one of them be populated.",
          "createdAt": "2019-10-01T21:42:29Z",
          "updatedAt": "2019-10-01T21:42:29Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "At the interim:\r\n* Commit must cover all Proposals in the same message\r\n* As a result, if any of the Proposals are invalid, then the whole thing fails",
          "createdAt": "2019-10-02T08:31:22Z",
          "updatedAt": "2019-10-02T08:31:22Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #242 ",
          "createdAt": "2019-11-14T18:24:44Z",
          "updatedAt": "2019-11-14T18:24:44Z"
        }
      ]
    },
    {
      "number": 101,
      "id": "MDU6SXNzdWUzOTkxMTk2ODA=",
      "title": "Use common framing",
      "url": "https://github.com/mlswg/mls-protocol/issues/101",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bifurcation"
      ],
      "labels": [
        "functionality",
        "performance",
        "security"
      ],
      "body": "We have several types of top-level objects right now:\r\n\r\n* UserInitKey messages\r\n* Welcome messages\r\n* Handshake messages\r\n* Application messages\r\n\r\nWe should have a common framing layer that describes the object type (and optionally provides encryption), to prevent confusion among these types.  This would be analogous to the [TLS record layer](https://tlswg.github.io/tls13-spec/draft-ietf-tls-tls13.html#rfc.section.5.1)",
      "createdAt": "2019-01-14T23:21:24Z",
      "updatedAt": "2019-12-17T10:37:53Z",
      "closedAt": "2019-05-02T17:46:04Z",
      "comments": [
        {
          "author": "katrielalex",
          "authorAssociation": "MEMBER",
          "body": "(cc @alexsherkin when they accept the invite :) )",
          "createdAt": "2019-01-16T00:07:25Z",
          "updatedAt": "2019-01-16T00:07:25Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussion with @beurdouche and @raphaelrobert \r\n* Some desire for privacy of header fields\r\n  * Encrypt using a group key?\r\n  * MAC (for low-entropy values like `sender`, `generation`)\r\n  * Not doing this for -04, but note an OPEN ISSUE to discuss in Prague\r\n* Likewise, concerns about using application keys for Handshake messages -> OPEN ISSUE\r\n* @beurdouche will try to mature #131 in the next few days, otherwise we can do #120 \r\n",
          "createdAt": "2019-02-28T14:55:38Z",
          "updatedAt": "2019-02-28T14:55:38Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #155 ",
          "createdAt": "2019-05-02T17:46:04Z",
          "updatedAt": "2019-05-02T17:46:04Z"
        }
      ]
    },
    {
      "number": 102,
      "id": "MDU6SXNzdWUzOTk0Mzg3NzI=",
      "title": "Replay protection",
      "url": "https://github.com/mlswg/mls-protocol/issues/102",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "beurdouche"
      ],
      "labels": [
        "? follow-up",
        "security"
      ],
      "body": "We should ensure that there is adequate anti-replay protection for both Handshake and Application messages.  (In particular, we should define what anti-replay issues are a concern.)  Could be related to #101 if we want to solve it at that framing layer.",
      "createdAt": "2019-01-15T16:52:28Z",
      "updatedAt": "2019-12-17T10:37:33Z",
      "closedAt": "2019-09-30T12:20:45Z",
      "comments": [
        {
          "author": "alexsherkin",
          "authorAssociation": "NONE",
          "body": "It looks like application key schedule on its own may not be enough to prevent replay attacks if out-of-order messages are supported (and it seems like they are supported according to section 9.2.1).\r\n\r\nLets say we are at epoch x, and the receiver derives application_secret_[sender]_[0] for epoch x. Then, the receiver receives message1 (generation = 1) first before message0. In order to decrypt message1, the receiver needs to advance the application secret forward once to application_secret_[sender]_[1] to get message1 nonce and AEAD secret. The receiver then happily processes message 1. However, the receiver cannot forget application_secret_[sender]_[0] at this time; otherwise it will never be able to decrypt message0 so it has to keep application_secret_[sender]_[0] around.\r\n\r\nIf the receiver receives message1 again, it can compute application_secret_[sender]_[1] from application_secret_[sender]_[0] and process the message. Hence, it seems that key schedule on its own will not prevent replay attacks. The receiver needs to remember that it has already processed message1.\r\n\r\nThe same problem may apply to receiving a message from epoch N+1 while not all messages from epoch N have been received (if such case is possible).\r\n\r\nReplay attack counter-measures may be implemented as part of key schedule logic or separately, but it looks like implementors need to pay attention to this.",
          "createdAt": "2019-01-18T19:31:44Z",
          "updatedAt": "2019-01-18T19:31:44Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Obviously, if you keep a previous application secret, you are breaking FS. This is forbidden by the protocol. The protocol mandates: \"Receivers MUST delete an Application Secret once it has been used to derive the corresponding AEAD key and nonce as well as the next Application Secret. Receivers MAY keep the AEAD key and nonce around for some reasonable period.\"",
          "createdAt": "2019-01-18T19:57:43Z",
          "updatedAt": "2019-01-18T19:57:43Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Cf. \"Updating the Application Secret\"",
          "createdAt": "2019-01-18T20:02:34Z",
          "updatedAt": "2019-01-18T20:02:34Z"
        },
        {
          "author": "alexsherkin",
          "authorAssociation": "NONE",
          "body": "Does it mean that receiving out-of-order messages is not possible? If I abandon application_secret_[sender][0] and advance to application_secret_[sender][2] after receiving message 1 before message 0, I will never be able to process message 0. Is this intended behavior or am I missing something?",
          "createdAt": "2019-01-18T20:36:37Z",
          "updatedAt": "2019-01-18T20:36:37Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "No, you can do out of order, but what you keep are the AEAD keys/nonces and not the Application Secrets. \r\n\r\nThe idea is the following:\r\n1 - Compute Application Secret[sender][0]\r\n2 - Derive AEAD Key[Sender][0] and AEAD Nonce[Sender][0] from Application Secret[sender][0]\r\n3 - Overwrite Application Secret[sender][0] with Application Secret[sender][1]\r\nBasically, you should see these 3 steps as a single operation\r\nNow, if you iterate over that you can get more AEAD Keys and nonces [0 ... N] to receive out of order.\r\nBecause of step 3 you have local Forward Secrecy. Note that you never store more than a single (the latest) Application Secret per sender and that you have the keys [0...N] to decrypt out of order.",
          "createdAt": "2019-01-18T20:53:41Z",
          "updatedAt": "2019-01-18T20:55:02Z"
        },
        {
          "author": "alexsherkin",
          "authorAssociation": "NONE",
          "body": "Makes sense. Thanks for explaining. I suspect receiving out of order messages from a different epoch works in a similar way. If I am at epoch 0, and I receive a message from epoch 2, I derive and keep application_secret for epoch 1 and roll the init_secret forward.\r\n\r\nFrom the implementation perspective, how do I know when I can safely discard an application secret for a particular epoch? Or how do I know that no more messages are coming for a particular sender/epoch?\r\n\r\nDo you think there is value in adding a paragraph clarifying how the key schedule ensures replay attack protection to the spec? I know these are probably all implementation questions, but I suspect these may be the questions the implementors may be asking.\r\n\r\n",
          "createdAt": "2019-01-20T16:33:47Z",
          "updatedAt": "2019-01-20T16:33:47Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "@alexsherkin \r\n\r\nI have some text stashed for when to discard the previous application secrets after there is a new epoch, so I will handle that. The idea is that you \"publish\" the number of application messages you sent in the previous epoch, but that is to be discussed...\r\n\r\nRegarding replay, if you asked, it means clarification might be helpful here, do you want to submit a PR and assign me for review ? Otherwise just tell me and I'll handle it... : )",
          "createdAt": "2019-01-22T22:09:21Z",
          "updatedAt": "2019-01-22T22:09:21Z"
        },
        {
          "author": "alexsherkin",
          "authorAssociation": "NONE",
          "body": "@beurdouche I think you should review the below and update the spec as you see fit : )\r\n\r\n-- I would update section 9.2.1 with something like:\r\n\r\nIf receiver's application secret is at generation N, and the receiver receives an out of order message with generation N+x (where x>0), the receiver MUST advance the application secret forward to application secret N+x+1 after processing the out of order message. For every message with generation between N and N+x-1 (messages that have not been received), the receiver SHOULD derive AEAD nonce and AEAD key and store them in order to be able to decrypt these messages later. Application secret MUST NOT be kept at generation N in order allow for decryption of out-of-order messages. Instead, stored AEAD key and nonce will allow for decryption of out-of-order messages when received later.\r\n\r\n\r\n-- We may also introduce a short new section \"Message Replay Protection\" with something like:\r\n\r\nApplication key schedule provides replay attack counter-measures. If a message is replayed, the receiver should not have the right AEAD key nor have the application secret that could be used for deriving the right AEAD key for the replayed message. Hence, replayed message will be rejected by the receiver. ",
          "createdAt": "2019-01-23T22:20:26Z",
          "updatedAt": "2019-01-23T22:20:26Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is adequately addressed by #146 and #155 ",
          "createdAt": "2019-09-30T12:18:58Z",
          "updatedAt": "2019-09-30T12:18:58Z"
        }
      ]
    },
    {
      "number": 103,
      "id": "MDU6SXNzdWUzOTk0Mzk5NDU=",
      "title": "Simplify nonce generation",
      "url": "https://github.com/mlswg/mls-protocol/issues/103",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement"
      ],
      "body": "Right now, nonces used to encrypt application messages are derived off the key schedule.  Since the keys are effectively single-use, this could probably be done more simply, e.g., by using the generation number as the nonce.",
      "createdAt": "2019-01-15T16:54:51Z",
      "updatedAt": "2019-12-17T10:36:37Z",
      "closedAt": "2019-01-16T00:20:06Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "The rationale for random nonces is a time/space tradeoff with mass surveillance on 128-bit keyspaces. See:\r\nhttps://tools.ietf.org/rfcmarkup?doc=8446#appendix-E.2\r\nand\r\nhttps://eprint.iacr.org/2016/564",
          "createdAt": "2019-01-16T00:20:02Z",
          "updatedAt": "2019-01-16T00:20:02Z"
        }
      ]
    },
    {
      "number": 104,
      "id": "MDU6SXNzdWUzOTk0NDE0MTc=",
      "title": "Server-initiated removal",
      "url": "https://github.com/mlswg/mls-protocol/issues/104",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "raphaelrobert"
      ],
      "labels": [
        "functionality",
        "security"
      ],
      "body": "Long-term inactive users undermine the FS and PCS properties of the protocol.  Obviously, users can remove each other if they notice that a participant is inactive.  We should consider whether we want to allow the server to do such a removal.",
      "createdAt": "2019-01-15T16:58:12Z",
      "updatedAt": "2019-12-17T10:35:48Z",
      "closedAt": "2019-11-14T17:16:10Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussion at interim 2019-01: \r\n* Could do this as \"server-instructed\" vs. \"server done\"\r\n  * i.e., server instructs a client to do a remove\r\n  * But this causes some ambiguity w.r.t. the rest of the group\r\n* The only difference between Remove and a server-initiated variant would be signature\r\n* Other use cases: \r\n  * User deletes account\r\n  * User is no longer authorized to be in group\r\n* Application would need to set policy about whether / when server-initiated actions would be allowed\r\n",
          "createdAt": "2019-01-16T00:31:45Z",
          "updatedAt": "2019-01-16T00:31:45Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm assigning this to draft-04 under the theory that the signature changes that will come about as a result of #101 will make it straightforward to have an additional key for the server that can be used to sign Adds / Removes.  If that doesn't turn out to be the case, this might get deferred.",
          "createdAt": "2019-02-26T19:38:36Z",
          "updatedAt": "2019-02-26T19:38:36Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "After discussion with @beurdouche and @raphaelrobert: \r\n* There will be a need to signal that a non-member key is being used, e.g., with some reserved `sender` values\r\n* Do the participants in the group need to agree the set of allowed non-member signers?  If some members accept a signer, others don't, then you can get partition\r\n* -04 will focus on Remove, not Add, and punt on the agreement question; we assume the application maintains consistency of the view of authorized signers.",
          "createdAt": "2019-02-28T14:23:20Z",
          "updatedAt": "2019-02-28T14:24:08Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "We should push some of this to the application layer in order to not introduce a new handshake message with problematic authenticity (agreement on the list of non-members who can sign handshake messages).\r\n\r\nThe server could publish an \"intent to remove\" that will be honored by the first client to come online.\r\nThe actual Remove HS message will be issued by a member of the group. It can additionally be attached to the server intent to remove, so that clients can convey more contextual information to users.\r\n\r\nExample: \r\n\r\n - Server issues the intent to remove Alice from the group.\r\n - Bob comes online first after that and send a regular Remove HS message to remove Alice and links it to the sever intent.\r\n - Other members of the group can now display \"Alice was removed\" instead of \"Bob removed Alice\" to the user.\r\n\r\nIn this example Bob is the first member to come online, but it could really be any other member.\r\n\r\nThis has the advantage that the protocol remains unaffected as such, while the desired behavior is still achieved.",
          "createdAt": "2019-03-11T16:43:30Z",
          "updatedAt": "2019-03-11T16:43:30Z"
        }
      ]
    },
    {
      "number": 105,
      "id": "MDU6SXNzdWUzOTk1NDg1NjY=",
      "title": "Version negotiation",
      "url": "https://github.com/mlswg/mls-protocol/issues/105",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bifurcation"
      ],
      "labels": [
        "functionality",
        "security"
      ],
      "body": "We need some story for how to evolve versions over time.  How and where is version support indicated?  How can a group transition from one version to another?",
      "createdAt": "2019-01-15T21:43:13Z",
      "updatedAt": "2019-12-17T10:35:40Z",
      "closedAt": "2019-10-01T21:48:12Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "It seems like the right answer here is roughly the same as for ciphersuites -- advertise support in UserInitKey, select in Welcome.",
          "createdAt": "2019-02-26T19:37:03Z",
          "updatedAt": "2019-02-26T19:37:03Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "For -04, this will be a preliminary effort.  @beurdouche points out that there are more subtle considerations here, e.g., what remains constant across versions.  But we'll go ahead and put something basic in -04, as a basis for discussion.",
          "createdAt": "2019-02-28T14:12:27Z",
          "updatedAt": "2019-02-28T14:12:27Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Moving to -05 to see if we need something more.",
          "createdAt": "2019-03-11T06:38:42Z",
          "updatedAt": "2019-03-11T06:38:42Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Per discussion at interim, this is adequately addressed by:\r\n\r\n* Stating a version in ClientInitKey (in current draft)\r\n* Providing a list of supported versions in CIK to prevent downgrade (#224)\r\n\r\nSo closing this in favor of #224 ",
          "createdAt": "2019-10-01T21:48:10Z",
          "updatedAt": "2019-10-01T21:48:10Z"
        }
      ]
    },
    {
      "number": 107,
      "id": "MDU6SXNzdWU0MDEwNDE5NzQ=",
      "title": "Application key schedule is busted",
      "url": "https://github.com/mlswg/mls-protocol/issues/107",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "beurdouche"
      ],
      "labels": [
        "bug"
      ],
      "body": "There are at least two bugs in the message protection section that make it unimplementable:\r\n\r\n1. It calls for `Derive-Secret(., \"app sender\", [sender])`, but the third argument to `Derive-Secret` as defined is a `GroupState`, not an octet string.\r\n\r\n2. It refers to a function `HKDF-Expand-Label`, which is defined in TLS, but not here.\r\n\r\nISTM the simplest way to fix these problems would to define `HKDF-Expand-Label` and use it (1) as the basis for `Derive-Secret`, (2) for deriving sender root secrets, and (3) for deriving keys and nonces.",
      "createdAt": "2019-01-19T22:37:48Z",
      "updatedAt": "2019-12-17T10:35:17Z",
      "closedAt": "2019-02-21T11:41:30Z",
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Fixed by #123 ",
          "createdAt": "2019-02-21T11:41:29Z",
          "updatedAt": "2019-02-21T11:41:29Z"
        }
      ]
    },
    {
      "number": 108,
      "id": "MDU6SXNzdWU0MDE5MjQ1ODk=",
      "title": "Some undefined terms and primitives",
      "url": "https://github.com/mlswg/mls-protocol/issues/108",
      "state": "CLOSED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "beurdouche"
      ],
      "labels": [
        "editorial"
      ],
      "body": "I think a bunch of these are probably relics of previous versions. For reference, the page numbers listed are from the PDF version of draft 3 of the protocol:\r\n\r\n- [x] 1 - p6: `GroupInit` is mentioned, but it is not defined anywhere in the specification. Perhaps `Init` is intended.\r\n\r\n- [x] 2 - p19: A `transcript` field is mentioned, but only `transcript_hash` is present. Also it's unclear which `Hash` function is supposed to be used here. It can't be ciphersuite-dependent, since it has to be the same for every Participant.\r\n\r\n- [x] 3 - p22: `update_secret` is used in a diagram, but never defined. I think this is important, and it's mentioned elsewhere.\r\n\r\n- [x] 4 - p24: `finished_mac` is mentioned, but never defined. Is it supposed to say `confirmation`?\r\n\r\n- [ ] 5 - p25: The underlying Hash that HMAC uses can't be defined by anyone's ciphersuite. This is group state, and everyone has to agree on this.\r\n\r\n- [x] 6 - p28: Mentioned \"update secret\" again without explanation.\r\n\r\n- [x] 7 - p29: \"identity tree\" is mentioned, but I can't tell what that's referring to. Also \"update secret\" is here.\r\n\r\n- [x] 8 - p35: `MLSPlaintext` is mentioned, but never defined. Perhaps `ApplicationPlaintext` is intended.",
      "createdAt": "2019-01-22T19:47:02Z",
      "updatedAt": "2019-03-01T09:34:09Z",
      "closedAt": "2019-03-01T09:34:08Z",
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Thanks a lot for the review, this is very useful.\nI have a pass planned for this week and will fix these issues :)\n",
          "createdAt": "2019-01-22T20:08:59Z",
          "updatedAt": "2019-01-22T20:08:59Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "@rozbb A PR #126 was opened with fixes for points 1, 2, 4, 7. Point 8 was already solved.\r\nAn issue has been opened #125 to solve points 3 and 6 related to the update secret definition.\r\nI tried to figure out your point 5 but I didn't understand it, can you give details ?",
          "createdAt": "2019-02-23T10:55:39Z",
          "updatedAt": "2019-02-23T10:55:39Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sorry for the delay. I think point 5 was a misunderstanding over when a common ciphersuite is established in the protocol. I'm still not 100% clear on it, but I think I'm just missing something simple. Consider it withdrawn.",
          "createdAt": "2019-02-28T22:41:12Z",
          "updatedAt": "2019-02-28T22:41:12Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Ok, then these issues are fixed by #126 and #125. Thanks",
          "createdAt": "2019-03-01T09:34:08Z",
          "updatedAt": "2019-03-01T09:34:08Z"
        }
      ]
    },
    {
      "number": 110,
      "id": "MDU6SXNzdWU0MDE5NzE5MDA=",
      "title": "Syntax unification",
      "url": "https://github.com/mlswg/mls-protocol/issues/110",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [
        "beurdouche"
      ],
      "labels": [
        "editorial"
      ],
      "body": "We inconsistently use the backtick, the underscore or nothing for messages fields or specific operations in the draft. This needs a fix, currently the opinion is to use the TLS style (aka remove everything)",
      "createdAt": "2019-01-22T21:57:05Z",
      "updatedAt": "2019-11-16T14:41:03Z",
      "closedAt": "2019-11-16T14:41:03Z",
      "comments": []
    },
    {
      "number": 112,
      "id": "MDU6SXNzdWU0MDE5Nzg4Nzk=",
      "title": "Discarding Application secrets from the previous Epoch",
      "url": "https://github.com/mlswg/mls-protocol/issues/112",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [
        "beurdouche"
      ],
      "labels": [
        "recommendation",
        "security"
      ],
      "body": "In the current draft it is not known to the other group members when to discard the participant application secret from the previous epoch. My formal specification sends the 4 byte application message counter of the previous epoch within the first application message of each participant in the new epoch. Discuss and PR.",
      "createdAt": "2019-01-22T22:17:07Z",
      "updatedAt": "2019-12-17T10:35:05Z",
      "closedAt": "2019-05-17T14:27:58Z",
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "This can be handled as part of #140 and #160",
          "createdAt": "2019-05-17T14:27:58Z",
          "updatedAt": "2019-05-17T14:27:58Z"
        }
      ]
    },
    {
      "number": 117,
      "id": "MDU6SXNzdWU0MDgyMjYxMjM=",
      "title": "Key and nonce should have separate lengths",
      "url": "https://github.com/mlswg/mls-protocol/issues/117",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "bug"
      ],
      "body": "This text is wrong:\r\n\r\n```\r\n   key = HKDF-Expand(Secret, ECIESLabel(\"key\"), Length)\r\n   nonce = HKDF-Expand(Secret, ECIESLabel(\"nonce\"), Length\r\n```",
      "createdAt": "2019-02-08T16:26:27Z",
      "updatedAt": "2019-12-17T10:34:44Z",
      "closedAt": "2019-02-21T11:42:59Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "This could also be addressed by using draft-barnes-cfrg-hpke.",
          "createdAt": "2019-02-08T16:27:49Z",
          "updatedAt": "2019-02-08T16:27:49Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "This has been fixed by #116 ",
          "createdAt": "2019-02-21T11:42:59Z",
          "updatedAt": "2019-02-21T11:42:59Z"
        }
      ]
    },
    {
      "number": 118,
      "id": "MDU6SXNzdWU0MTAxODUyNzg=",
      "title": "Discuss DH cofactor issues and Update DH and Elliptic Curve parameters text.",
      "url": "https://github.com/mlswg/mls-protocol/issues/118",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Sof\u00eda noted \"It is also unclear at some points the notation used for the Diffie-Hellman or\r\nElliptic Curve parameters. Related to this, is unsure if this protocol takes\r\ninto account the cofactor issues.\"\r\n",
      "createdAt": "2019-02-14T08:34:55Z",
      "updatedAt": "2020-06-19T12:53:42Z",
      "closedAt": "2020-06-19T12:53:42Z",
      "comments": [
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What precisely is unclear? X25519 specifies the scalar-clamping that's used to remove the 8-torsion part of the given curve point. And P-256 is a prime curve, so it has no cofactor.",
          "createdAt": "2019-02-14T17:05:58Z",
          "updatedAt": "2019-02-14T17:05:58Z"
        },
        {
          "author": "claucece",
          "authorAssociation": "NONE",
          "body": "Well, it only says:\r\n\r\n```\r\nGiven an octet string X, the private key produced by the Derive-Key-Pair operation is SHA-256(X).\r\n (Recall that any 32-octet string is a valid Curve25519 private key.) The corresponding public key is\r\n X25519(SHA-256(X), 9).\r\n\r\nImplementations SHOULD use the approach specified in {{RFC7748}} to calculate the Diffie-Hellman\r\n shared secret. \r\n```\r\n\r\nIt does not refer that you are referring to section 'The X25519 and X448 Functions' of the RFC (if so). And actually, I think it is referred to the subsection in that section where is says \"To implement the X25519(k, u) and X448(k, u)\". \r\n\r\nIt also says:\r\n\r\n```\r\nIf implementers use an alternative implementation of these elliptic curves, they SHOULD perform the\r\n additional checks specified in Section 7 of {{RFC7748}}\r\n```\r\n\r\nwhich does not recommend taking into account that \"For X25519, in order to decode 32 random bytes as an integer scalar, set the three least significant bits of the first byte and the most significant bit of the last to zero, set the second most significant bit of the last byte to 1 and, finally, decode as little-endian. \" (the clamping mechanism).\r\n\r\nIt is a little bit unclear from the text how the generation of the shared secret happens, as it does not point to an specific part of the RFC, nor specify if the encoding/decoding functions are needed.\r\n\r\nBut this is just my read ;)\r\n\r\n> And P-256 is a prime curve, so it has no cofactor.\r\n\r\nPrecisely. But this section is a little bit more defined. Compare:\r\n\r\n```\r\nP-256 ECDH calculations (including parameter and key generation as well as the shared secret\r\n calculation) are performed according to {{IEEE1363}} using the ECKAS-DH1 scheme with the identity\r\n map as key derivation function (KDF), so that the shared secret is the x-coordinate of the ECDH\r\n shared secret elliptic curve point represented as an octet string. Note that this octet string (Z in IEEE\r\n 1363 terminology) as output by FE2OSP, the Field Element to Octet String Conversion Primitive, has\r\n constant length for any given field; leading zeros found in this octet string MUST NOT be truncated.\r\n```\r\n\r\n\r\n:)\r\n",
          "createdAt": "2019-02-15T17:15:52Z",
          "updatedAt": "2019-02-15T17:16:36Z"
        },
        {
          "author": "claucece",
          "authorAssociation": "NONE",
          "body": "And around unclear:\r\n\r\n- The definition of `Derive-Key-Pair` used to derive the private key, is defined as \"The ciphersuite must also specify an algorithm Derive-Key-Pair that maps octet strings with the same length as the output of the hash function to key pairs for the asymmetric encryption scheme.\". It is unclear how this algorithm looks in practice. It seems to imply that this function takes any amount of same length octet strings as input (generated as an output of a hash function) and map to create a private key and a public key somehow. \r\n\r\n- It says \"Given an octet string X, the private key produced by the Derive-Key-Pair operation is SHA-256(X). (Recall that any 32-octet string is a valid Curve25519 private key.) The corresponding public key is X25519(SHA-256(X), 9).\" If you don't read the RFC, it is unclear that the \"9 is the u-coordinate of the base point and is encoded as a byte with value 9, followed by 31 zero bytes\". It also does not specify if the private key should have been generated from randomness. \r\n\r\n- When saying \"Encryption keys are derived from shared secrets by taking the first 16 bytes of H(Z), where Z is the shared secret and H is SHA-256.\", it seems like 'H(input)' could be defined somewhere else previously. Maybe it should be in place to have a definition section for the different functions, like on the RFC7748 in \"3.  Notation\"?\r\n\r\n- When it says \"Generate an ephemeral DH key pair (x, x * G) in the DH group specified by the ciphersuite in use\", does this refer only to the usage of elliptic curves (as it generates the public key as 'x*G'? Maybe if it is DH, it should be noted as 'g^x'?\r\n\r\nThis is just some things that were unclear for me when reading :) Perhaps they are discussed somewhere else. It also depends on how self-contained that document wants to be. \r\n\r\nHope this helps :)",
          "createdAt": "2019-02-15T17:49:40Z",
          "updatedAt": "2019-02-15T17:53:31Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah, ok. These seem like fair points. I had thought that X25519 specifies that clamping be done on every call to `X25519(k, u)`, but I see now that it's done once in the decoding step and then never again. Also that P-256 excerpt was very informative. Thanks!",
          "createdAt": "2019-02-15T17:51:33Z",
          "updatedAt": "2019-02-15T17:51:33Z"
        }
      ]
    },
    {
      "number": 119,
      "id": "MDU6SXNzdWU0MTA0Mjg5Mjk=",
      "title": "Handshake message parsing is ambiguous in type-safe implementations",
      "url": "https://github.com/mlswg/mls-protocol/issues/119",
      "state": "CLOSED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "invalid"
      ],
      "body": "At least 2 existing implementations of MLS have some sort of curve-specific DH public key type. This is to ensure type safety and reduce the likelihood of the programmer accidentally using one point value for a different curve. For me, this is\r\n```\r\nenum DhPoint {\r\n    X25519([u8; 32]),\r\n    P256([u8; 32]),\r\n}\r\n```\r\nThe issue I run into is that I cannot unambiguously deserialize `DHPublicKey`s into a `DHPoint`. Recall the definition `opaque DHPublicKey<1..2^16-1>`. The parse of an unmarked sequence of bytes is dependent on ambient state, namely the `CipherSuite` of the current session. Notably, the value of this `CipherSuite` is not repeated in any top-level messages. This means that a given `Handshake` message will have at least two correct interpretations unless context is specified. \r\n\r\nThis is not a massive issue, but one could imagine a case where a participant receives a message from another participant who somehow disagrees on the current `CipherSuite`. The receiver will parse all the messages correctly, check the signatures, and throw an invalid signature error. If we were to mark the type of the `DHPublicKey`, though, the receiver would parse the values and check that they agree with the current `CipherSuite`. This check will fail, and it will throw a decoherence error, which is more appropriate and informative.\r\n\r\n`DHPublicKey` is not the only data type for which this ambiguity occurs. I propose that we change at least some `opaque` datatypes to enums. Currently, the not-really-bytes opaque types are\r\n\r\n* `DHPublicKey`\r\n* `SignaturePublicKey`\r\n* `ECIES::ciphertext`\r\n* `UserInitKey::signature`\r\n* `Handshake::signature`\r\n* `ApplicationPlaintext::signature`\r\n* `Application::encrypted_content`\r\n\r\nMy own implementation makes distinctions between different signature types, ECDSA pubkey types, and ECDH pubkey types. Encrypted content is treated as a binary blob.",
      "createdAt": "2019-02-14T18:17:21Z",
      "updatedAt": "2019-12-17T10:34:35Z",
      "closedAt": "2019-02-26T19:16:17Z",
      "comments": [
        {
          "author": "burdges",
          "authorAssociation": "NONE",
          "body": "I'd kinda expect a trait instead of an enum for this in Rust, just because cipher suite agility creates many complexities.  If it's only a compile time choice, or protocol version number, then differentiating MACs and/or hashes might provide the desired protections.  Apologies if I've failed to understand all the goals here. ",
          "createdAt": "2019-02-20T06:48:41Z",
          "updatedAt": "2019-02-20T06:48:41Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "No, this is a good point. I've chosen in my implementation to treat DH algorithms as trait implementations, and `DhPoint`s as data. So I would have something like `X25519.diffie_hellman(my_scalar, others_point)`. The reason I've chosen this representation for DH public keys is because these types cannot be known at compile time. If they could be, then I would probably use associated types for the aforementioned trait impls. So I have enums which I unwrap at runtime, and panic if there's a type error then. It's not pretty, but it'll hopefully prevent some bad things from happening.",
          "createdAt": "2019-02-20T07:04:36Z",
          "updatedAt": "2019-02-20T07:04:36Z"
        },
        {
          "author": "burdges",
          "authorAssociation": "NONE",
          "body": "Oh?  I'm curious why the types cannot be known?  Is it for linking with C or something?",
          "createdAt": "2019-02-20T09:26:31Z",
          "updatedAt": "2019-02-20T09:26:31Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Well the types of, say, the DH implementor is not known. If DH operations are implemented as a trait `DiffieHellman`, then there are structs called `X25519` and `P256`. So if these are marked by bytes, say 0x00 and 0x01, respectively, then what is the return type of `deserialize_dh_from_byte(marker: u8) -> ???`.\r\nWell naturally it would be a `dyn DiffieHellman`. So say you do `let dh_impl = deserialize_dh_from_byte(b)`. Then what types does `dh_impl.multiply_basepoint(scalar: ???) -> ???` take and return? If each DH implementation has their own scalar type and point type, how can I know what to give this function?",
          "createdAt": "2019-02-20T17:10:06Z",
          "updatedAt": "2019-02-20T17:10:06Z"
        },
        {
          "author": "burdges",
          "authorAssociation": "NONE",
          "body": "I'd love it if Rust had type parameters for modules, but no such luck.  Instead, we often create parameters traits for the entire module or crate, commonly called `Trait` or `Params`.  It'd bloat the binary though if you need both X25519 and P256 in the same code, hence my C question.  Anyways not a big deal.  :)",
          "createdAt": "2019-02-20T17:37:30Z",
          "updatedAt": "2019-02-20T17:37:30Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "From a protocol design POV, there are basically two options here:\r\n\r\n1. Set the ciphersuite once, and force implementations to tell their deserializers what it is\r\n2. Set the ciphersuite on every object, and force implementations to verify that all the  ciphersuites are consistent\r\n\r\nIMO, option 1 is likely to be less error-prone, simply because it touches less code, and it is more likely to fail if you get it wrong.  It also doesn't seem *that* burdensome to implement.  Yes, you have to route the ciphersuite around to all the right places, but things like templates and generics can help a lot.",
          "createdAt": "2019-02-26T16:22:09Z",
          "updatedAt": "2019-02-26T16:22:09Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "I agree with Richard, the preferable way is usually to do 1 : ) It is more a implementation specific state machine enforcement issue than a protocol issue so I will close this, but feel free to discuss more in the Implementation issues if you feel like it is necessary.",
          "createdAt": "2019-02-26T19:16:17Z",
          "updatedAt": "2019-02-26T19:16:17Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, I tend to agree with this argument. I think I can find a way to pass state into my deserializer.",
          "createdAt": "2019-02-26T20:31:18Z",
          "updatedAt": "2019-02-26T20:31:18Z"
        }
      ]
    },
    {
      "number": 125,
      "id": "MDU6SXNzdWU0MTM2ODM0MTg=",
      "title": "Missing definition of update secret",
      "url": "https://github.com/mlswg/mls-protocol/issues/125",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2019-02-23T10:51:12Z",
      "updatedAt": "2019-02-26T19:34:31Z",
      "closedAt": "2019-02-26T19:34:31Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@beurdouche could you elaborate on this?  It seems to me that the update secret is whatever the GroupOperation says it is.",
          "createdAt": "2019-02-26T16:15:21Z",
          "updatedAt": "2019-02-26T16:15:21Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as a dup of #108 ",
          "createdAt": "2019-02-26T19:34:31Z",
          "updatedAt": "2019-02-26T19:34:31Z"
        }
      ]
    },
    {
      "number": 129,
      "id": "MDU6SXNzdWU0MTQzNDc0MDA=",
      "title": "Fix issues introduced in #114",
      "url": "https://github.com/mlswg/mls-protocol/issues/129",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "beurdouche"
      ],
      "labels": [
        "bug",
        "editorial"
      ],
      "body": "The PR from @kkohbrok introducing a KDF was merged before I had a chance to review it.  There are a number of problems with it:\r\n\r\n* Instead of calling for an abstract KDF, it should define one, as we have with the use of HKDF elsewhere\r\n* We can't just say `private_key = KDF(...)`, since KDFs produce octet strings, not private keys.  We need `Derive-Key-Pair()`, not just `Derive-Public-Key()`.\r\n* This doesn't match what I recall discussing on the list.  \r\n\r\nI think what you want is actually as follows:\r\n\r\n```\r\npath_secret[n+1]\r\n     ^\r\n     |\r\npath_secret[n] --> node_secret --> node_key_pair\r\n```\r\n\r\nOr in prose:\r\n\r\n```\r\nnode_secret = HKDF-Expand-Label(path_secret[n], \"node\", \"\", Hash.Length)\r\nnode_private, node_public = Derive-Key-Pair(node_secret)\r\npath_secret[n+1] = HKDF-Expand-Label(path_secret[n], \"path\", \"\", Hash.Length)\r\n```",
      "createdAt": "2019-02-25T22:56:32Z",
      "updatedAt": "2019-12-17T10:34:03Z",
      "closedAt": "2019-03-28T00:41:51Z",
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That was exactly the question I was asking on the list, i.e., if we need an explicit \"derive-keypair\" function. The idea with deriving the private key directly was to avoid a redundant derive-key operation. I'm totally fine re-doing the PR to represent either approach.",
          "createdAt": "2019-02-26T08:00:14Z",
          "updatedAt": "2019-02-26T08:00:14Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Merging that PR too quickly is on me.\r\nFor the parent derivation, we can just use what the formal model for TreeKEM does, which is roughly the `HKDF_Expand_Label` Richard points out. The part I don't like about this, is to define `Derive-Key-Pair` in the MLS specification as it depends on the HPKE internal algorithm.\r\n\r\nThe TreeKEM formal specification, it is done the following way (because we know that the HPKE interface we use can take random bytes as a secret key):\r\n```\r\n(** Key Derivation: compute a parent secret from the group secret *)\r\nval derive_parent_secret: alg:algorithm_hash -> context:bytes -> secret_s -> Tot secret_s\r\nlet derive_parent_secret alg context s =\r\n  Spec.HKDF.hkdf_expand_label alg s \"parent\" context size_secret\r\n\r\n(** Key Derivation: compute a KEM encryption key from the group secret *)\r\nval derive_encryption_secret: alg:algorithm_hash -> context:bytes -> secret_s -> Tot key_secret_s\r\nlet derive_encryption_secret alg context s =\r\n  Spec.HKDF.hkdf_expand_label alg s \"kem enc\" context size_key_secret\r\n```\r\n\r\nIn the MLS specification, I suggest we avoid defining anything new but point to the HPKE spec instead.\r\nAs it provides the KEM scheme, it should also provide ways to derive the `HPKEPrivateKey` from an octet string and the function that transform an `HPKEPrivateKey` to a `HPKEPublicKey`.\r\nI suggest we define, in the HPKE document, something like `HPKE_secret_to_public ()` that we already need anyway and eventually `HPKE_bytes_to_secret ()` that maps the random bytes to an `HPKEPrivateKey`. For X25519 we don't even need the second function but generically we probably need it.\r\nThat would lead to define the following in the MLS spec:\r\n```\r\n(** Key Derivation: compute a KEM encryption key from the group secret *)\r\nval mls_derive_encryption_secret: alg:algorithm_hash -> context:bytes -> secret_s -> Tot key_secret_s\r\nlet mls_derive_encryption_secret alg context s =\r\n  let output = Spec.HKDF.hkdf_expand_label alg s \"kem enc\" context size_key_secret in\r\n  Spec.HPKE.bytes_to_secret alg output\r\n```\r\n\r\n@bifurcation ?",
          "createdAt": "2019-02-26T08:50:04Z",
          "updatedAt": "2019-02-26T09:17:57Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think we can delegate this to HPKE.  HPKE doesn't have a need for anything like Derive-Key-Pair.  We do, so it's on us to define it.  The point @kkohbrok's raises about avoiding unnecessary operations is relevant here: If we're forking the hashes like this, then we can remove the hashing part from Derive-Key-Pair, so that it's really just a definition of how you convert from an octet string to a private key (and thus its public key).",
          "createdAt": "2019-02-26T16:10:36Z",
          "updatedAt": "2019-02-26T16:10:36Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "I disagree, it is not for MLS to define the `bytes_to_secret` and `secret_to_public` functions for all asymmetric schemes possibly used in HPKE. In MLS we should have to do only what TreeKEM does, aka, 2 KDFs, one outputing the parent's secret, one outputing the KEM encryption key, and that's it.\r\nI am willing to accept defining `Derive-Public-Key` here but this is already odd.",
          "createdAt": "2019-02-27T10:44:06Z",
          "updatedAt": "2019-02-27T10:44:06Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "If it's not our job, whose is it?  It's not HPKE's job, because they don't have a need to convert byte strings to private keys.  Some document needs to define this conversion in order for MLS to be implementable.",
          "createdAt": "2019-02-27T13:32:41Z",
          "updatedAt": "2019-02-27T13:32:41Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "I agree we are in trouble here :) But I still wish that if we can avoid it, we should.",
          "createdAt": "2019-02-27T13:34:05Z",
          "updatedAt": "2019-02-27T13:34:05Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that the KEM schemes themselves should define these things, like Curve25519 does.  But it's like two lines of text.  I'm not too bothered with it.",
          "createdAt": "2019-02-27T13:36:17Z",
          "updatedAt": "2019-02-27T13:36:17Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think I'm a bit lost here. How do we go forward?\r\n\r\nRegarding the use of an abstract KDF: I was mostly just adapting the existing text, which used an abstract hash function if I recall correctly.  I didn't touch the texts that got more concrete because they seemed to be a little outdated anyway. That shouldn't be a problem though.",
          "createdAt": "2019-02-28T06:23:50Z",
          "updatedAt": "2019-02-28T06:23:50Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "@bifurcation Ok, looking at this now, I am not sure what we decided in the end.\r\nI would be ok to define `Derive-Key-Pair` as you said but as it is KEM specific so there is no good solution for P256 or for whatever PQ KEM that would have a specific way of generating keys from pseudo random bytes...",
          "createdAt": "2019-03-10T17:52:54Z",
          "updatedAt": "2019-03-10T17:52:54Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "@karthikbhargavan any suggestion here",
          "createdAt": "2019-03-10T17:54:44Z",
          "updatedAt": "2019-03-10T17:54:44Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Fixed by #139 ",
          "createdAt": "2019-03-28T00:41:51Z",
          "updatedAt": "2019-03-28T00:41:51Z"
        }
      ]
    },
    {
      "number": 130,
      "id": "MDU6SXNzdWU0MTQ3MTI5MjM=",
      "title": "STROBE",
      "url": "https://github.com/mlswg/mls-protocol/issues/130",
      "state": "CLOSED",
      "author": "burdges",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "invalid"
      ],
      "body": "There is a nifty advantage of using Mike Hamburg's STROBE for symmetric cryptography:  \r\n \r\nApplications using WASM virtual machines should improve performance by using native code for cryptography.  STROBE works well for this because all actual processing is handled by *one* call that processes an arbitrary amount of data.  You always require multiple STROBE calls per operation in practice of course, but only O(1) cals.  If you wrapped say a ChaCha or Keccak permutation directly then you\u2019d have O(data_size) calls.  In short, STROBE simplifies the WASM call boundary dramatically without much performance penalty. \r\n\r\nIn MLS, you might favor adding ChaCha into your WASM call boundary anyways because STROBE lacks any round count configuration.  I wanted to mention this however since messengers do commonly get implemented in VMs. ",
      "createdAt": "2019-02-26T16:51:18Z",
      "updatedAt": "2019-12-17T10:33:00Z",
      "closedAt": "2019-07-08T14:12:55Z",
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Hi Jeff, I don't think this is much of an issue for our use cases, so I'll close the issue for now, but feel free to discuss this on the mailing list if you feel strongly about using STROBE as a base primitive ; )",
          "createdAt": "2019-07-08T14:12:55Z",
          "updatedAt": "2019-07-08T14:12:55Z"
        }
      ]
    },
    {
      "number": 137,
      "id": "MDU6SXNzdWU0MTkxNzk2NDY=",
      "title": "Rename UserInitKey to ClientInitKey",
      "url": "https://github.com/mlswg/mls-protocol/issues/137",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "terminology"
      ],
      "body": "These keys are Client one-time use keys, so \"UserInitKey\" seems like a strange name.",
      "createdAt": "2019-03-10T12:25:17Z",
      "updatedAt": "2019-05-24T14:04:36Z",
      "closedAt": "2019-05-24T14:04:36Z",
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I'm fine with ClientInitKey, as long as a client is not only a physical endpoint. Changes in the architecture doc should make this clear soon.",
          "createdAt": "2019-03-10T16:43:17Z",
          "updatedAt": "2019-03-10T16:43:17Z"
        }
      ]
    },
    {
      "number": 140,
      "id": "MDU6SXNzdWU0MjYwNDEzMDQ=",
      "title": "Provide signals to support better FS",
      "url": "https://github.com/mlswg/mls-protocol/issues/140",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "duplicate"
      ],
      "body": "If a group member can signal what its latest epoch is (e.g., by ACKing a handshake message), then other members know that they can safely delete any keys older than that epoch, at least for that sender.",
      "createdAt": "2019-03-27T15:51:03Z",
      "updatedAt": "2019-12-17T10:32:32Z",
      "closedAt": "2019-09-30T12:10:49Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Duplicate of #160 ",
          "createdAt": "2019-09-30T12:10:49Z",
          "updatedAt": "2019-09-30T12:10:49Z"
        }
      ]
    },
    {
      "number": 142,
      "id": "MDU6SXNzdWU0MjYzNjUyMDk=",
      "title": "Prevent suppression of Handshake messages",
      "url": "https://github.com/mlswg/mls-protocol/issues/142",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement"
      ],
      "body": "In current proposals, it is possible for the delivery service to distinguish handshake and application messages.  This enables the DS to lock in a compromise by forbidding key updates while allowing application messaging to continue.  We should make it harder to distinguish handshake and application messages, e.g., by encrypting the content type.",
      "createdAt": "2019-03-28T08:41:51Z",
      "updatedAt": "2020-10-20T15:07:58Z",
      "closedAt": "2020-10-20T15:07:58Z",
      "comments": []
    },
    {
      "number": 144,
      "id": "MDU6SXNzdWU0MjkzNDI2ODM=",
      "title": "Application Secret deletion",
      "url": "https://github.com/mlswg/mls-protocol/issues/144",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [
        "beurdouche"
      ],
      "labels": [
        "security"
      ],
      "body": "It has been pointed out that the text is not clear enough about the fact that once the Application secrets of the senders have been computed, the shared Application secret MUST be deleted. Make that clear.",
      "createdAt": "2019-04-04T15:25:49Z",
      "updatedAt": "2019-12-17T10:32:12Z",
      "closedAt": "2019-09-30T12:09:07Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "This was addressed by Jo\u00ebl's PR that created ASTrees and a deletion schedule.",
          "createdAt": "2019-09-30T12:09:07Z",
          "updatedAt": "2019-09-30T12:09:07Z"
        }
      ]
    },
    {
      "number": 145,
      "id": "MDU6SXNzdWU0MjkzNDQ1OTM=",
      "title": "? Introduce the notion of \"virtual\" client.",
      "url": "https://github.com/mlswg/mls-protocol/issues/145",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [
        "beurdouche"
      ],
      "labels": [
        "terminology"
      ],
      "body": "From @raphaelrobert ... This would be a useful terminology to describe a client which shares its cryptographic material across multiple device.\r\nTo be discussed ?",
      "createdAt": "2019-04-04T15:29:24Z",
      "updatedAt": "2019-12-17T10:31:40Z",
      "closedAt": "2019-07-08T14:04:38Z",
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Done in draft-06",
          "createdAt": "2019-07-08T14:04:38Z",
          "updatedAt": "2019-07-08T14:04:38Z"
        }
      ]
    },
    {
      "number": 150,
      "id": "MDU6SXNzdWU0MzUxODgzNDI=",
      "title": "Allow direct initialization",
      "url": "https://github.com/mlswg/mls-protocol/issues/150",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "functionality",
        "security"
      ],
      "body": "We have a long-standing OPEN ISSUE on creating a group with a single Init message instead of  N Add messages, which would change the work of initialization from O(N log N) to O(N).  I would propose roughly the following:\r\n\r\n```\r\nstruct {\r\n    Welcome creator_info<0..2^32-1>; // Welcome from one-member group to each joiner\r\n    UserInitKey members<0..2^32-1>; // Info to populate at the leaves\r\n    DirectPath creator_update; // Update from the creator to warm the tree\r\n} Init;\r\n```\r\n\r\nThen the processing would be:\r\n\r\n* Find the welcome that's for you\r\n* Initialize a one-member tree from the Welcome\r\n* Use the UserInitKeys to populate the leaves of the tree\r\n* Use the DirectPath to populate the creator's direct path (as in Update)",
      "createdAt": "2019-04-19T14:04:05Z",
      "updatedAt": "2019-12-17T10:31:28Z",
      "closedAt": "2019-07-08T13:58:59Z",
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Fixed by https://github.com/mlswg/mls-protocol/pull/171",
          "createdAt": "2019-07-08T13:58:59Z",
          "updatedAt": "2019-07-08T13:58:59Z"
        }
      ]
    },
    {
      "number": 154,
      "id": "MDU6SXNzdWU0Mzc2MTUyMzQ=",
      "title": "Weekly Digest (19 April, 2019 - 26 April, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/154",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week 4 issues were created.\nOf these, 1 issues have been closed and 3 issues are still open.\n## OPEN ISSUES\n:green_heart: #153 [Common framing, consolidated](https://github.com/mlswg/mls-protocol/pull/153), by [bifurcation](https://github.com/bifurcation)\n:green_heart: #152 [Make epochs unpredictable](https://github.com/mlswg/mls-protocol/pull/152), by [bifurcation](https://github.com/bifurcation)\n:green_heart: #150 [Allow direct initialization](https://github.com/mlswg/mls-protocol/issues/150), by [bifurcation](https://github.com/bifurcation)\n## CLOSED ISSUES\n:heart: #151 [A couple of minor fixes](https://github.com/mlswg/mls-protocol/pull/151), by [bifurcation](https://github.com/bifurcation)\n## NOISY ISSUE\n:speaker: #152 [Make epochs unpredictable](https://github.com/mlswg/mls-protocol/pull/152), by [bifurcation](https://github.com/bifurcation)\nIt received 4 comments.\n\n - - - \n# PULL REQUESTS\nLast week, 9 pull requests were created, updated or merged.\n## UPDATED PULL REQUEST\nLast week, 8 pull requests were updated.\n:yellow_heart: #153 [Common framing, consolidated](https://github.com/mlswg/mls-protocol/pull/153), by [bifurcation](https://github.com/bifurcation)\n:yellow_heart: #152 [Make epochs unpredictable](https://github.com/mlswg/mls-protocol/pull/152), by [bifurcation](https://github.com/bifurcation)\n:yellow_heart: #148 [Added that users SHOULD verify pubkeys in an Update](https://github.com/mlswg/mls-protocol/pull/148), by [rozbb](https://github.com/rozbb)\n:yellow_heart: #147 [Added public_key_index to Add message](https://github.com/mlswg/mls-protocol/pull/147), by [rozbb](https://github.com/rozbb)\n:yellow_heart: #146 [Tree based app keyschedule](https://github.com/mlswg/mls-protocol/pull/146), by [psyoptix](https://github.com/psyoptix)\n:yellow_heart: #143 [Fixes to tree manipulation in Remove](https://github.com/mlswg/mls-protocol/pull/143), by [rozbb](https://github.com/rozbb)\n:yellow_heart: #134 [Tree Hash](https://github.com/mlswg/mls-protocol/pull/134), by [bifurcation](https://github.com/bifurcation)\n:yellow_heart: #131 [Common Framing](https://github.com/mlswg/mls-protocol/pull/131), by [beurdouche](https://github.com/beurdouche)\n## MERGED PULL REQUEST\nLast week, 1 pull request was merged.\n:purple_heart: #151 [A couple of minor fixes](https://github.com/mlswg/mls-protocol/pull/151), by [bifurcation](https://github.com/bifurcation)\n\n - - - \n# COMMITS\nLast week there were 4 commits.\n:hammer_and_wrench: [Merge pull request #151 from mlswg/minor-fixes  A couple of minor fixes](https://github.com/mlswg/mls-protocol/commit/24efba91dd3c679a27d9c96158707cfee3b09df3) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Fix error noted by @rozbb](https://github.com/mlswg/mls-protocol/commit/b42e702fdfec54197159a27bd29f0bfa5c84a3da) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Make welcome/add diagram clearer](https://github.com/mlswg/mls-protocol/commit/ee358ac6ac44c1e2fa65d6638b2d9473fc33da03) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Open issue cleanup](https://github.com/mlswg/mls-protocol/commit/6d01e5cbe59abb49e0057582432bdd305bfad655) by [bifurcation](https://github.com/bifurcation)\n\n - - - \n# CONTRIBUTORS\nLast week there was 1 contributor.\n:bust_in_silhouette: [bifurcation](https://github.com/bifurcation)\n\n - - - \n# STARGAZERS\nLast week there was 1 stargazer.\n:star: [Mromson](https://github.com/Mromson)\nYou are the star! :star2:\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-04-26T10:48:59Z",
      "updatedAt": "2019-04-26T10:52:03Z",
      "closedAt": "2019-04-26T10:52:03Z",
      "comments": []
    },
    {
      "number": 157,
      "id": "MDU6SXNzdWU0Mzk3MzU2NTc=",
      "title": "Resolve circular dependency between GroupOperation.confirmation and transcript_hash",
      "url": "https://github.com/mlswg/mls-protocol/issues/157",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bug"
      ],
      "body": "```\r\nGroupOperation.confirmation =\r\n    HMAC(confirmation_key, GroupState.transcript\\_hash)\r\n```",
      "createdAt": "2019-05-02T18:51:28Z",
      "updatedAt": "2019-12-17T10:31:19Z",
      "closedAt": "2019-05-30T15:29:57Z",
      "comments": []
    },
    {
      "number": 158,
      "id": "MDU6SXNzdWU0NDI1OTc4ODk=",
      "title": "Issue in definition of MLSCiphertextContent",
      "url": "https://github.com/mlswg/mls-protocol/issues/158",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [
        "beurdouche"
      ],
      "labels": [
        "editorial"
      ],
      "body": "The definition of `MLSCiphertextContent` is incorrect as it relies on `MLSInnerPlaintext.sig_len`. Should we make the `signature` opaque anyway ?",
      "createdAt": "2019-05-10T08:24:17Z",
      "updatedAt": "2019-12-17T10:31:11Z",
      "closedAt": "2019-05-17T09:48:11Z",
      "comments": []
    },
    {
      "number": 159,
      "id": "MDU6SXNzdWU0NDI5NjMyNzU=",
      "title": "Rename the GroupState structure as it is not a group state.",
      "url": "https://github.com/mlswg/mls-protocol/issues/159",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [
        "beurdouche"
      ],
      "labels": [
        "terminology"
      ],
      "body": "We should change the name of this struct as it doesn't even contain the tree.",
      "createdAt": "2019-05-11T07:16:40Z",
      "updatedAt": "2019-12-17T10:30:58Z",
      "closedAt": "2019-05-24T14:10:34Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #166 ",
          "createdAt": "2019-05-24T14:10:34Z",
          "updatedAt": "2019-05-24T14:10:34Z"
        }
      ]
    },
    {
      "number": 160,
      "id": "MDU6SXNzdWU0NDI5NjczNTc=",
      "title": "Advertize a global app generation for a sender",
      "url": "https://github.com/mlswg/mls-protocol/issues/160",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [
        "beurdouche"
      ],
      "labels": [
        "enhancement",
        "security",
        "work in progress"
      ],
      "body": "We could use the sender_generation field of the MLS message to signal what was the global app generation of the sender.  Functionally, this allows receivers to know if they received all previous application messages from the sender. In the current design, if S sent M0, M1, M2 you can know if you missed M1 when receiving M2, but you cannot know if you missed M2. There are many ways of doing this: global sender counter, counter between two operations of the sender...",
      "createdAt": "2019-05-11T08:07:45Z",
      "updatedAt": "2020-10-20T15:07:58Z",
      "closedAt": "2020-10-20T15:07:58Z",
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "We seemed in agreement at the interim because it prevents the application message suppression attacks",
          "createdAt": "2019-05-17T14:23:04Z",
          "updatedAt": "2019-05-17T14:23:04Z"
        }
      ]
    },
    {
      "number": 161,
      "id": "MDU6SXNzdWU0NDI5Njk0MTk=",
      "title": "? Include the node_hash in the RatchetNode struct",
      "url": "https://github.com/mlswg/mls-protocol/issues/161",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "recommendation",
        "security"
      ],
      "body": "",
      "createdAt": "2019-05-11T08:34:38Z",
      "updatedAt": "2019-12-17T10:30:46Z",
      "closedAt": "2019-05-24T14:10:02Z",
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "@bifurcation I am not immediately clear if we need that or not. I think we do not have to send it in certain cases like update, but I think a receiver of an Add cannot recompute it, right ? We do send it in the formal spec...",
          "createdAt": "2019-05-17T14:44:37Z",
          "updatedAt": "2019-05-17T14:44:37Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think we need this.  Right now, we presume that each member caches the whole tree, which means that they can compute all the node hashes.  If we want to enable members to exist with log state, then we'll need to add a bunch of node hashes to the protocol messages.",
          "createdAt": "2019-05-24T14:10:02Z",
          "updatedAt": "2019-05-24T14:10:02Z"
        }
      ]
    },
    {
      "number": 162,
      "id": "MDU6SXNzdWU0NDUzMTU0NDE=",
      "title": "Reorder blanking and update in the Remove operation.",
      "url": "https://github.com/mlswg/mls-protocol/issues/162",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [
        "beurdouche"
      ],
      "labels": [
        "performance"
      ],
      "body": "",
      "createdAt": "2019-05-17T08:02:38Z",
      "updatedAt": "2019-12-17T10:30:24Z",
      "closedAt": "2019-05-24T14:01:35Z",
      "comments": []
    },
    {
      "number": 168,
      "id": "MDU6SXNzdWU0NDU3MjcyNTY=",
      "title": "Clarify obligation of clients to Update",
      "url": "https://github.com/mlswg/mls-protocol/issues/168",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [
        "beurdouche"
      ],
      "labels": [
        "editorial",
        "security",
        "recommendation"
      ],
      "body": "It has been noted that we don't discuss enough he influence of clients refusing to update in this document. The architecture document briefly explain why we minimally should evict clients that refuse to update to preserve FS or PCS. I think we actually enforce a MUST and provide a minimal recommendation. \r\n```\r\n### Membership and offline members\r\nBecause Forward Secrecy (FS) and Post-Compromise Security (PCS)\r\nrely on the deletion and replacement of keying material,\r\nany client which is persistently offline\r\nmay still be holding old keying material and thus be a threat\r\nto both FS and PCS if it is later compromised.\r\nMLS does not inherently defend against this problem, but\r\nMLS-using systems can enforce some mechanism for doing\r\nso. Typically this will consist of evicting clients which\r\nare idle for too long, thus containing the threat of\r\ncompromise. The precise details of such mechanisms are\r\na matter of local policy and beyond the scope of this document.\r\n```",
      "createdAt": "2019-05-18T15:37:32Z",
      "updatedAt": "2021-11-30T23:39:36Z",
      "closedAt": "2021-11-30T23:39:36Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "The Security Considerations correctly notes that that you only get PCS when you update, which I think is sufficient for this document.  If we want to lay out operational recommendations for how Updates should be arranged in practice, that seems like a better topic for the architecture document, or for implementation considerations (cc @kkohbrok).",
          "createdAt": "2021-11-30T23:39:36Z",
          "updatedAt": "2021-11-30T23:39:36Z"
        }
      ]
    },
    {
      "number": 174,
      "id": "MDU6SXNzdWU0NDg1ODg4OTg=",
      "title": "Weekly Digest (19 May, 2019 - 26 May, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/174",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week 5 issues were created.\nOf these, 1 issues have been closed and 4 issues are still open.\n## OPEN ISSUES\n:green_heart: #173 [Formatting: removed `\\_` where it was syntactically incorrect](https://github.com/mlswg/mls-protocol/pull/173), by [rozbb](https://github.com/rozbb)\n:green_heart: #172 [DirectPathNode contains encrypted node secrets, not path secrets](https://github.com/mlswg/mls-protocol/pull/172), by [rozbb](https://github.com/rozbb)\n:green_heart: #171 [Specify an Init message](https://github.com/mlswg/mls-protocol/pull/171), by [bifurcation](https://github.com/bifurcation)\n:green_heart: #170 [Confirmation and transcript improvements](https://github.com/mlswg/mls-protocol/pull/170), by [bifurcation](https://github.com/bifurcation)\n## CLOSED ISSUES\n:heart: #169 [Notion of virtual client when secrets are shared accross devices](https://github.com/mlswg/mls-protocol/pull/169), by [beurdouche](https://github.com/beurdouche)\n\n - - - \n# PULL REQUESTS\nLast week, 9 pull requests were created, updated or merged.\n## OPEN PULL REQUEST\nLast week, 3 pull requests were opened.\n:green_heart: #173 [Formatting: removed `\\_` where it was syntactically incorrect](https://github.com/mlswg/mls-protocol/pull/173), by [rozbb](https://github.com/rozbb)\n:green_heart: #172 [DirectPathNode contains encrypted node secrets, not path secrets](https://github.com/mlswg/mls-protocol/pull/172), by [rozbb](https://github.com/rozbb)\n:green_heart: #171 [Specify an Init message](https://github.com/mlswg/mls-protocol/pull/171), by [bifurcation](https://github.com/bifurcation)\n## UPDATED PULL REQUEST\nLast week, 1 pull request was updated.\n:yellow_heart: #170 [Confirmation and transcript improvements](https://github.com/mlswg/mls-protocol/pull/170), by [bifurcation](https://github.com/bifurcation)\n## MERGED PULL REQUEST\nLast week, 5 pull requests were merged.\n:purple_heart: #169 [Notion of virtual client when secrets are shared accross devices](https://github.com/mlswg/mls-protocol/pull/169), by [beurdouche](https://github.com/beurdouche)\n:purple_heart: #167 [Fix incorrect definition of update_secret](https://github.com/mlswg/mls-protocol/pull/167), by [beurdouche](https://github.com/beurdouche)\n:purple_heart: #166 [GroupState is not a group state, renaming to GroupContext](https://github.com/mlswg/mls-protocol/pull/166), by [beurdouche](https://github.com/beurdouche)\n:purple_heart: #164 [Rename UserInitKey to ClientInitKey](https://github.com/mlswg/mls-protocol/pull/164), by [beurdouche](https://github.com/beurdouche)\n:purple_heart: #163 [Reorder blanking and update in the Remove operation](https://github.com/mlswg/mls-protocol/pull/163), by [beurdouche](https://github.com/beurdouche)\n\n - - - \n# COMMITS\nLast week there were 8 commits.\n:hammer_and_wrench: [Merge pull request #164 from mlswg/beurdouche_clientinitkey  Rename UserInitKey to ClientInitKey](https://github.com/mlswg/mls-protocol/commit/0d849622508cebd6d9c769dd0388fa17d15fd083) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge branch 'master' into beurdouche_clientinitkey](https://github.com/mlswg/mls-protocol/commit/72056b8116d31326a9f84855cde0ae08007715dd) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge pull request #163 from mlswg/beurdouche_remove  Reorder blanking and update in the Remove operation](https://github.com/mlswg/mls-protocol/commit/46b8ece169e2bf0eb6771eac4396f144199032e4) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Remove: truncate the tree on sending](https://github.com/mlswg/mls-protocol/commit/50bc327f2e5d65832713c93e0c2ab7588be0a4d1) by [beurdouche](https://github.com/beurdouche)\n:hammer_and_wrench: [Fix merge conflict with master](https://github.com/mlswg/mls-protocol/commit/b094afcfbe3cc1f7eb4dd8700933fc3d20b8a7e9) by [beurdouche](https://github.com/beurdouche)\n:hammer_and_wrench: [GroupState is not a group state, renaming to GroupContext (#166)  * GroupState is not a group state, renaming to GroupContext\r \r * GroupContext, update according to Richard's comment](https://github.com/mlswg/mls-protocol/commit/564ee2662e4eeac93a854edf3a6ab44eb46cb6d6) by [beurdouche](https://github.com/beurdouche)\n:hammer_and_wrench: [Merge pull request #169 from mlswg/beurdouche_145  Notion of virtual client when secrets are shared accross devices](https://github.com/mlswg/mls-protocol/commit/cefc48b64e3651fafeab56c6413fdd75bef4c4c5) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge pull request #167 from mlswg/beurdouche_us  Fix incorrect definition of update_secret](https://github.com/mlswg/mls-protocol/commit/6e672188c590c2dbd34fd1369b3b6e1d6da8fda8) by [bifurcation](https://github.com/bifurcation)\n\n - - - \n# CONTRIBUTORS\nLast week there were 2 contributors.\n:bust_in_silhouette: [bifurcation](https://github.com/bifurcation)\n:bust_in_silhouette: [beurdouche](https://github.com/beurdouche)\n\n - - - \n# STARGAZERS\nLast week there was 1 stargazer.\n:star: [eknoes](https://github.com/eknoes)\nYou are the star! :star2:\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-05-26T17:31:59Z",
      "updatedAt": "2019-06-04T11:30:42Z",
      "closedAt": "2019-06-04T11:30:42Z",
      "comments": []
    },
    {
      "number": 177,
      "id": "MDU6SXNzdWU0NTExNTgwMTc=",
      "title": "Weekly Digest (26 May, 2019 - 2 June, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/177",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week 2 issues were created.\nOf these, 2 issues have been closed and 0 issues are still open.\n## CLOSED ISSUES\n:heart: #176 [Use correct field names](https://github.com/mlswg/mls-protocol/pull/176), by [bifurcation](https://github.com/bifurcation)\n:heart: #175 [Typo fix](https://github.com/mlswg/mls-protocol/pull/175), by [bifurcation](https://github.com/bifurcation)\n\n - - - \n# PULL REQUESTS\nLast week, 4 pull requests were created, updated or merged.\n## MERGED PULL REQUEST\nLast week, 4 pull requests were merged.\n:purple_heart: #176 [Use correct field names](https://github.com/mlswg/mls-protocol/pull/176), by [bifurcation](https://github.com/bifurcation)\n:purple_heart: #175 [Typo fix](https://github.com/mlswg/mls-protocol/pull/175), by [bifurcation](https://github.com/bifurcation)\n:purple_heart: #173 [Formatting: removed `\\_` where it was syntactically incorrect](https://github.com/mlswg/mls-protocol/pull/173), by [rozbb](https://github.com/rozbb)\n:purple_heart: #170 [Confirmation and transcript improvements](https://github.com/mlswg/mls-protocol/pull/170), by [bifurcation](https://github.com/bifurcation)\n\n - - - \n# COMMITS\nLast week there were 9 commits.\n:hammer_and_wrench: [Merge pull request #176 from mlswg/path-secret-typo  Use correct field names](https://github.com/mlswg/mls-protocol/commit/112b535e77f1122e434c2a49492393d15bf19aa8) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Use correct field names](https://github.com/mlswg/mls-protocol/commit/facd7a383ec8952072d0ead3c30daae16824a4fe) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge pull request #175 from mlswg/circular-confirmation  Typo fix](https://github.com/mlswg/mls-protocol/commit/b7498970e5dc1a8b4eb1a3db8db699e4dd1f5698) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge pull request #173 from rozbb/backslash-underscore  Formatting: removed `\\_` where it was syntactically incorrect](https://github.com/mlswg/mls-protocol/commit/8c7cbca1e568b47394b1d89c73dbeaebe3f62afb) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge branch 'master' into backslash-underscore](https://github.com/mlswg/mls-protocol/commit/c12be2c8a3e2fe913f4a0e81854308aa86298852) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Typo fix](https://github.com/mlswg/mls-protocol/commit/779adb41d09c2fe99c55b61483bd3b26aa58d184) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge pull request #170 from mlswg/circular-confirmation  Confirmation and transcript improvements](https://github.com/mlswg/mls-protocol/commit/7602f683a6e9ba79cdb732814314a259d8738cb2) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge branch 'master' into circular-confirmation](https://github.com/mlswg/mls-protocol/commit/9132e357ce338c34d3fa95b93c1b5e5eb7598df4) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Responses to comments from @raphaelrobert](https://github.com/mlswg/mls-protocol/commit/d30557726eacd6f748ef650e26e2dbfc20ff1b72) by [bifurcation](https://github.com/bifurcation)\n\n - - - \n# CONTRIBUTORS\nLast week there was 1 contributor.\n:bust_in_silhouette: [bifurcation](https://github.com/bifurcation)\n\n - - - \n# STARGAZERS\nLast week there were no stargazers.\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-06-02T06:19:27Z",
      "updatedAt": "2019-06-04T11:30:42Z",
      "closedAt": "2019-06-04T11:30:42Z",
      "comments": []
    },
    {
      "number": 180,
      "id": "MDU6SXNzdWU0NTM4Njc0OTE=",
      "title": "Weekly Digest (2 June, 2019 - 9 June, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/180",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week 2 issues were created.\nOf these, 1 issues have been closed and 1 issues are still open.\n## OPEN ISSUES\n:green_heart: #178 [Fix transcript so that new members get the right information](https://github.com/mlswg/mls-protocol/pull/178), by [bifurcation](https://github.com/bifurcation)\n## CLOSED ISSUES\n:heart: #179 [Add Beurdouche as a co-author](https://github.com/mlswg/mls-protocol/pull/179), by [bifurcation](https://github.com/bifurcation)\n## NOISY ISSUE\n:speaker: #179 [Add Beurdouche as a co-author](https://github.com/mlswg/mls-protocol/pull/179), by [bifurcation](https://github.com/bifurcation)\nIt received 1 comments.\n\n - - - \n# PULL REQUESTS\nLast week, 2 pull requests were created, updated or merged.\n## UPDATED PULL REQUEST\nLast week, 1 pull request was updated.\n:yellow_heart: #178 [Fix transcript so that new members get the right information](https://github.com/mlswg/mls-protocol/pull/178), by [bifurcation](https://github.com/bifurcation)\n## MERGED PULL REQUEST\nLast week, 1 pull request was merged.\n:purple_heart: #179 [Add Beurdouche as a co-author](https://github.com/mlswg/mls-protocol/pull/179), by [bifurcation](https://github.com/bifurcation)\n\n - - - \n# COMMITS\nLast week there were 2 commits.\n:hammer_and_wrench: [Merge pull request #179 from mlswg/add-beurdouche  Add Beurdouche as a co-author](https://github.com/mlswg/mls-protocol/commit/a3ac74a28e2417f9d08fe45375298db7bb7b3315) by [jmillican](https://github.com/jmillican)\n:hammer_and_wrench: [Add Beurdouche as a co-author](https://github.com/mlswg/mls-protocol/commit/af877ca3eb8c50a1bbfe6095756d7186aa5e221c) by [bifurcation](https://github.com/bifurcation)\n\n - - - \n# CONTRIBUTORS\nLast week there were 2 contributors.\n:bust_in_silhouette: [jmillican](https://github.com/jmillican)\n:bust_in_silhouette: [bifurcation](https://github.com/bifurcation)\n\n - - - \n# STARGAZERS\nLast week there were no stargazers.\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-06-09T06:19:28Z",
      "updatedAt": "2019-06-23T08:38:49Z",
      "closedAt": "2019-06-23T08:38:49Z",
      "comments": []
    },
    {
      "number": 181,
      "id": "MDU6SXNzdWU0NTY2MDcxODM=",
      "title": "Weekly Digest (9 June, 2019 - 16 June, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/181",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week, no issues were created.\n\n - - - \n# PULL REQUESTS\nLast week, no pull requests were created, updated or merged.\n\n - - - \n# COMMITS\nLast week there were no commits.\n\n - - - \n# CONTRIBUTORS\nLast week there were no contributors.\n\n - - - \n# STARGAZERS\nLast week there were 3 stagazers.\n:star: [ianopolous](https://github.com/ianopolous)\n:star: [yisiliu](https://github.com/yisiliu)\n:star: [hatgit](https://github.com/hatgit)\nYou all are the stars! :star2:\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-06-16T06:19:27Z",
      "updatedAt": "2019-06-23T08:38:50Z",
      "closedAt": "2019-06-23T08:38:50Z",
      "comments": []
    },
    {
      "number": 182,
      "id": "MDU6SXNzdWU0NTk1NDEzMTE=",
      "title": "Weekly Digest (16 June, 2019 - 23 June, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/182",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week, no issues were created.\n\n - - - \n# PULL REQUESTS\nLast week, no pull requests were created, updated or merged.\n\n - - - \n# COMMITS\nLast week there were no commits.\n\n - - - \n# CONTRIBUTORS\nLast week there were no contributors.\n\n - - - \n# STARGAZERS\nLast week there were 2 stagazers.\n:star: [defclass](https://github.com/defclass)\n:star: [capt8bit](https://github.com/capt8bit)\nYou all are the stars! :star2:\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-06-23T06:19:27Z",
      "updatedAt": "2019-06-23T08:38:50Z",
      "closedAt": "2019-06-23T08:38:50Z",
      "comments": []
    },
    {
      "number": 185,
      "id": "MDU6SXNzdWU0NjQ5MTY3MjQ=",
      "title": "Weekly Digest (30 June, 2019 - 7 July, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/185",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the Weekly Digest for [mlswg/mls-protocol](https://github.com/mlswg/mls-protocol):\n# ISSUES \nThis week, 8 issues were created. Of these, 4 issues have been closed and 4 issues are still open. \n## OPEN ISSUES \n:green_heart: #171 [Specify an Init message](https://github.com/mlswg/mls-protocol/pull/171), by [bifurcation](https://github.com/bifurcation)\n:green_heart: #146 [Tree based app keyschedule](https://github.com/mlswg/mls-protocol/pull/146), by [psyoptix](https://github.com/psyoptix)\n:green_heart: #144 [Application Secret deletion](https://github.com/mlswg/mls-protocol/issues/144), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #105 [Version negotiation](https://github.com/mlswg/mls-protocol/issues/105), by [bifurcation](https://github.com/bifurcation)\n## CLOSED ISSUES \n:heart: #184 [Clarify how HPKE ciphertexts are computed](https://github.com/mlswg/mls-protocol/pull/184), by [rozbb](https://github.com/rozbb)\n:heart: #183 [Multiple clarifications around Framing](https://github.com/mlswg/mls-protocol/pull/183), by [rozbb](https://github.com/rozbb)\n:heart: #152 [Make epochs unpredictable](https://github.com/mlswg/mls-protocol/pull/152), by [bifurcation](https://github.com/bifurcation)\n:heart: #113 [Algorithm agility and ciphersuites (Issue #95)](https://github.com/mlswg/mls-protocol/pull/113), by [beurdouche](https://github.com/beurdouche)\n## NOISY ISSUE \nThe issue most discussed this week has been:\n:speaker: #152 [Make epochs unpredictable](https://github.com/mlswg/mls-protocol/pull/152), by [bifurcation](https://github.com/bifurcation)\nIt received 9 comments.\n\n# PULL REQUESTS\nThis week, no pull requests has been proposed by the users. \n\n# CONTRIBUTORS \nThis week, 4 users have contributed to this repository. \nThey are [rozbb](https://github.com/rozbb), [bifurcation](https://github.com/bifurcation), [psyoptix](https://github.com/psyoptix), and [beurdouche](https://github.com/beurdouche).\n\n# STARGAZERS\nThis week, no user has starred this repository.\n\n# COMMITS\nThis week, there have been 4 commits in the repository.\nThese are: \n:hammer_and_wrench: [Merge pull request #183 from rozbb/mlsplaintext-signature\n\nMultiple clarifications around Framing](https://github.com/mlswg/mls-protocol/commit/74987e2b70e3bc5c2e02b0092d5bbb21cb7ae1eb) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge pull request #184 from rozbb/hpke-encrypt\n\nClarify how HPKE ciphertexts are computed](https://github.com/mlswg/mls-protocol/commit/12b572eb379a571ff7830337201e3549f7912989) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [SetupBaseI returns eph_key, context](https://github.com/mlswg/mls-protocol/commit/f18d0d28f87af9998e74659172e4b658596e35ff) by [rozbb](https://github.com/rozbb)\n:hammer_and_wrench: [Turned em-dashes into `--` surrounded by single spaces](https://github.com/mlswg/mls-protocol/commit/edd48b4d01c2ca99c9f8cbc2c263699311ddb3f0) by [rozbb](https://github.com/rozbb)\n\n # RELEASES\nThis week, no releases were published.\n\nThat's all for this week, please watch :eyes: and star :star: [mlswg/mls-protocol](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:",
      "createdAt": "2019-07-07T05:31:06Z",
      "updatedAt": "2019-07-08T13:58:17Z",
      "closedAt": "2019-07-08T13:58:17Z",
      "comments": []
    },
    {
      "number": 199,
      "id": "MDU6SXNzdWU0ODE5Nzk4NzA=",
      "title": "Weekly Digest (11 August, 2019 - 18 August, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/199",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week 2 issues were created.\nOf these, 1 issues have been closed and 1 issues are still open.\n## OPEN ISSUES\n:green_heart: #198 [Initial design for the key schedule Exporter](https://github.com/mlswg/mls-protocol/pull/198), by [beurdouche](https://github.com/beurdouche)\n## CLOSED ISSUES\n:heart: #197 [Minor edit](https://github.com/mlswg/mls-protocol/pull/197), by [seanieb](https://github.com/seanieb)\n## LIKED ISSUE\n:+1: #198 [Initial design for the key schedule Exporter](https://github.com/mlswg/mls-protocol/pull/198), by [beurdouche](https://github.com/beurdouche)\nIt received :+1: x1, :smile: x0, :tada: x0 and :heart: x0.\n## NOISY ISSUE\n:speaker: #197 [Minor edit](https://github.com/mlswg/mls-protocol/pull/197), by [seanieb](https://github.com/seanieb)\nIt received 1 comments.\n\n - - - \n# PULL REQUESTS\nLast week, 3 pull requests were created, updated or merged.\n## OPEN PULL REQUEST\nLast week, 1 pull request was opened.\n:green_heart: #198 [Initial design for the key schedule Exporter](https://github.com/mlswg/mls-protocol/pull/198), by [beurdouche](https://github.com/beurdouche)\n## UPDATED PULL REQUEST\nLast week, 1 pull request was updated.\n:yellow_heart: #194 [Clarified and Changed WelcomeInfo Secrets](https://github.com/mlswg/mls-protocol/pull/194), by [rozbb](https://github.com/rozbb)\n## MERGED PULL REQUEST\nLast week, 1 pull request was merged.\n:purple_heart: #197 [Minor edit](https://github.com/mlswg/mls-protocol/pull/197), by [seanieb](https://github.com/seanieb)\n\n - - - \n# COMMITS\nLast week there were 2 commits.\n:hammer_and_wrench: [Merge pull request #197 from seanieb/patch-1  Minor edit](https://github.com/mlswg/mls-protocol/commit/483c2b2d87c4e2911a7428ea38d04bae938258dc) by [beurdouche](https://github.com/beurdouche)\n:hammer_and_wrench: [Minor edit   The operations in the lifecycle of a group has been reduced to three.](https://github.com/mlswg/mls-protocol/commit/9743c0e671eb1c18894703f18aff1e44d9ce5b94) by [seanieb](https://github.com/seanieb)\n\n - - - \n# CONTRIBUTORS\nLast week there were 2 contributors.\n:bust_in_silhouette: [beurdouche](https://github.com/beurdouche)\n:bust_in_silhouette: [seanieb](https://github.com/seanieb)\n\n - - - \n# STARGAZERS\nLast week there were 3 stagazers.\n:star: [Metalnem](https://github.com/Metalnem)\n:star: [ahmgeek](https://github.com/ahmgeek)\n:star: [dconnolly](https://github.com/dconnolly)\nYou all are the stars! :star2:\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-08-18T10:48:56Z",
      "updatedAt": "2019-09-27T09:04:16Z",
      "closedAt": "2019-09-27T09:04:16Z",
      "comments": []
    },
    {
      "number": 202,
      "id": "MDU6SXNzdWU0ODQ5MTY5Mzg=",
      "title": "Weekly Digest (18 August, 2019 - 25 August, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/202",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week 2 issues were created.\nOf these, 0 issues have been closed and 2 issues are still open.\n## OPEN ISSUES\n:green_heart: #201 [Define enum values for ProtocolVersion.](https://github.com/mlswg/mls-protocol/pull/201), by [Bren2010](https://github.com/Bren2010)\n:green_heart: #200 [Non-destructive add](https://github.com/mlswg/mls-protocol/pull/200), by [bifurcation](https://github.com/bifurcation)\n\n - - - \n# PULL REQUESTS\nLast week, 8 pull requests were created, updated or merged.\n## OPEN PULL REQUEST\nLast week, 1 pull request was opened.\n:green_heart: #201 [Define enum values for ProtocolVersion.](https://github.com/mlswg/mls-protocol/pull/201), by [Bren2010](https://github.com/Bren2010)\n## UPDATED PULL REQUEST\nLast week, 5 pull requests were updated.\n:yellow_heart: #200 [Non-destructive add](https://github.com/mlswg/mls-protocol/pull/200), by [bifurcation](https://github.com/bifurcation)\n:yellow_heart: #198 [Initial design for the key schedule Exporter](https://github.com/mlswg/mls-protocol/pull/198), by [beurdouche](https://github.com/beurdouche)\n:yellow_heart: #196 [Cleaned up beginning of Cryptographic Objects section](https://github.com/mlswg/mls-protocol/pull/196), by [rozbb](https://github.com/rozbb)\n:yellow_heart: #194 [Clarified and Changed WelcomeInfo Secrets](https://github.com/mlswg/mls-protocol/pull/194), by [rozbb](https://github.com/rozbb)\n:yellow_heart: #192 [Made it clear that Init messages MUST be sent unencrypted](https://github.com/mlswg/mls-protocol/pull/192), by [rozbb](https://github.com/rozbb)\n## MERGED PULL REQUEST\nLast week, 2 pull requests were merged.\n:purple_heart: #195 [Tightened up wording in AS tree deletion sched](https://github.com/mlswg/mls-protocol/pull/195), by [rozbb](https://github.com/rozbb)\n:purple_heart: #193 [Fix formatting issues.](https://github.com/mlswg/mls-protocol/pull/193), by [Bren2010](https://github.com/Bren2010)\n\n - - - \n# COMMITS\nLast week there were 2 commits.\n:hammer_and_wrench: [Merge pull request #195 from rozbb/astree-style-fixes  Tightened up wording in AS tree deletion sched](https://github.com/mlswg/mls-protocol/commit/4e60ddcd16df6ed524f64bf701fc4126594e4157) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge pull request #193 from Bren2010/brendan/2019.7.0  Fix formatting issues.](https://github.com/mlswg/mls-protocol/commit/996280ee06a12ce7d51975bf929284cb59de7c3f) by [bifurcation](https://github.com/bifurcation)\n\n - - - \n# CONTRIBUTORS\nLast week there was 1 contributor.\n:bust_in_silhouette: [bifurcation](https://github.com/bifurcation)\n\n - - - \n# STARGAZERS\nLast week there was 1 stargazer.\n:star: [eau-u4f](https://github.com/eau-u4f)\nYou are the star! :star2:\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-08-25T10:48:54Z",
      "updatedAt": "2019-09-27T09:04:16Z",
      "closedAt": "2019-09-27T09:04:16Z",
      "comments": []
    },
    {
      "number": 205,
      "id": "MDU6SXNzdWU0ODc4NzA1NDA=",
      "title": "Weekly Digest (25 August, 2019 - 1 September, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/205",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week 2 issues were created.\nOf these, 0 issues have been closed and 2 issues are still open.\n## OPEN ISSUES\n:green_heart: #204 [Update ClientInitKey to contain only one ciphersuite.](https://github.com/mlswg/mls-protocol/pull/204), by [Bren2010](https://github.com/Bren2010)\n:green_heart: #203 [HPKECiphertext takes generic KEM output, not a public key.](https://github.com/mlswg/mls-protocol/pull/203), by [Bren2010](https://github.com/Bren2010)\n\n - - - \n# PULL REQUESTS\nLast week, 2 pull requests were created, updated or merged.\n## OPEN PULL REQUEST\nLast week, 2 pull requests were opened.\n:green_heart: #204 [Update ClientInitKey to contain only one ciphersuite.](https://github.com/mlswg/mls-protocol/pull/204), by [Bren2010](https://github.com/Bren2010)\n:green_heart: #203 [HPKECiphertext takes generic KEM output, not a public key.](https://github.com/mlswg/mls-protocol/pull/203), by [Bren2010](https://github.com/Bren2010)\n\n - - - \n# COMMITS\nLast week there were no commits.\n\n - - - \n# CONTRIBUTORS\nLast week there were no contributors.\n\n - - - \n# STARGAZERS\nLast week there were 2 stagazers.\n:star: [ericwestfall](https://github.com/ericwestfall)\n:star: [myfreeweb](https://github.com/myfreeweb)\nYou all are the stars! :star2:\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-09-01T10:48:37Z",
      "updatedAt": "2019-09-27T09:04:17Z",
      "closedAt": "2019-09-27T09:04:17Z",
      "comments": []
    },
    {
      "number": 206,
      "id": "MDU6SXNzdWU0OTA3MzkzNDY=",
      "title": "Weekly Digest (1 September, 2019 - 8 September, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/206",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week, no issues were created.\n\n - - - \n# PULL REQUESTS\nLast week, no pull requests were created, updated or merged.\n\n - - - \n# COMMITS\nLast week there were no commits.\n\n - - - \n# CONTRIBUTORS\nLast week there were no contributors.\n\n - - - \n# STARGAZERS\nLast week there were 3 stagazers.\n:star: [bernarden](https://github.com/bernarden)\n:star: [1993Dajana](https://github.com/1993Dajana)\n:star: [gonzalgu](https://github.com/gonzalgu)\nYou all are the stars! :star2:\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-09-08T10:48:38Z",
      "updatedAt": "2019-09-27T09:04:17Z",
      "closedAt": "2019-09-27T09:04:17Z",
      "comments": []
    },
    {
      "number": 207,
      "id": "MDU6SXNzdWU0OTM3MjI3Mzk=",
      "title": "Weekly Digest (8 September, 2019 - 15 September, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/207",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week, no issues were created.\n\n - - - \n# PULL REQUESTS\nLast week, 3 pull requests were created, updated or merged.\n## UPDATED PULL REQUEST\nLast week, 2 pull requests were updated.\n:yellow_heart: #204 [Update ClientInitKey to contain only one ciphersuite.](https://github.com/mlswg/mls-protocol/pull/204), by [Bren2010](https://github.com/Bren2010)\n:yellow_heart: #203 [HPKECiphertext takes generic KEM output, not a public key.](https://github.com/mlswg/mls-protocol/pull/203), by [Bren2010](https://github.com/Bren2010)\n## MERGED PULL REQUEST\nLast week, 1 pull request was merged.\n:purple_heart: #201 [Define enum values for ProtocolVersion.](https://github.com/mlswg/mls-protocol/pull/201), by [Bren2010](https://github.com/Bren2010)\n\n - - - \n# COMMITS\nLast week there was 1 commit.\n:hammer_and_wrench: [Merge pull request #201 from Bren2010/brendan/2019.8.0  Define enum values for ProtocolVersion.](https://github.com/mlswg/mls-protocol/commit/b8eed965739bae912b971e6156a377656f1884c0) by [bifurcation](https://github.com/bifurcation)\n\n - - - \n# CONTRIBUTORS\nLast week there was 1 contributor.\n:bust_in_silhouette: [bifurcation](https://github.com/bifurcation)\n\n - - - \n# STARGAZERS\nLast week there was 1 stargazer.\n:star: [rmdouglas](https://github.com/rmdouglas)\nYou are the star! :star2:\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-09-15T10:48:42Z",
      "updatedAt": "2019-09-27T09:04:17Z",
      "closedAt": "2019-09-27T09:04:17Z",
      "comments": []
    },
    {
      "number": 211,
      "id": "MDU6SXNzdWU0OTY3NjI2MDA=",
      "title": "Weekly Digest (15 September, 2019 - 22 September, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/211",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week 3 issues were created.\nOf these, 1 issues have been closed and 2 issues are still open.\n## OPEN ISSUES\n:green_heart: #209 [Proposals and Commits](https://github.com/mlswg/mls-protocol/pull/209), by [bifurcation](https://github.com/bifurcation)\n:green_heart: #208 [Add authenticated_data to the mls message.](https://github.com/mlswg/mls-protocol/pull/208), by [psla](https://github.com/psla)\n## CLOSED ISSUES\n:heart: #210 [Update changelog for recent PRs](https://github.com/mlswg/mls-protocol/pull/210), by [bifurcation](https://github.com/bifurcation)\n## NOISY ISSUE\n:speaker: #210 [Update changelog for recent PRs](https://github.com/mlswg/mls-protocol/pull/210), by [bifurcation](https://github.com/bifurcation)\nIt received 1 comments.\n\n - - - \n# PULL REQUESTS\nLast week, 6 pull requests were created, updated or merged.\n## OPEN PULL REQUEST\nLast week, 1 pull request was opened.\n:green_heart: #208 [Add authenticated_data to the mls message.](https://github.com/mlswg/mls-protocol/pull/208), by [psla](https://github.com/psla)\n## UPDATED PULL REQUEST\nLast week, 1 pull request was updated.\n:yellow_heart: #209 [Proposals and Commits](https://github.com/mlswg/mls-protocol/pull/209), by [bifurcation](https://github.com/bifurcation)\n## MERGED PULL REQUEST\nLast week, 4 pull requests were merged.\n:purple_heart: #210 [Update changelog for recent PRs](https://github.com/mlswg/mls-protocol/pull/210), by [bifurcation](https://github.com/bifurcation)\n:purple_heart: #204 [Update ClientInitKey to contain only one ciphersuite.](https://github.com/mlswg/mls-protocol/pull/204), by [Bren2010](https://github.com/Bren2010)\n:purple_heart: #203 [HPKECiphertext takes generic KEM output, not a public key.](https://github.com/mlswg/mls-protocol/pull/203), by [Bren2010](https://github.com/Bren2010)\n:purple_heart: #196 [Cleaned up beginning of Cryptographic Objects section](https://github.com/mlswg/mls-protocol/pull/196), by [rozbb](https://github.com/rozbb)\n\n - - - \n# COMMITS\nLast week there were 6 commits.\n:hammer_and_wrench: [Merge pull request #210 from mlswg/changelog-08  Update changelog for recent PRs](https://github.com/mlswg/mls-protocol/commit/46e586329b16d9703ec321a83f79c70d6ed72c17) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge pull request #196 from rozbb/cleanup-crypto-objects  Cleaned up beginning of Cryptographic Objects section](https://github.com/mlswg/mls-protocol/commit/1a201118d76925dcc1e9b31138299798d71cc90f) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge branch 'master' into cleanup-crypto-objects](https://github.com/mlswg/mls-protocol/commit/cf5b19766eaf75678010de52dac80b5d1ddcb0e8) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Update changelog for recent PRs](https://github.com/mlswg/mls-protocol/commit/5d738bd4c395d1bf18597018d77dd06c50f381cb) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge pull request #204 from Bren2010/brendan/2019.8.2  Update ClientInitKey to contain only one ciphersuite.](https://github.com/mlswg/mls-protocol/commit/f7142b7c206fca6217ac87aeae76c9ea2db67c06) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge pull request #203 from Bren2010/brendan/2019.8.1  HPKECiphertext takes generic KEM output, not a public key.](https://github.com/mlswg/mls-protocol/commit/e3c6e466c17ea3ca41e2be3551ad432775b3b23e) by [bifurcation](https://github.com/bifurcation)\n\n - - - \n# CONTRIBUTORS\nLast week there was 1 contributor.\n:bust_in_silhouette: [bifurcation](https://github.com/bifurcation)\n\n - - - \n# STARGAZERS\nLast week there was 1 stargazer.\n:star: [psrihari007](https://github.com/psrihari007)\nYou are the star! :star2:\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-09-22T10:48:39Z",
      "updatedAt": "2019-09-27T09:04:17Z",
      "closedAt": "2019-09-27T09:04:17Z",
      "comments": []
    },
    {
      "number": 212,
      "id": "MDU6SXNzdWU0OTk4NDU2OTU=",
      "title": "Weekly Digest (22 September, 2019 - 29 September, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/212",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week, no issues were created.\n\n - - - \n# PULL REQUESTS\nLast week, 1 pull request was created, updated or merged.\n## UPDATED PULL REQUEST\nLast week, 1 pull request was updated.\n:yellow_heart: #209 [Proposals and Commits](https://github.com/mlswg/mls-protocol/pull/209), by [bifurcation](https://github.com/bifurcation)\n\n - - - \n# COMMITS\nLast week there were no commits.\n\n - - - \n# CONTRIBUTORS\nLast week there were no contributors.\n\n - - - \n# STARGAZERS\nLast week there were no stargazers.\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-09-29T02:31:07Z",
      "updatedAt": "2019-10-01T11:06:55Z",
      "closedAt": "2019-10-01T11:06:55Z",
      "comments": []
    },
    {
      "number": 214,
      "id": "MDU6SXNzdWU1MDA1NTI2NzY=",
      "title": "Include message type in AAD when encrypting to public keys in leaves of ratchet tree",
      "url": "https://github.com/mlswg/mls-protocol/issues/214",
      "state": "CLOSED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "Bren2010"
      ],
      "labels": [
        "security"
      ],
      "body": "The protocol currently uses the public keys in the leaves of the ratchet tree for two purposes: For encrypting path secrets, and for encrypting WelcomeInfo data. We should include the type of message we're sending in the HPKE AAD for that message.\r\n\r\nTaking messages meant for one purpose and using them for another might leak information about the plaintext because decryption will succeed but not subsequent processing. Ex: Putting a ciphertext containing a path secret in a Welcome message and observing error \"unknown group id: abcdef123...\" or similar",
      "createdAt": "2019-09-30T22:09:16Z",
      "updatedAt": "2019-12-17T10:30:12Z",
      "closedAt": "2019-11-14T17:18:25Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Question: Should this be HPKE `info` or `aad`?",
          "createdAt": "2019-10-02T08:36:35Z",
          "updatedAt": "2019-10-02T08:36:35Z"
        }
      ]
    },
    {
      "number": 215,
      "id": "MDU6SXNzdWU1MDA1NTM5NDg=",
      "title": "Restrict life of ClientInitKey",
      "url": "https://github.com/mlswg/mls-protocol/issues/215",
      "state": "CLOSED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "beurdouche"
      ],
      "labels": [
        "security"
      ],
      "body": "Generally, the protocol provides no way to prevent ClientInitKeys from being re-used.\r\n\r\nOne case where this matters: If a user's ClientInitKey is compromised, the DS can serve it to anybody that wants to communicate with the user and immediately decrypt the user's communication, for the rest of their identity key's life.\r\n\r\nWe could put an expiry on ClientInitKeys to limit their effective lifespan. Or something else?",
      "createdAt": "2019-09-30T22:12:44Z",
      "updatedAt": "2019-12-17T10:29:59Z",
      "closedAt": "2019-11-14T18:24:07Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "As discussed in the interim meeting (and in #225), the general goal here is to limit inappropriate replay of CIKs by CIK servers.  This can be done either in the CIK itself or by expiring/revoking the credential used to sign the CIK.",
          "createdAt": "2019-10-01T21:38:24Z",
          "updatedAt": "2019-10-01T21:38:24Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #234 ",
          "createdAt": "2019-11-14T18:23:58Z",
          "updatedAt": "2019-11-14T18:23:58Z"
        }
      ]
    },
    {
      "number": 216,
      "id": "MDU6SXNzdWU1MDA1NTQ4ODg=",
      "title": "Address risk of re-using nonces after state loss",
      "url": "https://github.com/mlswg/mls-protocol/issues/216",
      "state": "CLOSED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bifurcation",
        "beurdouche"
      ],
      "labels": [
        "security",
        "work in progress"
      ],
      "body": "Nonces and keys are generated deterministically. If a client's state is rolled back to a previous version (because the process crashed, for instance), then the client is very likely to re-use the same key+nonce pair to encrypt a different application message. This breaks the confidentiality of the AEAD.\r\n\r\nConsider using explicit nonces (even small ones will do) or SIV-like constructions.",
      "createdAt": "2019-09-30T22:15:45Z",
      "updatedAt": "2020-02-17T17:57:43Z",
      "closedAt": "2020-02-17T17:57:43Z",
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Denis Jackson already discussed this, the WG, including I, was pretty conservative\nat the time but I am feeling more and more we should do it, indeed\u2026\n\nThere are other linked problems that I\u2019ll discuss today but in general, in case of recoverable\nstate loss I would strongly favor mandating an update which would definitely help with\nthe problem. Detecting such losses is probably not trivial though :) \n\nB.",
          "createdAt": "2019-10-01T06:49:04Z",
          "updatedAt": "2019-10-01T06:49:04Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "@bifurcation Notes for reference:The other solution we thought about was using the fresh explicit nonce as a re-randomizing solution for the deterministic handshake nonce.",
          "createdAt": "2019-11-16T14:45:58Z",
          "updatedAt": "2019-11-16T14:45:58Z"
        }
      ]
    },
    {
      "number": 217,
      "id": "MDU6SXNzdWU1MDA1NTY1MjU=",
      "title": "Signatures in MLSPlaintext should cover entire group context",
      "url": "https://github.com/mlswg/mls-protocol/issues/217",
      "state": "CLOSED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "beurdouche"
      ],
      "labels": [
        "security"
      ],
      "body": "Signatures that go in the MLSPlaintext field right now only include the group ID and epoch. The group ID does help bind the message to a specific group, but group IDs are arbitrary and it seems multiple groups could have the same ID.\r\n\r\nWe should include the whole group context object in the data that's signed, to prevent messages from being copied from one conversation and pasted into another conversation with the same group ID.",
      "createdAt": "2019-09-30T22:20:31Z",
      "updatedAt": "2019-12-17T10:29:48Z",
      "closedAt": "2019-11-14T17:18:25Z",
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Yes, the lack of context has been pointed out by Karthik and I at the last interim.\nI said I would fix this but I didn\u2019t find time to write the PR yet, I\u2019ll try to do that today.\n\nThanks for the remainder...\n\n\n",
          "createdAt": "2019-10-01T06:43:14Z",
          "updatedAt": "2019-10-01T06:43:14Z"
        }
      ]
    },
    {
      "number": 222,
      "id": "MDU6SXNzdWU1MDA4MTM1Njc=",
      "title": "Performance measurements",
      "url": "https://github.com/mlswg/mls-protocol/issues/222",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "performance",
        "question"
      ],
      "body": "Some messaging providers can observe the sequence of adds and removes that happen in real groups.  From that, we can simulate MLS histories, under various assumptions about Update scheduling.  The data we would need to support this is effectively a list of (add/remove(id), timestamp) tuples for each group.\r\n\r\nAt the 2019-10 interim, @eomara  and @raphaelrobert agreed to provide some data of this character.",
      "createdAt": "2019-10-01T10:44:48Z",
      "updatedAt": "2020-06-19T12:55:34Z",
      "closedAt": "2020-06-19T12:55:34Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Also @dwd offered to gather XMPP data",
          "createdAt": "2019-10-02T08:38:04Z",
          "updatedAt": "2019-10-02T08:38:04Z"
        }
      ]
    },
    {
      "number": 223,
      "id": "MDU6SXNzdWU1MDA4MjQ4NDM=",
      "title": "Welcome should not leak previous epoch encryption keys",
      "url": "https://github.com/mlswg/mls-protocol/issues/223",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bifurcation",
        "beurdouche"
      ],
      "labels": [
        "recommendation",
        "security"
      ],
      "body": "Instead of initializing new members with information from the previous epoch and requiring them to process an Add, we should initialize new members directly with current epoch information.  This is covered in #209, but should be factored out.",
      "createdAt": "2019-10-01T11:08:36Z",
      "updatedAt": "2019-12-17T10:29:30Z",
      "closedAt": "2019-11-14T18:22:31Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Dependent on: Some modeling to convince ourselves that removing `welcome_info_hash` isn't dangerous\r\n\r\nBlocks: #209 ",
          "createdAt": "2019-10-02T08:46:13Z",
          "updatedAt": "2019-10-02T08:46:13Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I have made a Tamarin model of the 2- and 3-member cases of the proposal in #233, which shows that it provides certain authentication properties that one should expect of an AKE.  In particular, it provides the property that even if the adder is malicious, they cannot cause the new member and the existing members to come to differing views of the group without causing to group to decohere.  (Since the GroupContext is included in the key schedule, this might not be surprising.)\r\n\r\nTamarin model here:\r\n\r\nhttps://github.com/bifurcation/tamarin-ake/blob/master/mls-08-3way.spthy\r\n\r\nGiven this analysis, I'm comfortable making this change.  It's preliminary, but I think it's good enough to justify moving forward with this concept pending a more complete analysis.",
          "createdAt": "2019-10-09T21:08:00Z",
          "updatedAt": "2019-10-09T21:08:00Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #239 ",
          "createdAt": "2019-11-14T18:22:31Z",
          "updatedAt": "2019-11-14T18:22:31Z"
        }
      ]
    },
    {
      "number": 224,
      "id": "MDU6SXNzdWU1MDA5MDU4ODc=",
      "title": "Add extensions for ClientInitKeys",
      "url": "https://github.com/mlswg/mls-protocol/issues/224",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "functionality"
      ],
      "body": "To address the risk of version / ciphersuite downgrade by the CIK server, CIKs need to express the lists of versions and ciphersuites that a client supports.\r\n\r\n* Add a general extensions field to ClientInitKey, in the same form as TLS ClientHello/ServerHello\r\n* Define a `supported_versions` extension\r\n* Define a `supported_ciphersuites` extension\r\n* Require both extensions to be present\r\n\r\nThis allows the creator of a group to verify that CIKs it gets do not omit versions that the other client actually supports.  On Init, the participants of the group can examine the CIKs in the group to verify that the proper version / ciphersuite have been selected.",
      "createdAt": "2019-10-01T13:43:32Z",
      "updatedAt": "2019-12-17T10:28:47Z",
      "closedAt": "2019-11-14T17:58:54Z",
      "comments": []
    },
    {
      "number": 225,
      "id": "MDU6SXNzdWU1MDA5MDc3NzE=",
      "title": "Limit CIK servers' ability to replay",
      "url": "https://github.com/mlswg/mls-protocol/issues/225",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "security"
      ],
      "body": "There are a variety of risks that arise from CIK servers replaying old keys.  If a CIK server has compromised the private key corresponding to a CIK, then it can use that compromised key to join groups indefinitely.  If a client operates from supporting version 2 to supporting versions 2+3, then the CIK server can force the client to use version 2 by continuing to send the old CIK (cf. #224).\r\n\r\nThere are basically two ways to approach this:\r\n\r\n* Expiry / revocation of the CIK\r\n* Expiry / revocation of the credential used to sign the CIK",
      "createdAt": "2019-10-01T13:46:20Z",
      "updatedAt": "2019-12-17T10:28:31Z",
      "closedAt": "2019-10-01T21:38:31Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Duplicate of #215 ",
          "createdAt": "2019-10-01T21:38:31Z",
          "updatedAt": "2019-10-01T21:38:31Z"
        }
      ]
    },
    {
      "number": 226,
      "id": "MDU6SXNzdWU1MDExNTgzODA=",
      "title": "Generalize ASTree to create multi-use per-user secrets",
      "url": "https://github.com/mlswg/mls-protocol/issues/226",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "security",
        "wontfix"
      ],
      "body": "At a minimum we need to make handshake key chains.  If we do Proposals (#209), then we will need to encrypt multiple handshake message per epoch, so we will need key chains instead of just a single handshake key.  Even if we don't do #209, this would improve symmetry / code reuse.\r\n\r\nSpecifically, we should repurpose the ASTree \"per-user secret tree\".  Instead of the leaves of the tree being the starting point for an application key chain, there would be used to derive the starting points for the application key chain, handshake key chain, and possibly exported per-user secrets.\r\n\r\n```\r\n...\r\n | \r\n +--(handshake)--> handshake_secret_[sender]_[0]\r\n | \r\n +--(application)--> application_secret_[sender]_[0]\r\n | \r\n +--(exporter+label)--> exported_secret_[sender]_[label]\r\n```",
      "createdAt": "2019-10-01T21:34:32Z",
      "updatedAt": "2019-12-17T10:28:11Z",
      "closedAt": "2019-11-14T18:22:06Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "This ended up not being necessary.  For handshake messages, we don't need forward secrecy within an epoch, so the full AStree machinery isn't necessary.  Instead we use the simple TLS-like nonce updating described in #209 ",
          "createdAt": "2019-11-14T18:22:06Z",
          "updatedAt": "2019-11-14T18:22:06Z"
        }
      ]
    },
    {
      "number": 227,
      "id": "MDU6SXNzdWU1MDEzNjg0NTI=",
      "title": "Expose extended group attributes to new/existing members",
      "url": "https://github.com/mlswg/mls-protocol/issues/227",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bifurcation",
        "beurdouche"
      ],
      "labels": [
        "? follow-up",
        "enhancement",
        "security"
      ],
      "body": "It could be useful for groups to agree on extended attributes (@psyoptix to provide examples), which are provided to new members and agreed by existing members.  Syntactically, this would mean:\r\n\r\n* An extensions field in the WelcomeInfo message\r\n* Including that field in the GroupContext so that it is confirmed that all members agree\r\n\r\nThat is, these attributes should follow the same general pattern as ciphersuites and versions, where the CIK advertises them (cf. #224) and the group picks and confirms.",
      "createdAt": "2019-10-02T09:09:31Z",
      "updatedAt": "2019-12-20T16:38:04Z",
      "closedAt": "2019-12-20T16:38:03Z",
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "We now have CIK in the leaves #254, hence exposing not only the credential but also the extensions. We currently don't have mechanisms to extend group attribute within the protocol after initial \"agreement\" provided by accepting the message from the creator.",
          "createdAt": "2019-12-20T16:38:03Z",
          "updatedAt": "2019-12-20T16:38:03Z"
        }
      ]
    },
    {
      "number": 228,
      "id": "MDU6SXNzdWU1MDE0MjEyNzQ=",
      "title": "Re-randomize TreeKEM keys",
      "url": "https://github.com/mlswg/mls-protocol/issues/228",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "performance",
        "security"
      ],
      "body": "At the 2019-10 interim, @psyoptix described some work to re-randomize the tree as updates happen:\r\n\r\n* Distribute `(Enc(r), g^r)` in Update/Commit message\r\n* Transform the recipient public key as `x -> x+r, g^x -> g^{x+r}`\r\n\r\nBenefits are roughly some better FS properties, to be described in a forthcoming ePrint.\r\n\r\nCosts:\r\n* Additional public key in `DirectPath`\r\n* Restriction to curves with homomorphic multiplication (in particular, X25519->Ristretto)\r\n* Possibly harder modeling",
      "createdAt": "2019-10-02T11:04:23Z",
      "updatedAt": "2020-01-31T15:12:45Z",
      "closedAt": "2020-01-31T15:12:45Z",
      "comments": [
        {
          "author": "psyoptix",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Improvement to construction which allows using X25510/X448\r\n- Basic Idea: Use multiplicative \"updateable PKE\" instead of additive.\r\n\r\nWhen sending HPKE ciphertext for some message m to (pk, sk) in Update/Commit do:\r\n1) Sample re-randomizer r'. Compute re-randomizer scalar r = HKDF(r, pk, context...).\r\n2) Transform receiver's pk from g^x -> (g^x)^r = g^xr'=: pk'. Send  c <-- Enc(pk, r'|| m). Send (pk', c)\r\n3) Receiver use sk to decrypt c. gets m and r'. compute r. Update sk x to sk' := xr.\r\n\r\nSee \"UPKE for X25519/X448\" and draft-barnes-cfrg-mult-for-7748-00 RFC draft for how to implement \"*\" operation for updating sk --> sk' when using X25519/X448 curves.\r\n\r\n\r\n",
          "createdAt": "2020-01-11T15:00:58Z",
          "updatedAt": "2020-01-11T15:00:58Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "This was discussed at the January 2020 interim, with the conclusion that while this an interesting idea, it would be better handled as an extension.",
          "createdAt": "2020-01-31T15:12:45Z",
          "updatedAt": "2020-01-31T15:12:45Z"
        }
      ]
    },
    {
      "number": 231,
      "id": "MDU6SXNzdWU1MDMwNDI1Nzc=",
      "title": "Weekly Digest (29 September, 2019 - 6 October, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/231",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week 18 issues were created.\nOf these, 3 issues have been closed and 15 issues are still open.\n## OPEN ISSUES\n:green_heart: #230 [Device loss and sig key compromise](https://github.com/mlswg/mls-protocol/pull/230), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #228 [Re-randomize TreeKEM keys](https://github.com/mlswg/mls-protocol/issues/228), by [bifurcation](https://github.com/bifurcation)\n:green_heart: #227 [Expose extended group attributes to new/existing members](https://github.com/mlswg/mls-protocol/issues/227), by [bifurcation](https://github.com/bifurcation)\n:green_heart: #226 [Generalize ASTree to create multi-use per-user secrets](https://github.com/mlswg/mls-protocol/issues/226), by [bifurcation](https://github.com/bifurcation)\n:green_heart: #224 [Add extensions for ClientInitKeys](https://github.com/mlswg/mls-protocol/issues/224), by [bifurcation](https://github.com/bifurcation)\n:green_heart: #223 [Welcome should not leak previous epoch encryption keys](https://github.com/mlswg/mls-protocol/issues/223), by [bifurcation](https://github.com/bifurcation)\n:green_heart: #222 [Performance measurements](https://github.com/mlswg/mls-protocol/issues/222), by [bifurcation](https://github.com/bifurcation)\n:green_heart: #221 [Precisions on authentication and IdentityKeys](https://github.com/mlswg/mls-protocol/pull/221), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #220 [More requirements regarding state loss](https://github.com/mlswg/mls-protocol/pull/220), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #219 [Fix application message truncation attack](https://github.com/mlswg/mls-protocol/pull/219), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #218 [Favor not reusing ClientInitKey reuse (SHOULD)](https://github.com/mlswg/mls-protocol/pull/218), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #217 [Signatures in MLSPlaintext should cover entire group context](https://github.com/mlswg/mls-protocol/issues/217), by [Bren2010](https://github.com/Bren2010)\n:green_heart: #216 [Address risk of re-using nonces after state loss](https://github.com/mlswg/mls-protocol/issues/216), by [Bren2010](https://github.com/Bren2010)\n:green_heart: #215 [Restrict life of ClientInitKey](https://github.com/mlswg/mls-protocol/issues/215), by [Bren2010](https://github.com/Bren2010)\n:green_heart: #214 [Include message type in AAD when encrypting to public keys in leaves of ratchet tree](https://github.com/mlswg/mls-protocol/issues/214), by [Bren2010](https://github.com/Bren2010)\n## CLOSED ISSUES\n:heart: #229 [Correction of three minor typos](https://github.com/mlswg/mls-protocol/pull/229), by [pjunodsc](https://github.com/pjunodsc)\n:heart: #225 [Limit CIK servers' ability to replay](https://github.com/mlswg/mls-protocol/issues/225), by [bifurcation](https://github.com/bifurcation)\n:heart: #213 [Change ciphertext content to be standard TLS format.](https://github.com/mlswg/mls-protocol/pull/213), by [Bren2010](https://github.com/Bren2010)\n## NOISY ISSUE\n:speaker: #219 [Fix application message truncation attack](https://github.com/mlswg/mls-protocol/pull/219), by [beurdouche](https://github.com/beurdouche)\nIt received 5 comments.\n\n - - - \n# PULL REQUESTS\nLast week, 10 pull requests were created, updated or merged.\n## OPEN PULL REQUEST\nLast week, 1 pull request was opened.\n:green_heart: #230 [Device loss and sig key compromise](https://github.com/mlswg/mls-protocol/pull/230), by [beurdouche](https://github.com/beurdouche)\n## UPDATED PULL REQUEST\nLast week, 7 pull requests were updated.\n:yellow_heart: #221 [Precisions on authentication and IdentityKeys](https://github.com/mlswg/mls-protocol/pull/221), by [beurdouche](https://github.com/beurdouche)\n:yellow_heart: #220 [More requirements regarding state loss](https://github.com/mlswg/mls-protocol/pull/220), by [beurdouche](https://github.com/beurdouche)\n:yellow_heart: #219 [Fix application message truncation attack](https://github.com/mlswg/mls-protocol/pull/219), by [beurdouche](https://github.com/beurdouche)\n:yellow_heart: #218 [Favor not reusing ClientInitKey reuse (SHOULD)](https://github.com/mlswg/mls-protocol/pull/218), by [beurdouche](https://github.com/beurdouche)\n:yellow_heart: #209 [Proposals and Commits](https://github.com/mlswg/mls-protocol/pull/209), by [bifurcation](https://github.com/bifurcation)\n:yellow_heart: #208 [Add authenticated_data to the mls message.](https://github.com/mlswg/mls-protocol/pull/208), by [psla](https://github.com/psla)\n:yellow_heart: #200 [Non-destructive add](https://github.com/mlswg/mls-protocol/pull/200), by [bifurcation](https://github.com/bifurcation)\n## MERGED PULL REQUEST\nLast week, 2 pull requests were merged.\n:purple_heart: #229 [Correction of three minor typos](https://github.com/mlswg/mls-protocol/pull/229), by [pjunodsc](https://github.com/pjunodsc)\n:purple_heart: #213 [Change ciphertext content to be standard TLS format.](https://github.com/mlswg/mls-protocol/pull/213), by [Bren2010](https://github.com/Bren2010)\n\n - - - \n# COMMITS\nLast week there were 4 commits.\n:hammer_and_wrench: [Merge pull request #229 from pjunodsc/20191004_minor-typos  Correction of three minor typos](https://github.com/mlswg/mls-protocol/commit/d8672cf6e78d781a5ff6f9e238ee6b0db3b3f026) by [beurdouche](https://github.com/beurdouche)\n:hammer_and_wrench: [Corrected three minor typos](https://github.com/mlswg/mls-protocol/commit/328effac7452a831836ebe43391d3d2caa30cbf7) by [pjunodsc](https://github.com/pjunodsc)\n:hammer_and_wrench: [Merge pull request #213 from Bren2010/brendan/2019.9.0  Change ciphertext content to be standard TLS format.](https://github.com/mlswg/mls-protocol/commit/30c31565ce57843e10e36c69c8573da54d505a56) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Change ciphertext content to be standard TLS format.](https://github.com/mlswg/mls-protocol/commit/1c3a2a6757ba447965ea90e2e1942d9e930d42fb) by [Bren2010](https://github.com/Bren2010)\n\n - - - \n# CONTRIBUTORS\nLast week there were 4 contributors.\n:bust_in_silhouette: [beurdouche](https://github.com/beurdouche)\n:bust_in_silhouette: [pjunodsc](https://github.com/pjunodsc)\n:bust_in_silhouette: [bifurcation](https://github.com/bifurcation)\n:bust_in_silhouette: [Bren2010](https://github.com/Bren2010)\n\n - - - \n# STARGAZERS\nLast week there were no stargazers.\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-10-06T02:31:06Z",
      "updatedAt": "2019-10-07T17:29:23Z",
      "closedAt": "2019-10-07T17:29:23Z",
      "comments": []
    },
    {
      "number": 235,
      "id": "MDU6SXNzdWU1MDk1MzU2MzM=",
      "title": "Weekly Digest (13 October, 2019 - 20 October, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/235",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week, no issues were created.\n\n - - - \n# PULL REQUESTS\nLast week, no pull requests were created, updated or merged.\n\n - - - \n# COMMITS\nLast week there were no commits.\n\n - - - \n# CONTRIBUTORS\nLast week there were no contributors.\n\n - - - \n# STARGAZERS\nLast week there were no stargazers.\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-10-20T02:31:08Z",
      "updatedAt": "2019-10-20T13:48:13Z",
      "closedAt": "2019-10-20T13:48:13Z",
      "comments": []
    },
    {
      "number": 236,
      "id": "MDU6SXNzdWU1MTI5NDk5MDk=",
      "title": "Weekly Digest (20 October, 2019 - 27 October, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/236",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week, no issues were created.\n\n - - - \n# PULL REQUESTS\nLast week, no pull requests were created, updated or merged.\n\n - - - \n# COMMITS\nLast week there were no commits.\n\n - - - \n# CONTRIBUTORS\nLast week there were no contributors.\n\n - - - \n# STARGAZERS\nLast week there were no stargazers.\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-10-27T10:48:51Z",
      "updatedAt": "2019-10-27T15:58:18Z",
      "closedAt": "2019-10-27T15:58:18Z",
      "comments": []
    },
    {
      "number": 237,
      "id": "MDU6SXNzdWU1MTY4MTAzMTM=",
      "title": "Weekly Digest (27 October, 2019 - 3 November, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/237",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week, no issues were created.\n\n - - - \n# PULL REQUESTS\nLast week, no pull requests were created, updated or merged.\n\n - - - \n# COMMITS\nLast week there were no commits.\n\n - - - \n# CONTRIBUTORS\nLast week there were no contributors.\n\n - - - \n# STARGAZERS\nLast week there was 1 stargazer.\n:star: [andytruong](https://github.com/andytruong)\nYou are the star! :star2:\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-11-03T10:48:43Z",
      "updatedAt": "2019-11-03T11:09:56Z",
      "closedAt": "2019-11-03T11:09:56Z",
      "comments": []
    },
    {
      "number": 238,
      "id": "MDU6SXNzdWU1MjA1ODQ2MTE=",
      "title": "Weekly Digest (3 November, 2019 - 10 November, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/238",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week, no issues were created.\n\n - - - \n# PULL REQUESTS\nLast week, 5 pull requests were created, updated or merged.\n## UPDATED PULL REQUEST\nLast week, 3 pull requests were updated.\n:yellow_heart: #218 [Favor not reusing ClientInitKey reuse (SHOULD)](https://github.com/mlswg/mls-protocol/pull/218), by [beurdouche](https://github.com/beurdouche)\n:yellow_heart: #209 [Proposals and Commits](https://github.com/mlswg/mls-protocol/pull/209), by [bifurcation](https://github.com/bifurcation)\n:yellow_heart: #200 [Non-destructive add](https://github.com/mlswg/mls-protocol/pull/200), by [bifurcation](https://github.com/bifurcation)\n## MERGED PULL REQUEST\nLast week, 2 pull requests were merged.\n:purple_heart: #230 [Device loss and sig key compromise](https://github.com/mlswg/mls-protocol/pull/230), by [beurdouche](https://github.com/beurdouche)\n:purple_heart: #221 [Precisions on authentication and IdentityKeys](https://github.com/mlswg/mls-protocol/pull/221), by [beurdouche](https://github.com/beurdouche)\n\n - - - \n# COMMITS\nLast week there were 2 commits.\n:hammer_and_wrench: [Merge pull request #221 from mlswg/beurdouche_auth_control  Precisions on authentication and IdentityKeys](https://github.com/mlswg/mls-protocol/commit/69739df60d07ee53c245ff9bbee7d391f1ce5b9d) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge pull request #230 from mlswg/beurdouche_sig_pcs  Device loss and sig key compromise](https://github.com/mlswg/mls-protocol/commit/d4362b8075dd5e42e1a45c721874409a82a7438f) by [bifurcation](https://github.com/bifurcation)\n\n - - - \n# CONTRIBUTORS\nLast week there was 1 contributor.\n:bust_in_silhouette: [bifurcation](https://github.com/bifurcation)\n\n - - - \n# STARGAZERS\nLast week there were no stargazers.\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-11-10T10:48:58Z",
      "updatedAt": "2019-11-10T12:35:46Z",
      "closedAt": "2019-11-10T12:35:46Z",
      "comments": []
    },
    {
      "number": 248,
      "id": "MDU6SXNzdWU1MjM5Njc5NjA=",
      "title": "Weekly Digest (10 November, 2019 - 17 November, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/248",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week 9 issues were created.\nOf these, 6 issues have been closed and 3 issues are still open.\n## OPEN ISSUES\n:green_heart: #247 [Welcome confirmation and key derivation](https://github.com/mlswg/mls-protocol/pull/247), by [bifurcation](https://github.com/bifurcation)\n:green_heart: #246 [Bugfixes in ClientInitKey, Commit, and Welcome](https://github.com/mlswg/mls-protocol/pull/246), by [bifurcation](https://github.com/bifurcation)\n:green_heart: #245 [Unpredictable epochs](https://github.com/mlswg/mls-protocol/pull/245), by [bifurcation](https://github.com/bifurcation)\n## CLOSED ISSUES\n:heart: #244 [Some editorial fixes](https://github.com/mlswg/mls-protocol/pull/244), by [bifurcation](https://github.com/bifurcation)\n:heart: #243 [Add GroupContext to signatures and AAD](https://github.com/mlswg/mls-protocol/pull/243), by [bifurcation](https://github.com/bifurcation)\n:heart: #242 [Pack multiple Proposals and a Commit together](https://github.com/mlswg/mls-protocol/pull/242), by [bifurcation](https://github.com/bifurcation)\n:heart: #241 [IANA Considerations](https://github.com/mlswg/mls-protocol/pull/241), by [bifurcation](https://github.com/bifurcation)\n:heart: #240 [External proposals](https://github.com/mlswg/mls-protocol/pull/240), by [bifurcation](https://github.com/bifurcation)\n:heart: #239 [Welcome* == Init](https://github.com/mlswg/mls-protocol/pull/239), by [bifurcation](https://github.com/bifurcation)\n## NOISY ISSUE\n:speaker: #242 [Pack multiple Proposals and a Commit together](https://github.com/mlswg/mls-protocol/pull/242), by [bifurcation](https://github.com/bifurcation)\nIt received 2 comments.\n\n - - - \n# PULL REQUESTS\nLast week, 13 pull requests were created, updated or merged.\n## UPDATED PULL REQUEST\nLast week, 3 pull requests were updated.\n:yellow_heart: #247 [Welcome confirmation and key derivation](https://github.com/mlswg/mls-protocol/pull/247), by [bifurcation](https://github.com/bifurcation)\n:yellow_heart: #246 [Bugfixes in ClientInitKey, Commit, and Welcome](https://github.com/mlswg/mls-protocol/pull/246), by [bifurcation](https://github.com/bifurcation)\n:yellow_heart: #245 [Unpredictable epochs](https://github.com/mlswg/mls-protocol/pull/245), by [bifurcation](https://github.com/bifurcation)\n## MERGED PULL REQUEST\nLast week, 10 pull requests were merged.\n:purple_heart: #244 [Some editorial fixes](https://github.com/mlswg/mls-protocol/pull/244), by [bifurcation](https://github.com/bifurcation)\n:purple_heart: #243 [Add GroupContext to signatures and AAD](https://github.com/mlswg/mls-protocol/pull/243), by [bifurcation](https://github.com/bifurcation)\n:purple_heart: #242 [Pack multiple Proposals and a Commit together](https://github.com/mlswg/mls-protocol/pull/242), by [bifurcation](https://github.com/bifurcation)\n:purple_heart: #241 [IANA Considerations](https://github.com/mlswg/mls-protocol/pull/241), by [bifurcation](https://github.com/bifurcation)\n:purple_heart: #240 [External proposals](https://github.com/mlswg/mls-protocol/pull/240), by [bifurcation](https://github.com/bifurcation)\n:purple_heart: #239 [Welcome* == Init](https://github.com/mlswg/mls-protocol/pull/239), by [bifurcation](https://github.com/bifurcation)\n:purple_heart: #234 [Add downgrade protection to ClientInitKeys](https://github.com/mlswg/mls-protocol/pull/234), by [bifurcation](https://github.com/bifurcation)\n:purple_heart: #218 [Favor not reusing ClientInitKey reuse (SHOULD)](https://github.com/mlswg/mls-protocol/pull/218), by [beurdouche](https://github.com/beurdouche)\n:purple_heart: #209 [Proposals and Commits](https://github.com/mlswg/mls-protocol/pull/209), by [bifurcation](https://github.com/bifurcation)\n:purple_heart: #200 [Non-destructive add](https://github.com/mlswg/mls-protocol/pull/200), by [bifurcation](https://github.com/bifurcation)\n\n - - - \n# COMMITS\nLast week there were 38 commits.\n:hammer_and_wrench: [Merge pull request #244 from mlswg/editorial  Some editorial fixes](https://github.com/mlswg/mls-protocol/commit/09110a985ad173c546c37707e90614ae54f7468a) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Some editorial fixes](https://github.com/mlswg/mls-protocol/commit/6961d3ec6915ecec9d7e8397cd6c4e7e7cb8d71a) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge pull request #242 from mlswg/multi  Pack multiple Proposals and a Commit together](https://github.com/mlswg/mls-protocol/commit/b3f7fe7c836cfd951fc638966ebd95f478324f7d) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Nits](https://github.com/mlswg/mls-protocol/commit/f8e5827a8d1c8a2b181cb8d6d9540fa4bc316f3c) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Nits](https://github.com/mlswg/mls-protocol/commit/1418d678c94f1971e682068e4836ce6bf16f0e75) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Comments from @beurdouche](https://github.com/mlswg/mls-protocol/commit/866829e6602b8a025dc32db27c9b43259be9b411) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge branch 'master' into multi](https://github.com/mlswg/mls-protocol/commit/6fcb81c1960b5f1781392bef48764cb1932f73cb) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge pull request #234 from mlswg/cik-extensions  Add downgrade protection to ClientInitKeys](https://github.com/mlswg/mls-protocol/commit/1ba65c11aee17962c22c85e1b2eb2250e3584a9c) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge branch 'master' into cik-extensions](https://github.com/mlswg/mls-protocol/commit/5f9c2ff63e822ff7a51832778834be942e03f8b6) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge pull request #239 from mlswg/welcome-equals-init  Welcome* == Init](https://github.com/mlswg/mls-protocol/commit/517c83b3b83ae73d5bd58cff763245c771567d2e) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge branch 'master' into welcome-equals-init](https://github.com/mlswg/mls-protocol/commit/292a51be8f9ebcc921349f2a2fa469873bb29583) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Comments from @beurdouche and a bugfix](https://github.com/mlswg/mls-protocol/commit/2f2f5d813037f7cf3c3d0d78612bc506f31eef5e) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge pull request #218 from mlswg/beurdouche_noreuse  Favor not reusing ClientInitKey reuse (SHOULD)](https://github.com/mlswg/mls-protocol/commit/39006cae700c2acdd769046911b6983c7d566c66) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge pull request #200 from mlswg/non-destructive-add  Non-destructive add](https://github.com/mlswg/mls-protocol/commit/d7ca4817c58cf48fd1ddc23dea5be4b5e89595fa) by [beurdouche](https://github.com/beurdouche)\n:hammer_and_wrench: [Merge pull request #243 from mlswg/inputs  Add GroupContext to signatures and AAD](https://github.com/mlswg/mls-protocol/commit/3bc25daa05026562a7221ca228498451ded9ceb4) by [beurdouche](https://github.com/beurdouche)\n:hammer_and_wrench: [Merge pull request #241 from mlswg/iana  IANA Considerations](https://github.com/mlswg/mls-protocol/commit/e03e5d74e59ba2aca912b6f454141a6d204bad3d) by [beurdouche](https://github.com/beurdouche)\n:hammer_and_wrench: [Merge pull request #240 from mlswg/external-proposals  External proposals](https://github.com/mlswg/mls-protocol/commit/2eb798398763655082d43c22fab5e52d563ecd4b) by [beurdouche](https://github.com/beurdouche)\n:hammer_and_wrench: [Merge branch 'master' into non-destructive-add](https://github.com/mlswg/mls-protocol/commit/064353ecff9d84b719a1333d53e785c2593642c5) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge branch 'master' into welcome-equals-init](https://github.com/mlswg/mls-protocol/commit/93de1beb1ec07c6490e9e827fda46c5b05710fe7) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge branch 'master' into external-proposals](https://github.com/mlswg/mls-protocol/commit/e543c19029d839ffe95e8ebd0a6c8597a0802290) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge branch 'master' into iana](https://github.com/mlswg/mls-protocol/commit/96599f8b82016f8ffd43941cb4d810e3f5362df2) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge branch 'master' into multi](https://github.com/mlswg/mls-protocol/commit/c9a09772ab5bd49fe12c180f89e876b8c1c64e1f) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge branch 'master' into inputs](https://github.com/mlswg/mls-protocol/commit/34b3022a9ba40cb96114734915e7bb82af3c171c) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge pull request #209 from mlswg/proposals  Proposals and Commits](https://github.com/mlswg/mls-protocol/commit/41a2389abf922fe0c3dbcc1ec67e2ddbd7416ec2) by [beurdouche](https://github.com/beurdouche)\n:hammer_and_wrench: [Comments from Karthik and Benjamin](https://github.com/mlswg/mls-protocol/commit/1af815682b86f1bb659302553b72c57517e6c48d) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Add GroupContext to signatures and AAD](https://github.com/mlswg/mls-protocol/commit/33b260fdca7b46cdabf76b81370f8c75f56fbcc1) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Changelog](https://github.com/mlswg/mls-protocol/commit/afc4965e76175fc3948466587719fbf805f5b184) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Pack multiple Proposals and a Commit together](https://github.com/mlswg/mls-protocol/commit/c6d55441a77f6e44b645f4c9b8c514d28454b17a) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Break into subsections](https://github.com/mlswg/mls-protocol/commit/4aad99c29a04eae55ab85b97b95eb26a89db3b94) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Add expiration extension](https://github.com/mlswg/mls-protocol/commit/60f596f8a6db5aa6b1912a4eba405042db445031) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Add downgrade protection recommendations](https://github.com/mlswg/mls-protocol/commit/235ff3d09ef3ce324d3e8a94c74209495e6c6986) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge branch 'welcome-equals-init' into cik-extensions](https://github.com/mlswg/mls-protocol/commit/bdffffc72e1f1b472a6e5bc28b5775fbdb287a30) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge branch 'proposals' into cik-extensions](https://github.com/mlswg/mls-protocol/commit/879528bf3890a0cc7b73318df7e18a35c9b4eb52) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [IANA considerations](https://github.com/mlswg/mls-protocol/commit/507744be08e202634311d8638b7437b230d0e703) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [User-initiated Add](https://github.com/mlswg/mls-protocol/commit/bd70d67c433529e072bdac480ff54a7f5057424d) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [External proposals](https://github.com/mlswg/mls-protocol/commit/5ff5e41e98a913f0ee01e6dfdc291f56bcd741c5) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Collapse multiple Welcomes and make that Init](https://github.com/mlswg/mls-protocol/commit/5490d0ebfa1b41fff0ee54966ef375c37dadab68) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge branch 'master' into proposals](https://github.com/mlswg/mls-protocol/commit/8f506ecac14c5f1bb413305901093202e94073fb) by [bifurcation](https://github.com/bifurcation)\n\n - - - \n# CONTRIBUTORS\nLast week there were 2 contributors.\n:bust_in_silhouette: [bifurcation](https://github.com/bifurcation)\n:bust_in_silhouette: [beurdouche](https://github.com/beurdouche)\n\n - - - \n# STARGAZERS\nLast week there was 1 stargazer.\n:star: [PaulLeCam](https://github.com/PaulLeCam)\nYou are the star! :star2:\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-11-17T10:49:01Z",
      "updatedAt": "2019-11-17T18:53:17Z",
      "closedAt": "2019-11-17T18:53:17Z",
      "comments": []
    },
    {
      "number": 249,
      "id": "MDU6SXNzdWU1MjQ1NTE0NzI=",
      "title": "Discuss \"closing\" groups vs PCS",
      "url": "https://github.com/mlswg/mls-protocol/issues/249",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "performance",
        "security"
      ],
      "body": "Keeping cryptographic states for groups in which no members ever update is a problem because there is now a very large window of compromise for the session if it ever restarts updating. However, one could argue that recreating the group when the application needs it will reduce the PCS benefits we had from an ongoing session... Discuss.",
      "createdAt": "2019-11-18T18:51:16Z",
      "updatedAt": "2020-06-19T14:04:59Z",
      "closedAt": "2020-06-19T14:04:59Z",
      "comments": []
    },
    {
      "number": 250,
      "id": "MDU6SXNzdWU1MjQ1NTYxNDE=",
      "title": "Rename update_secret to commit_secret ?",
      "url": "https://github.com/mlswg/mls-protocol/issues/250",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2019-11-18T19:00:52Z",
      "updatedAt": "2019-12-20T16:59:54Z",
      "closedAt": "2019-12-15T09:30:57Z",
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Fixed by #257",
          "createdAt": "2019-12-15T09:30:57Z",
          "updatedAt": "2019-12-15T09:30:57Z"
        }
      ]
    },
    {
      "number": 258,
      "id": "MDU6SXNzdWU1MjQ5MDQ3NjI=",
      "title": "Should direct paths include the root?",
      "url": "https://github.com/mlswg/mls-protocol/issues/258",
      "state": "CLOSED",
      "author": "kelrit",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "In the \"Ratchet Trees\" section it specifies that a direct path does not include the root. From an ad hoc discussion with @bifurcation in Singapore this may not be required. I at least don't see a reason for it - in  \"Synchronizing Views of the Tree\" it specifies to transmit information \"for each node in the direct path of the leaf, as well as the root\", and other mentions of direct paths seem to assume it includes the root.",
      "createdAt": "2019-11-19T10:08:32Z",
      "updatedAt": "2019-12-20T16:34:00Z",
      "closedAt": "2019-12-20T16:34:00Z",
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "The path secret for the parent of the root in not included but the path secret at the level of the root has to be encrypted to the non-updated child subgroup. Can you point us to a place where you think the draft is incorrect ? If there is one we can fix it... : ) Thanks.",
          "createdAt": "2019-11-21T09:05:13Z",
          "updatedAt": "2019-11-21T09:05:13Z"
        },
        {
          "author": "kelrit",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In particular the \"Ratchet Trees\" section that specifies that \"[t]he direct path of a root is the empty list\" looks incorrect. However the usage in the draft seems to imply it does include the root, or specifies \"intermediate nodes and the root\". It appears more natural to just include the root node (or I've seriously misunderstood something here).\r\n\r\nSemi-appendix: all mentions of \"Direct path\":\r\n\r\n**Synchronizing Views of the Tree** section:\r\n> When a client proposes a change to the tree (e.g., to add or remove a member), it transmits a handshake message containing a set of public values for intermediate nodes in the direct path of a leaf.\r\n\r\nThis message contains the public key for the root node as well.\r\n\r\n> To perform an update for a leaf, the sender broadcasts to the group the following information for each node in the direct path of the leaf, as well as the root\r\n\r\nUses direct path with the root.\r\n\r\n> Compute the updated path secrets.\r\n> - Identify a node in the direct path for which the local member is in the subtree of the non-updated child.\r\n\r\nThis node could be the root node.\r\n\r\n> Merge the updated path secrets into the tree.\r\n> - Replace the public keys for nodes on the direct path with the received public keys.\r\n\r\nThis could also be the root node.\r\n\r\n**Direct paths** section:\r\n\r\n> As described in {{ratchet-tree-updates}}, each MLS message needs to transmit node values along the direct path of a leaf. The path contains a public key for the leaf node, and a public key and encrypted secret value for intermediate nodes in the path. In both cases, the path is ordered from the leaf to the root; each node MUST be the parent of its predecessor.\r\n\r\nThis should also include the root node.\r\n\r\n**Group Creation** section:\r\n\r\n> The only choices the creator makes here are its own HPKE key and credential, the leaf secret from which the Commit is built, and the intermediate key pairs along the direct path to the root.\r\n\r\nThe creator also decides the root node key pair.\r\n\r\n> Process the path value to update the ratchet tree referenced by the provisional GroupContext and generate the update secret:\r\n> Update the ratchet tree by replacing nodes in the direct path of the sender with the corresponding nodes in the path (see {{direct-paths}}).\r\n\r\nThis replaces the root node secret as well.\r\n\r\n**Welcoming New Members** section:\r\n\r\n> In the same encrypted package, the committer transmits the path secret for the lowest node contained in the direct paths of both the committer and the new member. This allows the new member to compute private keys for nodes in its direct path that are being reset by the corresponding Commit.\r\n\r\n> Identify the lowest node at which the direct paths from index and signer_index overlap. Set private keys for that node and its parents up to the root of the tree, using the path_secret from the KeyPackage and following the algorithm in {{ratchet-tree-updates}} to move up the tree.\r\n\r\nThis node could be the root node.",
          "createdAt": "2019-11-21T10:15:07Z",
          "updatedAt": "2019-11-21T10:15:07Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "I believe this has been clarified as part as the redefinition of the DirectPath in the Leaf CIK PR",
          "createdAt": "2019-12-20T16:33:59Z",
          "updatedAt": "2019-12-20T16:33:59Z"
        }
      ]
    },
    {
      "number": 260,
      "id": "MDU6SXNzdWU1Mjc2ODAyMzI=",
      "title": "Weekly Digest (17 November, 2019 - 24 November, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/260",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week 11 issues were created.\nOf these, 1 issues have been closed and 10 issues are still open.\n## OPEN ISSUES\n:green_heart: #258 [Should direct paths include the root?](https://github.com/mlswg/mls-protocol/issues/258), by [kelrit](https://github.com/kelrit)\n:green_heart: #257 [Make clear that Commits are responsible for FS and PCS](https://github.com/mlswg/mls-protocol/pull/257), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #256 [Remove OPEN ISSUE: the entire group context is now in the signature](https://github.com/mlswg/mls-protocol/pull/256), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #255 [Move epoch numbers to UInt64](https://github.com/mlswg/mls-protocol/pull/255), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #254 [Initial work to use CIK in leaves](https://github.com/mlswg/mls-protocol/pull/254), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #253 [Initial version of the Tree of Signature](https://github.com/mlswg/mls-protocol/pull/253), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #252 [Bugfixes: fix a few typos in text and structs](https://github.com/mlswg/mls-protocol/pull/252), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #251 [Initial proposal for PSK inputs](https://github.com/mlswg/mls-protocol/pull/251), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #250 [Rename update_secret to commit_secret ?](https://github.com/mlswg/mls-protocol/issues/250), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #249 [Discuss \"closing\" groups vs PCS](https://github.com/mlswg/mls-protocol/issues/249), by [beurdouche](https://github.com/beurdouche)\n## CLOSED ISSUES\n:heart: #259 [Remove blanking of nodes on Add, clarify language](https://github.com/mlswg/mls-protocol/pull/259), by [kelrit](https://github.com/kelrit)\n## NOISY ISSUE\n:speaker: #258 [Should direct paths include the root?](https://github.com/mlswg/mls-protocol/issues/258), by [kelrit](https://github.com/kelrit)\nIt received 2 comments.\n\n - - - \n# PULL REQUESTS\nLast week, 11 pull requests were created, updated or merged.\n## OPEN PULL REQUEST\nLast week, 6 pull requests were opened.\n:green_heart: #257 [Make clear that Commits are responsible for FS and PCS](https://github.com/mlswg/mls-protocol/pull/257), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #256 [Remove OPEN ISSUE: the entire group context is now in the signature](https://github.com/mlswg/mls-protocol/pull/256), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #255 [Move epoch numbers to UInt64](https://github.com/mlswg/mls-protocol/pull/255), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #254 [Initial work to use CIK in leaves](https://github.com/mlswg/mls-protocol/pull/254), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #253 [Initial version of the Tree of Signature](https://github.com/mlswg/mls-protocol/pull/253), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #252 [Bugfixes: fix a few typos in text and structs](https://github.com/mlswg/mls-protocol/pull/252), by [beurdouche](https://github.com/beurdouche)\n## UPDATED PULL REQUEST\nLast week, 4 pull requests were updated.\n:yellow_heart: #251 [Initial proposal for PSK inputs](https://github.com/mlswg/mls-protocol/pull/251), by [beurdouche](https://github.com/beurdouche)\n:yellow_heart: #247 [Welcome confirmation and key derivation](https://github.com/mlswg/mls-protocol/pull/247), by [bifurcation](https://github.com/bifurcation)\n:yellow_heart: #219 [Fix application message truncation attack](https://github.com/mlswg/mls-protocol/pull/219), by [beurdouche](https://github.com/beurdouche)\n:yellow_heart: #198 [Initial design for the key schedule Exporter](https://github.com/mlswg/mls-protocol/pull/198), by [beurdouche](https://github.com/beurdouche)\n## MERGED PULL REQUEST\nLast week, 1 pull request was merged.\n:purple_heart: #259 [Remove blanking of nodes on Add, clarify language](https://github.com/mlswg/mls-protocol/pull/259), by [kelrit](https://github.com/kelrit)\n\n - - - \n# COMMITS\nLast week there were 2 commits.\n:hammer_and_wrench: [Merge pull request #259 from kelrit/master  Remove blanking of nodes on Add, clarify language](https://github.com/mlswg/mls-protocol/commit/bff920cf70b0de0ae5e2a71ae85ddf66615fe443) by [beurdouche](https://github.com/beurdouche)\n:hammer_and_wrench: [Remove blanking of nodes on Add, clarify language  - Blanking on add (I think) was obsoleted by unmerged leaves - Clarify/fix some language](https://github.com/mlswg/mls-protocol/commit/f9d003b76c69b80c429396ef90db54c847968300) by [kelrit](https://github.com/kelrit)\n\n - - - \n# CONTRIBUTORS\nLast week there were 2 contributors.\n:bust_in_silhouette: [beurdouche](https://github.com/beurdouche)\n:bust_in_silhouette: [kelrit](https://github.com/kelrit)\n\n - - - \n# STARGAZERS\nLast week there were 2 stagazers.\n:star: [Zottel](https://github.com/Zottel)\n:star: [zoresvit](https://github.com/zoresvit)\nYou all are the stars! :star2:\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-11-24T10:48:42Z",
      "updatedAt": "2019-11-24T16:05:28Z",
      "closedAt": "2019-11-24T16:05:28Z",
      "comments": []
    },
    {
      "number": 261,
      "id": "MDU6SXNzdWU1MzA3MTE2ODY=",
      "title": "Weekly Digest (24 November, 2019 - 1 December, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/261",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week, no issues were created.\n\n - - - \n# PULL REQUESTS\nLast week, 1 pull request was created, updated or merged.\n## UPDATED PULL REQUEST\nLast week, 1 pull request was updated.\n:yellow_heart: #255 [Move epoch numbers to UInt64](https://github.com/mlswg/mls-protocol/pull/255), by [beurdouche](https://github.com/beurdouche)\n\n - - - \n# COMMITS\nLast week there were no commits.\n\n - - - \n# CONTRIBUTORS\nLast week there were no contributors.\n\n - - - \n# STARGAZERS\nLast week there were no stargazers.\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-12-01T10:49:08Z",
      "updatedAt": "2019-12-01T20:34:03Z",
      "closedAt": "2019-12-01T20:34:03Z",
      "comments": []
    },
    {
      "number": 262,
      "id": "MDU6SXNzdWU1MzQ1MjM2ODM=",
      "title": "Weekly Digest (1 December, 2019 - 8 December, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/262",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week, no issues were created.\n\n - - - \n# PULL REQUESTS\nLast week, no pull requests were created, updated or merged.\n\n - - - \n# COMMITS\nLast week there were no commits.\n\n - - - \n# CONTRIBUTORS\nLast week there were no contributors.\n\n - - - \n# STARGAZERS\nLast week there were no stargazers.\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-12-08T10:48:44Z",
      "updatedAt": "2019-12-08T10:52:57Z",
      "closedAt": "2019-12-08T10:52:57Z",
      "comments": []
    },
    {
      "number": 264,
      "id": "MDU6SXNzdWU1MzU5ODU3NTM=",
      "title": "Fix inconsistent definitions of Derive-Secret",
      "url": "https://github.com/mlswg/mls-protocol/issues/264",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bifurcation",
        "beurdouche"
      ],
      "labels": [
        "bug",
        "security",
        "work in progress"
      ],
      "body": "On the one hand...\r\n```\r\nDerive-Secret(Secret, Label) =\r\n    HKDF-Expand-Label(Secret, Label, \"\", Hash.length)\r\n```\r\n\r\nOn the other hand...\r\n```\r\n...\r\n |\r\n +--> Derive-Secret(., \"sender data\", GroupContext_[n])\r\n |    = sender_data_secret\r\n```\r\n\r\nWe probably want Derive-Secret to have a third argument for the GroupContext, or define that Derive-Secret always takes the current group context.",
      "createdAt": "2019-12-10T20:48:55Z",
      "updatedAt": "2020-06-19T12:55:35Z",
      "closedAt": "2020-06-19T12:55:34Z",
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "I would much prefer to go back to the TLS definition, we don't need the `GroupContext` thing at all, this is an implementation artifact...\r\n\r\nDefinition we use for TLS and the symbolic proof in the formal model:\r\n```\r\nDerive-Secret(Secret, Label, Messages) =\r\n            HKDF-Expand-Label(Secret, Label,\r\n                              Transcript-Hash(Messages), Hash.length)```",
          "createdAt": "2019-12-20T15:53:40Z",
          "updatedAt": "2019-12-20T15:55:10Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Ps: because `Messages` is quite long in MLS, we directly pass `Transcript-Hash(Messages)` to `Derive-Secret` instead.",
          "createdAt": "2019-12-20T15:56:48Z",
          "updatedAt": "2019-12-20T15:56:48Z"
        }
      ]
    },
    {
      "number": 266,
      "id": "MDU6SXNzdWU1MzcwMjU5OTM=",
      "title": "Relax default policy of adding from left to right",
      "url": "https://github.com/mlswg/mls-protocol/issues/266",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "performance",
        "privacy"
      ],
      "body": "The current default strategy (add from left to right) doesn't allow for flexibility in forming optimized subgroups.\r\nIt also isn't super good for privacy: a newcomer should not be able to infer who is the creator of the group at epoch 0 from its position in the tree except when she is in the initial participants...",
      "createdAt": "2019-12-12T14:52:00Z",
      "updatedAt": "2020-07-27T19:09:37Z",
      "closedAt": "2020-07-27T19:09:37Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Is it only the creator you're worried about?  If so, then we should be able to address that just by having the creator put themselves elsewhere in the tree.\r\n\r\nI'm also not convinced that this is an aspect of privacy that I really care about enough to design much mechanism around it.  It only applies at group creation time anyway, since after that, a new joiner doesn't know if member 0 is the creator or someone who was added after.",
          "createdAt": "2020-01-31T15:16:43Z",
          "updatedAt": "2020-01-31T15:16:43Z"
        }
      ]
    },
    {
      "number": 267,
      "id": "MDU6SXNzdWU1MzgwMzM1MDg=",
      "title": "Weekly Digest (8 December, 2019 - 15 December, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/267",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week 4 issues were created.\nOf these, 0 issues have been closed and 4 issues are still open.\n## OPEN ISSUES\n:green_heart: #266 [Relax default policy of adding from left to right](https://github.com/mlswg/mls-protocol/issues/266), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #265 [Align spec text with implementation](https://github.com/mlswg/mls-protocol/pull/265), by [bifurcation](https://github.com/bifurcation)\n:green_heart: #264 [Fix inconsistent definitions of Derive-Secret](https://github.com/mlswg/mls-protocol/issues/264), by [bifurcation](https://github.com/bifurcation)\n:green_heart: #263 [Change special values to structed types for external senders](https://github.com/mlswg/mls-protocol/pull/263), by [kelrit](https://github.com/kelrit)\n\n - - - \n# PULL REQUESTS\nLast week, 14 pull requests were created, updated or merged.\n## UPDATED PULL REQUEST\nLast week, 8 pull requests were updated.\n:yellow_heart: #265 [Align spec text with implementation](https://github.com/mlswg/mls-protocol/pull/265), by [bifurcation](https://github.com/bifurcation)\n:yellow_heart: #263 [Change special values to structed types for external senders](https://github.com/mlswg/mls-protocol/pull/263), by [kelrit](https://github.com/kelrit)\n:yellow_heart: #254 [Initial work to use CIK in leaves](https://github.com/mlswg/mls-protocol/pull/254), by [beurdouche](https://github.com/beurdouche)\n:yellow_heart: #253 [Initial version of the Tree of Signature](https://github.com/mlswg/mls-protocol/pull/253), by [beurdouche](https://github.com/beurdouche)\n:yellow_heart: #247 [Welcome confirmation and key derivation](https://github.com/mlswg/mls-protocol/pull/247), by [bifurcation](https://github.com/bifurcation)\n:yellow_heart: #246 [Bugfixes in ClientInitKey, Commit, and Welcome](https://github.com/mlswg/mls-protocol/pull/246), by [bifurcation](https://github.com/bifurcation)\n:yellow_heart: #245 [Unpredictable epochs](https://github.com/mlswg/mls-protocol/pull/245), by [bifurcation](https://github.com/bifurcation)\n:yellow_heart: #219 [Fix application message truncation attack](https://github.com/mlswg/mls-protocol/pull/219), by [beurdouche](https://github.com/beurdouche)\n## MERGED PULL REQUEST\nLast week, 6 pull requests were merged.\n:purple_heart: #257 [Make clear that Commits are responsible for FS and PCS](https://github.com/mlswg/mls-protocol/pull/257), by [beurdouche](https://github.com/beurdouche)\n:purple_heart: #256 [Remove OPEN ISSUE: the entire group context is now in the signature](https://github.com/mlswg/mls-protocol/pull/256), by [beurdouche](https://github.com/beurdouche)\n:purple_heart: #255 [Move epoch numbers to UInt64](https://github.com/mlswg/mls-protocol/pull/255), by [beurdouche](https://github.com/beurdouche)\n:purple_heart: #252 [Bugfixes: fix a few typos in text and structs](https://github.com/mlswg/mls-protocol/pull/252), by [beurdouche](https://github.com/beurdouche)\n:purple_heart: #251 [Initial proposal for PSK inputs](https://github.com/mlswg/mls-protocol/pull/251), by [beurdouche](https://github.com/beurdouche)\n:purple_heart: #198 [Initial design for the key schedule Exporter](https://github.com/mlswg/mls-protocol/pull/198), by [beurdouche](https://github.com/beurdouche)\n\n - - - \n# COMMITS\nLast week there were 10 commits.\n:hammer_and_wrench: [Merge pull request #198 from mlswg/beurdouche_exporter  Initial design for the key schedule Exporter](https://github.com/mlswg/mls-protocol/commit/d1c8986d3ef932ae4a7cc05b4172d2762428fcd0) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Fix typo in the exporter section](https://github.com/mlswg/mls-protocol/commit/d7e67c208d70a846b3aa32bd70596bec3c990049) by [beurdouche](https://github.com/beurdouche)\n:hammer_and_wrench: [Merge branch 'master' into beurdouche_exporter](https://github.com/mlswg/mls-protocol/commit/7ed23e57901753871eacc9ad0d954dd136f4e529) by [beurdouche](https://github.com/beurdouche)\n:hammer_and_wrench: [Merge pull request #251 from mlswg/beurdouche_psk  Initial proposal for PSK inputs](https://github.com/mlswg/mls-protocol/commit/3eee58aa2ba2896a0f28fb9e1c6df16245b6fee7) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Fix merging conflict with Master](https://github.com/mlswg/mls-protocol/commit/8fddd9af921b76f9b88bc41b9a65b4626c027b47) by [beurdouche](https://github.com/beurdouche)\n:hammer_and_wrench: [Insert on open issue for how to coordinate a PSK insertion](https://github.com/mlswg/mls-protocol/commit/517d461a3a1b5ef9bfbc19e1d7709bf9345d81c5) by [beurdouche](https://github.com/beurdouche)\n:hammer_and_wrench: [Merge pull request #252 from mlswg/beurdouche_bugfixes  Bugfixes: fix a few typos in text and structs](https://github.com/mlswg/mls-protocol/commit/c99d7c11318d78545a15973776b6bb1cf62833ea) by [raphaelrobert](https://github.com/raphaelrobert)\n:hammer_and_wrench: [Merge pull request #255 from mlswg/beurdouche_epoch  Move epoch numbers to UInt64](https://github.com/mlswg/mls-protocol/commit/6fc93429ad31553ca34f657f457da54272a962b0) by [raphaelrobert](https://github.com/raphaelrobert)\n:hammer_and_wrench: [Merge pull request #256 from mlswg/beurdouche_rem_openissue  Remove OPEN ISSUE: the entire group context is now in the signature](https://github.com/mlswg/mls-protocol/commit/c6bbdcd315d2201fb85681a3dc12d3d201135acf) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge pull request #257 from mlswg/beurdouche_us_to_cs  Make clear that Commits are responsible for FS and PCS](https://github.com/mlswg/mls-protocol/commit/5140d9417f022f9313ac4ae4eb7355f18a12d517) by [bifurcation](https://github.com/bifurcation)\n\n - - - \n# CONTRIBUTORS\nLast week there were 3 contributors.\n:bust_in_silhouette: [bifurcation](https://github.com/bifurcation)\n:bust_in_silhouette: [beurdouche](https://github.com/beurdouche)\n:bust_in_silhouette: [raphaelrobert](https://github.com/raphaelrobert)\n\n - - - \n# STARGAZERS\nLast week there were no stargazers.\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-12-15T10:48:39Z",
      "updatedAt": "2019-12-15T10:59:49Z",
      "closedAt": "2019-12-15T10:59:49Z",
      "comments": []
    },
    {
      "number": 268,
      "id": "MDU6SXNzdWU1Mzg5MTg5NDU=",
      "title": "Missing context in the PSK/Importer injection",
      "url": "https://github.com/mlswg/mls-protocol/issues/268",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [
        "beurdouche"
      ],
      "labels": [
        "bug",
        "security"
      ],
      "body": "I forgot to push my last commit when merging #251 there should be a non-empty context for within the `Derive-Secret` just after the PSK.\r\n\r\nFix this when doing step 2 to keep close to the TLS importer...\r\n\r\n",
      "createdAt": "2019-12-17T08:42:05Z",
      "updatedAt": "2020-07-27T19:12:57Z",
      "closedAt": "2020-07-27T19:12:56Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Think this is obsolete given recent revisions to Derive-Secret",
          "createdAt": "2020-07-27T19:12:56Z",
          "updatedAt": "2020-07-27T19:12:56Z"
        }
      ]
    },
    {
      "number": 269,
      "id": "MDU6SXNzdWU1Mzg5OTEwOTA=",
      "title": "Randomize values in the common framing header",
      "url": "https://github.com/mlswg/mls-protocol/issues/269",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "enhancement",
        "privacy",
        "work in progress"
      ],
      "body": "We can't really touch the ContentType because of the ordering constraints.\r\n\r\nWe could try to improve for the Epoch Number but loosing lexicographical ordering of the epoch numbers is a problem for transport loss + DS reordering.\r\n\r\nWe can definitely make sure that only group members can recognize the Group Identifier *across epochs* by generating the GID from the Key Schedule.\r\nWe also can do significantly better if we allow the DS to assist and modify the GID by deterministically blinding the GID with a pseudo random recipient ID. In that case seeing the GID after dispatching in the delivery queue will make it significantly more difficult to determine the group.\r\n\r\n\r\n\r\n",
      "createdAt": "2019-12-17T10:56:38Z",
      "updatedAt": "2020-10-19T14:31:06Z",
      "closedAt": "2020-10-19T14:31:06Z",
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "See also: https://github.com/mlswg/mls-protocol/pull/245",
          "createdAt": "2019-12-17T10:58:24Z",
          "updatedAt": "2019-12-17T10:58:24Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "After WG discussion, we decided not to do this.  An implementation can provide this randomization if they like; all that is required is for clients to maintain a mapping between randomized IDs and groupID/epochID pairs.",
          "createdAt": "2020-10-19T14:31:06Z",
          "updatedAt": "2020-10-19T14:31:06Z"
        }
      ]
    },
    {
      "number": 270,
      "id": "MDU6SXNzdWU1Mzk1OTY0Mjg=",
      "title": "Expiration on \"last resort key\" must not be omitted",
      "url": "https://github.com/mlswg/mls-protocol/issues/270",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "security",
        "work in progress"
      ],
      "body": "Raphael and I noticed that the expiration can be omitted on a last resort key.\r\nDiscuss this as it doesn't seem to be a good idea, maybe a long expiration time is better...\r\nThis is also related to have the expiration extension mandatory or not.\r\n\r\nBecause we are planning signature key rotation in #254 we may not have to enforce an expiration of the last resort key, but it somehow feels dangerous.",
      "createdAt": "2019-12-18T10:36:44Z",
      "updatedAt": "2020-06-19T12:55:35Z",
      "closedAt": "2020-06-19T12:55:35Z",
      "comments": []
    },
    {
      "number": 271,
      "id": "MDU6SXNzdWU1Mzk1OTgyODU=",
      "title": "Create and send to sub-groups",
      "url": "https://github.com/mlswg/mls-protocol/issues/271",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "discussion",
        "functionality",
        "work in progress"
      ],
      "body": "An application with meta knowledge of subgroups could optimize the placement of members, discuss if we want to either create a new group from an existing subgroup or have a send to sub-group function.",
      "createdAt": "2019-12-18T10:40:01Z",
      "updatedAt": "2020-06-19T12:55:35Z",
      "closedAt": "2020-06-19T12:55:35Z",
      "comments": []
    },
    {
      "number": 272,
      "id": "MDU6SXNzdWU1Mzk3NDgwMTE=",
      "title": "Redundant information in MLSPlaintextCommitContent",
      "url": "https://github.com/mlswg/mls-protocol/issues/272",
      "state": "CLOSED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "discussion",
        "performance"
      ],
      "body": "`MLSPlaintextCommitContent` contains all of the Proposals that were previously sent within the same epoch. This seems unnecessary, since all members should have them anyway. The list of `PorposalIDs` in the actual `Commit` message should be enough for members to parse and validate a `Commit` message.\r\n\r\nWe should discuss if we can de-duplicate this, since the list of Proposals might be quite long.",
      "createdAt": "2019-12-18T15:21:36Z",
      "updatedAt": "2020-06-02T17:02:47Z",
      "closedAt": "2020-06-02T17:02:46Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "The current definition of `MLSPlaintextCommitContent` is as follows;\r\n\r\n```\r\nstruct {\r\n  opaque group_id<0..255>;\r\n  uint64 epoch;\r\n  Sender sender;\r\n  ContentType content_type = commit;\r\n  Commit commit;\r\n} MLSPlaintextCommitContent;\r\n```\r\n\r\nMaybe this issue is obsolete?",
          "createdAt": "2020-02-05T12:41:18Z",
          "updatedAt": "2020-02-05T12:41:18Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "Seems it is now obsolete indeed.",
          "createdAt": "2020-06-02T17:02:46Z",
          "updatedAt": "2020-06-02T17:02:46Z"
        }
      ]
    },
    {
      "number": 273,
      "id": "MDU6SXNzdWU1NDEwNjA5NDg=",
      "title": "Editorial: structure of the document",
      "url": "https://github.com/mlswg/mls-protocol/issues/273",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "discussion",
        "editorial"
      ],
      "body": "We relocated multiple pieces recently which causes the general structure of the document to feel a bit disordered, we need to do a minimal editorial restructure before releasing the next draft.\r\nChanging the depth of some sections might be enough...",
      "createdAt": "2019-12-20T15:48:48Z",
      "updatedAt": "2020-10-06T07:29:05Z",
      "closedAt": "2020-10-06T07:29:05Z",
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "I am gonna close this in favor of the newer issue where we started a bit more discussion:\r\nhttps://github.com/mlswg/mls-protocol/issues/409",
          "createdAt": "2020-10-06T07:29:04Z",
          "updatedAt": "2020-10-06T07:29:04Z"
        }
      ]
    },
    {
      "number": 276,
      "id": "MDU6SXNzdWU1NDE0MzU1NjA=",
      "title": "Weekly Digest (15 December, 2019 - 22 December, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/276",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week 8 issues were created.\nOf these, 0 issues have been closed and 8 issues are still open.\n## OPEN ISSUES\n:green_heart: #275 [Mandate expiration of ClientInitKeys and presence of some extensions](https://github.com/mlswg/mls-protocol/pull/275), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #274 [Fix contexts and simplify key schedule](https://github.com/mlswg/mls-protocol/pull/274), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #273 [Editorial: structure of the document](https://github.com/mlswg/mls-protocol/issues/273), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #272 [Redundant information in MLSPlaintextCommitContent](https://github.com/mlswg/mls-protocol/issues/272), by [raphaelrobert](https://github.com/raphaelrobert)\n:green_heart: #271 [Create and send to sub-groups](https://github.com/mlswg/mls-protocol/issues/271), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #270 [Expiration on \"last resort key\" must not be omitted](https://github.com/mlswg/mls-protocol/issues/270), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #269 [Randomize values in the common framing header](https://github.com/mlswg/mls-protocol/issues/269), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #268 [Missing context in the PSK/Importer injection](https://github.com/mlswg/mls-protocol/issues/268), by [beurdouche](https://github.com/beurdouche)\n## NOISY ISSUE\n:speaker: #269 [Randomize values in the common framing header](https://github.com/mlswg/mls-protocol/issues/269), by [beurdouche](https://github.com/beurdouche)\nIt received 1 comments.\n\n - - - \n# PULL REQUESTS\nLast week, 6 pull requests were created, updated or merged.\n## OPEN PULL REQUEST\nLast week, 1 pull request was opened.\n:green_heart: #275 [Mandate expiration of ClientInitKeys and presence of some extensions](https://github.com/mlswg/mls-protocol/pull/275), by [beurdouche](https://github.com/beurdouche)\n## UPDATED PULL REQUEST\nLast week, 3 pull requests were updated.\n:yellow_heart: #274 [Fix contexts and simplify key schedule](https://github.com/mlswg/mls-protocol/pull/274), by [beurdouche](https://github.com/beurdouche)\n:yellow_heart: #265 [Align spec text with implementation](https://github.com/mlswg/mls-protocol/pull/265), by [bifurcation](https://github.com/bifurcation)\n:yellow_heart: #219 [Fix application message truncation attack](https://github.com/mlswg/mls-protocol/pull/219), by [beurdouche](https://github.com/beurdouche)\n## MERGED PULL REQUEST\nLast week, 2 pull requests were merged.\n:purple_heart: #254 [Initial work to use CIK in leaves and CIK rotation](https://github.com/mlswg/mls-protocol/pull/254), by [beurdouche](https://github.com/beurdouche)\n:purple_heart: #253 [Initial version of the Tree of Signature](https://github.com/mlswg/mls-protocol/pull/253), by [beurdouche](https://github.com/beurdouche)\n\n - - - \n# COMMITS\nLast week there were 10 commits.\n:hammer_and_wrench: [Merge pull request #253 from mlswg/beurdouche_sigtree  Initial version of the Tree of Signature](https://github.com/mlswg/mls-protocol/commit/6555b94c457b22c3bf623c0f6ee29e6e14a1ca3f) by [raphaelrobert](https://github.com/raphaelrobert)\n:hammer_and_wrench: [Committer index in the ParentNodeHash](https://github.com/mlswg/mls-protocol/commit/9a1664a2f1575378df5860f3672c3463db39e3db) by [beurdouche](https://github.com/beurdouche)\n:hammer_and_wrench: [Fix GroupInfo terminology to tree_hash](https://github.com/mlswg/mls-protocol/commit/353fe3d064469fecc459748cc8586ba1832fbefc) by [beurdouche](https://github.com/beurdouche)\n:hammer_and_wrench: [SigTree follow-up: fix for server-assist when the tree is outsourced](https://github.com/mlswg/mls-protocol/commit/a670098a0e2223eaa049de5400f7c79969a47a4b) by [beurdouche](https://github.com/beurdouche)\n:hammer_and_wrench: [Update of the tree of signature section](https://github.com/mlswg/mls-protocol/commit/4ba6d55448df9818af39eaf8f9d014a574c59fb1) by [beurdouche](https://github.com/beurdouche)\n:hammer_and_wrench: [Initial definition of the Tree of Signatures](https://github.com/mlswg/mls-protocol/commit/d407030f79a658ac4f9f62211265748df0a0cfb3) by [beurdouche](https://github.com/beurdouche)\n:hammer_and_wrench: [Merge pull request #254 from mlswg/beurdouche_leafcik  Initial work to use CIK in leaves](https://github.com/mlswg/mls-protocol/commit/a72f07db7bfbbc1294754149cc9354b01322f846) by [raphaelrobert](https://github.com/raphaelrobert)\n:hammer_and_wrench: [Leaf CIK: review from Raphael](https://github.com/mlswg/mls-protocol/commit/02fefcc1fecfc0e834d2b4e4a4724a4763e97264) by [beurdouche](https://github.com/beurdouche)\n:hammer_and_wrench: [New strategy for Leaf CIK with Richard and Raphael](https://github.com/mlswg/mls-protocol/commit/7fbf94f376466332760d51126e51a928f169a02a) by [beurdouche](https://github.com/beurdouche)\n:hammer_and_wrench: [Fixes suggested by @Bren2010](https://github.com/mlswg/mls-protocol/commit/ccfb0d81a2eb9671c8c68288dbf169cb0bc3de5e) by [beurdouche](https://github.com/beurdouche)\n\n - - - \n# CONTRIBUTORS\nLast week there were 2 contributors.\n:bust_in_silhouette: [raphaelrobert](https://github.com/raphaelrobert)\n:bust_in_silhouette: [beurdouche](https://github.com/beurdouche)\n\n - - - \n# STARGAZERS\nLast week there was 1 stargazer.\n:star: [tuxcanfly](https://github.com/tuxcanfly)\nYou are the star! :star2:\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-12-22T10:49:03Z",
      "updatedAt": "2019-12-22T13:42:25Z",
      "closedAt": "2019-12-22T13:42:25Z",
      "comments": []
    },
    {
      "number": 277,
      "id": "MDU6SXNzdWU1NDE0NDEyOTI=",
      "title": "Add/Welcome message should send the epoch secret and not init+commit secrets",
      "url": "https://github.com/mlswg/mls-protocol/issues/277",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [
        "bifurcation",
        "beurdouche"
      ],
      "labels": [
        "bug",
        "security",
        "work in progress"
      ],
      "body": "Sending the `init_secret` and the `commit_secret` at once seem equivalent to sending the `epoch_secret` but I don't think it is actually the case since the message could be rejected by the DS, breaking the encryption key of that message would hence still have consequences even if the message is rejected.\r\n\r\nTechnically this is also breaking secrecy of the `init_secret` because the principals of the protocol which are associated to its secrecy are the members of the previous epoch, while the principals associated to the `epoch_secret` do contain the newcomer.\r\n\r\nI think we should update this mechanism to send the `epoch_secret` directly. DIscuss... ",
      "createdAt": "2019-12-22T11:52:37Z",
      "updatedAt": "2020-01-31T15:09:53Z",
      "closedAt": "2020-01-31T15:09:53Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #247 ",
          "createdAt": "2020-01-31T15:09:53Z",
          "updatedAt": "2020-01-31T15:09:53Z"
        }
      ]
    },
    {
      "number": 280,
      "id": "MDU6SXNzdWU1NDMzNTU2NjA=",
      "title": "Weekly Digest (22 December, 2019 - 29 December, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/280",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week 3 issues were created.\nOf these, 0 issues have been closed and 3 issues are still open.\n## OPEN ISSUES\n:green_heart: #279 [Bring back more ciphersuites](https://github.com/mlswg/mls-protocol/pull/279), by [raphaelrobert](https://github.com/raphaelrobert)\n:green_heart: #278 [Review of sections 1-6.](https://github.com/mlswg/mls-protocol/pull/278), by [Bren2010](https://github.com/Bren2010)\n:green_heart: #277 [Add/Welcome message should send the epoch secret and not init+commit secrets](https://github.com/mlswg/mls-protocol/issues/277), by [beurdouche](https://github.com/beurdouche)\n\n - - - \n# PULL REQUESTS\nLast week, 4 pull requests were created, updated or merged.\n## UPDATED PULL REQUEST\nLast week, 3 pull requests were updated.\n:yellow_heart: #279 [Bring back more ciphersuites](https://github.com/mlswg/mls-protocol/pull/279), by [raphaelrobert](https://github.com/raphaelrobert)\n:yellow_heart: #278 [Review of sections 1-6.](https://github.com/mlswg/mls-protocol/pull/278), by [Bren2010](https://github.com/Bren2010)\n:yellow_heart: #274 [Fix contexts and simplify key schedule](https://github.com/mlswg/mls-protocol/pull/274), by [beurdouche](https://github.com/beurdouche)\n## MERGED PULL REQUEST\nLast week, 1 pull request was merged.\n:purple_heart: #265 [Align spec text with implementation](https://github.com/mlswg/mls-protocol/pull/265), by [bifurcation](https://github.com/bifurcation)\n\n - - - \n# COMMITS\nLast week there was 1 commit.\n:hammer_and_wrench: [Merge pull request #265 from mlswg/impl  Align spec text with implementation](https://github.com/mlswg/mls-protocol/commit/9426b880dace5a105405196b347e7e493f3677ac) by [beurdouche](https://github.com/beurdouche)\n\n - - - \n# CONTRIBUTORS\nLast week there was 1 contributor.\n:bust_in_silhouette: [beurdouche](https://github.com/beurdouche)\n\n - - - \n# STARGAZERS\nLast week there were no stargazers.\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-12-29T10:49:01Z",
      "updatedAt": "2019-12-29T14:46:37Z",
      "closedAt": "2019-12-29T14:46:37Z",
      "comments": []
    },
    {
      "number": 284,
      "id": "MDU6SXNzdWU1NDU0MDE1OTI=",
      "title": "Weekly Digest (29 December, 2019 - 5 January, 2020)",
      "url": "https://github.com/mlswg/mls-protocol/issues/284",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week 3 issues were created.\nOf these, 0 issues have been closed and 3 issues are still open.\n## OPEN ISSUES\n:green_heart: #283 [Use the same ratchet for Handshake and Application keys](https://github.com/mlswg/mls-protocol/pull/283), by [bifurcation](https://github.com/bifurcation)\n:green_heart: #282 [Specify an Ack message](https://github.com/mlswg/mls-protocol/pull/282), by [bifurcation](https://github.com/bifurcation)\n:green_heart: #281 [Extend the epoch with a commit hash](https://github.com/mlswg/mls-protocol/pull/281), by [bifurcation](https://github.com/bifurcation)\n## NOISY ISSUE\n:speaker: #283 [Use the same ratchet for Handshake and Application keys](https://github.com/mlswg/mls-protocol/pull/283), by [bifurcation](https://github.com/bifurcation)\nIt received 1 comments.\n\n - - - \n# PULL REQUESTS\nLast week, 7 pull requests were created, updated or merged.\n## OPEN PULL REQUEST\nLast week, 2 pull requests were opened.\n:green_heart: #282 [Specify an Ack message](https://github.com/mlswg/mls-protocol/pull/282), by [bifurcation](https://github.com/bifurcation)\n:green_heart: #281 [Extend the epoch with a commit hash](https://github.com/mlswg/mls-protocol/pull/281), by [bifurcation](https://github.com/bifurcation)\n## UPDATED PULL REQUEST\nLast week, 4 pull requests were updated.\n:yellow_heart: #283 [Use the same ratchet for Handshake and Application keys](https://github.com/mlswg/mls-protocol/pull/283), by [bifurcation](https://github.com/bifurcation)\n:yellow_heart: #279 [Bring back more ciphersuites](https://github.com/mlswg/mls-protocol/pull/279), by [raphaelrobert](https://github.com/raphaelrobert)\n:yellow_heart: #278 [Review of sections 1-6.](https://github.com/mlswg/mls-protocol/pull/278), by [Bren2010](https://github.com/Bren2010)\n:yellow_heart: #275 [Mandate expiration of ClientInitKeys and presence of some extensions](https://github.com/mlswg/mls-protocol/pull/275), by [beurdouche](https://github.com/beurdouche)\n## MERGED PULL REQUEST\nLast week, 1 pull request was merged.\n:purple_heart: #263 [Change special values to structed types for external senders](https://github.com/mlswg/mls-protocol/pull/263), by [kelrit](https://github.com/kelrit)\n\n - - - \n# COMMITS\nLast week there were 3 commits.\n:hammer_and_wrench: [Merge pull request #263 from kelrit/master  Change special values to structed types for external senders](https://github.com/mlswg/mls-protocol/commit/02bf13ebad9a8efd675f6c30c3261dcf6191f179) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Address comments from @bifurcation  Reword MLSCiphertext encryption section and mandate sender type for encrypting MLSPlaintext.](https://github.com/mlswg/mls-protocol/commit/d8bbe3d4e0692669d58a132ddab5d3d33d3d081b) by [kelrit](https://github.com/kelrit)\n:hammer_and_wrench: [Merge branch 'master' of https://github.com/mlswg/mls-protocol](https://github.com/mlswg/mls-protocol/commit/639577426f247a75d7fcc8292bf7bdd03271b8e6) by [kelrit](https://github.com/kelrit)\n\n - - - \n# CONTRIBUTORS\nLast week there were 2 contributors.\n:bust_in_silhouette: [bifurcation](https://github.com/bifurcation)\n:bust_in_silhouette: [kelrit](https://github.com/kelrit)\n\n - - - \n# STARGAZERS\nLast week there were 2 stagazers.\n:star: [jasikpark](https://github.com/jasikpark)\n:star: [iethree](https://github.com/iethree)\nYou all are the stars! :star2:\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2020-01-05T10:49:03Z",
      "updatedAt": "2020-01-05T11:36:37Z",
      "closedAt": "2020-01-05T11:36:37Z",
      "comments": []
    },
    {
      "number": 289,
      "id": "MDU6SXNzdWU1NDg0ODA0MTg=",
      "title": "Make Editor's Copy and WG draft compare work properly",
      "url": "https://github.com/mlswg/mls-protocol/issues/289",
      "state": "CLOSED",
      "author": "seanturner",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "katrielalex"
      ],
      "labels": [
        "build"
      ],
      "body": "Please fix the link on the repo page to display diffs between the current editor's draft and the WG draft.  Now, it should PRs comparing back to the -00 version.",
      "createdAt": "2020-01-11T21:08:29Z",
      "updatedAt": "2020-06-19T12:55:36Z",
      "closedAt": "2020-06-19T12:55:36Z",
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "@katrielalex Any change you could have a look at this when you have some time ? : )",
          "createdAt": "2020-01-15T10:56:51Z",
          "updatedAt": "2020-01-15T10:56:51Z"
        },
        {
          "author": "katrielalex",
          "authorAssociation": "MEMBER",
          "body": "Yeah, I'm gonna fix the CI and I can take a look at this as well. I tried to get it done before the interim but, well, excuses excuses",
          "createdAt": "2020-01-15T14:13:50Z",
          "updatedAt": "2020-01-15T14:13:50Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Ahah... ;) No problem!!\nThanks !\n\n> On Jan 15, 2020, at 3:13 PM, Katriel Cohn-Gordon <notifications@github.com> wrote:\n> \n> \ufeff\n> Yeah, I'm gonna fix the CI and I can take a look at this as well. I tried to get it done before the interim but, well, excuses excuses\n> \n> \u2014\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub, or unsubscribe.\n",
          "createdAt": "2020-01-15T14:53:43Z",
          "updatedAt": "2020-01-15T14:53:43Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@katrielalex -- last call on this, or i'm just going to close it",
          "createdAt": "2020-06-13T18:53:38Z",
          "updatedAt": "2020-06-13T18:53:38Z"
        },
        {
          "author": "katrielalex",
          "authorAssociation": "MEMBER",
          "body": "Sorry. As you will have guessed, this fell through the cracks. I'll try this week to fix it out and close it out if I don't get to it this weekend :/",
          "createdAt": "2020-06-15T13:19:22Z",
          "updatedAt": "2020-06-15T13:19:22Z"
        }
      ]
    },
    {
      "number": 290,
      "id": "MDU6SXNzdWU1NDg1NTI4NzI=",
      "title": "Weekly Digest (5 January, 2020 - 12 January, 2020)",
      "url": "https://github.com/mlswg/mls-protocol/issues/290",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week 5 issues were created.\nOf these, 1 issues have been closed and 4 issues are still open.\n## OPEN ISSUES\n:green_heart: #289 [Make Editor's Copy and WG draft compare work properly](https://github.com/mlswg/mls-protocol/issues/289), by [seanturner](https://github.com/seanturner)\n:green_heart: #287 [Switch to signing strategy using one signature per leaf.](https://github.com/mlswg/mls-protocol/pull/287), by [Bren2010](https://github.com/Bren2010)\n:green_heart: #286 [Editorial: Unclear that Commits always include an Update/refreshes the CIK for the committer.](https://github.com/mlswg/mls-protocol/pull/286), by [Bren2010](https://github.com/Bren2010)\n:green_heart: #285 [Get rid of ignored proposals.](https://github.com/mlswg/mls-protocol/pull/285), by [Bren2010](https://github.com/Bren2010)\n## CLOSED ISSUES\n:heart: #288 [Typos](https://github.com/mlswg/mls-protocol/pull/288), by [raphaelrobert](https://github.com/raphaelrobert)\n## NOISY ISSUE\n:speaker: #285 [Get rid of ignored proposals.](https://github.com/mlswg/mls-protocol/pull/285), by [Bren2010](https://github.com/Bren2010)\nIt received 3 comments.\n\n - - - \n# PULL REQUESTS\nLast week, 8 pull requests were created, updated or merged.\n## UPDATED PULL REQUEST\nLast week, 7 pull requests were updated.\n:yellow_heart: #287 [Switch to signing strategy using one signature per leaf.](https://github.com/mlswg/mls-protocol/pull/287), by [Bren2010](https://github.com/Bren2010)\n:yellow_heart: #286 [Editorial: Unclear that Commits always include an Update/refreshes the CIK for the committer.](https://github.com/mlswg/mls-protocol/pull/286), by [Bren2010](https://github.com/Bren2010)\n:yellow_heart: #285 [Get rid of ignored proposals.](https://github.com/mlswg/mls-protocol/pull/285), by [Bren2010](https://github.com/Bren2010)\n:yellow_heart: #283 [Use the same ratchet for Handshake and Application keys](https://github.com/mlswg/mls-protocol/pull/283), by [bifurcation](https://github.com/bifurcation)\n:yellow_heart: #282 [Specify an Ack message](https://github.com/mlswg/mls-protocol/pull/282), by [bifurcation](https://github.com/bifurcation)\n:yellow_heart: #281 [Extend the epoch with a commit hash](https://github.com/mlswg/mls-protocol/pull/281), by [bifurcation](https://github.com/bifurcation)\n:yellow_heart: #278 [Review of sections 1-6.](https://github.com/mlswg/mls-protocol/pull/278), by [Bren2010](https://github.com/Bren2010)\n## MERGED PULL REQUEST\nLast week, 1 pull request was merged.\n:purple_heart: #288 [Typos](https://github.com/mlswg/mls-protocol/pull/288), by [raphaelrobert](https://github.com/raphaelrobert)\n\n - - - \n# COMMITS\nLast week there were 3 commits.\n:hammer_and_wrench: [Merge pull request #288 from mlswg/raphaelrobert-typos  Typos](https://github.com/mlswg/mls-protocol/commit/62bd560673d8e795e8b124e717d122e459e08611) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Update draft-ietf-mls-protocol.md](https://github.com/mlswg/mls-protocol/commit/6b535809d07db778e7dfeb6ec8442f056abb3f07) by [raphaelrobert](https://github.com/raphaelrobert)\n:hammer_and_wrench: [Typos](https://github.com/mlswg/mls-protocol/commit/dbf8e1c753a2073c91494a23d05913f6e8043913) by [raphaelrobert](https://github.com/raphaelrobert)\n\n - - - \n# CONTRIBUTORS\nLast week there were 2 contributors.\n:bust_in_silhouette: [bifurcation](https://github.com/bifurcation)\n:bust_in_silhouette: [raphaelrobert](https://github.com/raphaelrobert)\n\n - - - \n# STARGAZERS\nLast week there were no stargazers.\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2020-01-12T10:48:55Z",
      "updatedAt": "2020-01-12T13:23:58Z",
      "closedAt": "2020-01-12T13:23:58Z",
      "comments": []
    },
    {
      "number": 291,
      "id": "MDU6SXNzdWU1NDg2MTMyNzk=",
      "title": "Detection of tree forks by recipients via a commitment",
      "url": "https://github.com/mlswg/mls-protocol/issues/291",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [
        "beurdouche"
      ],
      "labels": [
        "functionality",
        "work in progress"
      ],
      "body": "",
      "createdAt": "2020-01-12T19:12:01Z",
      "updatedAt": "2020-07-27T19:17:00Z",
      "closedAt": "2020-07-27T19:17:00Z",
      "comments": [
        {
          "author": "kelrit",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There's a few implications of simply allowing forks:\r\n\r\n- FS issues - clients would need to use init_secret twice, which means keeping around init_secret for a potential fork, which breaks FS. One resolution here is to use something from the ASTree for init_secret (maybe the nth app secret, or a new ratchet derived from astree_node_[n]_secret).\r\n- Does detection yield any sort of meaningful resolution technique? Are we better off than we are now in terms of user experience? (What we have now, if the DS fails to order, is two (or N) groups of clients operating on different versions of the tree, which effectively partitions the group)\r\n\r\nI wrote about this here: https://mailarchive.ietf.org/arch/msg/mls/A4mVaXT-rqwZTNYXrC1TDb6XC_o suggesting merges as a resolution technique. The main downside is clients would need to keep around the list of proposals for a while.",
          "createdAt": "2020-01-14T22:57:55Z",
          "updatedAt": "2020-01-14T22:57:55Z"
        }
      ]
    },
    {
      "number": 293,
      "id": "MDU6SXNzdWU1NTczOTA3ODE=",
      "title": "How to derive group_info_key from the init_secret",
      "url": "https://github.com/mlswg/mls-protocol/issues/293",
      "state": "CLOSED",
      "author": "ericcornelissen",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "bug",
        "editorial",
        "security"
      ],
      "body": "In the [latest version of the draft in the section _Commit_](https://github.com/mlswg/mls-protocol/blob/13a4e3c8b0ee3e8b0145fb7c5bd8d6261f4b8520/draft-ietf-mls-protocol.md#commit) there is a sub-bullet for creating the GroupInfo object/Welcome message that says:\r\n\r\n> Encrypt the GroupInfo using the key and nonce derived from the `init_secret` for the current epoch (see {{welcoming-new-members}})\r\n\r\n\r\nThen, in [the section _Welcoming New Members_](https://github.com/mlswg/mls-protocol/blob/13a4e3c8b0ee3e8b0145fb7c5bd8d6261f4b8520/draft-ietf-mls-protocol.md#welcoming-new-members) it is stated that:\r\n\r\n> From the `init_secret` in the decrypted KeyPackage object, derive the `group_info_secret`, `group_info_key`, and `group_info_nonce`. Use the key and nonce to decrypt the `encrypted_group_info` field.\r\n\r\n\r\nHowever, from what I can tell, it is not explained anywhere how the _key and nonce_ should be derived from the `init_secret`. If it is somewhere, can someone point it out to me? If it is not in the RFC, should it be included?",
      "createdAt": "2020-01-30T10:12:10Z",
      "updatedAt": "2020-01-31T15:09:34Z",
      "closedAt": "2020-01-31T15:09:34Z",
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Thanks! There is indeed missing definitions in the document.\r\n\r\nOn a side note, I labelled this a security issue as I suspect there is a design issue to handle. The secrets derived from the init_secret are cryptographically associated to the previous group, not the current one, which breaks the secrecy invariant. I would much prefer to derive and encrypt under keys that are cryptographically associated to the new group and reveal those to the newcomer.",
          "createdAt": "2020-01-30T10:44:32Z",
          "updatedAt": "2020-01-30T10:44:32Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Relates to #277",
          "createdAt": "2020-01-30T10:45:28Z",
          "updatedAt": "2020-01-30T10:45:28Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I will make sure this gets covered in the revived #247 ",
          "createdAt": "2020-01-30T15:05:23Z",
          "updatedAt": "2020-01-30T15:05:23Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #247 ",
          "createdAt": "2020-01-31T15:09:34Z",
          "updatedAt": "2020-01-31T15:09:34Z"
        }
      ]
    },
    {
      "number": 297,
      "id": "MDU6SXNzdWU1NjAwOTU1Mzk=",
      "title": "Restart",
      "url": "https://github.com/mlswg/mls-protocol/issues/297",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement",
        "question",
        "security"
      ],
      "body": "Certain things about a group are fixed, for example, its ciphersuite and version of MLS, and with #296, its extensions.  It could be desirable to have the ability to change these parameters, e.g., to use a new ciphersuite when all members support it.\r\n\r\nDefining a way to change these values \"in place\" seems tricky, though.  Instead, we could define a \"restart\" mechanism that initializes a new group with the same membership and different parameters.  At one level this is trivially possible, just by creating a new group over the same members.  But it could be useful to explicitly hand-over from one to the other, so that clients understand that they are the same.  You could also tie them together cryptographically, e.g., by exporting a secret from the old group's key schedule, and importing it as a PSK into the new group.",
      "createdAt": "2020-02-05T02:05:25Z",
      "updatedAt": "2020-07-27T19:09:21Z",
      "closedAt": "2020-07-27T19:09:21Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Replaced by #368 ",
          "createdAt": "2020-07-27T19:09:18Z",
          "updatedAt": "2020-07-27T19:09:18Z"
        }
      ]
    },
    {
      "number": 298,
      "id": "MDU6SXNzdWU1NjAxMDIyMzc=",
      "title": "Varints",
      "url": "https://github.com/mlswg/mls-protocol/issues/298",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement",
        "performance"
      ],
      "body": "As part of the cTLS work, we looked into the possibility of [using QUIC-style varints as vector lengths](https://github.com/ekr/draft-rescorla-tls-ctls/blob/specialization/draft-rescorla-tls-ctls.md#varints) in the TLS presentation syntax.   With the proper specification text, we could do the same in MLS, as well as using varints for in place of uint values like `epoch`, `sender_index`, and `generation`.\r\n\r\nUsing varints has a few benefits: \r\n\r\n* It avoids the need to specify vector lengths in the presentation syntax\r\n* It allows any field to go up to 2^64 (possibly not a benefit!)\r\n* It is more efficient at encoding values that are far below the maximum\r\n \r\nThe main drawback is that there's no support for varint vector lengths in existing code for encoding/decoding TLS syntax.\r\n\r\nThere's also a procedural question of where the varints mechanism should be defined.  Arguably MLS shouldn't be making its own extensions to the TLS syntax.  We've already sort of crossed that bridge, though, since we added optional<T>.",
      "createdAt": "2020-02-05T02:30:30Z",
      "updatedAt": "2020-06-19T12:55:36Z",
      "closedAt": "2020-06-19T12:55:36Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Better link for [QUIC-style varints](https://tools.ietf.org/html/draft-ietf-quic-transport-22#section-16).  For whatever reason, the cTLS version only does 1/2/3-byte encodings, whereas the QUIC one does 1/2/4/8, which is better for our usage.",
          "createdAt": "2020-06-02T17:04:27Z",
          "updatedAt": "2020-06-02T17:04:27Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Just repeating what I said during the call, but I think this is mixing layers of abstraction. The MLS spec uses the TLS presentation language to define structs, but we don't actually assume that the wire encoding of messages is TLS. Referencing this line from the architecture doc:\r\n\r\n```\r\nIn addition, it does not specify a complete wire encoding, but rather a \r\nset of abstract data structures which can then be mapped onto a variety \r\nof concrete encodings, such as TLS, CBOR, and JSON.\r\n```\r\n\r\nPeople said that we need to define the wire encoding to support interoperability (if we don't want interop, why are we writing a spec?). But I think in practice, different MLS implementations interoperating will be quite rare for a variety of reasons, mostly due to incompatible delivery and authentication services. The point of writing the spec, then, is to produce a well-reviewed protocol that people can implement confidently.\r\n\r\nLong story short, if you wanted varints you would use cTLS as the wire encoding, which doesn't require any changes to the spec.",
          "createdAt": "2020-06-02T18:35:41Z",
          "updatedAt": "2020-06-02T18:35:41Z"
        }
      ]
    },
    {
      "number": 299,
      "id": "MDU6SXNzdWU1NjAxMDQ0MjY=",
      "title": "Allow indirection of credentials",
      "url": "https://github.com/mlswg/mls-protocol/issues/299",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement",
        "performance"
      ],
      "body": "Credentials can be big, and they all go in the tree.  We should define a type of credential that is a secure indirection, something like:\r\n\r\n```\r\nenum {\r\n    ...\r\n    reference(xxx),\r\n    ...\r\n} CredentialType;\r\n\r\nstruct {\r\n    opaque hash<0..255>;\r\n    opaque uri<0..255>;\r\n} CredentialReference;\r\n```\r\n\r\nWith the provisos that: (1) the content reference by the URI MUST be a valid Credential struct, and MUST match the hash, and (2) it's up to the application to make sure that clients know how to deference the URIs.",
      "createdAt": "2020-02-05T02:39:00Z",
      "updatedAt": "2020-06-19T12:55:36Z",
      "closedAt": "2020-06-19T12:55:36Z",
      "comments": []
    },
    {
      "number": 300,
      "id": "MDU6SXNzdWU1NjAyNDU3Mjc=",
      "title": "Order in which proposals should be applied is a little bit vague",
      "url": "https://github.com/mlswg/mls-protocol/issues/300",
      "state": "CLOSED",
      "author": "ericcornelissen",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The [Commit section](https://github.com/mlswg/mls-protocol/blob/d460925cac306275e529a6c657e74eed653cf11b/draft-ietf-mls-protocol.md#commit) writes:\r\n\r\n> Generate a provisional GroupContext object by applying the proposals referenced in the initial Commit object in the order provided, as described in {{proposals}}. [...]\r\n\r\nHowever, from this it is not immediately clear to me in which order the collections of proposals `updates`, `removes`, and `adds` are to be applied. I assume it should be in that order because it makes practical sense and because they're written in that order in the Commit struct.\r\n\r\nIf my guess is correct, perhaps it would be useful to make this explicit? E.g.:\r\n\r\n > Generate a provisional GroupContext object by applying the proposals referenced in the initial Commit object, as described in {{proposals}}. First the list of update proposals, then the list of remove proposals, and last the list of add proposals. [...]",
      "createdAt": "2020-02-05T09:32:29Z",
      "updatedAt": "2020-05-08T14:20:39Z",
      "closedAt": "2020-05-08T14:20:39Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@ericcornelissen - I agree with your interpretation here.  Could you make a PR with some proposed wording?",
          "createdAt": "2020-04-21T14:41:04Z",
          "updatedAt": "2020-04-21T14:41:04Z"
        },
        {
          "author": "ericcornelissen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Apologies for closing/opening the issue. I will open a PR to update the wording.",
          "createdAt": "2020-05-07T17:37:42Z",
          "updatedAt": "2020-05-07T17:37:42Z"
        }
      ]
    },
    {
      "number": 301,
      "id": "MDU6SXNzdWU1NjA0MzM2NDI=",
      "title": "Targeted message",
      "url": "https://github.com/mlswg/mls-protocol/issues/301",
      "state": "CLOSED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "discussion",
        "functionality",
        "privacy"
      ],
      "body": "It might be interesting to have a mechanism to send targeted messages within a group. The recipient could either be a leaf node or an intermediary node (in which case you send the message to a subgroup).\r\nThere certainly is a need for that kind of functionality in some messengers (think read receipts that shouldn't be broadcasted to the whole group, etc.).\r\nA starting point could be:\r\n - KEM to the public leaf key and combine that with something from the key schedule for the first message\r\n - hash ratchet forward for subsequent messages within the same epoch (FS)\r\n - include the new freshness in the forward ratcheting after an epoch an change (does that mean we inherit PCS guarantees?)\r\n\r\nJust a thought for now but worth pursuing IMHO.",
      "createdAt": "2020-02-05T15:07:37Z",
      "updatedAt": "2020-06-19T12:55:37Z",
      "closedAt": "2020-06-19T12:55:37Z",
      "comments": [
        {
          "author": "burdges",
          "authorAssociation": "NONE",
          "body": "In this vein, I think \"cryptographic introductions\" actually matter quite a lot, even when you make the participants start a seperate channel, so any authentication property you can extract here helps enormously.  I suppose TreeKEM lacks any semi-ephemeral public key for the parties lying around like in Axolotl or ART, right?",
          "createdAt": "2020-02-06T14:09:07Z",
          "updatedAt": "2020-02-06T14:09:07Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "The leaf nodes contain ClientInitKeys which allow you to authenticate members through the AS. So KEMing to a leaf node is authenticated and KEMing to intermediary nodes would be authenticated in the sense that only the leaves from the subtree would know the private key of the intermediary nodes. That notion of authentication seems less strong, but tree signatures should give some additional confidence.\r\n\r\n> I suppose TreeKEM lacks any semi-ephemeral public key for the parties lying around like in Axolotl or ART, right?\r\n\r\nDo you mean something like prekeys? MLS has ClientInitKeys for that.",
          "createdAt": "2020-02-07T09:33:28Z",
          "updatedAt": "2020-02-07T09:33:28Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "After some discussion with @beurdouche we realised this could be generalised to a more generic concept to send application messages.\r\n\r\nThe parameters would be:\r\n - Send from inside vs outside\r\n - Send to the whole vs send to subtree vs send to leaf node",
          "createdAt": "2020-02-07T09:36:24Z",
          "updatedAt": "2020-02-07T09:36:24Z"
        },
        {
          "author": "burdges",
          "authorAssociation": "NONE",
          "body": "> Do you mean something like prekeys? MLS has ClientInitKeys for that.\r\n\r\nNo.  I do not track this project closely enough but at first blush what you describe sounds fine.  In particular the ClientInitKeys comes bound into client's participation in the current session, not just from some untrusted external server somewhere. \r\n\r\nAxolotl has an ephemeral public key the client retains as part of the current session, which you can mutate for use in introductions.  I donno if you need to mutate ClientInitKeys for use here too.",
          "createdAt": "2020-02-07T10:25:12Z",
          "updatedAt": "2020-02-07T10:25:12Z"
        },
        {
          "author": "br-hale",
          "authorAssociation": "NONE",
          "body": "The coming PR for the key schedule change to allow ciphersuite upgrades also enables an option for group branching that may be a viable alternative for this. A group can use a PSK to upgrade, but it could also use it to re-initialize the group. In this vein, a PSK can be used to branch a group as well (enabling side conversations among nodes or subtrees that partially rely on the group state). \r\n\r\nThis is not quite the same, but would be an option using much of the current protocol infrastructure.\r\n\r\nNotably, such branching and side-messages that are linked to the group state do have potentially significant effects on PCS (by any of the ideas in this discussion and simply in general). While development of an option that could be enabled in the future would be good, the understanding of PCS security in various group structures is already tenuous at the moment. I would not recommend that we roll-out this as an option in the first protocol version. Cas, Konrad, and I started looking into PCS effects when side-chats among sub-trees were allowed (assuming the subtree is not treated as a separate group), and found the possible cross-effects of compromise between groups when this is enabled grew very quickly and unexpectedly.",
          "createdAt": "2020-03-29T23:01:12Z",
          "updatedAt": "2020-03-29T23:01:12Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "Branching is a cool thing as such, but I think it's orthogonal to the idea of targeted messages.\r\nThis stems from the real-world need to send certain messages only to one recipient, while the contextual scope of that message is still a certain group (as mentioned delivery and read receipts fall in that category).\r\nBy real-world I mean that messengers already have the need to do exactly that and right now they would have to resort to solving this on the application layer. It's not the end of the world, but one of the goals of MLS was to reduce the amount of low-level crypto operations messengers should solve on the application layer.\r\nThe risk of doing the wrong thing is higher if messengers solve this individually (because there is typically no scrutiny from academia at that level).",
          "createdAt": "2020-04-01T20:47:47Z",
          "updatedAt": "2020-04-01T20:47:47Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@raphaelrobert in your first post you say that you might want to send a message to a sub-group. That would be where branching comes in, as it gives you a nice way to send messages to a sub-group and at the same time profit from all the security guarantees we got in the original group. I think sending to an intermediate note might be a bit unpractical, because the subgroup you want to send a message to might or might not be gathered under one such node. \r\n\r\nMaybe you can elaborate a bit more on the use-case?\r\n\r\n\"Targeted message\" seems to suggest that you might want to send a message to a _user_ rather than to a specific group member (where by user, I mean someone who might run multiple devices and thus be the entity behind more than one node in the group. Sorry if I got the official terminology wrong here). If that is the case, again, a proper sub-group might be the way to go. A quick-and-dirty way might be to just KEM to multiple leaf nodes, so that might also be an option (if there are not too many of them and targeted messages are an infrequent thing).",
          "createdAt": "2020-04-03T17:22:46Z",
          "updatedAt": "2020-04-03T17:22:46Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that there's some potential utility here, but it seems far enough afield of the main goal here (group AKE) that I would be inclined to not address it in the main specification.",
          "createdAt": "2020-04-21T14:44:10Z",
          "updatedAt": "2020-04-21T14:44:10Z"
        }
      ]
    },
    {
      "number": 302,
      "id": "MDU6SXNzdWU1NjExNzE5NTc=",
      "title": "Use masking instead of AES-GCM for sender data",
      "url": "https://github.com/mlswg/mls-protocol/issues/302",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "Bren2010"
      ],
      "labels": [
        "performance",
        "question",
        "security"
      ],
      "body": "Earlier, we had considered a \"masking\" approach for sender data, much like QUIC does for [encrypting packet sequence numbers](https://github.com/quicwg/base-drafts/blob/master/draft-ietf-quic-tls.md#header-protection-header-protect).  This approach would save 28 bytes of overhead (nonce + tag), but was abandoned because of uncertainty around the security of the masking approach.\r\n\r\nSince then, Bellare et al. published [\"Nonces are Noticed\"](https://eprint.iacr.org/2019/624.pdf), which includes what is effectively a proof of the security properties of the QUIC scheme.  The QUIC scheme is essentially scheme HN1 of the paper, the main difference being that QUIC encrypt not the nonce directly, but a packet number which is used to compute the nonce.  Our application would be similar, since we would encrypt metadata used to encrypt the key and the nonce.\r\n\r\nGiven this new analysis, is it time to bring back masking?",
      "createdAt": "2020-02-06T17:51:16Z",
      "updatedAt": "2020-09-10T15:01:09Z",
      "closedAt": "2020-09-10T15:01:09Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #360 ",
          "createdAt": "2020-09-10T15:01:09Z",
          "updatedAt": "2020-09-10T15:01:09Z"
        }
      ]
    },
    {
      "number": 312,
      "id": "MDU6SXNzdWU1NzUxNDE1MjU=",
      "title": "Add IANA considerations for Extensions ",
      "url": "https://github.com/mlswg/mls-protocol/issues/312",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "bug"
      ],
      "body": "Now that we have a more robust extension mechanism, we need to have an IANA registry to manage extensions, including:\r\n\r\n* Registry structure\r\n* Registry policy and (probably) designated experts\r\n* Reserved vendor space",
      "createdAt": "2020-03-04T05:10:07Z",
      "updatedAt": "2020-07-14T17:25:16Z",
      "closedAt": "2020-07-14T17:25:16Z",
      "comments": []
    },
    {
      "number": 323,
      "id": "MDU6SXNzdWU1ODgwMDgxMTU=",
      "title": "Fix context for new-member-initiated Add",
      "url": "https://github.com/mlswg/mls-protocol/issues/323",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "bug"
      ],
      "body": "Right now, the signature on an MLSPlaintext includes the GroupContext for the group.  If we are going to allow Add proposals signed by the new member, then this will need to change, because the new member doesn't know the GroupContext.\r\n\r\nMy preference would be to simply remove the GroupContext from the plaintext.  The Group ID is already included, so copy/paste protection can be added that way.  The other elements of the GroupContext effectively overlap with the Epoch that is already signed.",
      "createdAt": "2020-03-25T21:40:54Z",
      "updatedAt": "2020-06-16T19:07:44Z",
      "closedAt": "2020-06-16T19:07:44Z",
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Haven't thought about this too deeply, but having the full GroupContext in MLSPlaintextTBS means that we know all the members agree on the state of the ratchet tree, the transcript, the extensions. Removing it means we would no longer have agreement on those, right?",
          "createdAt": "2020-03-27T20:59:36Z",
          "updatedAt": "2020-03-27T20:59:36Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "We won't have confirmation of agreement as a result of signature verification.  The question is whether that is necessary.   If the MLSPlaintext was decrypted from an MLSCiphertext, for example, then the successful decryption of the MLSCiphertext implies agreement on all those things.\r\n\r\nI suppose you could also switch the signature input based on SenderType, but that seems messier.",
          "createdAt": "2020-04-21T14:39:33Z",
          "updatedAt": "2020-04-21T14:39:33Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not so sure that decrypting an MLSCiphertext implies agreement, because the crypto is symmetric. A man-in-the-middle can re-encrypt but not re-sign.",
          "createdAt": "2020-04-21T17:54:34Z",
          "updatedAt": "2020-04-21T17:54:34Z"
        }
      ]
    },
    {
      "number": 324,
      "id": "MDU6SXNzdWU1ODg0NTUwMzI=",
      "title": "Use consistent arguments to Derive-Secret",
      "url": "https://github.com/mlswg/mls-protocol/issues/324",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement"
      ],
      "body": "The document is not consistent about how many arguments go into Derive-Secret:\r\n\r\n* The definition takes two labels, and some invocations provide two, e.g., MLS-Exporter\r\n* The derivations in the key schedule provide an extra argument\r\n\r\nI'm pretty sure the latter is wrong, and we should just delete the explicit context from the three-argument version.  At the same time, I'm wary that using the GroupContext in every invocation of HKDF-Expand-Label will get us into some unimplementable situations if we try to use HKDF-Expand-Label outside an established group.",
      "createdAt": "2020-03-26T14:16:40Z",
      "updatedAt": "2020-07-20T18:21:51Z",
      "closedAt": "2020-07-20T18:21:51Z",
      "comments": [
        {
          "author": "GaPhil",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I believe this duplicates #264?",
          "createdAt": "2020-03-31T07:38:40Z",
          "updatedAt": "2020-03-31T07:38:40Z"
        }
      ]
    },
    {
      "number": 325,
      "id": "MDU6SXNzdWU1ODg0ODgzMTI=",
      "title": "Simplify epoch secret derivation?",
      "url": "https://github.com/mlswg/mls-protocol/issues/325",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "analysis",
        "question"
      ],
      "body": "It doesn't seem like the `Derive-Secret` step between the `early_secret` and the `epoch_secret` is helping anything.  Could we remove it?\r\n\r\n```\r\n    PSK (or 0) -> HKDF-Extract = early_secret\r\n                     |\r\n                     V\r\ncommit_secret -> HKDF-Extract = epoch_secret\r\n```",
      "createdAt": "2020-03-26T15:01:29Z",
      "updatedAt": "2020-07-28T17:29:26Z",
      "closedAt": "2020-07-28T17:29:26Z",
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I think a number of people want to revisit the key schedule:\r\n\r\n - Britta/Konrad: want to make changes to the PSK part for version upgrades\r\n - Brendan: (I don't remember exactly)\r\n - Raphael: wants to harmonise how the GroupState is pulled in\r\n\r\nAt this point it would be good to collect all feedback first and do one big change instead of many small ones.",
          "createdAt": "2020-03-26T15:08:38Z",
          "updatedAt": "2020-03-26T15:08:38Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "+ Me: wants to use the transcript hash instead of the group state because the transcript hash contains strictly more.",
          "createdAt": "2020-03-26T16:18:05Z",
          "updatedAt": "2020-03-26T16:18:05Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Not sure if this is everything, but I know I wanted to:\r\n1. Stop integrating the node id into every level of the application secret tree, to be more friendly to recursive implementations that don't store nodes in a linear array.\r\n2. Integrate context information at specific places, and then just use a hash directly (instead of HKDF) wherever possible. Hashes really do get quite expensive (~10 hashes = 1 ECDSA signature), and HKDF is two or three hashes.",
          "createdAt": "2020-03-27T20:52:06Z",
          "updatedAt": "2020-03-27T20:52:06Z"
        },
        {
          "author": "br-hale",
          "authorAssociation": "NONE",
          "body": "Konrad and I have a draft PR for a number of changes, mostly relating to version upgrades (with group branching support considered if we want that feature in the future). \r\n\r\nAdditional: derive authentication secret per-epoch separate from exporter key (i.e. secrets used in and for the protocol should be derived separately from secrets used beyond the protocol). \r\nTL:DR on IETF 104 presentation and other PCS work: authentication secrets can be used either for detection of an active MitM following signature key compromise or simply AS compromise, or in replacement of a TTP.",
          "createdAt": "2020-03-29T22:46:04Z",
          "updatedAt": "2020-03-29T22:46:04Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It seems to me that most of these changes to the key schedule are orthogonal, so maybe everyone should just make a PR for their preferred change?\r\n\r\nRegarding the changes proposed by @Bren2010, I think we should be careful such that we (1) still get the properties we need from the keys and (2) can prove that we actually do. I'm all for optimizing MLS for ease of implementation, but I think it at least warrants a discussion.\r\n\r\nMy take is that 1. does not impact key pseudorandomness but rather the collision resistance properties of that key (and the keys derived from it). From a proof-standpoint (using state-separating proofs ymmv with other techniques) we need that property at least when we next use the corresponding group key in an HKDF-extract function. If we include the transcript (which includes the groupstate) into the key at some point before, it should be doable as well. That being said, it would be *much* easier if we could make that argument \"up the tree\" as opposed to just in the end. So I think we have an \"ease-of-implementation\" vs. \"ease-of-proof\" trade-off here. My experience with a proof of the TLS key schedule we did recently is that this sort of step complicates the proof quite a bit (although that probably depends on your proof technique). I'd be interested what the other parties think that are doing (or are going to do) proofs.\r\n\r\nRegarding 2.: Are we not just using HKDF-expand in most cases? If the output of the hash function used to instantiate the hmac used in the HKDF is equal to the desired length of the key, there should only be one hash operation per call to HKDF-expand and it should not be much of a performance penalty if we include context at those points. Please correct me if I'm wrong.",
          "createdAt": "2020-03-31T11:15:55Z",
          "updatedAt": "2020-03-31T11:15:55Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "> My take is that 1. does not impact key pseudorandomness but rather the collision resistance properties of that key (and the keys derived from it).\r\n\r\nI don't understand the argument about collision resistance here. We're including explicit data in the call to HKDF-Expand (particularly, node id and generation) that's implicitly authenticated by the structure of HKDF-Expand calls used to build the tree. The tree's root is given by the key schedule, which is integrating all of the context you need.\r\n\r\nIf the hash function is weak, how would including more data in its input mitigate an attack?\r\n\r\n> Regarding 2.: Are we not just using HKDF-expand in most cases? If the output of the hash function used to instantiate the hmac used in the HKDF is equal to the desired length of the key, there should only be one hash operation per call to HKDF-expand and it should not be much of a performance penalty if we include context at those points. Please correct me if I'm wrong.\r\n\r\nThe HKDF-Expand is one HMAC call, and HMAC is two hashes. HMAC would be three hashes if the key were a different length.",
          "createdAt": "2020-03-31T23:47:14Z",
          "updatedAt": "2020-03-31T23:47:14Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> We're including explicit data in the call to HKDF-Expand (particularly, node id and generation) that's implicitly authenticated by the structure of HKDF-Expand calls used to build the tree.\r\n\r\nMy impression was that you wanted to remove the node-id from the HKDF-expand call. Is that not the case?\r\n\r\nAgain, I'm not saying it's impossible to prove uniqueness of the resulting group key if we remove the node-id. I'm just saying it might make it _harder_ to prove (just as leaving them in might make it harder to implement).\r\n\r\n> If the hash function is weak, how would including more data in its input mitigate an attack?\r\n\r\nIt's not about the properties of the hash function. It's about ensuring that the output key is distinct from the keys derived in the other nodes. If we assume that the hash function is ideal with regard to collision resistance, the input uniquely determines the output. Thus, if we include the unique node id, we get a unique key, even if the rest of the input is potentially the same. This allows us to assume that the output key is unique, even if the adversary chooses the rest of the input.\r\n\r\n> The HKDF-Expand is one HMAC call, and HMAC is two hashes. HMAC would be three hashes if the key were a different length.\r\n\r\nAh, I was under the impression that HMAC was just one hash operation. In any case, I'm not an expert regarding properties of hash functions, but my understanding from [1] is that simple hashing is not advisable as a KDF, even if the input is already pseudorandom. Are there any further results on this? I'm happy to go to just a simple hash, but we need to be sure that we actually get good keys as a result.\r\n\r\n[1] Krawczyk, Cryptographic Extraction and Key Derivation:\r\nThe HKDF Scheme (https://eprint.iacr.org/2010/264)",
          "createdAt": "2020-04-01T05:35:56Z",
          "updatedAt": "2020-04-01T05:35:56Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "> My impression was that you wanted to remove the node-id from the HKDF-expand call. Is that not the case?\r\n\r\nYes, that's what I want to do. I want to remove `generation` now too, that I've thought of it.\r\n\r\n> It's not about the properties of the hash function. It's about ensuring that the output key is distinct from the keys derived in the other nodes.\r\n\r\nIf the output key for different nodes is the same, that clearly implies you've found a collision in the hash function, so the hash function is weak. That's because you *are* hashing different things at every point, in particular, `H(parent || \"left\")` and `H(parent || \"right\")`. Arguing \"if we assume the hash function is ideal\" doesn't make sense to me, because we know the hash function is not ideal.\r\n\r\n> Ah, I was under the impression that HMAC was just one hash operation. In any case, I'm not an expert regarding properties of hash functions, but my understanding from [1] is that simple hashing is not advisable as a KDF, even if the input is already pseudorandom.\r\n\r\nWe can generate the bulk of the tree with a hash, and still use HKDF for the chain at the leaves of the ASTree. But perhaps just one call to HKDF-Extract to generate both the key and nonce at once.",
          "createdAt": "2020-04-01T15:09:11Z",
          "updatedAt": "2020-04-01T15:09:11Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Yes, that's what I want to do. I want to remove generation now too, that I've thought of it.\r\n\r\nBut if we're not including that, then how is that \"implicitly authenticated by the structure of HKDF-Expand calls used to build the tree\" as you said in your earlier reply?\r\n\r\n> If the output key for different nodes is the same, that clearly implies you've found a collision in the hash function, so the hash function is weak. That's because you are hashing different things at every point, in particular, H(parent || \"left\") and H(parent || \"right\"). Arguing \"if we assume the hash function is ideal\" doesn't make sense to me, because we know the hash function is not ideal.\r\n\r\nI'm talking about arguments in the context of a proof, where the goal is to figure out if we get good keys in the end, under a set of assumptions. One of the assumptions is that we can replace the hash function we use by an ideal one, without an adversary \"noticing the difference\". It would make the proof easier if we can assume that the output of the key derivation step doesn't collide _even if_ the adversary can control the input key material. Then the inclusion of the node-specific label would give us that guarantee. We might be able to do the proof iteratively across the layers of the tree, but I'm not certain about that. That is why I wouldn't want to throw out that extra information in the key derivation step. I'm happy to explain our proof methodology in more detail to make clear what I'm worried about, but I'm not going to do that in a git issue.\r\n\r\n> We can generate the bulk of the tree with a hash, and still use HKDF for the chain at the leaves of the ASTree. But perhaps just one call to HKDF-Extract to generate both the key and nonce at once.\r\n\r\nI'm not sure that works, because for HKDF-Extract to give you a good (pseudorandom) key, you need the input to be pseudorandom. And I'm not sure there is solid basis to assume that the output of a hash function is indeed a pseudorandom string. If there was, I'd be happy to agree to just replace all HKDF-Expand calls with hash function calls.",
          "createdAt": "2020-04-01T15:37:56Z",
          "updatedAt": "2020-04-01T15:37:56Z"
        },
        {
          "author": "br-hale",
          "authorAssociation": "NONE",
          "body": "> Integrate context information at specific places, and then just use a hash directly (instead of HKDF) wherever possible....\r\n> We can generate the bulk of the tree with a hash, and still use HKDF for the chain at the leaves of the ASTree. \r\n\r\nA hash is definitely not enough for a key derivation. Just a quick look at the research should be enough to make that statement convincing. There is a reason why we use a KDF for key derivation to achieve sufficient pseudorandomness, and switching it out with a hash as a quick fix will be asking for problems down the line. If we use just a hash, then the output should NOT be called a secret or used as a key, as a general rule (exceptions depending on input). \r\n\r\nAs to removing context from the key derivation: I think that there is an underlying assumption being presented in the argument for removal that the remaining inputs are unique and tied sufficiently to individual nodes already. Hopefully this is the case, but there is no guarantee. Consequently the result of removing them is not simply that proofs may become more difficult, but that the ensuing reductions (for computational proofs) may become less tight. In (quite loose) terms, this means that there are more conditions on the contexts in which security is achieved, and increased possibilities for breaking it.",
          "createdAt": "2020-04-01T16:04:14Z",
          "updatedAt": "2020-04-01T16:04:14Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "> But if we're not including that, then how is that \"implicitly authenticated by the structure of HKDF-Expand calls used to build the tree\" as you said in your earlier reply?\r\n\r\nTake for example, the chain at each leaf of the ASTree. We include a `generation` counter in the input to each HKDF-Expand, but the generation counter is equal to how far you've walked in the hash chain. The generation counter = explicit authentication, how far you've walked in the chain = implicit authentication.\r\n\r\n> I'm talking about arguments in the context of a proof, where the goal is to figure out if we get good keys in the end, under a set of assumptions.\r\n\r\nPeople have been complaining about the difficulty of proving properties of the key schedule the whole time the wg has existed, trying to make it more expensive and materially less secure, to simplify proofs. In reality, it's one of the few \"obviously secure\" parts of the protocol and there are still vulnerabilities elsewhere. Proof efforts should be directed to parts of the protocol that are actually difficult for humans to reason about.\r\n\r\n> I'm not sure there is solid basis to assume that the output of a hash function is indeed a pseudorandom string. If there was, I'd be happy to agree to just replace all HKDF-Expand calls with hash function calls.\r\n\r\nI think it's very fair to assume that a secure hash function is a random oracle. HKDF is just the output of a hash. We would want to keep HKDF-Expand at the leaves for pragmatic reasons: infinite stream derivation (because key and nonce size are variable), and safely combining the label (\"key\", \"nonce\", \"secret\") with the IKM.\r\n\r\n---\r\n\r\nI believe Britta's comments are addressed above.",
          "createdAt": "2020-04-01T17:56:23Z",
          "updatedAt": "2020-04-01T17:56:23Z"
        },
        {
          "author": "br-hale",
          "authorAssociation": "NONE",
          "body": ">People have been complaining about the difficulty of proving properties of the key schedule the whole time the wg has existed, trying to make it more expensive and materially less secure, to simplify proofs. In reality, it's one of the few \"obviously secure\" parts of the protocol and there are still vulnerabilities elsewhere. Proof efforts should be directed to parts of the protocol that are actually difficult for humans to reason about.\r\n\r\nI agree with the assessment that there are many potential vulnerabilities elsewhere that need focus. However, the above statement not only lacks core reasoning on the problem, but indicates misunderstanding of analysis methods and results. You are making an _ad hominem_ argument for ignoring what could have serious implications. See my comment above about tightness of security reductions, which you did not address. Tightness is not about ease of proof, it is about what claims can be proven. Your changes will likely have an effect on that. \r\n\r\n>I think it's very fair to assume that a secure hash function is a random oracle. HKDF is just the output of a hash. \r\n\r\nOK, but a decade of cryptographic research disagrees with that general statement. Making wide claims about what you _think_ should be _assumed_ does not progress the decision; it would be helpful if you founded your argument instead on the what the exact inputs are to the different hash uses (and there is a difference based on node height) and explain why you think there is sufficient randomness in the input to not use a KDF. \r\n\r\nNo one so far has said your suggestion is wrong, only that you have not put forth any supporting arguments, i.e. Konrad's comment:\r\n>And I'm not sure there is solid basis to assume that the output of a hash function is indeed a pseudorandom string. If there was, I'd be happy to agree to just replace all HKDF-Expand calls with hash function calls.\r\n\r\nIt is in everyone's interest to progress with decisions as scientifically as possible, with descriptive, shared reasoning behind changes - especially ones that have the potential to affect the randomness of keys - and without taking requests for justification personally. \r\n\r\nGiven the extended discussion on this issue, I suggest that it be moved to an interim meeting where it can be given appropriate attention. Engaging further in a git issue thread on the topic is unlikely to achieve satisfactory results, and it clearly warrants further attention.",
          "createdAt": "2020-04-01T18:38:47Z",
          "updatedAt": "2020-04-01T18:40:21Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "> You are making an ad hominem argument for ignoring what could have serious implications. See my comment above about tightness of security reductions, which you did not address. Tightness is not about ease of proof, it is about what claims can be proven. Your changes will likely have an effect on that.\r\n\r\nI'm saying we should de-prioritize provable security in the key schedule for three reasons:\r\n- It's easy to convince yourself of the key schedule's properties on-sight, both due to its simplicity and how much it has in common with other widely deployed cryptosystems.\r\n- Even if we optimize the key schedule for provable security, people have indicated that the proofs will still be very difficult and that they may not do them.\r\n- Existing system-level vulnerabilities are being (and have been) overlooked because of a hyper-focus on proving component-level properties.\r\n\r\nThis way, we can make the key schedule much faster and easier to implement.",
          "createdAt": "2020-04-01T19:55:44Z",
          "updatedAt": "2020-04-01T19:55:44Z"
        }
      ]
    },
    {
      "number": 326,
      "id": "MDU6SXNzdWU1ODg1MDg4MDQ=",
      "title": "Authenticate that added members know the PSK",
      "url": "https://github.com/mlswg/mls-protocol/issues/326",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "work in progress"
      ],
      "body": "The current PSK construct does not authenticate that a member added during the epoch knows the PSK.  This is because the PSK is used as an input to the epoch secret computation, and the new joiner is provided with the epoch secret directly.  I think that if we reverse the input of the commit secret and the PSK, and provide the intermediate product to the new joiner, we can achieve this property:\r\n\r\n```\r\n               init_secret_[n-1] (or 0)\r\n                     |\r\n                     V\r\n commit_secret -> HKDF-Extract = joiner_secret\r\n                     |\r\n                     V\r\n    PSK (or 0) -> HKDF-Extract = epoch_secret\r\n```\r\n\r\nIn other words, would provide the `joiner_secret` value to the new joiners in the GroupSecrets object, instead of the `epoch_secret`.",
      "createdAt": "2020-03-26T15:28:24Z",
      "updatedAt": "2020-07-28T17:29:26Z",
      "closedAt": "2020-07-28T17:29:26Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "We might want to also provide an optional PSK ID in the GroupSecrets object.",
          "createdAt": "2020-03-26T15:29:24Z",
          "updatedAt": "2020-03-26T15:29:24Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Konrad, Britta and I have been looking at this...\r\nNote that a PSK that is generated for a specific group should not be known by another group.",
          "createdAt": "2020-03-26T16:15:59Z",
          "updatedAt": "2020-03-26T16:15:59Z"
        },
        {
          "author": "br-hale",
          "authorAssociation": "NONE",
          "body": "Second that. \r\nAlso, the PSK ID should be linked to the epoch (or similarly identifiable) such that it is clear what current state is associated with the PSK being used (such as which members have access to the PSK in cases of reinitializing after breaks in group state, branching, etc.). ",
          "createdAt": "2020-03-29T22:28:48Z",
          "updatedAt": "2020-03-29T22:28:48Z"
        }
      ]
    },
    {
      "number": 328,
      "id": "MDU6SXNzdWU1ODk4NTU2MDM=",
      "title": "Use the same index for hashing parent and leaf nodes",
      "url": "https://github.com/mlswg/mls-protocol/issues/328",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement"
      ],
      "body": "Right now the LeafNodeHashInput struct uses the index of the node among the leaves, while the ParentNodeHashInput struct uses the index of the node among all nodes.  This means that, for example, the index value will be the same for the second leaf and its parent (`1` in both cases).\r\n\r\nWe should probably just use the node index in both cases.",
      "createdAt": "2020-03-29T18:40:44Z",
      "updatedAt": "2020-07-07T19:04:55Z",
      "closedAt": "2020-07-07T19:04:55Z",
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "https://github.com/mlswg/mls-protocol/pull/320 is a better solution",
          "createdAt": "2020-03-29T19:05:04Z",
          "updatedAt": "2020-03-29T19:05:04Z"
        }
      ]
    },
    {
      "number": 340,
      "id": "MDU6SXNzdWU2MjE3NjE5NDc=",
      "title": "Clarify what it means to send a Commit with no Proposals",
      "url": "https://github.com/mlswg/mls-protocol/issues/340",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Right now, it is possible to send a Commit that covers no proposals.  This has the result that the leaf of the sender and its direct path are refreshed, but no other change to the tree is made.  (The epoch also advances, of course.)  This can be is a useful operation.  For example, an Add wipes out the new joiner's direct path, so having the new joiner send a Commit over no proposals would fill in that direct path and make subsequent operations more efficient.\r\n\r\nWe should clarify in some prose that (a) this is possible and (b) why it might be useful.",
      "createdAt": "2020-05-20T13:26:45Z",
      "updatedAt": "2020-07-24T21:11:12Z",
      "closedAt": "2020-07-24T21:11:11Z",
      "comments": []
    },
    {
      "number": 344,
      "id": "MDU6SXNzdWU2MjkyOTYzNTA=",
      "title": "Tree in GroupInfo not optional",
      "url": "https://github.com/mlswg/mls-protocol/issues/344",
      "state": "CLOSED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "functionality",
        "performance"
      ],
      "body": "I remember we discussed this in the past, but I don't think we ever spec'ed this out fully:\r\n\r\nRight now the whole tree is part of `GroupInfo` (which in turn is part of `Welcome`). This can grow quite big in large groups (~17MB with 100k members with the MTI). The practical limitations are:\r\n\r\n - The TLS representation of the tree is hard to parse efficiently (no skipping and no a priori information of how many nodes are in the tree)\r\n - Out-of-band transmission (like server assist) is not possible\r\n - Large messages like that are hard to handle on mobile devices, when they have to be downloaded in the background\r\n\r\nWe should introduce an indirection, like a commit hash of the tree.",
      "createdAt": "2020-06-02T15:26:56Z",
      "updatedAt": "2020-07-24T21:14:45Z",
      "closedAt": "2020-07-24T21:14:45Z",
      "comments": []
    },
    {
      "number": 346,
      "id": "MDU6SXNzdWU2MzY0MzAxNzQ=",
      "title": "Ratcheting of External PSKs",
      "url": "https://github.com/mlswg/mls-protocol/issues/346",
      "state": "CLOSED",
      "author": "br-hale",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "This issue is to start a discussion thread on the suggestion made by Chris Wood under PR #336. The suggestion is not directly related to #336, so is listed here for discussion (some discussion already appears there):\r\n\r\n`chris-wood:\r\nAre \"external\" PSKs fixed? Would it make sense for them to also include an epoch, to allow applications to roll them forward for some FS?`\r\n\r\nCurrent considerations: \r\n1) Is this a use case worth addressing for MLS (i.e. taking in an external PSK and then maintaining it in sync to protocol ratcheting)?\r\n2) If so, is it sufficiently critical to be part of the protocol, or sufficiently peripheral to be discussed in the architecture?",
      "createdAt": "2020-06-10T17:38:06Z",
      "updatedAt": "2020-06-19T12:55:37Z",
      "closedAt": "2020-06-19T12:55:37Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think this is really an issue we need to address here.  We already allow a different PSK to be injected at every epoch change.  How exactly the app chooses which PSK to inject at which time is their business, not ours.",
          "createdAt": "2020-06-13T19:04:45Z",
          "updatedAt": "2020-06-13T19:04:45Z"
        }
      ]
    },
    {
      "number": 351,
      "id": "MDU6SXNzdWU2Mzk5NTM4NDM=",
      "title": "Use HPKE KDF for the MLS key schedule",
      "url": "https://github.com/mlswg/mls-protocol/issues/351",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Our HPKE dependency provides a perfectly usable KDF.  We should just use that instead of nailing a dependency to HKDF.  This will mainly be a matter of changing `HKDF-Extract` and `HKDF-Expand` calls to the corresponding calls on the HPKE KDF.",
      "createdAt": "2020-06-16T20:32:22Z",
      "updatedAt": "2020-07-24T19:49:13Z",
      "closedAt": "2020-07-24T19:49:13Z",
      "comments": []
    },
    {
      "number": 365,
      "id": "MDU6SXNzdWU2NjU0MTk4Njc=",
      "title": "Update security considerations",
      "url": "https://github.com/mlswg/mls-protocol/issues/365",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "The not-protocol parts of the document, including security considerations and some of the operational considerations, are mostly untouched since the beginning of this work.  As we get the protocol firmed up, we should revisit these parts to make sure they're up to date and give an accurate reflection of the concerns around the protocol.",
      "createdAt": "2020-07-24T21:10:56Z",
      "updatedAt": "2021-11-30T23:37:59Z",
      "closedAt": "2021-11-30T23:37:59Z",
      "comments": [
        {
          "author": "ericcornelissen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One particular thing related to this that I noticed is that in the [Confidentiality of the Group Secrets section](https://github.com/mlswg/mls-protocol/blob/c3db39266505e9d202158d642d65918d35870e77/draft-ietf-mls-protocol.md#confidentiality-of-the-group-secrets) the first sentence:\r\n\r\n> Group secrets are derived from (i) previous group secrets, and (ii) the root key of a ratcheting tree. [...]\r\n\r\nis outdated as (ii) can now also be an all-zero vector, namely if `path` is not required and not set (as introduced in  #331 if I'm not mistaken).",
          "createdAt": "2020-08-04T11:57:03Z",
          "updatedAt": "2020-08-04T11:57:03Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I did a review of the Security Considerations and didn't see anything that needs fixing before WGLC.  The point that @ericcornelissen raises appears to have been fixed in some other PR.",
          "createdAt": "2021-11-30T23:37:59Z",
          "updatedAt": "2021-11-30T23:37:59Z"
        }
      ]
    },
    {
      "number": 366,
      "id": "MDU6SXNzdWU2NjU0NDEzNTk=",
      "title": "Add extensions to the Commit message",
      "url": "https://github.com/mlswg/mls-protocol/issues/366",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "[This issue is part of a feature breakdown based on #336]\r\n\r\nApplications might want to signal to group members  processing a commit that they should take certain actions in addition to ratcheting the group forward.  The most obvious example is folding in a PSK for the epoch, but you can also imagine addressing things like transcript consistency or updatable PKE through this channel.\r\n\r\nThis should be straightforward syntactically, but will also require updating the extensibility section to make clear that Commit extensions can also in principle affect the GroupContext extensions.  In other words:\r\n\r\n* Each group member associates a list of extensions with the group, which are confirmed via the GroupContext\r\n* New joiners get configured with these via extensions in the GroupInfo\r\n* Existing members can find out about changes to the group's extensions via extensions in the Commit",
      "createdAt": "2020-07-24T22:03:25Z",
      "updatedAt": "2020-08-25T18:15:15Z",
      "closedAt": "2020-08-25T18:15:15Z",
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think making commit messages extensible is a great idea. However, I'd like to understand better what we want to use the extensions first. \r\n\r\n> Applications might want to signal to group members processing a commit that they should take certain actions in addition to ratcheting the group forward.\r\n\r\nI thought that was what Proposals are for. I think for mechanisms that are part of the base protocol spec, there is no reason not to extend the list of proposals.\r\n\r\nRegarding the nature of extensions: Do I understand correctly, that an extension is a property of the group first and foremost? And extensions in the commit are meant to alert other group members to changes in those properties? Or are extensions in the commit messages a mechanism to allow for the inclusion of additional data in the commits? Or both? I feel like the meaning of the word \"extension\" is a little stretched here.\r\n\r\nSince we're discussing this also in the context of PSK injections: Do you think PSK injections should be something that can be switched on and off for any given group? If so, why? I would consider it part of the base protocol and do not see what benefits we get from disallowing it in a group.",
          "createdAt": "2020-08-03T08:54:42Z",
          "updatedAt": "2020-08-03T08:54:42Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "It's a fair point, that we have basically two extension points here -- proposal types and extensions.  I think the theory I had in mind was something like:\r\n\r\n1. Proposals describe modifications you make to the tree before you use it for TreeKEM (to get the path) (if you do)\r\n2. The DirectPath describes the outcome of TreeKEM.Encap\r\n3. Extensions tell you anything else you need to do\r\n\r\nIf that philosophy makes sense, I can update the PR to make that clearer.\r\n\r\nNote that proposal extensibility is currently broken because we don't actually have a way for the Commit to include any Proposals with new proposal types.  I've filed #383 for that.",
          "createdAt": "2020-08-03T21:30:05Z",
          "updatedAt": "2020-08-03T21:30:05Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "On the nature of extensions: My thinking here is that an \"extension\" is purely syntactic; its semantics are defined entirely by its ExtensionType.  One thing that extensions do (in the context of GroupContext) is express what attributes/parameters the group has agreed to.  But they can also do other things.",
          "createdAt": "2020-08-03T21:33:43Z",
          "updatedAt": "2020-08-03T21:33:43Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "On PSK injections: My thinking here is that PSKs are a per-epoch decision, in that you can inject a different set of PSKs at each epoch.  Since the Commit is the thing that starts a new epoch, it signals what PSKs to use for that epoch.  A few illustrative cases:\r\n\r\n- A \"meeting password\" might get injected on every commit\r\n- ... or you might only inject it in commits where you have an Add, to verify that the new guy has it\r\n- In a scenario where you have some OOB PSK distribution (say to add more PQ safety), you would inject a PSK every epoch, but a different one in each epoch\r\n- When re-starting a group or branching a subgroup, you would incorporate the resumption secret from the previous group, but then might not need a PSK ever again.",
          "createdAt": "2020-08-03T21:44:57Z",
          "updatedAt": "2020-08-03T21:44:57Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I see, thanks for the clarification. My understanding of extensions was that their advantage is that they're dynamic and can be defined and used after MLS is defined, i.e. to keep the standard extensible. I know that in the TLS context, extensions are used for all sorts of basic protocol behaviour, but my understanding was that was more something that has evolved over time rather than it being \"by-design\".\r\n\r\nIs there any reason for Proposals to be limited to TreeKEM operations (other than that being their historic purpose)? Because otherwise it seems a little odd to me not to use them for core MLS operations such as PSK injection.",
          "createdAt": "2020-08-04T07:31:57Z",
          "updatedAt": "2020-08-04T07:31:57Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Otherwise, I agree with your take on PSK injections. They should definitely be part of the commit and it should be possible to inject them ad-hoc. Although for the re-starting or branching use-case, I think they should be part of the Welcome message, but I think we're having that discussion on the mailing list already.",
          "createdAt": "2020-08-04T07:36:02Z",
          "updatedAt": "2020-08-04T07:36:02Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "This was discussed at the interim on 2020-08-25.  The feeling of the group was that Proposals should be a sufficient extension mechanism for Commits, so we don't need this if we fix #383.  And since #389 is about to do that, closing this issue.",
          "createdAt": "2020-08-25T18:15:15Z",
          "updatedAt": "2020-08-25T18:15:15Z"
        }
      ]
    },
    {
      "number": 367,
      "id": "MDU6SXNzdWU2NjU0NDg1ODE=",
      "title": "Negotiate PSKs",
      "url": "https://github.com/mlswg/mls-protocol/issues/367",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "kkohbrok"
      ],
      "labels": [
        "enhancement",
        "security",
        "work in progress"
      ],
      "body": "[This issue is part of a feature breakdown based on #336]\r\n\r\nThere are a few subissues here:\r\n\r\n# 1. Signaling which PSK(s) to add to the key schedule\r\n\r\nWhen a PSK is to be added to the key schedule in an epoch, the sender of the Commit needs to signal this to existing members in a Commit, and to any new members in the GroupInfo.  In both cases, there should be an extension to signal this.  This would work like the [TLS ServerHello PSK extension](https://tools.ietf.org/html/rfc8446#section-4.2.11), which simply indicates which PSK is being used.  In the MLS case, we would probably include the full ID instead of just an index, since there's not a clear list like in TLS.  And just like the server's ability to complete the TLS handshake proves that it has the PSK, the confirmation value in MLS would validate the same.\r\n\r\n```\r\nstruct {\r\n    opaque identity<1..2^16-1>;\r\n} PreSharedKeyExtension;\r\n```\r\n\r\n# 2. Signaling which PSKs are available\r\n\r\nIt might also be useful for clients to advertise in a KeyPackage extension what PSKs they have available.  This would be analogous to the ClientHello PSK extension, which includes a binding value to prove that the client has the PSK.  If we define such an extension, we will need to decide (a) whether we need such a binding and (b) what parts of the KeyPackage should be covered by the binding MAC.\r\n\r\nUnlike TLS, however, the set of available PSKs might change over the lifetime of the group.  Since the KeyPackages in the leaves of the tree can be modified, in principle, clients could signal the availability of new PSKs by updating, and you would get a clear assurance that everyone has the key before you try to use it.  But this seems pretty complex, and for not much benefit if the application can coordinate which PSKs are available.\r\n\r\n# 3. Structuring PSK input / multiple PSKs\r\n\r\nIt may be desirable for the input to the key schedule not to be a PSK directly, but some derived value that adds some context to the PSK.  This is the approach taken in the [TLS external PSK draft](https://tools.ietf.org/html/draft-ietf-tls-external-psk-importer-05) and in #336.  We might also want to support the application of multiple PSKs in a single epoch.\r\n\r\nFor the former need, we would need to define what context is added, how it is signaled in the relevant extensions, and how it is combined with the PSK itself to derive the ultimate PSK.  For the latter need, we need a way to signal multiple PSKs and their order, and an algorithm for combining them all into one value to be added to the key schedule.  (The schemes in both #336 and #337 are relevant here.)\r\n",
      "createdAt": "2020-07-24T22:24:00Z",
      "updatedAt": "2020-10-19T14:27:48Z",
      "closedAt": "2020-10-19T14:27:47Z",
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Except for the advertisement of PSKs in KeyPackages, we already covered all of this in #336. In particular, it is important to distinguish PSKs by type (internal/external, which type of internal) by having an extra layer of derivations before injecting the PSK into the key schedule. Again, this is already present in #336.\r\n\r\nPR #376 re-implements #336 partially, but instead of having additional types of proposals, it instead has a dedicated preSharedKey extension that can come with a commit. Why an extension instead of a proposal? I would think that PSKs are part of MLS' core functionality, for example to securely create subgroups or to restart groups with different parameters.\r\n\r\nHaving PSKs in KeyPackages might be a good idea, but as you already hint at, I don't think it's a good idea to use it as a necessary way of signalling the availability for all PSKs. With group restarting and branching, we use PSKs much more dynamically than in TLS. For example, when creating a sub-group, the creator already knows that the relevant PSKs are available to all members due to their membership in the original group.\r\n\r\nDo you want me to isolate the parts of #336 relevant for this particular issue and create a separate PR? If we still want an extension instead of a dedicated proposal, we should probably merge #369 first and then do the PR against the result.",
          "createdAt": "2020-07-29T07:35:37Z",
          "updatedAt": "2020-07-29T07:35:37Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #336 ",
          "createdAt": "2020-10-19T14:27:47Z",
          "updatedAt": "2020-10-19T14:27:47Z"
        }
      ]
    },
    {
      "number": 368,
      "id": "MDU6SXNzdWU2NjU0NTIxOTA=",
      "title": "Proof of prior membership in the group / Resumption",
      "url": "https://github.com/mlswg/mls-protocol/issues/368",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "kkohbrok"
      ],
      "labels": [
        "enhancement",
        "security",
        "work in progress"
      ],
      "body": "[This issue is part of a feature breakdown based on #336]\r\n\r\nThere are two cases where the members of a group might want to authenticate that the other members of the group were present at another point in history:\r\n\r\n1. A user who has lost state re-joining the group\r\n2. Re-initializing the group with different parameters\r\n3. Initializing a subgroup from a master group\r\n\r\nIn the former case, the group would want to authenticate that the user re-joining is the same user who was present at some past point in the history of the group.  In the latter two cases, the members of the new, re-initialized group would be authenticating that everyone in the new group was also in the old group.\r\n\r\nThese use cases are similar to resumption in TLS, where a PSK is derived from the key schedule and used as for authentication in a different session.  A similar approach seems sensible here, roughly:\r\n\r\n1. At each epoch of the group derive a PSK and PSK ID to be used \r\n2. Use the general PSK signaling mechanism (#367) to signal that a prior epoch's PSK should be used\r\n\r\nThis approach is also a good indication that the PSK mechanism in #367 should allow for PSKs to have specified types.  In TLS, there has been some confusion about how applications can distinguish external PSKs from resumption PSKs.  If we have an explicit type here, we won't end up with that confusion.",
      "createdAt": "2020-07-24T22:34:54Z",
      "updatedAt": "2020-10-19T14:28:05Z",
      "closedAt": "2020-10-19T14:28:05Z",
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As noted in my comment on #367, this is all detailed and implemented in PR #336.\r\n\r\nWe created #336 based on the use cases you identified and reached the same conclusions. Getting the PSK derivations and their inclusion in the key schedule right is a little tricky. How should we proceed? It probably makes sense to agree on something to merge for #367 and then create a separate PR for this issue with whatever is left of the original #336 PR.",
          "createdAt": "2020-07-29T07:47:55Z",
          "updatedAt": "2020-07-29T07:47:55Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, the idea of this sequence of issues (#366, #367, #368, #374) was to pull apart the multiple features being addressed in #336.\r\n\r\nAs you can see with #369 and #376, I've begun posting PRs to address these smaller issues, drawing on the work done in #336 and adding details / refinements that were missing.  Would it be a sensible split to cover #366 and #367 with those, and update #336 to cover #368 and #374?",
          "createdAt": "2020-07-29T14:02:06Z",
          "updatedAt": "2020-07-29T14:02:06Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #336 ",
          "createdAt": "2020-10-19T14:28:02Z",
          "updatedAt": "2020-10-19T14:28:02Z"
        }
      ]
    },
    {
      "number": 373,
      "id": "MDU6SXNzdWU2NjU5NTgyMzQ=",
      "title": "Address DoS by malicious insiders",
      "url": "https://github.com/mlswg/mls-protocol/issues/373",
      "state": "CLOSED",
      "author": "tomtau",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "discussion",
        "editorial",
        "enhancement"
      ],
      "body": "https://github.com/mlswg/mls-protocol/issues/21\r\n\r\nIn the current protocol draft:\r\n```\r\n<!-- OPEN ISSUE: It is not possible for the recipient of a handshake\r\nmessage to verify that ratchet tree information in the message is\r\naccurate, because each node can only compute the secret and private\r\nkey for nodes in its direct path.  This creates the possibility\r\nthat a malicious participant could cause a denial of service by sending a\r\nhandshake message with invalid values for public keys in the ratchet\r\ntree. -->\r\n```\r\n\r\nUnless I overlooked it, the current draft seems to be also missing a \"simple\" DoS case where a handshake message could omit / malform some `DirectPathNode` (e.g. by having an empty ciphertext or invalid kem_output) -- this should be easily detectable (either by members themselves or if handshake messages are transmitted as MLSPlaintext, the delivery service could reject that).\r\n\r\nFor that originally discussed case, I guess the sketched out solution with a \"Nack\" message containing a DLEQ proof could work. Besides the drawbacks described there, one will also need to extend HPKE definitions to allow for this \"directly decrypt from the revealed shared secret\" use case. ",
      "createdAt": "2020-07-27T04:04:21Z",
      "updatedAt": "2020-10-20T15:17:11Z",
      "closedAt": "2020-10-20T15:17:11Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "You're correct that there is a simpler DoS case where the sender could simply send a malformed `DirectPathNode`.  It shares with the DoS described that it is only detectable by affected nodes.   And I think that those two together cover the DoS possibilities, since it covers the two things that can be chosen in Commit.\r\n\r\nAs far as Nack/DLEQ -- I'm not sure what you have in mind there.  It seems like you would want zero-knowledge proofs for two relationships between HPKE ciphertexts: (1) that two ciphertexts are encryptions of the same value under two different public keys, and (2) that a parent ciphertext is an encryption of the parent node secret, and the child ciphertext is an encryption of the child node secret.  It's not clear that there are solutions for either of these.\r\n\r\nWhat we can do though, is make sure that the Security Considerations cover these risks.  I would propose focusing on documenting the risk rather than fixing it.\r\n",
          "createdAt": "2020-07-28T18:10:12Z",
          "updatedAt": "2020-07-28T18:10:12Z"
        },
        {
          "author": "tomtau",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> It shares with the DoS described that it is only detectable by affected nodes.\r\n\r\nFor that simpler case, it can be detected by other nodes by doing extra checks (e.g. checking all `DirectPathNode` cipher text lengths or public key formats match what one would expect in a particular ciphersuite).\r\n\r\n> As far as Nack/DLEQ -- I'm not sure what you have in mind there.\r\n\r\nI was referring to the final comments here: https://github.com/mlswg/mls-protocol/issues/21#issuecomment-455392023\r\nSo, the goal won't be to prevent malicious insiders, but allow affected nodes to report that they couldn't process Commit by revealing the corresponding ephemeral key. With HPKE / current draft, it may be:\r\n- for malformed path secrets, affected nodes reveal `dh` + `DLEQ(dh:kem_output :: node_public_key:G)`\r\n- others check DLEQ; then using `dh` compute `zz` for `SetupBaseR` and can go ahead to check the path secrets (either the ciphertext is malformed or the public keys derived from secrets don't match the received public keys in Commit)",
          "createdAt": "2020-07-29T01:58:01Z",
          "updatedAt": "2020-07-29T01:58:01Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed on virtual interim 2020-10-20: Closing pending a more detailed proposal.",
          "createdAt": "2020-10-20T15:17:11Z",
          "updatedAt": "2020-10-20T15:17:11Z"
        }
      ]
    },
    {
      "number": 374,
      "id": "MDU6SXNzdWU2NjY2MjY5OTM=",
      "title": "Derive an \"authentication secret\"",
      "url": "https://github.com/mlswg/mls-protocol/issues/374",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "functionality"
      ],
      "body": "[This issue is part of a feature breakdown based on #336]\r\n\r\nAs noted in #336, it can be useful for members of the group to have a value they can compare to verify that they have the same view of the state of the group, similar to \"short authentication strings\" in [ZRTP](https://tools.ietf.org/html/rfc6189#section-7) or [TLS](https://tools.ietf.org/id/draft-miers-tls-sas-00.html) or \"safety numbers\" in [Signal](https://support.signal.org/hc/en-us/articles/360007060632-What-is-a-safety-number-and-why-do-I-see-that-it-changed-) and related protocols.\r\n\r\nIn MLS, values derived from the epoch secret via Derive-Secret can be used as confirmations of the relevant state, including the roster, the contents of the tree, and the transcript.  So at a cryptographic level, this should only require deriving an additional secret from the key schedule (as in #336).  We should expand on the text in #336 for how this secret is used and what authentication guarantees it provides.",
      "createdAt": "2020-07-27T22:36:40Z",
      "updatedAt": "2020-10-19T14:26:54Z",
      "closedAt": "2020-10-19T14:26:54Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #336 and #419 ",
          "createdAt": "2020-10-19T14:26:54Z",
          "updatedAt": "2020-10-19T14:26:54Z"
        }
      ]
    },
    {
      "number": 383,
      "id": "MDU6SXNzdWU2NzIzNTE3MzA=",
      "title": "Enable Commit to cover new proposal types",
      "url": "https://github.com/mlswg/mls-protocol/issues/383",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In principle, the set of ProposalType values is extensible.  But with the current Commit syntax, there is no way for a Commit to reference a Proposal with a type other than Add/Update/Remove.  We could enable this by adding a field to the commit that would carry such references:\r\n\r\n```\r\nstruct {\r\n    ProposalID updates<0..2^32-1>;\r\n    ProposalID removes<0..2^32-1>;\r\n    ProposalID adds<0..2^32-1>;\r\n    ProposalID others<0..2^32-1>;    // <------\r\n\r\n    optional<DirectPath> path;\r\n} Commit;\r\n```\r\n\r\nHowever, if other proposal types had sequencing requirements, they would not get the benefit of explicit, separate grouping and ordering as is done for the current proposal types.\r\n\r\nIf we don't extend the Commit in this way, we should add some explanatory text to clarify that new proposal types require an extension that changes the format of the Commit message.",
      "createdAt": "2020-08-03T21:24:38Z",
      "updatedAt": "2020-08-25T19:50:20Z",
      "closedAt": "2020-08-25T19:50:20Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Personally, I lean toward the \"do nothing\" option here.  If we take the view that proposals should describe modifications to the tree (other actions being signaled in [Commit extensions](https://github.com/mlswg/mls-protocol/issues/366)), then Add, Update, and Remove are pretty much the available atomic operations.  You could envision some minor variations (an Add with a specified location, say) or compositions (Resync = Remove+Add), but nothing is coming to my mind that would be important enough to merit the extra complexity.",
          "createdAt": "2020-08-03T21:28:30Z",
          "updatedAt": "2020-08-03T21:28:30Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #389 ",
          "createdAt": "2020-08-25T19:50:20Z",
          "updatedAt": "2020-08-25T19:50:20Z"
        }
      ]
    },
    {
      "number": 386,
      "id": "MDU6SXNzdWU2NzYxNzQ2OTk=",
      "title": "Remove remaning raw Hash or add hash function to ciphersuite",
      "url": "https://github.com/mlswg/mls-protocol/issues/386",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In #364, we changed from using HKDF to using the KDF from HPKE, which I thought removed the need for the ciphersuite to specify a hash function. As a result, ciphersuites no longer needed to specify a hash.\r\n\r\nHowever, the transcript computations still have a raw `Hash()` invocation, not a KDF invocation.  So we need to either:\r\n\r\n1. Change the transcript hash computations to use the KDF, or\r\n2. Clarify that ciphersuites still specify a hash function (as before)",
      "createdAt": "2020-08-10T14:21:13Z",
      "updatedAt": "2020-08-11T19:18:11Z",
      "closedAt": "2020-08-11T19:18:11Z",
      "comments": [
        {
          "author": "ericcornelissen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What about the `Hash()` call in the [Exporters section](https://github.com/mlswg/mls-protocol/blob/d1d5f56a5d83781042d19c830497ab5aa104907f/draft-ietf-mls-protocol.md#exporters) and the \"hashes\" for [Tree Hashes](https://github.com/mlswg/mls-protocol/blob/d1d5f56a5d83781042d19c830497ab5aa104907f/draft-ietf-mls-protocol.md#tree-hashes)?",
          "createdAt": "2020-08-11T13:10:29Z",
          "updatedAt": "2020-08-11T13:10:29Z"
        }
      ]
    },
    {
      "number": 390,
      "id": "MDU6SXNzdWU2Nzc0NTI2NTM=",
      "title": "impossible to verify the group creation process for the joiner without knowing the random init_secret that the group creator used",
      "url": "https://github.com/mlswg/mls-protocol/issues/390",
      "state": "CLOSED",
      "author": "tomtau",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "https://github.com/mlswg/mls-protocol/pull/385#issuecomment-671949236",
      "createdAt": "2020-08-12T07:09:17Z",
      "updatedAt": "2020-08-18T14:50:20Z",
      "closedAt": "2020-08-18T14:50:20Z",
      "comments": []
    },
    {
      "number": 392,
      "id": "MDU6SXNzdWU2NzkxMTczNjM=",
      "title": "Is the path secret used as PRK when doing Kdf.Expand?",
      "url": "https://github.com/mlswg/mls-protocol/issues/392",
      "state": "CLOSED",
      "author": "yihuang",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "When evolving the ratchet tree, we'll do:\r\n```\r\npath_secret[n] = ExpandWithLabel(path_secret[n-1],\r\n                                   \"path\", \"\", KEM.Nsk)\r\n```\r\nDoes the `path_secret[n-1]` used as the `PRK` directly?\r\n```\r\n   HKDF-Expand(PRK, info, L) -> OKM\r\n```\r\nIf that's the case, does that mean ` KEM.Nsk` should be `>= Kdf.Nh`?\r\n\r\nOr should we do an extract before the expand?",
      "createdAt": "2020-08-14T12:14:46Z",
      "updatedAt": "2020-09-03T00:30:22Z",
      "closedAt": "2020-09-03T00:30:22Z",
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, `path_secret[n-1]` is used as the PRK directly. Why does `Kdf.Nh` matter?",
          "createdAt": "2020-08-18T16:11:36Z",
          "updatedAt": "2020-08-18T16:11:36Z"
        },
        {
          "author": "yihuang",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Because in https://tools.ietf.org/html/rfc5869, there's:\r\n```\r\n   HKDF-Expand(PRK, info, L) -> OKM\r\n...\r\n   Inputs:\r\n      PRK      a pseudorandom key of at least HashLen octets\r\n               (usually, the output from the extract step)\r\n```\r\n\r\nAnd length of `path_secret` is `KEM.Nsk`, so `KEM.Nsk >= Kdf.Nh`? unless we do an extract before expand?",
          "createdAt": "2020-08-18T16:52:27Z",
          "updatedAt": "2020-08-18T16:52:27Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe the PRK is just used as an HMAC key in HKDF, so I don't think that's a hard requirement",
          "createdAt": "2020-08-18T17:43:38Z",
          "updatedAt": "2020-08-18T17:43:38Z"
        },
        {
          "author": "yihuang",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I believe the PRK is just used as an HMAC key in HKDF, so I don't think that's a hard requirement\r\n\r\nI'm not sure how hard the requirement is, the RFC didn't say it's a `SHOULD`, and [implementation added check on this](https://github.com/RustCrypto/KDFs/blob/master/hkdf/src/hkdf.rs#L128), so it'll cause confusion, or even panic program.",
          "createdAt": "2020-08-19T03:35:48Z",
          "updatedAt": "2020-08-19T03:37:18Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@yihuang I think you're right here.  We should probably change `KEM.Nsk` to `KDF.Nh`.",
          "createdAt": "2020-08-25T18:13:18Z",
          "updatedAt": "2020-08-25T18:13:18Z"
        }
      ]
    },
    {
      "number": 405,
      "id": "MDU6SXNzdWU3MDU1NDMyMDc=",
      "title": "Mandatory Extensions vs. Fields",
      "url": "https://github.com/mlswg/mls-protocol/issues/405",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Why are extensions that MUST be present in an instance of a struct (e.g. `capabilities` and `lifetime` in a `KeyPackage`) not just fields in that struct?\r\n\r\nShouldn't `extensions` be used for custom extensions or maybe optional parts of the struct? (Although those should probably be `optional` fields, I would think.)",
      "createdAt": "2020-09-21T12:16:00Z",
      "updatedAt": "2020-09-28T13:31:10Z",
      "closedAt": "2020-09-28T13:31:09Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't have a strong feeling on this.  The best argument that comes to my mind is that it makes changes in the future a bit easier, since adding/removing extensions is a bit easier than changing the base struct.  The [TLS 1.3 ClientHello](https://tools.ietf.org/html/rfc8446#section-4.1.2), for example, has fields like `legacy_version` that have been deprecated because they found a better way to do things like version negotiation.  \r\n\r\n@Bren2010 @raphaelrobert maybe you guys have opinions?",
          "createdAt": "2020-09-22T17:43:39Z",
          "updatedAt": "2020-09-22T17:43:39Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe this has been brought up before, but you said you wanted them to be extensions because it forces people to actually implement the extensibility logic. I would like them to be fields but that was a good enough argument that I left it alone",
          "createdAt": "2020-09-22T20:40:27Z",
          "updatedAt": "2020-09-22T20:40:27Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for elaborating on this. I also prefer fields, but given those arguments, I'm happy to have them as extensions as well.",
          "createdAt": "2020-09-23T06:02:30Z",
          "updatedAt": "2020-09-23T06:02:30Z"
        }
      ]
    },
    {
      "number": 409,
      "id": "MDU6SXNzdWU3MTQ3MjAxMTY=",
      "title": "Draft structure/Editorial Changes",
      "url": "https://github.com/mlswg/mls-protocol/issues/409",
      "state": "OPEN",
      "author": "franziskuskiefer",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "This issue accompanies the e-mail [1] pointing out editorial issues with the draft and suggesting improvements.\r\n\r\nTL;DR: I don't think the draft currently is what is needed to implement MLS. It needs an editorial overhaul with a better structure.\r\n\r\n[1] https://mailarchive.ietf.org/arch/msg/mls/ZOy80Yp5bRhoM8fsQMGVwmFFEzY/",
      "createdAt": "2020-10-05T10:31:58Z",
      "updatedAt": "2021-12-01T17:13:38Z",
      "closedAt": null,
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "If we want an implementation document, which is a legitimate ask, we should write an implementation document.",
          "createdAt": "2020-10-05T11:14:19Z",
          "updatedAt": "2020-10-05T11:14:19Z"
        },
        {
          "author": "franziskuskiefer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What's the purpose of the document if not for implementation?\r\nIn order for this draft to become an RFC it needs implementations. I don't see a way this will happen with the draft as is.",
          "createdAt": "2020-10-05T11:31:04Z",
          "updatedAt": "2020-10-05T11:31:04Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Specifying a functional behavior and providing a guide for implementation are two very different things.\r\n\r\nRe: what you suggested in your email: Internal representations of the tree, the way you number the indices, how you implement them or the fact that you store some hashes in the nodes are completely irrelevant to this document.\r\nAlso, there is nothing formal about this appendix. \r\n\r\nOn the other hand the information you need from this document is how to perform **computations** : things such as providing the arguments to the node_encap/node_decap functions which are required to generate a correct payload and a standard way to serialize abstract structures... etc.",
          "createdAt": "2020-10-05T12:10:26Z",
          "updatedAt": "2020-10-05T12:10:26Z"
        },
        {
          "author": "franziskuskiefer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Specifying a functional behavior and providing a guide for implementation are two very different things.\r\n\r\nRight, the document is doing neither right now.",
          "createdAt": "2020-10-05T12:58:11Z",
          "updatedAt": "2020-10-05T12:58:11Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "We have two separable issues here: We need better explanation of the overall structure of the protocol (as in Franziskus' email), and we could rearrange the text to be clearer.\r\n\r\nFor the first, I have filed #520.  That provides a pretty complete overview of the protocol, covering all of the syntax and high-level operations.\r\n\r\nFor the second, we should do a second PR after the other outstanding PRs have landed.  Looking at the table of contents, I would propose we refactor in the following way:\r\n\r\n* For top-level sections: \r\n    * Move `# Ratchet Trees` to after `# Cryptographic Objects` and `# Key Packages`\r\n* For subsections:\r\n    * Move the tree-relevant subsections of `# Key Packages` into `# Ratchet Trees` \u2014 including `## Parent Hash`, `## Tree Hashes`, and `## Update Paths`\r\n    * Split `## Group State` into two:\r\n        * Put the GroupContext definition part in a new subsection `## Group Context` under `# Cryptographic Objects` \r\n        * Put the transcript updating part in a new subsection `## Updating the Transcript` under `# Key Schedule` ",
          "createdAt": "2021-12-01T17:13:38Z",
          "updatedAt": "2021-12-01T17:13:38Z"
        }
      ]
    },
    {
      "number": 410,
      "id": "MDU6SXNzdWU3MTQ3NjEwMzM=",
      "title": "Welcome message delivery",
      "url": "https://github.com/mlswg/mls-protocol/issues/410",
      "state": "CLOSED",
      "author": "franziskuskiefer",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "It is currently unclear how welcome messages are supposed to be delivered. They should be sent to the clients directly without sending them to the group. But welcome messages as described in `11.2.1. Welcoming New Members` have no information about recipients. Neither are they framed in a way that would allow delivery.\r\nEither the `Welcome` message should get a recipient field, or it should get framed as an `MLSPlaintext` and sent to the group instead.",
      "createdAt": "2020-10-05T11:34:47Z",
      "updatedAt": "2021-08-19T23:26:04Z",
      "closedAt": "2021-08-19T23:26:04Z",
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "The encoded `Welcome` struct is what's sent to the new user. The exact method of delivery is up to the application, but you have the user's identity in their credential which should be enough",
          "createdAt": "2020-10-05T20:56:31Z",
          "updatedAt": "2020-10-05T20:56:31Z"
        },
        {
          "author": "franziskuskiefer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If message delivery and franking is something that's supposed to be left to the implementation, it should be removed for `MLSPlaintext` and `MLSCiphertext` as well. In fact description of the delivery service should be dropped all together from the architecture doc as well then.\r\nBut I don't think that's what you want. What's currently missing is a way to deliver `Welcome` messages only. All other messages are fine as far as I can see.\r\nSo if message delivery is something that should be described, as it is for all other messages, it should be done for `Welcome` messages as well.",
          "createdAt": "2020-10-06T06:45:39Z",
          "updatedAt": "2020-10-06T06:45:39Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "What you mean when you say there's no way to deliver Welcome messages? You just send the encoded struct to the new user.",
          "createdAt": "2020-10-06T15:04:10Z",
          "updatedAt": "2020-10-06T15:04:10Z"
        },
        {
          "author": "franziskuskiefer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> You just send the encoded struct to the new user.\r\n\r\nHow is the new user identified and how is the message supposed to get there? There's no real definition of users.",
          "createdAt": "2020-10-07T07:11:58Z",
          "updatedAt": "2020-10-07T07:11:58Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "You're correct that the Welcome message only needs to be sent to the new members, though of course there's no security impact if it is also broadcast to the group.\r\n\r\nI would argue that this is a problem for the DS to solve, for example by having the Welcome sender specify the routing identifiers for the recipients of the Welcome.  There's no need for these identifiers to be at all tied to the rest of the protocol, so there's no need for them to go in MLS; they can just be part of whatever framing is used to send MLS messages.\r\n\r\nAll that said, this could be a good topic for an issue on the architecture doc.  Basically, we want the DS to provide the following services:\r\n\r\n1. Routing of KeyPackages from (potential) joiners to group members who might add them\r\n2. Unicast/multicast routing of Welcome back to joiner(s)\r\n3. Multicast routing of Proposals/Commits to the group\r\n",
          "createdAt": "2020-10-07T12:38:23Z",
          "updatedAt": "2020-10-07T12:38:23Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "> How is the new user identified and how is the message supposed to get there? There's no real definition of users.\r\n\r\nWe have the new member's KeyPackage which contains a Credential which contains their identity.",
          "createdAt": "2020-10-07T15:17:42Z",
          "updatedAt": "2020-10-07T15:17:42Z"
        }
      ]
    },
    {
      "number": 411,
      "id": "MDU6SXNzdWU3MTYwODc0ODk=",
      "title": "Track Expected Types of Deployments",
      "url": "https://github.com/mlswg/mls-protocol/issues/411",
      "state": "CLOSED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This ticket is meant to collect all of the use-cases and types of deployments that we support, or types of deployments that we've chosen not to support. In the future, I'd like us to take some time to make a sorta taxonomy of deployments -- think through the architecture / protocol decisions you need to achieve each use-case, and the security properties you get.\r\n\r\nI'll start with a few:\r\n\r\n- **Centralized Deployment:** Optimally simple client-side implementation.\r\n  - Authentication Service: Endpoint run by service provider. Either trusted to act correctly or built with transparency technology.\r\n  - Delivery Service: Endpoint run by service provider. Ensures a linear ordering of Commits.\r\n  - Proposals and Commits are left as plaintext.\r\n  - *Properties:*\r\n    - The DS knows of all groups and which members are in each group, as well as the value of the group's ratchet tree.\r\n    - Since the DS ensures a linear ordering of Commits, members can process Commits in the naive way.\r\n    - The DS must process messages and maintain a copy of the ratchet tree.\r\n    - New members can get a copy of a group's ratchet tree from the DS, meaning Welcome messages can be smaller.\r\n    - Members are aware of all the other members in each group.\r\n- **Broadcast Channel Deployment:** Server-side implementation that doesn't require strong coordination.\r\n  - Authentication Service: Endpoint run by service provider. Either trusted to act correctly or built with transparency technology.\r\n  - Delivery Service: Broadcast channel that sends new messages to all group members indiscriminately, combined with a separate mechanism for KeyPackage distribution.\r\n  - Proposals and Commits are encrypted.\r\n  - *Properties:*\r\n    - The DS can infer which groups exist and which members are in each group, but this isn't required for it to operate. It does not know the ratchet tree.\r\n    - Members must use a consensus protocol to decide on which Commit to accept if multiple are sent at once. This may imply forking or reverting to a previous state.\r\n    - Since the ratchet tree isn't stored centrally, Welcome messages must be larger to accommodate the serialized tree.\r\n    - Members are aware of all the other members in each group.\r\n- **Anonymous Deployment:** Attempts to hide the membership of each group but does not attempt to hide the number of groups / number of members in each group.\r\n  - Authentication Service: Endpoint run by service provider. Either trusted to act correctly or built with transparency technology. Must be accessed anonymously.\r\n  - Delivery Service: Oblivious to *both* who writes a message to a given group, and who read that message. An onion network could be used, as long as a new circuit is created for each message. Ensures a linear ordering of Commits.\r\n  - Proposals and Commits are encrypted. No additional framing is used beyond what the onion network dictates.\r\n  - *Properties:*\r\n    - The DS knows of all groups and how many members are in each group. It does not know the ratchet tree or the identities of group members.\r\n    - Since the DS ensures a linear ordering of Commits, members can process Commits in the naive way.\r\n    - Since the ratchet tree isn't stored centrally, Welcome messages must be larger to accommodate the serialized tree.\r\n    - Members are aware of all the other members in each group.\r\n\r\nSome that I need to think more about:\r\n\r\n- **Hidden-Membership Deployment:** Allows groups where group members are unable to determine the identity of other members. All communication is either from/to the group creator.\r\n- **Deniable Deployment:** Avoids signing messages sent to a group with a binding private key.\r\n- **Federated Deployment:** Allows the users of multiple cooperating AS and DS providers to inter-communicate.\r\n",
      "createdAt": "2020-10-06T23:29:26Z",
      "updatedAt": "2020-10-19T14:31:44Z",
      "closedAt": "2020-10-19T14:31:44Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "This seems worth thinking about, but more in the context of the architecture document than the protocol.",
          "createdAt": "2020-10-07T12:39:12Z",
          "updatedAt": "2020-10-07T12:39:12Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this as a protocol issue, feel free to re-file on the architecture.",
          "createdAt": "2020-10-19T14:31:44Z",
          "updatedAt": "2020-10-19T14:31:44Z"
        }
      ]
    },
    {
      "number": 418,
      "id": "MDU6SXNzdWU3MTkyNzgzNDM=",
      "title": "Reuse guard mechanism is described in wrong section",
      "url": "https://github.com/mlswg/mls-protocol/issues/418",
      "state": "CLOSED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "It is in \"Content Encryption\" but should be in \"Sender Data Encryption\".",
      "createdAt": "2020-10-12T10:48:38Z",
      "updatedAt": "2020-10-16T14:04:59Z",
      "closedAt": "2020-10-16T14:04:59Z",
      "comments": []
    },
    {
      "number": 426,
      "id": "MDU6SXNzdWU3MjUyNTc1NzE=",
      "title": "Adopt TLS-Style Key Schedule",
      "url": "https://github.com/mlswg/mls-protocol/issues/426",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Extracting from the `GroupContext_[n]` doesn't really make sense from a provable security standpoint. Instead, we should go with the TLS approach and use the `GroupContext_[n]` as context in a `KDF.Derive` step. This could be an extra step before we derive the individual keys off the key schedule or we include it in each individual derivation operation.",
      "createdAt": "2020-10-20T06:44:12Z",
      "updatedAt": "2020-10-20T15:41:44Z",
      "closedAt": "2020-10-20T15:41:44Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed on virtual interim:\r\n\r\n```\r\nBEFORE:\r\n                   Derive-Secret(., \"epoch\") = ExpandWithLabel(Secret, \"epoch\", \"\", KDF.Nh)\r\n                         |\r\n                         V\r\n GroupContext_[n] -> KDF.Extract = epoch_secret\r\n                         |\r\n                         +--> Derive-Secret(., <label>)\r\n                         |    = <secret>\r\n\r\nAFTER:\r\n                   ExpandWithLabel(., \"epoch\", GroupContext_[n], KDF.Nh)\r\n                         |\r\n                         V\r\n                    epoch_secret\r\n                         |\r\n                         +--> Derive-Secret(., <label>)\r\n                         |    = <secret>\r\n```",
          "createdAt": "2020-10-20T15:15:51Z",
          "updatedAt": "2020-10-20T15:15:51Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Solved by merging #427 . Closing.",
          "createdAt": "2020-10-20T15:41:44Z",
          "updatedAt": "2020-10-20T15:41:44Z"
        }
      ]
    },
    {
      "number": 432,
      "id": "MDU6SXNzdWU3Mjc5ODI3OTU=",
      "title": "Ensure no ambiguity between leaf and node indices",
      "url": "https://github.com/mlswg/mls-protocol/issues/432",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "We currently distinguish between leaf indices and node indices, where node indices are a straight-forward index in the array representing a ratcheting tree and leaf indices index what (I think) used be called the roster, an array just containing the members. However, the roster was removed and instead, we always use the ratcheting tree array when referring to both nodes and leaves. As a result, whenever we use a leaf index, we have to translate it to a node index when actually indexing the array. I don't see a reason for this added complexity and propose only use node indices.\r\n\r\nThis was already discussed a bit in #431 , where @bifurcation pointed out that leaf indices make sure that a Remove only ever references a leaf. I think having a little check here that the index actually refers to a leaf is preferable over having to translate back and forth in many other places. Note, that we have to check anyway if the index in Remove is within the bounds of the tree, regardless of it being a leaf or a node index.\r\n\r\nI'm happy to provide a PR if this is something we want to do.",
      "createdAt": "2020-10-23T07:25:18Z",
      "updatedAt": "2021-10-11T19:11:21Z",
      "closedAt": "2021-10-11T19:11:21Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "When I mentioned Remove in the context of #431, that was only an initial example.  Here's a more fulsome list of where leaf indices are used:\r\n\r\n* `Remove.removed`\r\n* `ParentNode.unmerged_leaves`\r\n* `MLSPlaintext.Sender.sender`\r\n* `GroupInfo.signer_index`\r\n\r\nAll of those are cases where a node index would be nonsensical.  So while even with a leaf index, you still have to bounds-check, you're basically asking for us to allow more nonsensical cases to be expressible in the syntax.\r\n\r\nAs far as comprehensibility / implementability: The difference between node indices and leaf indices is clearly laid out in the [tree terminology section](https://github.com/mlswg/mls-protocol/blob/master/draft-ietf-mls-protocol.md#tree-computation-terminology), and AFAICT, all of the references to indices are clear about which one they refer to.  \r\n\r\nThis distinction is a good one for implementors to have in mind, and not just to simplify parsing / input validation on messages as above.  There are lots of internal methods that only make sense to refer to leaves as well.  For example, a TreeKEM implementation internal to an MLS implementation will need to know the index of the caller of `TreeKEM.encap()` so that it can make the right UpdatePath.  Here again, providing a node index is nonsensical.  So implementations will likely end up needing to differentiate leaves from nodes *anyway*.\r\n\r\nNet of all that, I propose closing this with no action.\r\n",
          "createdAt": "2020-10-23T17:49:15Z",
          "updatedAt": "2020-10-23T17:49:15Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fair enough. Closing this, then.",
          "createdAt": "2020-10-25T06:49:23Z",
          "updatedAt": "2020-10-25T06:49:23Z"
        },
        {
          "author": "franziskuskiefer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I suggest to re-open this in order to remove the concept of lead indices from the spec.\r\nWe'll do so in OpenMLS in https://github.com/openmls/openmls/issues/356 because it's a footgun causing a ton of issues.\r\n\r\nIf you really want to keep the concept in the spec, it must be made clear when a leaf index and when a node index is used. Taking the text for remove proposals for example.\r\n\r\n> A Remove proposal requests that the client at a specified index in the tree be removed from the group.\r\n\r\nThis sounds like the index is a node index.\r\n\r\n> Replace the leaf node at position removed with a blank node\r\n\r\nThis sounds like it could be a leaf index.\r\n\r\nBut it's not defined either way.\r\n\r\nSo your claim @bifurcation that \"all of the references to indices are clear about which one they refer to.\" is not true.\r\n\r\n> This distinction is a good one for implementors to have in mind\r\n\r\nI totally agree with this. But the current concept introduces more issues than it actually solves. So this definitely needs work, either by removing the concept (which I'd prefer) or actually making clear which index is used.\r\nIn my opinion the tree should only be indexed by one type of indices to reduce ambiguity and the potential for bugs. This way we can reduce the places of conversion while still making it clear to implementors that there is a distinction between the two.",
          "createdAt": "2021-04-12T07:53:33Z",
          "updatedAt": "2021-04-12T07:53:33Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm happy to clean up references, but I would like to avoid explicitly allowing invalid requests.  You shouldn't be able to ask to remove node 5, or say you signed with node 7.  You risk bugs either way; in the \"all indices are node indices\" case you just have to catch them at runtime, as opposed to using the right type at build time.  So I continue to believe this is better handled with type systems.\r\n\r\nNonetheless, I'll do a review and try to clean up any ambiguous cases.",
          "createdAt": "2021-08-10T23:54:20Z",
          "updatedAt": "2021-08-10T23:54:20Z"
        }
      ]
    },
    {
      "number": 440,
      "id": "MDU6SXNzdWU3NDU4MzgxNjg=",
      "title": "Fix the protocol overview section",
      "url": "https://github.com/mlswg/mls-protocol/issues/440",
      "state": "CLOSED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Currently section \"4. Protocol Overview\" states:\r\n\r\n`Upon receiving the Welcome message and the corresponding Commit, the new member will be able to read and send new messages to the group`\r\n\r\nI think this is a legacy from before the propose/commit scheme and got carried over. New members no longer need the Commit.\r\nThe subsequent diagram also needs to be adapted.",
      "createdAt": "2020-11-18T17:03:31Z",
      "updatedAt": "2021-03-04T21:33:44Z",
      "closedAt": "2021-03-04T21:33:44Z",
      "comments": []
    },
    {
      "number": 443,
      "id": "MDU6SXNzdWU3NDgzNDU4NDc=",
      "title": "External commit for resync used with PSK",
      "url": "https://github.com/mlswg/mls-protocol/issues/443",
      "state": "CLOSED",
      "author": "br-hale",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "A good point was raised by Jonathon Hoyland during the MLS IETF 109 meeting regarding possible concerns in using external commits for resync, particularly in the case of Alice adding/removing herself. Richard noted that this is a feature in the case that Alice is no longer synchronized with the group and therefore can use an external commit to add herself back in, removing the previous version.\r\n \r\nAs opposed to any newcomer joining with an external commit, the case of Alice re-joining presents a potential security issue. Namely, as currently specified (in my reading of the draft), an existing group member, Bob, has no means to distinguish between the following cases:\r\n\r\n1) Alice needs to resync and therefore performs an external commit and removes her prior version.\r\n2) Alice\u2019s signature keys are compromised (it is not necessary for the adversary to compromise any group state). The adversary performs an external commit in Alice\u2019s name, and then removes her prior version and impersonates her to the group.\r\n \r\nOne might hope that Alice notices that she is removed and communicates this to the group members OOB, but it is also possible that that she assumes some other reason for the removal, is offline, or simply is not active enough to take action for a fairly long compromise window. Even if she tries to use an external commit to get back into the group and then removes the adversary-as-Alice, there is no means for other group members distinguish the real Alice from the adversary-as-Alice and the process could be circular (until new valid identity keys are issued).\r\n \r\nWhile a newcomer is a fresh source to be trusted or not, Alice has been \u201chealing\u201d along with the group and the above option (2) allows the adversary to bypass all of that.\r\n \r\nThe source of the problem is that when Alice re-syncs, she is not providing any validation of being the same/previous identity, so it is easy for other group members to accept that nothing more than a resync has taken place. Thus, a fairly straightforward solution is to require PSK use in cases where an external commit is used for resync. By enabling a PSK derived from a previous epoch during which Alice was part of the group to be injected with the external commit, Alice provides some proof of prior group membership and we avoid the total reset.\r\n\r\nThis is not quite PCS in that the attacker is active following compromise, but it is a linked case. As such it is important that a conscious decision is made regarding this (either as a slight change before the feature-freeze in line with the other changes that the editors have proposed, or as a working group decision to close the issue as out-of-scope).",
      "createdAt": "2020-11-22T20:44:14Z",
      "updatedAt": "2021-10-11T19:25:36Z",
      "closedAt": "2021-10-11T19:25:36Z",
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "Just to think this with what has been discussed on the mailing list: #439 will give members a way to do the distinction mentioned above.",
          "createdAt": "2021-03-02T15:16:07Z",
          "updatedAt": "2021-03-02T15:16:07Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@raphaelrobert - I don't think that's actually the case; it would only allow the members a way to recognize that Alice is replacing herself.\r\n\r\nI think the right answer here is what Britta suggests, plus a little: We should enumerate a few specific constraints on the proposals that can be carried inline in an external Commit:\r\n* There MUST be an Add proposal for the signer\r\n* There MUST be an ExternalInit proposal\r\n* There MUST NOT be any Update proposals\r\n* If a Remove proposal is present, then:\r\n    * The identity of the removed node MUST be the same as the identity in the Add KeyPackage\r\n    * There MUST be a PSK proposal of type `ReInit`, referencing an earlier epoch of this group\r\n  \r\nIn other words, you can commit things that existing members sent (by reference), but the joiner-initiated proposals must only (a) add the joiner, and (b) optionally remove the old instance of the joiner, with the PSK assurance @br-hale suggests.",
          "createdAt": "2021-08-11T00:17:48Z",
          "updatedAt": "2021-08-11T00:18:49Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Coming back to this after a few weeks, I'm actually not sure this is a problem worth solving.  The attack scenario (2) exists whether or not a member can resync without proving prior membership.  As long as (a) the group allows external Commits, and (b) the group does not require a new appearance of an existing identity to present a PSK from an earlier epoch, then the attacker can still do the attack by first joining, and then removing the old Alice.  The only difference in the case where the external commit also does the resync is that the two happen together.\r\n\r\nIt also doesn't seem unreasonable to regard the ability to resync from loss of all state except the signature key as a feature, not a bug.  Of course, that position would entail accepting that compromise of signature keys would be sufficient to impersonate the user, but that doesn't seem all that surprising, at least to me.\r\n\r\nSo this seems like a question of group policy to me.  Either the group requires ReInit PSKs on resync (and you can't recover from all-but-signature-key state loss), or it doesn't (and signature keys are the last resort).\r\n\r\nThis can be documented in the Security Considerations, in a new PR.  As far as #481, I think it's probably still worth adding the precision, but I would change the PSK part to MAY if not remove it entirely.",
          "createdAt": "2021-09-30T21:51:43Z",
          "updatedAt": "2021-09-30T21:51:43Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "There is also a practical issue with using PSKs to prove past membership, in that if there have been joins since Alice lost state, the new joiners won't have the PSK.  This is of course a general issue with the proof-of-past-membership PSK, but it is particularly salient here.",
          "createdAt": "2021-10-01T14:03:38Z",
          "updatedAt": "2021-10-01T14:03:38Z"
        }
      ]
    },
    {
      "number": 447,
      "id": "MDU6SXNzdWU3NjUyMzMyNzg=",
      "title": "Motivate Ratchet Trees",
      "url": "https://github.com/mlswg/mls-protocol/issues/447",
      "state": "CLOSED",
      "author": "yaronf",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "The top of Sec. 5 has exactly one sentence before diving into tree terminology. Please explain at a high level what is the motivation for this structure and maybe how it fits into the rest of the protocol.",
      "createdAt": "2020-12-13T09:57:39Z",
      "updatedAt": "2021-12-01T18:22:26Z",
      "closedAt": "2021-12-01T18:22:26Z",
      "comments": [
        {
          "author": "psyoptix",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My 2 cents: Abstractly, a distributed cryptographic state (like the ratchet tree) consists of a set of secrets. Each user j knows some subset S(j) of those secrets. More generally a set of users U collectively knows secrets S(U). To get Post Compromise Security for the distributed state we need a way for each user j to re-sample all secrets in S(j) and distribute such that the following is true. Suppose an adversary knows secrets S(U) in the old crypto state for some set of users U. Then in the new state, after witnessing the distribution phase on the wire, the adversary only knows the secrets in S(U\\\\{i}).\r\n\r\nFor example:\r\n - Suppose I steal your secrets (i.e. you are user j and now i know S(j)). Now you re-sample & distribute. As a result I now know S(\\emptyset) = nothing at all. The session is secure again. \r\n - Suppose I steal the keys of users 2, 4 and 7. So i know S({2,4,7}). Then after 7 re-samples & distributes I only know S({2,4}). Once 2 and 4 also re-sample and distribute I know nothing and the session is secure again.\r\n\r\nIn a nutshell, the ratchet tree in MLS gives us a way to efficiently do this re-sampling & distribution for commit_secrets repeatedly, non-interactively and *efficiently*. That is by sending out a single, reasonably small packet. \r\n\r\nOf course, as the ratchet tree adds more secrets to MLS distributed state we then have to be able to re-sample & distribute those as well which the ratchet tree lets us do. But at the end of the day, its all about distributing new commit_secrets.",
          "createdAt": "2021-10-28T15:34:47Z",
          "updatedAt": "2021-10-28T18:33:51Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "NONE",
          "body": "LGTM. Thanks!",
          "createdAt": "2021-10-28T17:22:49Z",
          "updatedAt": "2021-10-28T17:22:49Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@yaronf - I put my own spin on this in #513.  Let me know if that looks good to you!",
          "createdAt": "2021-11-19T22:07:16Z",
          "updatedAt": "2021-11-19T22:07:16Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "NONE",
          "body": "@bifurcation Absolutely. Thank you!",
          "createdAt": "2021-11-20T13:38:06Z",
          "updatedAt": "2021-11-20T13:38:06Z"
        }
      ]
    },
    {
      "number": 448,
      "id": "MDU6SXNzdWU3NjU1NTMwMDU=",
      "title": "Pin HPKE version",
      "url": "https://github.com/mlswg/mls-protocol/issues/448",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "editorial",
        "interoperability"
      ],
      "body": "@bifurcation points out that the HPKE version is not pinned. This is probably needed for interop. Version -07 should come sometime this week, so that seems like a perfectly fine version to use. I can send a PR when that version is cut.",
      "createdAt": "2020-12-13T17:35:39Z",
      "updatedAt": "2020-12-21T21:59:59Z",
      "closedAt": "2020-12-21T21:59:59Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #449 ",
          "createdAt": "2020-12-21T21:59:59Z",
          "updatedAt": "2020-12-21T21:59:59Z"
        }
      ]
    },
    {
      "number": 457,
      "id": "MDU6SXNzdWU4MTczNzYxMjM=",
      "title": "Clarify ParentHash verification",
      "url": "https://github.com/mlswg/mls-protocol/issues/457",
      "state": "CLOSED",
      "author": "franziskuskiefer",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The [parent hash verification](https://github.com/mlswg/mls-protocol/blob/master/draft-ietf-mls-protocol.md#verifying-parent-hashes) is currently not very well described. Depending on the reading it might also be wrong.\r\nIn particular, the condition `If R is a leaf node, the check fails`, if implemented as described makes it so that valid parent hashes are rejected. Take for example a simple tree with two leafs where the right leaf (node 2) sends a commit. In this case the other leaf will reject the parent hash because it fails when going down to the right leaf.\r\n\r\nThis might be a wrong interpretation of the described verification procedure but then the description needs updating.\r\nI suggest to add a more formal description of the parent hash generation and verification (e.g. pseudocode) to reduce ambiguity.",
      "createdAt": "2021-02-26T13:54:51Z",
      "updatedAt": "2021-08-11T07:54:44Z",
      "closedAt": "2021-08-11T07:54:44Z",
      "comments": [
        {
          "author": "psyoptix",
          "authorAssociation": "CONTRIBUTOR",
          "body": " I think that condition should read \"If R is a blank leaf node, the check fails\".",
          "createdAt": "2021-03-05T10:40:31Z",
          "updatedAt": "2021-03-05T10:40:31Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Agree with @psyoptix here; the [relevant code in MLSpp](https://github.com/cisco/mlspp/blob/main/src/treekem.cpp#L468) matches this interpretation.  So I think we just need to adjust that text.",
          "createdAt": "2021-08-11T00:00:12Z",
          "updatedAt": "2021-08-11T00:00:12Z"
        },
        {
          "author": "franziskuskiefer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree, this was fixed in #460 ",
          "createdAt": "2021-08-11T07:54:44Z",
          "updatedAt": "2021-08-11T07:54:44Z"
        }
      ]
    },
    {
      "number": 459,
      "id": "MDU6SXNzdWU4MjI5MjY5NDI=",
      "title": "Trim tree after removal",
      "url": "https://github.com/mlswg/mls-protocol/issues/459",
      "state": "CLOSED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Over time we lost the rule that the ratchet tree should also be trimmed after members have been removed (where it really makes sense), not only when members are added.",
      "createdAt": "2021-03-05T09:50:05Z",
      "updatedAt": "2021-08-10T23:48:02Z",
      "closedAt": "2021-08-10T23:48:02Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@suhasHere posted #461 to address this issue",
          "createdAt": "2021-03-08T00:04:59Z",
          "updatedAt": "2021-03-08T00:04:59Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #461  - https://github.com/mlswg/mls-protocol/blob/main/draft-ietf-mls-protocol.md#remove",
          "createdAt": "2021-08-10T23:48:02Z",
          "updatedAt": "2021-08-10T23:48:02Z"
        }
      ]
    },
    {
      "number": 468,
      "id": "MDU6SXNzdWU4NzAwOTI3ODM=",
      "title": "Clarify relationship between Ratchet Tree Evolution, Group Creation, and Key Schedule",
      "url": "https://github.com/mlswg/mls-protocol/issues/468",
      "state": "CLOSED",
      "author": "knightcode",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "The terminology used in these sections is different, so that it's unclear if they're descriptions of the same operation with different levels of detail or entirely different operations performed at different times. I come in having read most of the original white paper, so that my intuition is that it's one operation performed against data stored in the tree structure. As such, I'm unclear how the `init_secret`->`epoch_secret` relates to the `leaf_secret` via the \"number of secrets [that] are derived from the epoch secret for different purposes\".\r\n\r\nAlso, The Group Creation section makes no reference to any of these secrets by name. I would kind of expect something called, `init_secret`, to be involved during group creation, but it doesn't seem like that's necessary. \r\n\r\nis `authenticated_data` defined anywhere? Is it application level data to be included as desired?",
      "createdAt": "2021-04-28T15:44:52Z",
      "updatedAt": "2021-12-01T18:22:26Z",
      "closedAt": "2021-12-01T18:22:26Z",
      "comments": [
        {
          "author": "knightcode",
          "authorAssociation": "NONE",
          "body": "Can you add the definition of `commit_secret` definition to [Ratchet Tree Evolution](https://github.com/mlswg/mls-protocol/blob/main/draft-ietf-mls-protocol.md#ratchet-tree-evolution)?",
          "createdAt": "2021-06-04T19:02:31Z",
          "updatedAt": "2021-06-04T19:02:31Z"
        },
        {
          "author": "knightcode",
          "authorAssociation": "NONE",
          "body": "In [Encryption Keys](https://github.com/mlswg/mls-protocol/blob/main/draft-ietf-mls-protocol.md#encryption-keys),\r\nin the diagram copied below, the label, \"secret\", is passed to DeriveTreeSecret(), where in the preceding section, it was either \"application\" or \"handshake\". This is intentional?\r\n\r\n```\r\nratchet_secret_[N]_[j]\r\n      |\r\n      +--> DeriveTreeSecret(., \"nonce\", N, j, AEAD.Nn)\r\n      |    = ratchet_nonce_[N]_[j]\r\n      |\r\n      +--> DeriveTreeSecret(., \"key\", N, j, AEAD.Nk)\r\n      |    = ratchet_key_[N]_[j]\r\n      |\r\n      V\r\nDeriveTreeSecret(., \"secret\", N, j, KDF.Nh)\r\n= ratchet_secret_[N]_[j+1]\r\n```",
          "createdAt": "2021-06-07T23:12:37Z",
          "updatedAt": "2021-06-07T23:12:37Z"
        },
        {
          "author": "knightcode",
          "authorAssociation": "NONE",
          "body": "Could you specifically call out where the authentication tag created by AES-256-GCM is stored? Some implementations will need to find it and pass it in as a param to `open()`.",
          "createdAt": "2021-06-08T21:57:34Z",
          "updatedAt": "2021-06-08T21:57:34Z"
        },
        {
          "author": "knightcode",
          "authorAssociation": "NONE",
          "body": "The group creation and external init parts of the doc each have discussions in two parts. It'd be easier to follow if they were consolidated. I would suggest moving the group creation section up to the other relevant parts and maybe introduce the other concepts in the context of group creation... that's how implementations would start.",
          "createdAt": "2021-06-23T14:03:13Z",
          "updatedAt": "2021-06-23T14:03:13Z"
        },
        {
          "author": "knightcode",
          "authorAssociation": "NONE",
          "body": "I'm not sure why there needs to be two ratchets per leaf node. It seems like they never get ratcheted at the same time, and they both get reset during the same event(s).",
          "createdAt": "2021-06-23T14:04:36Z",
          "updatedAt": "2021-06-23T14:04:36Z"
        },
        {
          "author": "knightcode",
          "authorAssociation": "NONE",
          "body": "It was easier for me to understand the `resolution`  concept as just a kind of depth first search through the sibling's tree, favoring the left child, for a public or private key. If building an update path follows the addition of empty nodes, then for each step up the tree, the sibling's tree is not going to have filled any new key pairs yet, so that conducting a search at that moment is only going to resolve a public key from the previous epoch. ",
          "createdAt": "2021-06-23T15:13:30Z",
          "updatedAt": "2021-06-23T15:13:30Z"
        },
        {
          "author": "knightcode",
          "authorAssociation": "NONE",
          "body": "What does this mean? Is part of the sentence missing?\r\n\r\n```\r\nTruncate the tree by reducing the size of tree until the rightmost non-blank leaf node\r\n```\r\n ",
          "createdAt": "2021-06-24T22:13:44Z",
          "updatedAt": "2021-06-24T22:13:44Z"
        },
        {
          "author": "knightcode",
          "authorAssociation": "NONE",
          "body": "Leaving it to applications to determine how many resumption secrets to maintain creates a problem with ExternalInit's. The external init is predicated entirely on public group state, so that the new member(s) will not have any resumption secrets from prior epochs as determined by the application. If one of those resumption secrets is employed, the group fractures.\r\n\r\nMoreover, I'm not seeing how one resumption_secret alone is enough for a recovery operation... if that's one of its intended uses, which seems to be implied. There's not much to go on in the doc, but it seems to suggest the resumption secret is included in the key derivation schedule as a PSK. But the schedule also requires an init_secret and a commit_secret as inputs, which a recovering node cannot rely on to be in sync with the group.",
          "createdAt": "2021-06-30T14:20:25Z",
          "updatedAt": "2021-06-30T14:20:25Z"
        },
        {
          "author": "knightcode",
          "authorAssociation": "NONE",
          "body": "For members, A, C, and D of a 4 member group, where A performed the additions of B,C, and D and then broadcast a Welcome message to all the others, their respective trees would look like the following after each adds their own private keys locally:\r\n```\r\n         p[3]                  p[3]                   p[3]\r\n        /     \\              /      \\               /     \\\r\n     p[1]       _          p[1]       _          p[1]       _\r\n     /  \\      / \\         /  \\      / \\         /  \\      / \\\r\n    p[A] B    C   D       A    B  p[C]  D       A    B    C p[D]\r\n```\r\n`p[x]` denotes that a public/private key pair resides at node x\r\n\r\nIf node performs an another tree update, e.g. adds another member, when computing the updatePath for node 3, it must select a public key from the subtree rooted at node 5 (the underscore). No key pair has been computed for node 5 yet, so that it would select the public key for node C and proceed. This, however, prevents node D from decrypting the path_secret for node 3 because D does not know the private key for C. If A is to encrypt the path_secret multiple times---each with a different key---what's the protocol? How many copies are enough? Does the number of copies have to grow with the size of the tree?",
          "createdAt": "2021-06-30T16:33:24Z",
          "updatedAt": "2021-06-30T16:33:24Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi @knightcode,\r\n\r\nthanks for raising all these issues. There's an effort under way to give the draft an overhaul from an editorial standpoint. That should help with some of the issues around definitions and structuring/sequence of sections.\r\n\r\nRegarding `DeriveTreeSecret`: `DeriveTreeSecret` is just a function that's used in multiple places and the label changes depending on what kind of secret we're deriving.\r\n\r\nRegarding storage of authentication tags: I'm not sure what you mean by \"store\" here? This sounds like an implementation specific question that the draft won't be able to answer.\r\n\r\nRegarding two ratchets per leaf node: I assume you mean that from a leaf secret we derive a node secret and a path secret. This is to ensure that keys are cryptographically separate, such that they can be used by different cryptographic primitives. Cryptographic assumptions on primitives such as KDFs, authenticated encryption, etc usually assume that the key is only used with that primitive. As a consequence, proving the security of the protocol would likely require non-standard assumptions if one were _not_ to separate keys properly.\r\n\r\nRegarding truncation: The sentence is meant to express that, starting from the rightmost leaf, leaves are removed until the first non-blank leaf is reached.\r\n\r\nRegarding resumptions and ExternalInits: Good catch! That should be added to the section on ExternalInit.\r\n\r\nRecovery through resumption secrets: When creating a group, it can be linked to an existing group through the use of resumption secrets. Linking a new group to an existing group means that the creator follows the normal group creation process, i.e. creating a group and adding other members, sending Welcome messages, etc. However, when adding the new members, the group creator also injects a PSK derived from the resumption secret (from the existing group) into the key schedule. Thus, as per the \"normal\" group creation process, no other shared secrets are needed, excpet the PSK derived from the resumption secret for the step where the members are added.\r\n\r\nRegarding you most recent example: If I understand the scenario correctly, I believe you are not computing the resolution properly. The node sending the update would encrypt the path secret of node 3 to the resolution of the blank node. The resolution of a blank node is computed by taking the resolution of its two children, which in this case are both C _and_ D.\r\n\r\nI hope that answered some of your questions. If you have questions regarding the draft in general, the mailing list `mls@ietf.org` is usually a better place to get answers. Also, if you're working on an implementation, there's a Wire group for discussions regarding implementation issues and interop between the individual implementations. See [here](https://github.com/mlswg/mls-implementations) for the links. We're always happy to see new implementations!\r\n",
          "createdAt": "2021-07-01T06:53:36Z",
          "updatedAt": "2021-07-01T06:53:36Z"
        },
        {
          "author": "knightcode",
          "authorAssociation": "NONE",
          "body": "By \"two ratchets\", I was referring to the secrets derived at the leaves of the secret tree... i.e. the final values computed by `DeriveTreeSecret`. There's one using a label of \"application\" and one using a label of \"handshake\". The former is ratcheted for application messages, and the latter for handshake messages. In the diagram I referenced above, the label switches to \"secret\"... probably from an earlier iteration of the doc. In any case, I don't see a reason to have two secrets here. It's more to maintain for little benefit.\r\n\r\nSimply shifting leaves and then truncating the right side of the tree is sufficient to properly remove any arbitrary leaf from the tree? I guess maybe that works with the resolution computation you described, but that could like unmerge half the leaves between the departing index and the end.\r\n\r\nFor the AES-256-GCM authentication tag, for the `crypto` library in Node.js, the tag is retrieved with a separate call after the cipher is finalized (`cipher.getAuthTag()`), so that the ciphertext and the tag are two pieces of information that need to get formatted into a packet and transmitted. I understand that this is just one algorithm and others may only have the ciphertext. But for the ciphersuites that employ AES-256-GCM, two implementations might format the packets differently and be inoperable with each other. ..or there's already an agreed upon formatting that I don't know about. Moreover, the length of the tag is a configurable param for the algorithm, which should be specified somewhere.\r\n\r\nI get it now that recovery is just group creation using the same group ID with a resumption secret thrown in. I kind of like it being an External Init with the resumption secret thrown in. One message instead of N messages.\r\n\r\nMailing lists are terrible at organizing information (not that I'm doing any better putting all my topics in one Issue).",
          "createdAt": "2021-07-02T15:49:49Z",
          "updatedAt": "2021-07-02T15:49:49Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi @knightcode , finally getting around to addressing these comments.  Sorry it took a bit!\r\n\r\nNotes from a first read-through (before looking at the exchange with @kkohbrok):\r\n\r\n* Terminology between Ratchet Tree Evolution, Group Creation, Key Schedule - I\r\n  think this has been sorted out by some more recent changes.\r\n* Definition of `commit_secret` - This doesn't go in {{ratchet-tree-evolution}},\r\n  it is defined in the commit generation / handling sections\r\n* \"secret\" / \"handshake\" / \"application\" - Yes, this is intentional.  The first\r\n  derivation splits the application and handshake key chains, then both evolve\r\n  via \"secret\" derivation\r\n* GCM authentication tag - We assume the RFC 5116 AEAD interface, which has a\r\n  unitary ciphertext, not a separate ciphertext+tag.  Added a note to clarify.\r\n* Group creation and external init parts each have discussions in two parts -\r\n  Not immediately clear how to address this; will consider in a broader review.\r\n* Two ratchets per leaf node - Assuming you're talking about the `path_secret`\r\n  vs. `node_secret` distinction, this is to assure that each secret is only used\r\n  with one algortihm.  I have added a note to clarify.\r\n* Easier to understand resolution as depth-first search - Added this to the\r\n  description of resolution.\r\n* \"Truncate the tree...\" - Yep, missing part of the sentence. Reworded.\r\n* Resumption secret & ExternalInit - There's no connection between ExternalInit\r\n  and resumption secrets (just `external_pub`), and in any case, the only epoch\r\n  for which an ExternalInit can be constructed is the current one.  Otherwise,\r\n  you're forking history.  You're correct that the resumption secret is not\r\n  sufficient to join a group, and it's not meant to be.  It is only proof of\r\n  prior involvement with the group.\r\n* For members A, C, D, ... - Your representation of the secret knowledge here\r\n  isn't quite right.  C and D wouldn't know p[1], since it's not on their direct\r\n  path.  In your hypothetical, if A or B did an operation, they would encrypt to\r\n  the *resolution* of node 5, that is to both C and D.  This diagram seems\r\n  useful for building intuition, though, so I've added something like it to the\r\n  ratchet tree section.\r\n\r\n========\r\n\r\nNotes on responses to @kkohbrok:\r\n\r\n* The separate application and handshake ratchet to ensure that application and\r\n  handshake messages don't fate-share -- if the application keys are\r\n  compromised, that doesn't compromise the handshake keys.  While this might not\r\n  matter much in practice, I believe it helps with the security analysis.\r\n* Truncation is not how members are removed from the tree.  That's done by\r\n  blanking a member's leaf and parents.  Truncation is just garbage collection.\r\n  If you have a 1000-member group where leaf 1 is blank (starting at zero), and\r\n  the member at leaf 2 removes members at leaves 3-1000, then you'll end up with\r\n  a tree with three leaves (member A, blank, member B), and truncation will\r\n  clear out the now-blank leaves 3-1000 and all their parents.\r\n* Yeah, there's unfortunate divergence in AES-GCM interfaces.  The good news is\r\n  that even if an implementation produces a different layout, as long as you can\r\n  find the tag, you can rearrange things to match the desired layout here\r\n  (ciphertext || tag).\r\n",
          "createdAt": "2021-11-19T22:06:45Z",
          "updatedAt": "2021-11-19T22:06:45Z"
        }
      ]
    },
    {
      "number": 470,
      "id": "MDU6SXNzdWU4ODk4OTE4NjY=",
      "title": "group_context is passed into HPKE's aad instead of info",
      "url": "https://github.com/mlswg/mls-protocol/issues/470",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This came up during a discussion with @raphaelrobert and @franziskuskiefer on an issue discovered by Th\u00e9ophile (https://github.com/openmls/openmls/pull/404).\r\n\r\nI don't think this is a security issue necessarily, as both sender and receiver must agree on the group_context to successfully decrypt. However, I believe it's cleaner to have `group_context` go into the HPKE key derivation rather than the AEAD's aad.",
      "createdAt": "2021-05-12T09:45:27Z",
      "updatedAt": "2021-10-04T17:38:24Z",
      "closedAt": "2021-10-04T17:38:24Z",
      "comments": []
    },
    {
      "number": 472,
      "id": "MDU6SXNzdWU4OTU1MzM3NDE=",
      "title": "Make extensions more powerful",
      "url": "https://github.com/mlswg/mls-protocol/issues/472",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Extensions can currently be set when creating the group, after which they are fixed for the rest of the group's lifetime. Being able to change extensions dynamically, e.g. via a dedicated proposal would make extensions a much more powerful mechanism.\r\n\r\nFor example, there's currently no way to use MLS to make the group agree on arbitrary data/context. Sure, one could create a custom extension, which makes each client include a specific bit of data into the context. However, for that to work, one would have to change the implementation to include that mechanism for that specific bit of data. On the other hand, if one could change extensions on the fly, e.g. via a proposal, one could, for example, store group metadata (or hashes thereof) in an extension and thus achieve agreement, but also change that data from one epoch to the next.\r\n\r\nOf course, it should always be ensured that every type of extension used is supported by every group member.\r\n\r\nOne could also generalize such a proposal to be a GroupConfig proposal, which allows change of Version number or Ciphersuite as well...",
      "createdAt": "2021-05-19T14:41:51Z",
      "updatedAt": "2021-05-20T13:04:20Z",
      "closedAt": "2021-05-20T13:04:20Z",
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing in favor of #473.",
          "createdAt": "2021-05-20T13:04:20Z",
          "updatedAt": "2021-05-20T13:04:20Z"
        }
      ]
    },
    {
      "number": 473,
      "id": "MDU6SXNzdWU4OTY4MDI1MDg=",
      "title": "Extensions",
      "url": "https://github.com/mlswg/mls-protocol/issues/473",
      "state": "CLOSED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "After a thorough review of the current MLS extension system, there are a few questions and we also have a few suggestions for changes.\r\n\r\n#### How we interpret the spec currently:\r\n - The total set of extensions is fixed and cannot be changed during the lifetime of a group.\r\n - The set of extensions that is associated with a group is decided by the group creator.\r\n - All extension types from the set have to be supported by all clients and must therefore be advertised in their capabilities extension.\r\n - The implementation needs to validate the support in 4 instances: When creating a new group, when joining a group, when creating an add proposal, when parsing someone else's add proposal as part of a Commit.\r\n - Key package extensions are simple and well-understood, in that they never leave the KeyPackage and there is group consensus through the tree hash.\r\n - The other kind of extension seems to be called a Group Info Extension (GIE).\r\n - GIEs can come in two flavours: a) they must be included in the group context, b) they must not be included in the group context.\r\n - The ratchet tree extensions is an example of type b).\r\n - GIEs of type a) are essentially just passed from the Adder to the New Joiner, using Welcome messages as an E2EE pipe.\r\n\r\n#### Open questions:\r\n - The spec does not explicitly introduce the notion of a GIE, it is only mentioned in 16.2. Should the spec be more explicit here?\r\n - Should the flavour of a GIE (as described above) be reflected in the `Extension` struct in the spec? E.g. a message type that indicates whether a GIE should be included in the GroupContext (see proposal below).\r\n - Can the content of a GIE be dynamic (i.e. it can change during the lifetime of a group)? The ratchet tree extension seems to validate that assumption, it is a bit unclear if this is true for all kinds of GIE. We should be more explicit in the spec.\r\n - If the content of GIEs is indeed dynamic, should those GIEs always be excluded from the GroupContext? Or optionally? If they are to be included in the GroupContext, how do clients agree on the changes? (See proposal below)\r\n\r\nWe need more guidance regarding extensions in order to keep implementations aligned and capable of interop.\r\n\r\n#### Concrete proposed improvements:\r\n\r\nA first suggestion would be to allow for the creation of extensions that have dynamic content. This would allow them to use MLS to agree on arbitrary data.\r\n\r\nThe requirement would be to make GIEs with dynamic content more robust by introducing a new proposal type to update the content of extensions:\r\n\r\n```c\r\nstruct {\r\n  Extension extension;\r\n} ExtensionUpdate;\r\n```\r\n\r\n\r\nAnother improvement to the current extension system would be to be more clear about the kinds of extensions by introducing a dedicated `MessageType` field for every extension:\r\n\r\n```c\r\nenum {\r\n    reserved(0),\r\n    KeyPackage(1),\r\n    GroupContext(2), // GIEs that are to be included in the group context\r\n    GroupInfo(3), // GIEs that should not be included in the group context, like the ratchet tree extension\r\n    (255)\r\n} MessageType;\r\n\r\nstruct {\r\n    ExtensionId extension_id;\r\n    MessageType message_type;\r\n    opaque extension_data<0..2^16-1>;\r\n} Extension;\r\n```\r\n\r\nThis would allow generic `GroupInfo` extensions, which in turn allow committers of Add proposals to communicate arbitrary data to new group members in a robust fashion.",
      "createdAt": "2021-05-20T13:02:49Z",
      "updatedAt": "2021-10-04T19:47:55Z",
      "closedAt": "2021-10-04T19:47:55Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the analysis here.  To your point about \u201cdynamic GIEs\u201d \u2014 My initial concept here was that the GIEs included in the GroupContext would be fixed for all time.  The ratchet tree extension would not be included in the GroupContext; as you say, it just uses the Welcome for E2E tunneling.\r\n\r\nBoiling this down a bit, it seems like there are a few problems to solve here:\r\n\r\n* Clarifying which extensions in the GroupInfo go into the GroupContext and which are just used for tunneling E2E\r\n* Allowing for updates to the group\u2019s extensions\r\n\r\nFor the former, there's a pretty simple solution available: Just have separate fields in the GroupContext for permanent and ephemeral extensions.\r\n\r\n```\r\nstruct {\r\n  // ...\r\n  Extension group_context_extensions<0..2^32-1>;\r\n  Extension other_extensions<0..2^32-1>;\r\n  // ...\r\n} GroupInfo;\r\n```\r\n\r\nThe joiner processing would then place the `group_context_extensions` into the MLS state / GroupContext, and use/discard the `other_extensions`.  We could also then update the IANA considerations to reflect these additional categories for where an extension can appear.\r\n\r\nFor the latter problem, I think your ExtensionUpdate is about the right approach.  It might be simpler just to have the update proposal provide wholesale replacement to the extensions, so that we don't have to design a merge algorithm.  I'm not totally sure this is worth doing right now, since it seems easy to do as an extension.  But especially if we keep it simple, I'm not strongly opposed.",
          "createdAt": "2021-08-11T00:35:46Z",
          "updatedAt": "2021-08-11T00:35:46Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@kkohbrok @raphaelrobert and I discussed real-time, propose to do the following:\r\n\r\n1. Split out the GroupContext extensions as above\r\n2. Define a new proposal type to update the group's extensions:\r\n\r\n```\r\nstruct {\r\n    Extension new_extensions<0..2^32-1>;\r\n} ExtensionUpdate;\r\n\r\n// Processing:\r\n// group_context.extensions = ext_update.new_extensions;\r\n```",
          "createdAt": "2021-08-12T17:17:58Z",
          "updatedAt": "2021-08-12T17:17:58Z"
        }
      ]
    },
    {
      "number": 482,
      "id": "MDU6SXNzdWU5NzUxMjI3NzI=",
      "title": "Review advisory sections",
      "url": "https://github.com/mlswg/mls-protocol/issues/482",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "The \"Sequencing of State Changes\" and \"Application Messages\" sections date to very early in the document's life, and probably need some updates to reflect current thinking.",
      "createdAt": "2021-08-19T23:17:45Z",
      "updatedAt": "2021-11-30T23:28:29Z",
      "closedAt": "2021-11-30T23:28:29Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing for now, might reopen based on WGLC review.",
          "createdAt": "2021-11-30T23:28:29Z",
          "updatedAt": "2021-11-30T23:28:29Z"
        }
      ]
    },
    {
      "number": 485,
      "id": "I_kwDOBoyH6c48gSlC",
      "title": "Mandatory extension types?",
      "url": "https://github.com/mlswg/mls-protocol/issues/485",
      "state": "CLOSED",
      "author": "rohan-wire",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Many protocols which have an extensibility mechanism have a way to indicate that understanding an extension is mandatory for certain behaviors. For MLS, this would mean having a way to require a member understand an MLS extension before it can join a group. The three extension types defined currently are: \r\n MLS ciphersuites, \r\n MLS extension types, and \r\n MLS credential types. \r\n\r\nOne logical way to add mandatory extensions would be to pick one of these types (the MLS extensions type) and use the high order bit or a specific range to indicate that a member must understand and implement the extension to join a group which uses that extension. The IANA values could be changed as follows:\r\n\r\nValues from 0x8000-0xffff indicate understanding the extension is required\r\n0x7f00 - 0x7fff  Reserved for Private Use (not required)\r\n0xff00 - 0xfff   Reserved for Private Use (required)\r\n\r\nIf a required ciphersuite or credential becomes necessary, a new extension type could be created to add an extension in the KeyPackage or GroupInfo which would be required and would indicate support for the mandatory ciphersuites or credentials.\r\n\r\nIn order to prevent some other entity from adding an MLS client that does not support a mandatory extension, we already have the KeyPackage Client Capabilities, which lists which extensions are supported by the client. \r\n\r\n",
      "createdAt": "2021-10-04T12:09:23Z",
      "updatedAt": "2021-10-05T07:52:19Z",
      "closedAt": "2021-10-05T07:52:18Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Note that though this might seem \"now or never\", I don't think it really\nis.  Consider TLS by way of analogy -- it has no mechanism for specifying\nthat extensions are required.  But if a server gets a ClientHello that is\nmissing some extension that it requires, it can just abort the handshake.\nLikewise in MLS, the member adding a new joiner to the group can examine\nthat joiner's KeyPackage to see if they support the extensions needed for\nthe group.\n\nSo I think you could implement this as a non-mandatory GroupContext\nextension, which would state the extensions required by the group so that\nall members apply the same requirements for new joiners.\n\n--Richard\n\n\nOn Mon, Oct 4, 2021 at 8:09 AM rohan-wire ***@***.***> wrote:\n\n> Many protocols which have an extensibility mechanism have a way to\n> indicate that understanding an extension is mandatory for certain\n> behaviors. For MLS, this would mean having a way to require a member\n> understand an MLS extension before it can join a group. The three extension\n> types defined currently are:\n> MLS ciphersuites,\n> MLS extension types, and\n> MLS credential types.\n>\n> One logical way to add mandatory extensions would be to pick one of these\n> types (the MLS extensions type) and use the high order bit or a specific\n> range to indicate that a member must understand and implement the extension\n> to join a group which uses that extension. The IANA values could be changed\n> as follows:\n>\n> Values from 0x8000-0xffff indicate understanding the extension is required\n> 0x7f00 - 0x7fff Reserved for Private Use (not required)\n> 0xff00 - 0xfff Reserved for Private Use (required)\n>\n> If a required ciphersuite or credential becomes necessary, a new extension\n> type could be created to add an extension in the KeyPackage or GroupInfo\n> which would be required and would indicate support for the mandatory\n> ciphersuites or credentials.\n>\n> In order to prevent some other entity from adding an MLS client that does\n> not support a mandatory extension, we already have the KeyPackage Client\n> Capabilities, which lists which extensions are supported by the client.\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/mlswg/mls-protocol/issues/485>, or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAASOTL4OCSPWHLYHISRUM3UFGKP5ANCNFSM5FJGPVUQ>\n> .\n> Triage notifications on the go with GitHub Mobile for iOS\n> <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675>\n> or Android\n> <https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>.\n>\n>\n",
          "createdAt": "2021-10-04T13:58:07Z",
          "updatedAt": "2021-10-04T13:58:07Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "NONE",
          "body": "While you can implement this \"out-of-band\", that makes it implicit rather than explicit behavior.",
          "createdAt": "2021-10-04T14:41:57Z",
          "updatedAt": "2021-10-04T14:41:57Z"
        },
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed at 20211004 interim, liked this functionality. But, instead of IANA registry use field (or extension) in group context to indicate which extensions are required.\r\n\r\n@rohan-wire to generate PR.",
          "createdAt": "2021-10-04T15:56:18Z",
          "updatedAt": "2021-10-04T15:56:18Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "NONE",
          "body": "Discussed with @bifurcation and incorporated this functionality into PR #489  ",
          "createdAt": "2021-10-05T07:52:18Z",
          "updatedAt": "2021-10-05T07:52:18Z"
        }
      ]
    },
    {
      "number": 486,
      "id": "I_kwDOBoyH6c48g8Pb",
      "title": "Use `(identity, endpoint_id)` tuple instead of leaf indices in Message structs",
      "url": "https://github.com/mlswg/mls-protocol/issues/486",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As suggested in [here](https://github.com/mlswg/mls-protocol/pull/476#issuecomment-919746483), once #476 is merged, we can use `(identity, endpoint_id)` to uniquely address group members instead of leaf indices.\r\n\r\nThis slightly bloats messages, but it also helps abstract away the binary tree representation a little more.",
      "createdAt": "2021-10-04T14:39:53Z",
      "updatedAt": "2021-10-11T19:21:47Z",
      "closedAt": "2021-10-11T19:21:47Z",
      "comments": []
    },
    {
      "number": 493,
      "id": "I_kwDOBoyH6c48qOKi",
      "title": "Key schedule text - figure mismatch",
      "url": "https://github.com/mlswg/mls-protocol/issues/493",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I believe there's a small mismatch between the text and the Key Schedule figure. The text says [here](https://github.com/mlswg/mls-protocol/blob/b7a741e3d2b48252d3f005274d93d2e4212bcf12/draft-ietf-mls-protocol.md#L2648) that if there are no PSK proposals, the `psk_secret` should be a zero-length string, while the Key Schedule figure seems to indicate that it's a string of zeros of length `KDF.n`.",
      "createdAt": "2021-10-06T07:42:07Z",
      "updatedAt": "2021-10-11T19:28:25Z",
      "closedAt": "2021-10-11T19:28:25Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #490 ",
          "createdAt": "2021-10-11T19:28:25Z",
          "updatedAt": "2021-10-11T19:28:25Z"
        }
      ]
    },
    {
      "number": 498,
      "id": "I_kwDOBoyH6c49dYEO",
      "title": "`Ciphersuite` should be part of `PublicGroupStateTbs`",
      "url": "https://github.com/mlswg/mls-protocol/issues/498",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Am I missing something here, or should the ciphersuite really be part of the `PublicGroupStateTbs`? It's part of the `PublicGroupState`, but the way it is right now it doesn't get signed.",
      "createdAt": "2021-10-20T08:14:29Z",
      "updatedAt": "2021-11-19T20:22:47Z",
      "closedAt": "2021-11-19T20:22:47Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, this looks like a copy/paste error.  ",
          "createdAt": "2021-10-20T13:53:27Z",
          "updatedAt": "2021-10-20T13:53:27Z"
        }
      ]
    },
    {
      "number": 499,
      "id": "I_kwDOBoyH6c49eRaO",
      "title": "`typed` struct definition",
      "url": "https://github.com/mlswg/mls-protocol/issues/499",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In many places, we use a `typed` pattern of struct, where we have a type uint, followed by a `select` statement decides the type of the following field based on the preceding type uint. For example the `Credential` struct:\r\n```\r\nstruct {\r\n    CredentialType credential_type;\r\n    select (Credential.credential_type) {\r\n        case basic:\r\n            BasicCredential;\r\n\r\n        case x509:\r\n            Certificate chain<1..2^32-1>;\r\n    };\r\n} Credential;\r\n```\r\nOther examples are `Content`/`ContentType`, `PSKType` in `PreSharedKey`, `Sender`/`SenderType` and `Proposal`/`ProposalType`.\r\n\r\nIn the context of [an attempt at creating a macro for this pattern](https://github.com/RustCrypto/formats/pull/125), @franziskuskiefer suggested that we actually define a generic struct for this similar to the `optional<T>` pattern.\r\n```\r\nstruct {\r\n    T type;\r\n    select(typed<T>.type) {\r\n        T.variant1: \r\n            Variant1 \r\n    }\r\n} typed<T>\r\n```\r\nIt would translate, for example, as follows for `typed<CredentialType>` (although we could then probably rename the enum from `CredentialType` to `Credential`:\r\n```\r\nstruct {\r\n    CredentialType credential_type;\r\n    select typed<CredentialType>.type {\r\n        CredentialType.basic: \r\n            Basic\r\n        ...\r\n    }\r\n} typed<CredentialType>\r\n```\r\nIt doesn't quite match up to what's currently in the spec (`Basic` instead of `BasicCredential`), but this rather naive approach is meant more as a basis for discussion than as a complete proposal. Let me know what you think!",
      "createdAt": "2021-10-20T12:22:51Z",
      "updatedAt": "2021-11-30T23:12:19Z",
      "closedAt": "2021-11-30T23:12:19Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "On the one hand, there is merit to this idea in principle.  For example, we have implemented things like [Credential](https://github.com/cisco/mlspp/blob/main/include/mls/credential.h#L106) and [Proposal](https://github.com/cisco/mlspp/blob/main/include/mls/messages.h#L363) in MLSpp as \"tagged variants\" that [automatically serialize/deserialize in the required form](https://github.com/cisco/mlspp/blob/main/lib/tls_syntax/include/tls/tls_syntax.h#L408).\r\n\r\nOn the other hand, I'm not sure how much there is to be gained from it in the spec.  After all, the \"type + `select`\" framework already captures the intended semantic here, as long as it's used properly.  And as you can see in the MLSpp code, it's kind of messy even when you have language support for variants -- behold the [TEMPLATE MAGIC!](https://github.com/cisco/mlspp/blob/main/lib/tls_syntax/include/tls/tls_syntax.h#L430) to iterate through variant case and match them with their tags.\r\n\r\nIt seems like the best we could do here is provide some syntax that would codify this particular usage of the `select` mechanism, and maybe let you combine it with the enum definition.\r\n\r\n```\r\nstruct {\r\n    WireFormat wire_format;\r\n    opaque group_id<0..255>;\r\n    uint64 epoch;\r\n    Sender sender;\r\n    opaque authenticated_data<0..2^32-1>;\r\n\r\n    variant (ContentType) {\r\n        case application:\r\n          opaque application_data<0..2^32-1>;\r\n\r\n        case proposal:\r\n          Proposal proposal;\r\n\r\n        case commit:\r\n          Commit commit;\r\n \r\n        ...(255)\r\n    }\r\n\r\n    opaque signature<0..2^16-1>;\r\n    optional<MAC> confirmation_tag;\r\n    optional<MAC> membership_tag;\r\n} MLSPlaintext;\r\n```\r\n\r\nNet/net, though, this seems like a lot of invention for not a lot of benefit.",
          "createdAt": "2021-10-20T18:57:39Z",
          "updatedAt": "2021-10-20T18:57:39Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We're already somewhat formally extending the TLS serialization format with the `option` type, so why not continue with this. I think it would be useful in the spec. It would be useful for implementers to have a guideline for their template magic. But it might also benefit others in the same way that we are benefiting from the TLS spec.",
          "createdAt": "2021-10-21T11:12:56Z",
          "updatedAt": "2021-10-21T11:12:56Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not worried about perturbing the TLS serialization format.  I just don't think there's much savings to be had, given that you need to specify the mapping of enum values to types anyway.  ISTM the `variant` syntax I proposed above is about as compact/elegant as you could make it, so I would propose we either do that or just close this issue with no action.",
          "createdAt": "2021-11-19T20:48:42Z",
          "updatedAt": "2021-11-19T20:48:42Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sounds good to me. An alternative would be to put this in the implementation-considerations doc. It currently doesn't have any content, so this might be a good first contribution.",
          "createdAt": "2021-11-23T14:02:14Z",
          "updatedAt": "2021-11-23T14:02:14Z"
        },
        {
          "author": "franziskuskiefer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I suggest to move this to the implementation-considerations doc.",
          "createdAt": "2021-11-24T07:53:13Z",
          "updatedAt": "2021-11-24T07:53:13Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, sounds like we have consensus to move to implementation considerations, so I'm closing this.  \r\n\r\n@kkohbrok \u2014 It might be good to start up a repo for that document, so that we don't lose things like this.  The other topic that comes to mind is the array-based tree representation (cf. #507).",
          "createdAt": "2021-11-30T23:12:19Z",
          "updatedAt": "2021-11-30T23:12:19Z"
        }
      ]
    },
    {
      "number": 500,
      "id": "I_kwDOBoyH6c49eoQ2",
      "title": "Update HPKE requirement to latest",
      "url": "https://github.com/mlswg/mls-protocol/issues/500",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "MLS draft-12 still references draft-08 of HPKE, which is now on draft-12.  We should update to the final version of HPKE before finalizing MLS.",
      "createdAt": "2021-10-20T13:51:51Z",
      "updatedAt": "2021-11-30T22:51:50Z",
      "closedAt": "2021-11-30T22:51:50Z",
      "comments": []
    },
    {
      "number": 502,
      "id": "I_kwDOBoyH6c4-Rwzj",
      "title": "Consolidate resumption PSK definitions",
      "url": "https://github.com/mlswg/mls-protocol/issues/502",
      "state": "OPEN",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Right now, we treat the re-init and branch PSK cases as distinct cases, as opposed to just having a general \"export PSK from one group+epoch, insert it into another\" function.  What I would call a \"resumption PSK\", following TLS.   Even though we have the distinction, the content of the PSK itself is the same: (group ID, epoch, resumption secret).  So the only difference is that the PreSharedKeyID has a bit that signals the intent of injecting this resumption PSK.\r\n\r\nDo we really need that bit?  If there's not a compelling need, it would streamline the API and allow for more flexibility if we just had the notion of a resumption PSK.",
      "createdAt": "2021-11-04T14:47:01Z",
      "updatedAt": "2021-12-17T06:15:36Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Key separation by domain is usually a good idea. If we derive a key, the purpose should be \"baked in\", i.e. included in the derivation to avoid potential collision across protocol functionalities/domains. I'm not sure I understand how that makes the API more complex. If it's really bad, we should consider the trade-off, but if it's not too much trouble, I'd prefer we keep the key separation. Can you elaborate a bit on the API complexity?",
          "createdAt": "2021-11-15T08:28:22Z",
          "updatedAt": "2021-11-15T08:28:22Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm mostly concerned about being too specific in the \"purpose\" definitions, and thus making applications make a choice that doesn't really make sense.  For example, take the obvious case of TLS-like resumption, where I take a key from the last epoch of a prior instance of the group and use it as input to a new appearance of the group.  Is that a re-init?  There wasn't necessarily a ReInit proposal.  Is it a branch?  \"Branch\" isn't even defined in the spec.  Better to just talk about \"resumption\" as the general act of exporting a secret from one group and inserting it into another.",
          "createdAt": "2021-11-15T16:24:44Z",
          "updatedAt": "2021-11-15T16:24:44Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The scenarios you describe seem to indicate problems in the spec that don't have anything to do with the derivation of the resumption secret. If you want to enable re-init secrets without a proposal, that's fine and we can define in the spec which key to use for that purpose (probably the re-init key). Similarly, if branch isn't well defined in  the spec, we should probably define it better. In the end, for everything else that you want to do that's not (properly) defined in the spec, you can just use an exporter secret. I don't see that weakening the domain separation of the re-init and branch key derivation is the right way to solve these problems. Is the code complexity that bad?",
          "createdAt": "2021-11-16T13:54:15Z",
          "updatedAt": "2021-11-16T13:54:15Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "We could go off and try to define all the possible uses of a resumption PSK, but (a) that's a lot more work, (b) it seems unlikely to succeed, (c) even if you do succeed, you'll end up with a more complicated API for applications (bc N names for the same technical act) and (d) it's not clear to me what the benefit is.\r\n\r\nWhen you talk about domain separation here, what is the failure case that this prevents? ",
          "createdAt": "2021-11-16T15:20:46Z",
          "updatedAt": "2021-11-16T15:20:46Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What we're trying to prevent is that participants end up with the same keys after executing a different part/functionality of the protocol. If party A thinks, they are doing a branch, while party B thinks they're doing a Re-Init and they end up with the same key, then that's bad. If an implementer wants to do proprietary things, i.e. things that are not described in the spec, they have to use an exporter key and make sure their keys are properly separated.",
          "createdAt": "2021-12-01T06:56:36Z",
          "updatedAt": "2021-12-01T06:56:36Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "It depends on what you mean by a \"different functionality of the protocol\".  The only difference between the branch and reinit cases is that in the reinit case, you quit using the old group.  You could also imagine injecting a resumption PSK into an independent group with its own history, whose membership overlaps with the group from which the PSK was drawn.  Is the functionality \"linking one group/epoch to a prior group/epoch\" or is it \"reinit / branch / ...\"?  The former seems more at the right level of granularity to me, and leads to the approach here and in #518.\r\n\r\nIf you're really hard over here, how about a compromise: Unify the syntax, but add a `usage` distinguisher alongside the group ID and epoch, which has specified values for the branch and reinit cases, and which the application MAY set for other cases.\r\n\r\n```\r\nenum {\r\n  unspecified(0),\r\n  branch(1),\r\n  reinit(2),\r\n  (255)\r\n} PSKUsage;\r\n\r\n// ...\r\n\r\n    case resumption:\r\n      PSKUsage usage;\r\n      opaque psk_group_id<0..255>;\r\n      uint64 psk_epoch;\r\n```",
          "createdAt": "2021-12-01T13:43:20Z",
          "updatedAt": "2021-12-01T13:43:20Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I see where you're coming from and if you're convinced it is the more useful approach, we can make the trade-off and go with #518 (although we might as well rename the key from \"resumption\" to something like \"group-link\" or something). \r\n\r\nHowever, I do want to note that we have a trade-off here. Previously, designating a PSK \"branch\" or \"re-init\" signaled intent on the side of the sender and arriving at the same PSK meant agreement on said intent. For example, using a re-init key would imply that the new group is meant to replace the old group. As far as I understand that is no longer the case with #518.",
          "createdAt": "2021-12-01T14:13:05Z",
          "updatedAt": "2021-12-01T14:13:05Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I understand the concern from a cryptographic standpoint, it's nice to have a type that indicates that the group should be shut down.\r\nFrom an engineering perspective, this all feels pretty vague. It's not clear at all how exactly a group will be shut down and a new one will be created, the protocol doesn't give any specific guidance. I don't think this is a huge concern, as long as we don't paint ourselves in a corner when we want to upgrade groups to newer MLS versions in the future.",
          "createdAt": "2021-12-01T15:02:06Z",
          "updatedAt": "2021-12-01T15:02:06Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Even if we want to have everyone agree that the group should be shut down, the ReInit proposal provides that.  Committing the ReInit puts it in the transcript, which means everyone agrees on it.  So everyone who exports a PSK from that epoch should know it's a \"dead epoch\".  In fact, the `branch` vs. `reinit` distinction seems duplicative here, since you shouldn't be able to get a `reinit` PSK from a \"live\" epoch or a `branch` PSK from a dead one.  `branch` iff live; `reinit` iff dead.\r\n\r\nNow, there may be other sub-cases within live or dead; as noted, not all resumption PSK cases map clearly to `branch` or `reinit`.  But it seems premature to put in stub functionality without some taxonomy and requirements.\r\n\r\nI would propose we do #518 for now, and if there turns out to be a need to be PSK use cases that really need segregating, it should be straightforward extension to add another PSKType.",
          "createdAt": "2021-12-06T18:47:09Z",
          "updatedAt": "2021-12-06T18:47:09Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fair enough. I see that the trade-off is probably ok. I'd be ok with merging #518.\r\n\r\nThe proposal should indeed ensure that the streams don't get crossed, so that all that remains would be ease of provability at that point. I still feel uncomfortable about not properly separating keys, though.\r\n\r\nRegarding the last two arguments:\r\n- the \"for now\" solution is a bit moot, since with the WGLC at hand, it's almost certainly not going to change until then\r\n- the extension argument goes the other way as well, as you could just as easily have an extension that implements #518 and gets rid of the need for the distinction between resumption PSKs. If anything, we should opt to be conservative in the spec and allow users to loosen the key separation via an extension at their own risk.",
          "createdAt": "2021-12-07T07:23:01Z",
          "updatedAt": "2021-12-07T07:23:01Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I understand the concern from a cryptographic standpoint, it's nice to have a type that indicates that the group should be shut down. From an engineering perspective, this all feels pretty vague. It's not clear at all how exactly a group will be shut down and a new one will be created, the protocol doesn't give any specific guidance. I don't think this is a huge concern, as long as we don't paint ourselves in a corner when we want to upgrade groups to newer MLS versions in the future.\r\n\r\nI understand that it's unclear how the linking of groups is going to take place in a practical setting, but I don't see that that's an argument to weaken the cryptographic basis of the mechanism. If we don't figure out how to do it in practice, then that's fine, as we can just ignore that part of the protocol. If we do, however, we will want to get proper security guarantees whenever we link two groups in this way.\r\n\r\nAgain, I think #518 is ok. But it's because we probably get good enough guarentees and not because the whole mechanism is a secondary concern due to there being unsolved higher level engineering challenges.",
          "createdAt": "2021-12-07T07:34:22Z",
          "updatedAt": "2021-12-07T07:34:22Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I have recently implemented some of this to get a better feel for it. While we already knew the \"reinit\" case was quite underspecified, I now also realized that there might be another issue with it: A member can shut down a group before a new one is created and there is no way to force the creation of the new group within the protocol. I think it would be safer to first create a new group (with whatever new parameters) and to tear down the old one in that process. Since this is too complex for the protocol it should be solved at the application layer. In other words, I think #518 is indeed fine.",
          "createdAt": "2021-12-09T23:00:03Z",
          "updatedAt": "2021-12-09T23:00:03Z"
        },
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Commenting on #518 here, to keep discussion from splitting to the PR.\r\n\r\nThere are a few issues here that could use clarify, and some confusion in the interpretation of the proposals.\r\n\r\nFirst - as @kkohbrok pointed out, if anything is unclear/underspecified, then that should be clarified and cleaned up vs. removal as the default. From the confusion above, it is clear that some pieces are not sufficiently specified.\r\n\r\nSecond - There is a core distinction between how PSKs are used in MLS vs. TLS that we need to be careful of. In TLS, these are used strictly for the same _two_ members communicating again after a finished session. It is not used again within the same session nor outside of the protocol (exporter keys are for that). Namely, the uses are:\r\n\r\n1. Group-internal use (resumption by an identical member set of the two parties)\r\n \r\nIn MLS, these assumptions change by the very fact that the group may have more than 2 members. For the protocol-external case we have exporter keys as well. For PSK use, we have the following:\r\n\r\n1. Group-internal use (resumption by an identical member set)\r\n2. Subgroup-internal use (resumption by a proper subset of members)\r\n3. Session-internal use (since continuous KE implies that keying material may be injected)\r\n\r\nWhile the session-internal use is not the focus of this discussion, it has been previously (i.e. proving knowledge of prior group state). This contrasts against TLS were the handshake takes place only once\r\n\r\nPoint 2 is notable in that it is impossible for a proper subset of TLS session members to use session information in a separate session (i.e. that would imply only one communication party with no partner). In MLS, this is possible, and we need to be careful about mis-aligning TLS for precedent. To avoid potential forks, etc., and clarity of key source, any group-subset PSK use really ought to be denoted (currently a 'branch'). @kkohbrok is correct that there could be subtle attacks on this if key use is not properly separated.\r\n\r\n\r\nIn addition to the above there seems to be confusion on what resumption is linked to (this is consequently something that needs more clarity in the spec.). To be precise in alignment of terms, using a PSK in TLS for communication in a new session is aligned to using a PSK in MLS for a new group, i.e. it being a continuous session. Thus we need to align discussion here between \"alive\" and \"dead\" sessions in TLS to \"alive\" and \"dead\" groups in MLS - not epochs. We can get a reinit PSK from a live group, i.e. if a member wants to force a restart for any reason and instantiates a new group with the reinit secret. This signals to all members joining that group that the prior group should be terminated and not considered secure/alive after the point of reinit use. It is an edge case, but possible. Similarly and more commonly, we could get a branch PSK from a dead group, i.e. if a new (sub-)group wants members to prove knowledge from some prior connection. Thus it follows that we can branch from both \"alive\" and \"dead\" groups. This may be helpful in terms of authentication.\r\n\r\nI am favorable to @bifurcation 's PSKUsage suggestion, i.e. that if there are other desired uses apart from the above cases the application can provide for those. The \"bleeding\" of key separation across different uses is something that is concerning, and should involve closer scrutiny before inclusion in the specification. If anything, more separation is safer at this stage, vs consolidation.\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2021-12-10T22:25:27Z",
          "updatedAt": "2021-12-10T22:25:27Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@br-hale Good point about the differences from the two-party case.  I think your taxonomy is not quite complete, though. You could also imagine cases where the epoch into which the resumption PSK is injected has members that were not in the group in the epoch in which it was extracted (and these members were provided the PSK some other way).  For instance, in the session-internal case where there have been some Adds in the meantime.\r\n\r\nTo try to factor this a little differently, it seems like you have at least three independent columns in the truth table here comparing the extraction epoch to the injection epoch:\r\n\r\n* Same group or different group (\"group\" is the term that matches TLS \"session\"; linear sequence of epochs)\r\n* Some members have been removed\r\n* Some members have been added\r\n\r\nSo you have at least 8 cases to cover to start with assuming you care about both of those axes (same/different group and membership).\r\n\r\nIt's not clear to me why those are the two axes that one cares about.  On the one hand, why is it not important to distinguish ciphersuite changes as well, or changes in extensions?  On the other hand, why do we need to agree on membership changes here, given that the key schedule already confirms that we agree on the membership?  Basically, I don't understand (a) what cases need to be distinguished, (b) why do these cases need to be distinguished, and (c) why the required separation properties aren't provided by some other mechanism already.\r\n\r\nI would also note that you don't get the benefits of key separation unless the recipients know how to verify that the usage is right for the injection context. (Otherwise, a malicious PSK sender can send the wrong value.)  For the same/different group, that's easy enough to do based on key schedule continuity.  But membership is problematic.  For example, if you're changing the ciphersuite between extraction and injection, then all of the KeyPackages and Credentials will be different -- what do you compare to verify equality?\r\n\r\nI can update #518 to add PSKUsage, but the cases we put there need to at least be enforceable, and ideally fit into some principled taxonomy (even if all the cases in the taxonomy aren't enforceable).",
          "createdAt": "2021-12-14T15:38:07Z",
          "updatedAt": "2021-12-14T15:38:07Z"
        },
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For the record, distinguishing on ciphersuite changes was brought up earlier in the WG - I am in the support if bringing it back on the discussion table is an option...\r\nSeparately though, for most other changes during the lifespan of a group, proposals basically perform a similar action for distinguishing between keys and separating changes from epoch to epoch. The difference with the PSK is there is no \"one way\" to interpret a PSK's use (as compared to e.g. a ciphersuite change). This also means that it can be more challenging to provably separate out misuse. \r\n[BTW: I am assuming in this discussion you mean ciphersuite change in the context of the listed components, since reinit is actually used for ciphersuite key changes per line 1598.]\r\n\r\nYou are quite correct that there is a group-external use, i.e. the \"different group\" case. However, anything outside of the group/session is an external/exporter key use. Namely, the MLS protocol spec is about a single session and anything that is used in other groups/sessions is an external key (similar to TLS export from session). The distinction between PSK usage and external/exporter keys (whether the latter is used for another application or injected into a different group entirely) is that PSK use is within the analysis bounds of the given session. To this point, there is a gray area on item 2 (subgroup-internal use / resumption by a proper subset of members). This is probably the only one I could see an argument for also pushing as an exporter key use. \r\n\r\nThe issue of some members added between PSK usage is really reducible to two cases: a) a member was already in the set and the PSK use appears as item 1 or 3 (group-internal use or session-internal use) or b) a member was added and the PSK offers no security beyond that of an exporter key inject. The potential value proposition is for existing members, there is no loss for a new member, and the it is better to offer the value as possible than to deny it based on the weakest link.\r\n\r\nThe issue of some members being removed between PSK usage is similarly reducible. If the ejected member does not have the current group state then knowing a PSK should not provide value. It is similar to knowing an exporter key but having no place to export it into. The goal of PSK usage is to strengthen an existent system vs. being the sole point of security for that. If our KDF is done correctly, then combing current group state and the PSK will not be problematic (former unknown but latter known to the ejected member).\r\n\r\n",
          "createdAt": "2021-12-15T02:46:00Z",
          "updatedAt": "2021-12-15T02:46:00Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "So @kkohbrok and I had some offline discussion about this, and it led me to the conclusion that what I'm really grumpy about is a need for more clarity in the branch and reinit definitions.  We don't need a full taxonomy of uses if (a) we can say \"use this PSK usage for this specific protocol feature\", and (b) we have some escape hatch that allows for usages of resumption PSKs outside those specific protocol features.\r\n\r\nI have filed #525 reflecting this theory.  Hopefully folks find it more agreeable.",
          "createdAt": "2021-12-15T15:45:41Z",
          "updatedAt": "2021-12-15T15:45:41Z"
        },
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That seems like a well-reasoned solution. ",
          "createdAt": "2021-12-17T06:15:35Z",
          "updatedAt": "2021-12-17T06:15:35Z"
        }
      ]
    },
    {
      "number": 503,
      "id": "I_kwDOBoyH6c4-p7DW",
      "title": "Ciphersuite Addition",
      "url": "https://github.com/mlswg/mls-protocol/issues/503",
      "state": "CLOSED",
      "author": "br-hale",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I suggest that we consider including a ciphersuite that enables AES256 GCM with SHA384 and that for signatures ECDSA with P-384 (and SHA-384) is also permitted. The NSA restricts commercial applications to certain algorithms for applications that are used in or in coordination with the U.S. federal government and, from a general availability perspective, adding this could expand protocol use potential. ",
      "createdAt": "2021-11-11T16:54:53Z",
      "updatedAt": "2021-12-01T18:22:10Z",
      "closedAt": "2021-12-01T18:22:10Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I presume you're thinking of [Suite B](https://apps.nsa.gov/iaarchive/programs/iad-initiatives/cnsa-suite.cfm) here?  I realize that the table specifies P-384 and SHA-384; is it your understanding that it forbids using bigger curves/hashes?",
          "createdAt": "2021-11-16T22:48:20Z",
          "updatedAt": "2021-11-16T22:48:20Z"
        },
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Both Suite B and alignment to the [Commercial Capability Packages](https://www.nsa.gov/Resources/Commercial-Solutions-for-Classified-Program/Capability-Packages/#data-at-rest). The other options currently in the spec, size accounted for, do not align to requirements.",
          "createdAt": "2021-11-17T22:27:12Z",
          "updatedAt": "2021-11-17T22:27:12Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "You didn't answer my question about forbidding the use of bigger curves/hashes.  Would the cases you're interested in be covered by the AES-256 / SHA-512 / P-521 suite?",
          "createdAt": "2021-11-19T20:34:27Z",
          "updatedAt": "2021-11-19T20:34:27Z"
        }
      ]
    },
    {
      "number": 504,
      "id": "I_kwDOBoyH6c4-tHWM",
      "title": "KeyPackage ID vs KeyPackage Identifier",
      "url": "https://github.com/mlswg/mls-protocol/issues/504",
      "state": "CLOSED",
      "author": "franziskuskiefer",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "There's a KeyPackageID ( 7.1. Key Package IDs ) and a KeyPackage Identifiers ( 7.4. KeyPackage Identifiers ) right now.\r\nThis is pretty confusing and probably not necessary. \r\n\r\nAs far as I can tell the only difference is that the KeyPackageID has to be unique within a group. If we add this restriction to the KeyPacakge Identifier, for example by adding the key package hash, we could get rid of the KeyPackageID and the confusion.",
      "createdAt": "2021-11-12T14:19:50Z",
      "updatedAt": "2021-12-01T18:21:19Z",
      "closedAt": "2021-12-01T18:21:19Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "IMO there is a useful distinction here.  The KeyPackage identifier extension is application provided, and can contain something more / differently useful than just a hash.\r\n\r\nIn #510 I renamed KeyPackageID to KeyPackageRef, which should help?",
          "createdAt": "2021-11-16T22:46:16Z",
          "updatedAt": "2021-11-16T22:46:16Z"
        },
        {
          "author": "franziskuskiefer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fair enough. The `KeyPackageRef` description is certainly better than the `KeyPackageID` and avoids confusion.",
          "createdAt": "2021-11-17T07:58:51Z",
          "updatedAt": "2021-11-17T07:58:51Z"
        }
      ]
    },
    {
      "number": 505,
      "id": "I_kwDOBoyH6c4-ukfi",
      "title": "Add is unnecessary in external Commit",
      "url": "https://github.com/mlswg/mls-protocol/issues/505",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "When a new joiner sends an external Commit, within the current structure, they have to generate and send **two** KeyPackages:  First in an Add proposal, and second in `Commit.path.leaf_key_package`.  Obviously, this is wasteful, since the second immediately overwrites the first.  It also complicates receiver processing, since the receiver has to find where the appropriate Add happened so that it knows the sender's index in the new tree, so that it knows how to apply the update path in the Commit.\r\n\r\nWe should remove the requirement for an Add commit in an external Commit, and instead assign the new member the leftmost free slot after all proposals have been applied, then apply the commit from there.",
      "createdAt": "2021-11-12T20:45:00Z",
      "updatedAt": "2021-12-01T18:21:52Z",
      "closedAt": "2021-12-01T18:21:52Z",
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I agree that the key package in the Add proposal is redundant.\r\nI'm not so sure it will simplify implementations so much, because key packages from the update path of a Commit are usually treated like Update proposals (e.g. the constraint that the identity must be the same between the old and new credential).\r\nTl;DR: I agree with the change, but I want to raise awareness about issues this introduces.",
          "createdAt": "2021-11-20T11:46:02Z",
          "updatedAt": "2021-11-20T11:46:02Z"
        }
      ]
    },
    {
      "number": 506,
      "id": "I_kwDOBoyH6c4-u3z_",
      "title": "Use smaller, fixed-size hash-based identifiers",
      "url": "https://github.com/mlswg/mls-protocol/issues/506",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Right now, we use hash-based identifiers to reference KeyPackages (e.g., in KeyPackageID) and Proposals (ProposalOrRef).  To avoid truncating hashes, we use full-sized hashes, which are (a) much larger than necessary and (b) vary in size depend on the ciphersuite.\r\n\r\nWe should consider moving toward hash-identifiers that are of a fixed size just long enough to make collisions negligible (say 128 bits, like a UUID).  A rough proposal:\r\n\r\n```\r\nopaque HashIdentifier[16];\r\n\r\nMakeHash(value) = KDF.expand(KDF.extract(\"\", value), \"MLS 1.0 id\", 16)\r\n```",
      "createdAt": "2021-11-12T23:22:06Z",
      "updatedAt": "2021-12-01T18:21:19Z",
      "closedAt": "2021-12-01T18:21:19Z",
      "comments": []
    },
    {
      "number": 516,
      "id": "I_kwDOBoyH6c4_YcyV",
      "title": "Discard pending Update proposals for the sender if a `path` is included",
      "url": "https://github.com/mlswg/mls-protocol/issues/516",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Any Update proposal for the sender is redundant if the Commit includes a `path`.",
      "createdAt": "2021-11-25T09:59:49Z",
      "updatedAt": "2021-12-01T18:13:54Z",
      "closedAt": "2021-12-01T18:13:54Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "This is true, but they're also harmless, since the information in the `path` will overwrite all of their effects.\r\n\r\nNote that:\r\n* A requirement to this effect would only be binding on a committer.  The receiver of a Commit MUST process all of the referenced proposals, as prescribed in the Commit.\r\n* A `path` is required if a Commit covers Updates or Removes; if a Commit covers a self-Update, then it must have a `path`.   So there's no reasn to condition on \"if a `path` is included\".\r\n\r\nThis seems fine for some advisory text, but not an absolute prohibition.",
          "createdAt": "2021-11-30T23:26:54Z",
          "updatedAt": "2021-11-30T23:26:54Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The way I read Section 11.2 is that the receiver should verify that the committer has followed the rules, e.g. that the commit contains all valid proposals, etc., even if that is not explicit in the list of things the receiver of a commit should do. So any requirement on the committer would also affect the receiver. So if we mandate that a committer can't include self-updates if the path is populated, then it would be implicit that the receiver checks that the committer actually followed the rules when processing a commit.\r\n\r\nI'm not sure I understand your second point. My reasoning would be that if a committer wants to do an update, they would just include a path rather than an update proposal, which is redundant anyway.",
          "createdAt": "2021-12-01T06:47:57Z",
          "updatedAt": "2021-12-01T06:47:57Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry @kkohbrok, I missed that there was still conversation going on here before merging #517.\r\n\r\nOn the latter point: All I'm saying is that there is no case where there is both (a) a self-update and (b) no `path`.  So you're always in the bad scenario :)\r\n\r\nIn our Wire chat, you made a good point that repeated proposals for the same leaf are invalid, and self-Updates are effectively repeats of the `path`.  Reopening, will  file a fresh PR to adjust the text.",
          "createdAt": "2021-12-01T14:58:19Z",
          "updatedAt": "2021-12-01T14:58:19Z"
        }
      ]
    },
    {
      "number": 528,
      "id": "I_kwDOBoyH6c5Ajrn9",
      "title": "Include `context` in `MLSPlaintextTBS` for sender_type `NewMember`",
      "url": "https://github.com/mlswg/mls-protocol/issues/528",
      "state": "OPEN",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "From what I can see, there is no reason not to sign the context in the case of an external init. I'm not sure why it got taken out, but while implementing external inits, verification went through even when including the context.",
      "createdAt": "2021-12-17T10:11:11Z",
      "updatedAt": "2021-12-17T10:11:11Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 530,
      "id": "I_kwDOBoyH6c5Aj4q4",
      "title": "Require uniqueness of RatchetTreeExtensions in GroupInfo",
      "url": "https://github.com/mlswg/mls-protocol/issues/530",
      "state": "OPEN",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "A GroupInfo (or a PublicGroupState) should only ever contain one RatchetTreeExtension. Either that or it should be specified what happens if there is more than one.",
      "createdAt": "2021-12-17T11:09:22Z",
      "updatedAt": "2021-12-17T11:54:58Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 531,
      "id": "I_kwDOBoyH6c5Ak7dL",
      "title": "MLS version is used inconsistently in strings",
      "url": "https://github.com/mlswg/mls-protocol/issues/531",
      "state": "OPEN",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Both \"mls10\" and \"MLS 1.0\" are used. I'd go for \"mls10\" everywhere.",
      "createdAt": "2021-12-17T16:26:39Z",
      "updatedAt": "2021-12-17T16:26:39Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "MDExOlB1bGxSZXF1ZXN0MTUxMjI4OTAz",
      "title": "Add a document skeleton",
      "url": "https://github.com/mlswg/mls-protocol/pull/1",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2017-11-07T21:14:13Z",
      "updatedAt": "2019-12-17T10:09:30Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "14ac4b54880589153c6f152d846f7038c84a6ced",
      "headRepository": null,
      "headRefName": "skeleton",
      "headRefOid": "ba0bcf9369237ba1e2db13f645bb9be722537992",
      "closedAt": "2017-11-07T21:14:21Z",
      "mergedAt": "2017-11-07T21:14:21Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "53fc5e6d289a3c69fb7c6a9cd9478a28298c2101"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 2,
      "id": "MDExOlB1bGxSZXF1ZXN0MTUxMjM4NTg4",
      "title": "Braindump an introduction",
      "url": "https://github.com/mlswg/mls-protocol/pull/2",
      "state": "MERGED",
      "author": "katrielalex",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Also add myself as an author, and compensate for emacs's proclivities.",
      "createdAt": "2017-11-07T21:57:38Z",
      "updatedAt": "2019-12-17T10:09:24Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "53fc5e6d289a3c69fb7c6a9cd9478a28298c2101",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "36fd171fe3c6e066b446184b60618e9bf5e7d607",
      "closedAt": "2017-11-07T21:57:56Z",
      "mergedAt": "2017-11-07T21:57:56Z",
      "mergedBy": "katrielalex",
      "mergeCommit": {
        "oid": "7ce36ea1ce18360af81fc64525ff44b2cecb8ec2"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 3,
      "id": "MDExOlB1bGxSZXF1ZXN0MTUxMjM5OTY0",
      "title": "A bunch of TLS syntax and diagrams",
      "url": "https://github.com/mlswg/mls-protocol/pull/3",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2017-11-07T22:03:41Z",
      "updatedAt": "2019-12-17T10:09:20Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "7ce36ea1ce18360af81fc64525ff44b2cecb8ec2",
      "headRepository": null,
      "headRefName": "protocol",
      "headRefOid": "57bd1360c5bc2caac40aafe40e24c904e4635c9f",
      "closedAt": "2017-11-07T22:03:49Z",
      "mergedAt": "2017-11-07T22:03:49Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "b88d812550d80b269daf825dc56dc5211c7a29a3"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 4,
      "id": "MDExOlB1bGxSZXF1ZXN0MTUxMjQxOTk0",
      "title": "Add a brief description of ART and root key computation",
      "url": "https://github.com/mlswg/mls-protocol/pull/4",
      "state": "MERGED",
      "author": "jmillican",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2017-11-07T22:13:30Z",
      "updatedAt": "2019-12-17T10:09:16Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "b88d812550d80b269daf825dc56dc5211c7a29a3",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "art-description",
      "headRefOid": "05e30b1c244fa078a7eb2fff4d59e64ca609b02b",
      "closedAt": "2017-11-07T22:17:16Z",
      "mergedAt": "2017-11-07T22:17:16Z",
      "mergedBy": "jmillican",
      "mergeCommit": {
        "oid": "8bdeb004d86038cdef6a9c805328d45b9b64ec63"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 5,
      "id": "MDExOlB1bGxSZXF1ZXN0MTUxMjQ5NTU4",
      "title": "Briefly outline leaf updates",
      "url": "https://github.com/mlswg/mls-protocol/pull/5",
      "state": "MERGED",
      "author": "jmillican",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2017-11-07T22:51:39Z",
      "updatedAt": "2019-12-17T10:09:11Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "8bdeb004d86038cdef6a9c805328d45b9b64ec63",
      "headRepository": null,
      "headRefName": "leaf_key",
      "headRefOid": "7900f0a007f4262f324f416bfc9087e95c18a775",
      "closedAt": "2017-11-07T22:51:46Z",
      "mergedAt": "2017-11-07T22:51:45Z",
      "mergedBy": "jmillican",
      "mergeCommit": {
        "oid": "7b69093b7e8980d8e713554c18debf677bfc40b9"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 6,
      "id": "MDExOlB1bGxSZXF1ZXN0MTUxMjYyMDAz",
      "title": "Some prose",
      "url": "https://github.com/mlswg/mls-protocol/pull/6",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2017-11-08T00:09:34Z",
      "updatedAt": "2019-12-17T10:09:54Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "7b69093b7e8980d8e713554c18debf677bfc40b9",
      "headRepository": null,
      "headRefName": "prose",
      "headRefOid": "bc1a822950c4abae18c5e9bfb32a31b2932618c3",
      "closedAt": "2017-11-08T00:09:40Z",
      "mergedAt": "2017-11-08T00:09:40Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "63c315f135d4b4d14e953cc35825f64d145f8f30"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 8,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY0OTE5ODI2",
      "title": "State change sequencing / Message protection",
      "url": "https://github.com/mlswg/mls-protocol/pull/8",
      "state": "MERGED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-01-24T17:55:14Z",
      "updatedAt": "2019-12-17T10:09:58Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "cecefc7b1ba78e1fb092009325ffa483e44054cc",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "raphaelrobert",
      "headRefOid": "ce52c906f36aafd02c7150a95a6dd11c4aeb74b0",
      "closedAt": "2018-01-24T18:48:47Z",
      "mergedAt": "2018-01-24T18:48:47Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "308dc72b99c81ec1d7c7e912033fb54741ebd460"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 9,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY0OTc2MTk4",
      "title": "Protocol Details",
      "url": "https://github.com/mlswg/mls-protocol/pull/9",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial",
        "functionality"
      ],
      "body": "This PR adds a pretty complete description of the protocol.  The only major thing that's missing is `Init`, which should be straightforward-ish to construct.  @jmillican want to take a stab at that?",
      "createdAt": "2018-01-24T22:07:30Z",
      "updatedAt": "2019-12-17T10:08:50Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "308dc72b99c81ec1d7c7e912033fb54741ebd460",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "protocol2",
      "headRefOid": "4bc7a941672db04c7e8085ac447a90545da56085",
      "closedAt": "2018-01-24T22:07:43Z",
      "mergedAt": "2018-01-24T22:07:43Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "eef91e51ccbf0ea4fd3611d7e31b45b1be876dfe"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 10,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY1MDc5MTIy",
      "title": "Point to the security requirements in the architecture doc.",
      "url": "https://github.com/mlswg/mls-protocol/pull/10",
      "state": "MERGED",
      "author": "katrielalex",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-01-25T10:21:00Z",
      "updatedAt": "2019-12-17T10:08:12Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "eef91e51ccbf0ea4fd3611d7e31b45b1be876dfe",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "8cc06d6d91bc3f69c769837c57669fa9f68fbbde",
      "closedAt": "2018-01-25T10:21:10Z",
      "mergedAt": "2018-01-25T10:21:10Z",
      "mergedBy": "katrielalex",
      "mergeCommit": {
        "oid": "c09abcdf5f443cda52d2ace0f425c53c1fa1f762"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 11,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY1NzI2NzUy",
      "title": "Start writing \u00a7Security Considerations",
      "url": "https://github.com/mlswg/mls-protocol/pull/11",
      "state": "MERGED",
      "author": "katrielalex",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-01-29T14:58:04Z",
      "updatedAt": "2019-12-17T10:07:56Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "d7d5fe7f60574ba0c56efd8e799347dbe82f463a",
      "headRepository": null,
      "headRefName": "sec-consid",
      "headRefOid": "616e4d54169b77e128d54f298aa186c422d9591d",
      "closedAt": "2018-01-29T14:58:13Z",
      "mergedAt": "2018-01-29T14:58:13Z",
      "mergedBy": "katrielalex",
      "mergeCommit": {
        "oid": "2411124066d2b1b4ab48c0da063e6cd22f7e2fcc"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 12,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY1ODU0NDk2",
      "title": "Reference and terminology fixes",
      "url": "https://github.com/mlswg/mls-protocol/pull/12",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial",
        "terminology"
      ],
      "body": "",
      "createdAt": "2018-01-30T00:15:04Z",
      "updatedAt": "2019-12-17T10:07:45Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "2bd4803415bf0f5b8c631da6b5498b68823acaca",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "protocol2",
      "headRefOid": "f8c8f3ecc5c77839e8110e65160048651d3e7686",
      "closedAt": "2018-01-30T00:20:10Z",
      "mergedAt": "2018-01-30T00:20:10Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "d76f2502507019b74688b660ef318c50dc8e3600"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 13,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY1ODU2NDAw",
      "title": "Expand on the ratchet trees section",
      "url": "https://github.com/mlswg/mls-protocol/pull/13",
      "state": "MERGED",
      "author": "jmillican",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Prose for how ratchet trees work.",
      "createdAt": "2018-01-30T00:29:12Z",
      "updatedAt": "2019-12-17T10:07:26Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "d76f2502507019b74688b660ef318c50dc8e3600",
      "headRepository": null,
      "headRefName": "flesh_out_trees",
      "headRefOid": "60a4a60de1a637e3a1b540147e1a394ef6db8ea9",
      "closedAt": "2018-01-30T01:10:59Z",
      "mergedAt": "2018-01-30T01:10:59Z",
      "mergedBy": "jmillican",
      "mergeCommit": {
        "oid": "f5291786d729046c375ff95e9ea028dd4a81bb78"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 14,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY1ODYyMTM2",
      "title": "Expand on the blank nodes section",
      "url": "https://github.com/mlswg/mls-protocol/pull/14",
      "state": "MERGED",
      "author": "jmillican",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-01-30T01:13:59Z",
      "updatedAt": "2019-12-17T10:07:21Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "f5291786d729046c375ff95e9ea028dd4a81bb78",
      "headRepository": null,
      "headRefName": "blank_nodes",
      "headRefOid": "08877f7c3c26c591212fc1893d494bc77285d860",
      "closedAt": "2018-01-30T01:14:06Z",
      "mergedAt": "2018-01-30T01:14:06Z",
      "mergedBy": "jmillican",
      "mergeCommit": {
        "oid": "02893efeeac653917c87bded5ab3602c94e9aa92"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 15,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY1ODY1OTkw",
      "title": "Flesh out Merkle tree description",
      "url": "https://github.com/mlswg/mls-protocol/pull/15",
      "state": "MERGED",
      "author": "jmillican",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-01-30T01:45:05Z",
      "updatedAt": "2019-12-17T10:07:16Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "02893efeeac653917c87bded5ab3602c94e9aa92",
      "headRepository": null,
      "headRefName": "merkle",
      "headRefOid": "e0e89f7ce3bffd7dcfd6a643ae1dd240d32b6c19",
      "closedAt": "2018-01-30T01:45:13Z",
      "mergedAt": "2018-01-30T01:45:13Z",
      "mergedBy": "jmillican",
      "mergeCommit": {
        "oid": "42a85542b4bb318a7fe8800fc98e7fcb25dddc2e"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 16,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2MDM5NjEw",
      "title": "Expand on the prose describing the common tree properties",
      "url": "https://github.com/mlswg/mls-protocol/pull/16",
      "state": "MERGED",
      "author": "jmillican",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-01-30T17:00:34Z",
      "updatedAt": "2019-12-17T10:07:12Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "42a85542b4bb318a7fe8800fc98e7fcb25dddc2e",
      "headRepository": null,
      "headRefName": "expand_trees_prose",
      "headRefOid": "7bc6522eefdb36a373465e2394d04e9e2724ae6e",
      "closedAt": "2018-01-30T17:00:41Z",
      "mergedAt": "2018-01-30T17:00:41Z",
      "mergedBy": "jmillican",
      "mergeCommit": {
        "oid": "cdc8f4f0a2595104922dc3791ea5df3b73e237cc"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 17,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2MzAxNzEw",
      "title": "Prose-ify the bullet points in the introduction",
      "url": "https://github.com/mlswg/mls-protocol/pull/17",
      "state": "MERGED",
      "author": "katrielalex",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-01-31T16:02:21Z",
      "updatedAt": "2019-12-17T10:07:07Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "cdc8f4f0a2595104922dc3791ea5df3b73e237cc",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "eb1d50fdedd82bb0dc54a01cd471f04a73c9ebf0",
      "closedAt": "2018-01-31T16:03:06Z",
      "mergedAt": "2018-01-31T16:03:06Z",
      "mergedBy": "katrielalex",
      "mergeCommit": {
        "oid": "b83c2c3122ca72817a140307e66473fb17e24403"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 18,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2MzA2NDcz",
      "title": "Expand bullet points into subheadings in binary trees section",
      "url": "https://github.com/mlswg/mls-protocol/pull/18",
      "state": "MERGED",
      "author": "jmillican",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-01-31T16:18:07Z",
      "updatedAt": "2019-12-17T10:07:01Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "b83c2c3122ca72817a140307e66473fb17e24403",
      "headRepository": null,
      "headRefName": "improve_terminology_section",
      "headRefOid": "668240c6aa2520fe3c18633d75ebd1f2ef11a3b3",
      "closedAt": "2018-01-31T16:20:49Z",
      "mergedAt": "2018-01-31T16:20:49Z",
      "mergedBy": "katrielalex",
      "mergeCommit": {
        "oid": "167e5215a3ed8f4a7048424f6f31056f03e4b6a8"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 19,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2MzEzODMy",
      "title": "Trim some of the proliferation of section headers",
      "url": "https://github.com/mlswg/mls-protocol/pull/19",
      "state": "MERGED",
      "author": "katrielalex",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-01-31T16:43:15Z",
      "updatedAt": "2019-12-17T10:06:55Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "167e5215a3ed8f4a7048424f6f31056f03e4b6a8",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "aa68a027ff8f10dd9dcf526210d45ebb86b008b6",
      "closedAt": "2018-01-31T16:47:27Z",
      "mergedAt": "2018-01-31T16:47:27Z",
      "mergedBy": "jmillican",
      "mergeCommit": {
        "oid": "3f123b56d2db495c03fc97182162db2e3cc84484"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTI5OTY0ODg=",
          "commit": {
            "abbreviatedOid": "aa68a02"
          },
          "author": "jmillican",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-01-31T16:47:22Z",
          "updatedAt": "2018-01-31T16:47:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 20,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2MzIzNDgw",
      "title": "Start a section on group tree operations",
      "url": "https://github.com/mlswg/mls-protocol/pull/20",
      "state": "MERGED",
      "author": "jmillican",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-01-31T17:18:14Z",
      "updatedAt": "2019-12-17T10:06:34Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "3f123b56d2db495c03fc97182162db2e3cc84484",
      "headRepository": null,
      "headRefName": "group_initialisation",
      "headRefOid": "7baad56787bde688e44e010ae57ccb8a711a8c5c",
      "closedAt": "2018-01-31T17:18:21Z",
      "mergedAt": "2018-01-31T17:18:21Z",
      "mergedBy": "jmillican",
      "mergeCommit": {
        "oid": "801935fe8337b40708acf4e6ccc61e92a2591b12"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 22,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2NDMwMDcz",
      "title": "Editorial",
      "url": "https://github.com/mlswg/mls-protocol/pull/22",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-02-01T02:41:04Z",
      "updatedAt": "2019-12-17T10:06:23Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "801935fe8337b40708acf4e6ccc61e92a2591b12",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "ekr_edit",
      "headRefOid": "b029364bc54cac5fbd09c92e353ac0fe3f8a2be0",
      "closedAt": "2018-02-01T02:41:22Z",
      "mergedAt": "2018-02-01T02:41:22Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "178d585d147cac7f233ed5aa8c7b4f8716a47bbb"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 23,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2NDUzMjkx",
      "title": "Minor editorial and typo fixes",
      "url": "https://github.com/mlswg/mls-protocol/pull/23",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-02-01T06:24:17Z",
      "updatedAt": "2019-12-17T10:06:16Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "1e726dbaf9650d76b4e301b331713ea65f9d3b5c",
      "headRepository": "beurdouche/mls-protocol",
      "headRefName": "editorial_0",
      "headRefOid": "9194e6c32d3075e0ff005941039973f33345a2f5",
      "closedAt": "2018-02-01T06:24:25Z",
      "mergedAt": "2018-02-01T06:24:25Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "653a0023b715a6deefb5b53187cdcb0f968af438"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 24,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2NDU1NzEx",
      "title": "RLB edit pass",
      "url": "https://github.com/mlswg/mls-protocol/pull/24",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial",
        "recommendation"
      ],
      "body": "",
      "createdAt": "2018-02-01T06:43:23Z",
      "updatedAt": "2019-12-17T10:04:49Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "653a0023b715a6deefb5b53187cdcb0f968af438",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "rlb-edit-pass",
      "headRefOid": "efd2f5583137bbc4e63c807b2b72e03382b57a22",
      "closedAt": "2018-02-01T06:47:40Z",
      "mergedAt": "2018-02-01T06:47:40Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "c4feec23b01d6f44487be9460bc675467e7c2314"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTMxNzk1MjU=",
          "commit": {
            "abbreviatedOid": "2fa6ed3"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-01T06:44:34Z",
          "updatedAt": "2018-02-01T06:44:34Z",
          "comments": [
            {
              "originalPosition": 618,
              "body": "typo",
              "createdAt": "2018-02-01T06:44:34Z",
              "updatedAt": "2018-02-01T06:47:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTMxNzk1OTA=",
          "commit": {
            "abbreviatedOid": "2fa6ed3"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-01T06:44:59Z",
          "updatedAt": "2018-02-01T06:44:59Z",
          "comments": [
            {
              "originalPosition": 618,
              "body": "Wow, that was fast\r\n",
              "createdAt": "2018-02-01T06:44:59Z",
              "updatedAt": "2018-02-01T06:47:32Z"
            }
          ]
        }
      ]
    },
    {
      "number": 25,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2NDU4Nzk4",
      "title": "Add concreteness",
      "url": "https://github.com/mlswg/mls-protocol/pull/25",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial",
        "recommendation"
      ],
      "body": "",
      "createdAt": "2018-02-01T07:05:46Z",
      "updatedAt": "2019-12-17T10:04:32Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "c4feec23b01d6f44487be9460bc675467e7c2314",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "rlb-edit-pass",
      "headRefOid": "ac469a95b9210395ee4602d4b85c3a471701fb8a",
      "closedAt": "2018-02-01T07:05:52Z",
      "mergedAt": "2018-02-01T07:05:52Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "3942cd5c3eed8723595e4444ba0f5e8ea5ce1a56"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 26,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2NDcxNjM4",
      "title": "Technical bug fixes due to implementation",
      "url": "https://github.com/mlswg/mls-protocol/pull/26",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial",
        "recommendation"
      ],
      "body": "Noticed some bugs in the spec as I was working on aligning the Go implementation.",
      "createdAt": "2018-02-01T08:27:11Z",
      "updatedAt": "2019-12-17T10:04:18Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "3942cd5c3eed8723595e4444ba0f5e8ea5ce1a56",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "rlb-edit-pass",
      "headRefOid": "6b31f38bdd47b730b007eeb3f72432158c6faccb",
      "closedAt": "2018-02-01T08:27:32Z",
      "mergedAt": "2018-02-01T08:27:31Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "76d2db1f18ec9f553a0096b02ddb65b4d511e4c6"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 27,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2NTQyNDkx",
      "title": "Review on the current protocol specification",
      "url": "https://github.com/mlswg/mls-protocol/pull/27",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial",
        "recommendation"
      ],
      "body": "",
      "createdAt": "2018-02-01T13:52:15Z",
      "updatedAt": "2019-12-17T10:05:06Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "80cd9d1e8320d8ec6d49f8308b6c95c5d4b0a177",
      "headRepository": "beurdouche/mls-protocol",
      "headRefName": "update.0",
      "headRefOid": "362e9f5c162489a9d8e1891ba4d3a123010d822a",
      "closedAt": "2018-02-01T20:32:10Z",
      "mergedAt": "2018-02-01T20:32:10Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "10b1db9861a4475e39f59349eb70e965d5e3ac13"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTM0MDg2NTk=",
          "commit": {
            "abbreviatedOid": "fa9e653"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-02-01T19:32:35Z",
          "updatedAt": "2018-02-01T19:38:24Z",
          "comments": [
            {
              "originalPosition": 452,
              "body": "Request from the cache",
              "createdAt": "2018-02-01T19:32:35Z",
              "updatedAt": "2018-02-01T19:53:30Z"
            },
            {
              "originalPosition": 383,
              "body": "I would say \"potential group member\"",
              "createdAt": "2018-02-01T19:33:13Z",
              "updatedAt": "2018-02-01T19:53:30Z"
            },
            {
              "originalPosition": 383,
              "body": "and then \"that a current gorup member\"",
              "createdAt": "2018-02-01T19:33:22Z",
              "updatedAt": "2018-02-01T19:53:30Z"
            },
            {
              "originalPosition": 508,
              "body": "I would just condense these to say something like \"... derive key material for symmetric operations such as encryption/AEAD and MAC.\"",
              "createdAt": "2018-02-01T19:35:19Z",
              "updatedAt": "2018-02-01T19:53:30Z"
            },
            {
              "originalPosition": 519,
              "body": "SGTM",
              "createdAt": "2018-02-01T19:35:44Z",
              "updatedAt": "2018-02-01T19:53:30Z"
            },
            {
              "originalPosition": 527,
              "body": "Change \"strong indication\" to \"proof\"?\r\n",
              "createdAt": "2018-02-01T19:36:10Z",
              "updatedAt": "2018-02-01T19:53:30Z"
            },
            {
              "originalPosition": 533,
              "body": "Please add text.",
              "createdAt": "2018-02-01T19:36:28Z",
              "updatedAt": "2018-02-01T19:53:30Z"
            },
            {
              "originalPosition": 540,
              "body": "I think the idea is to cover it in a MAC / AEAD rather than mixing it into the key.  That way you can verify authenticity of the new thing even if you don't have the old thing.",
              "createdAt": "2018-02-01T19:37:16Z",
              "updatedAt": "2018-02-01T19:53:30Z"
            },
            {
              "originalPosition": 550,
              "body": "s/secret/private/",
              "createdAt": "2018-02-01T19:37:29Z",
              "updatedAt": "2018-02-01T19:53:30Z"
            },
            {
              "originalPosition": 550,
              "body": "(In general, I try to use \"private\" for asymmetric secrets, and \"secret\" for symmetric) ",
              "createdAt": "2018-02-01T19:37:51Z",
              "updatedAt": "2018-02-01T19:53:30Z"
            },
            {
              "originalPosition": 559,
              "body": "\"honnest\"",
              "createdAt": "2018-02-01T19:38:03Z",
              "updatedAt": "2018-02-01T19:53:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTM0MTYxMTc=",
          "commit": {
            "abbreviatedOid": "362e9f5"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-01T19:54:58Z",
          "updatedAt": "2018-02-01T19:54:59Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "Wasn't immediately sure on how to expand here.",
              "createdAt": "2018-02-01T19:54:59Z",
              "updatedAt": "2018-02-01T19:54:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTM0MTYyODU=",
          "commit": {
            "abbreviatedOid": "362e9f5"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-01T19:55:29Z",
          "updatedAt": "2018-02-01T19:55:29Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "I did the rest of the changes according to your comments @bifurcation ",
              "createdAt": "2018-02-01T19:55:29Z",
              "updatedAt": "2018-02-01T19:55:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTM0MjcxNzY=",
          "commit": {
            "abbreviatedOid": "362e9f5"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-02-01T20:31:43Z",
          "updatedAt": "2018-02-01T20:31:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 28,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2NTg4Njk1",
      "title": "make things make",
      "url": "https://github.com/mlswg/mls-protocol/pull/28",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "",
      "createdAt": "2018-02-01T16:37:08Z",
      "updatedAt": "2019-12-17T10:03:39Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "76d2db1f18ec9f553a0096b02ddb65b4d511e4c6",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "make-fix",
      "headRefOid": "6eb5ff68a934c974efd760244dbc62bd696e0cb6",
      "closedAt": "2018-02-01T16:37:15Z",
      "mergedAt": "2018-02-01T16:37:15Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "8c22ac17164702c7d3f101db8f338208bb8859c5"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 29,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2NjA3OTEw",
      "title": "Add a contributors list",
      "url": "https://github.com/mlswg/mls-protocol/pull/29",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-02-01T17:51:31Z",
      "updatedAt": "2019-12-17T10:03:30Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "8c22ac17164702c7d3f101db8f338208bb8859c5",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "contributors",
      "headRefOid": "0f419a16e5cf26af1eb14a248df70d09bd57faba",
      "closedAt": "2018-02-01T17:51:48Z",
      "mergedAt": "2018-02-01T17:51:47Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "d8989450c3f87ef66e81f4a817f200ae570217b9"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 30,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2NjI3OTI2",
      "title": "Some revisions",
      "url": "https://github.com/mlswg/mls-protocol/pull/30",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial",
        "recommendation"
      ],
      "body": "",
      "createdAt": "2018-02-01T19:21:15Z",
      "updatedAt": "2019-12-17T10:03:13Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "d8989450c3f87ef66e81f4a817f200ae570217b9",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "ekr_revisions2",
      "headRefOid": "880458e95463bf92cfcbd5229cc3f33eb94e1e5d",
      "closedAt": "2018-02-01T19:23:34Z",
      "mergedAt": "2018-02-01T19:23:34Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "80cd9d1e8320d8ec6d49f8308b6c95c5d4b0a177"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 31,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2NjM0MDcy",
      "title": "Explicitly note open issues",
      "url": "https://github.com/mlswg/mls-protocol/pull/31",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-02-01T19:47:43Z",
      "updatedAt": "2019-12-17T10:02:54Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "80cd9d1e8320d8ec6d49f8308b6c95c5d4b0a177",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "open-issues",
      "headRefOid": "1e02f0fcf38e9cdd0941a544767d0d5a2382009e",
      "closedAt": "2018-02-01T20:27:28Z",
      "mergedAt": "2018-02-01T20:27:28Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "94201ffb72bfb49907829aa19f9ccc4bcd069013"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 32,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2NjUwMDc5",
      "title": "A few tweaks to the top part of the doc",
      "url": "https://github.com/mlswg/mls-protocol/pull/32",
      "state": "MERGED",
      "author": "jmillican",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-02-01T20:58:37Z",
      "updatedAt": "2019-12-17T10:02:48Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "10b1db9861a4475e39f59349eb70e965d5e3ac13",
      "headRepository": null,
      "headRefName": "few_tweaks",
      "headRefOid": "9708555b06606e60de5ddd33fe3757f50ddd32cf",
      "closedAt": "2018-02-01T21:01:39Z",
      "mergedAt": "2018-02-01T21:01:39Z",
      "mergedBy": "jmillican",
      "mergeCommit": {
        "oid": "1c0a12ded892afe58f3e843ce01b13d25b902fdd"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 33,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2NjU3OTEw",
      "title": "minor changes specifying two different types of authentication",
      "url": "https://github.com/mlswg/mls-protocol/pull/33",
      "state": "MERGED",
      "author": "kwonalbert",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial",
        "functionality"
      ],
      "body": "",
      "createdAt": "2018-02-01T21:34:37Z",
      "updatedAt": "2019-12-17T10:02:32Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "1c0a12ded892afe58f3e843ce01b13d25b902fdd",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "0bc4a1ea5bbb0a3a22e0d9b0122190f97a05ed13",
      "closedAt": "2018-02-01T21:35:44Z",
      "mergedAt": "2018-02-01T21:35:44Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "73b886d514a57b971b22f31294c4e2ec0aaa33b1"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 34,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2NjYwMzY0",
      "title": "Title and reference fixes",
      "url": "https://github.com/mlswg/mls-protocol/pull/34",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-02-01T21:45:27Z",
      "updatedAt": "2019-12-17T10:01:54Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "73b886d514a57b971b22f31294c4e2ec0aaa33b1",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "title",
      "headRefOid": "fc26f237878c8de288e16e82f825e9d0b2a530de",
      "closedAt": "2018-02-01T21:45:34Z",
      "mergedAt": "2018-02-01T21:45:34Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "cf70d28484d6d0d08f5e6df051cbe1ca40dfa992"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 36,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2NjY1NTky",
      "title": "Add a note to cite ART paper",
      "url": "https://github.com/mlswg/mls-protocol/pull/36",
      "state": "MERGED",
      "author": "jmillican",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-02-01T22:08:58Z",
      "updatedAt": "2019-12-17T10:01:50Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "cf70d28484d6d0d08f5e6df051cbe1ca40dfa992",
      "headRepository": null,
      "headRefName": "note_to_cite_art",
      "headRefOid": "868846c93f01c8956d1ba6784c438dd241d69c4a",
      "closedAt": "2018-02-01T22:09:33Z",
      "mergedAt": "2018-02-01T22:09:33Z",
      "mergedBy": "jmillican",
      "mergeCommit": {
        "oid": "33cd37932e60dd566308df6b9ff6ec3082470611"
      },
      "comments": [
        {
          "author": "jmillican",
          "authorAssociation": "COLLABORATOR",
          "body": "We should probably have this cited there, as the security proof is pretty core to things.",
          "createdAt": "2018-02-01T22:09:30Z",
          "updatedAt": "2018-02-01T22:09:30Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 37,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2NjY3MjYz",
      "title": "Fix compilation by reordering references",
      "url": "https://github.com/mlswg/mls-protocol/pull/37",
      "state": "MERGED",
      "author": "katrielalex",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Because xml2rfc is crazy, if the first reference in a reference list\r\ndoes not include an author then xml2rfc will _actually crash_ with an\r\nUnboundLocalError (http://xml2rfc.xml.resource.narkive.com/DzQ2CS0L/243-version-2-cli-problem-in-html-rendering-of-minimal-references):\r\n\r\n```\r\nxml2rfc -q draft-barnes-mls-protocol.xml -o draft-barnes-mls-protocol.htmltmp --html\r\nTraceback (most recent call last):\r\n  File \"/usr/local/bin/xml2rfc\", line 225, in <module>\r\n    main()\r\n  File \"/usr/local/bin/xml2rfc\", line 192, in main\r\n    htmlwriter.write(filename)\r\n  File \"/Users/katrielalex/Library/Python/2.7/lib/python/site-packages/xml2rfc/writers/base.py\", line 1218, in write\r\n    self._build_document()\r\n  File \"/Users/katrielalex/Library/Python/2.7/lib/python/site-packages/xml2rfc/writers/base.py\", line 1164, in _build_document\r\n    self.write_reference_list(reference_list)\r\n  File \"/Users/katrielalex/Library/Python/2.7/lib/python/site-packages/xml2rfc/writers/html.py\", line 569, in write_reference_list\r\n    a.tail = ', '\r\nUnboundLocalError: local variable 'a' referenced before assignment\r\n```\r\n\r\nYes, this is crazy. In lieu of actually fixing the problem, here we\r\njust reorder the references so it compiles.",
      "createdAt": "2018-02-01T22:17:07Z",
      "updatedAt": "2019-12-17T10:01:31Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "33cd37932e60dd566308df6b9ff6ec3082470611",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "a34b5ae1647f33731c327fca53a68c36fcd72f2e",
      "closedAt": "2018-02-01T22:17:57Z",
      "mergedAt": "2018-02-01T22:17:57Z",
      "mergedBy": "katrielalex",
      "mergeCommit": {
        "oid": "ccab586f647bd978d101baa3b89078f9e9fb7da1"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 38,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2NjcwMzA5",
      "title": "Add an OPEN ISSUE about the signatures on identity keys breaking deniability",
      "url": "https://github.com/mlswg/mls-protocol/pull/38",
      "state": "MERGED",
      "author": "katrielalex",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial",
        "privacy"
      ],
      "body": "FAO @raphaelrobert ",
      "createdAt": "2018-02-01T22:31:36Z",
      "updatedAt": "2019-12-17T09:55:04Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "ccab586f647bd978d101baa3b89078f9e9fb7da1",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "806ab2ea720dcba03ea579117c31537b8ad3b805",
      "closedAt": "2018-02-01T22:31:51Z",
      "mergedAt": "2018-02-01T22:31:51Z",
      "mergedBy": "katrielalex",
      "mergeCommit": {
        "oid": "702b4f4ede84279d03e9a740817cd699e297947d"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 39,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2NzA5NjQ2",
      "title": "Add disclaimer of fitness",
      "url": "https://github.com/mlswg/mls-protocol/pull/39",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-02-02T03:23:34Z",
      "updatedAt": "2019-12-17T09:54:39Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "702b4f4ede84279d03e9a740817cd699e297947d",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "disclaimer",
      "headRefOid": "6106e400116b8e84549d54a33002448eaee4342b",
      "closedAt": "2018-02-02T03:26:58Z",
      "mergedAt": "2018-02-02T03:26:58Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "33b9abfb52be3eefca8099d4351ac1ab446f450f"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 40,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2NzExMzQ0",
      "title": "Real cite to ART",
      "url": "https://github.com/mlswg/mls-protocol/pull/40",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-02-02T03:40:50Z",
      "updatedAt": "2019-12-17T09:54:33Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "33b9abfb52be3eefca8099d4351ac1ab446f450f",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "cite",
      "headRefOid": "9c16aef25722b9e03aff509dec1e61c3c1b5b057",
      "closedAt": "2018-02-02T03:40:57Z",
      "mergedAt": "2018-02-02T03:40:57Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "76f0a6af08d580086c0bd6ca10b2c20666e81dbf"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 41,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2NzIwMjkx",
      "title": "Fix a minor computation bug",
      "url": "https://github.com/mlswg/mls-protocol/pull/41",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "bug",
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-02-02T05:22:11Z",
      "updatedAt": "2019-12-17T09:54:26Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "76f0a6af08d580086c0bd6ca10b2c20666e81dbf",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "bugfix",
      "headRefOid": "503665f476602ad13e7f2f679f9636b02d4fb207",
      "closedAt": "2018-02-02T05:22:21Z",
      "mergedAt": "2018-02-02T05:22:21Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "3afc78a3dbb5c530edadf75ede5e5ff72bfaa1f7"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 42,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2NzIwMzUy",
      "title": "Example figure in key schedule",
      "url": "https://github.com/mlswg/mls-protocol/pull/42",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-02-02T05:22:46Z",
      "updatedAt": "2019-12-17T09:54:13Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "3afc78a3dbb5c530edadf75ede5e5ff72bfaa1f7",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "diagram",
      "headRefOid": "ff9d95da7e1ec841a4274bf1e5cd21814498ef9a",
      "closedAt": "2018-09-10T22:11:30Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "This PR is obsolete.",
          "createdAt": "2018-09-10T22:11:30Z",
          "updatedAt": "2018-09-10T22:11:30Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTM2NDU4Mzg=",
          "commit": {
            "abbreviatedOid": "ff9d95d"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-02-02T14:58:14Z",
          "updatedAt": "2018-02-02T14:59:17Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Something seems wrong about the HKDFs here. I think the second one is taking its inputs from the wrong place.",
              "createdAt": "2018-02-02T14:58:14Z",
              "updatedAt": "2018-02-02T14:59:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTM2ODI4NDU=",
          "commit": {
            "abbreviatedOid": "ff9d95d"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-02T16:49:49Z",
          "updatedAt": "2018-02-02T16:51:53Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Ignore the direction of the inputs.  That's just there to make the diagram fit on the page.  Do you agree that the HKDF -> Epoch -> Fanout process matches the above diagram?\r\n\r\nAs far as inputs, the intent is to match text above and the sections below:\r\n\r\n> For UserAdd or GroupAdd, the new user does not know the prior epoch init secret. Instead, entropy from the prior epoch is added via the update secret, and an all-zero vector with the same length as a hash output is used in the place of the init secret\r\n\r\n> The update secret resulting from this change is the output of a DH computation between the private key for the root of the ratchet tree and the add public key from the previous epoch\r\n\r\n> The update secret resulting from this change is the secret for the root node of the ratchet tree",
              "createdAt": "2018-02-02T16:49:49Z",
              "updatedAt": "2018-02-02T16:51:53Z"
            }
          ]
        }
      ]
    },
    {
      "number": 43,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2ODgyNTk3",
      "title": "Presubmit revisions",
      "url": "https://github.com/mlswg/mls-protocol/pull/43",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-02-02T19:21:03Z",
      "updatedAt": "2019-12-17T09:53:59Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "79aee69664ab9de6743f37c2d4cd876b6a4ff90e",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "presubmit_revisions",
      "headRefOid": "c327a205aa221be5fda9351e2b2e870633393af3",
      "closedAt": "2018-02-02T19:28:15Z",
      "mergedAt": "2018-02-02T19:28:15Z",
      "mergedBy": "eomara",
      "mergeCommit": {
        "oid": "b65a9877a6d9abaf481fde1604fa1b4a03c15d38"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTM3MzAwNDM=",
          "commit": {
            "abbreviatedOid": "c327a20"
          },
          "author": "eomara",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-02-02T19:28:09Z",
          "updatedAt": "2018-02-02T19:28:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 44,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2ODg2NDA4",
      "title": "Explain frontiers and provide an example tree",
      "url": "https://github.com/mlswg/mls-protocol/pull/44",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-02-02T19:39:27Z",
      "updatedAt": "2019-12-17T09:53:22Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "b65a9877a6d9abaf481fde1604fa1b4a03c15d38",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "frontier",
      "headRefOid": "994940819e51bcdf903576ee51da764419c8191d",
      "closedAt": "2018-02-02T19:42:30Z",
      "mergedAt": "2018-02-02T19:42:30Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "4fcede42e2beb429e31aeb64c6855458f54bfc08"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 45,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY3NzEyNzk1",
      "title": "Fixes from Bob Harold",
      "url": "https://github.com/mlswg/mls-protocol/pull/45",
      "state": "MERGED",
      "author": "katrielalex",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-02-07T14:48:28Z",
      "updatedAt": "2019-12-17T09:52:46Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "fe423d81405b21527e06eb975e2dc8f97d88351a",
      "headRepository": "katrielalex/mls-protocol",
      "headRefName": "fixes",
      "headRefOid": "19be1fe2e7b0506fca0c3d6804ee355160832658",
      "closedAt": "2018-02-07T14:50:23Z",
      "mergedAt": "2018-02-07T14:50:23Z",
      "mergedBy": "katrielalex",
      "mergeCommit": {
        "oid": "57db650f4a4b026f7a2ebf46b0738f24d92bc1fa"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQ3MzQyNTk=",
          "commit": {
            "abbreviatedOid": "19be1fe"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-02-07T14:49:39Z",
          "updatedAt": "2018-02-07T14:49:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 46,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY4OTg2MzY4",
      "title": "\"Groups\" is ambiguous",
      "url": "https://github.com/mlswg/mls-protocol/pull/46",
      "state": "MERGED",
      "author": "mnot",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "It first reads as if MLS allows groups to communicate with each other, which I don't *think* is the intent.",
      "createdAt": "2018-02-13T23:38:13Z",
      "updatedAt": "2019-12-17T09:52:37Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "57db650f4a4b026f7a2ebf46b0738f24d92bc1fa",
      "headRepository": null,
      "headRefName": "patch-1",
      "headRefOid": "32665c667695f83ac54d9403f204365303911c72",
      "closedAt": "2018-02-14T08:01:14Z",
      "mergedAt": "2018-02-14T08:01:14Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "000d62d0fd28501fef54e82961df5a5ac6cf7c84"
      },
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Thanks Mark ;)",
          "createdAt": "2018-02-14T08:01:17Z",
          "updatedAt": "2018-02-14T08:01:17Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 48,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc1NzEzMTQ0",
      "title": "Remove GroupInitKey from Handshake; add to GroupAdd",
      "url": "https://github.com/mlswg/mls-protocol/pull/48",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement",
        "security"
      ],
      "body": "In implementing MLS, I found that having a `GroupInitKey` attached to all `Handshake` messages was almost never useful.  There's also a dangerous ambiguity between whether the `GroupInitKey` for a `Handshake` represents the state of the group before or after applying the change in the message.  \"After\" is the answer you want if you want to use historical `Handshake` messages as a way of distributing `GroupInitKey`s, but that requires emulating the change when signing the message -- and doing the emulation might rely on the `GroupInitKey`!\r\n\r\nInstead of all that complication, this PR just removes the `GroupInitKey` from `Handshake` and adds it to `GroupAdd`, where its construction and utility are both obvious.",
      "createdAt": "2018-03-17T18:03:46Z",
      "updatedAt": "2019-12-17T09:52:14Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "54420306144c793c18e8aa32268844c341a626f4",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "message-simplify",
      "headRefOid": "60448667e86dd8889f49ebd6d7301eeed147c75c",
      "closedAt": "2018-09-10T22:12:06Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "This PR is overtaken by the changes in #59 ",
          "createdAt": "2018-09-10T22:12:06Z",
          "updatedAt": "2018-09-10T22:12:06Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA0Nzc4NDQy",
          "commit": {
            "abbreviatedOid": "6044866"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-03-17T21:10:30Z",
          "updatedAt": "2018-03-17T21:10:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 49,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc1NzE2NjI4",
      "title": "Example code for tree math",
      "url": "https://github.com/mlswg/mls-protocol/pull/49",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "The math for left-balanced binary trees is very reliable once you have it right, but can be hard to get right from scratch.  This PR provides an appendix that explains a theory and code for managing these trees.",
      "createdAt": "2018-03-17T19:19:04Z",
      "updatedAt": "2019-12-17T09:50:34Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "eca365da10223eef64eda050427fc07c5f5ac254",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "tree-math",
      "headRefOid": "41d151124cbd3c08c76f5df59afd255f8be27abd",
      "closedAt": "2018-09-19T21:20:57Z",
      "mergedAt": "2018-09-19T21:20:57Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "eadb31c11ba1f447f86ca107e6c52cefcd66722f"
      },
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "NONE",
          "body": "I feel this is  very useful to have in the draft for implementors. What should be the plan to merge it ? @bifurcation ",
          "createdAt": "2018-09-13T22:24:43Z",
          "updatedAt": "2018-09-13T22:24:43Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA0Nzc2MTU1",
          "commit": {
            "abbreviatedOid": "b70f9f7"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Thanks ! I expect that it's going to be very useful for implementers. I am trusting that it is correct Python syntax ;) Pointed out a potential typo in the comments.",
          "createdAt": "2018-03-17T19:33:56Z",
          "updatedAt": "2018-03-17T21:07:03Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "s/../\"If a node's children are at different levels, then...\" ?",
              "createdAt": "2018-03-17T19:33:56Z",
              "updatedAt": "2018-09-19T21:17:36Z"
            },
            {
              "originalPosition": 41,
              "body": "Ok.",
              "createdAt": "2018-03-17T19:44:57Z",
              "updatedAt": "2018-09-19T21:17:36Z"
            },
            {
              "originalPosition": 53,
              "body": "Ok.",
              "createdAt": "2018-03-17T19:45:05Z",
              "updatedAt": "2018-09-19T21:17:36Z"
            },
            {
              "originalPosition": 63,
              "body": "Ok.",
              "createdAt": "2018-03-17T19:45:18Z",
              "updatedAt": "2018-09-19T21:17:36Z"
            },
            {
              "originalPosition": 67,
              "body": "Ok.",
              "createdAt": "2018-03-17T20:06:25Z",
              "updatedAt": "2018-09-19T21:17:36Z"
            },
            {
              "originalPosition": 74,
              "body": "Ok.",
              "createdAt": "2018-03-17T20:35:53Z",
              "updatedAt": "2018-09-19T21:17:36Z"
            },
            {
              "originalPosition": 84,
              "body": "Seems Ok.",
              "createdAt": "2018-03-17T20:50:25Z",
              "updatedAt": "2018-09-19T21:17:36Z"
            },
            {
              "originalPosition": 103,
              "body": "Ok.",
              "createdAt": "2018-03-17T20:53:59Z",
              "updatedAt": "2018-09-19T21:17:36Z"
            },
            {
              "originalPosition": 96,
              "body": "I am pressed by time and this one is more difficult. I'll get back to it later...",
              "createdAt": "2018-03-17T20:55:40Z",
              "updatedAt": "2018-09-19T21:17:36Z"
            },
            {
              "originalPosition": 113,
              "body": "Ok.",
              "createdAt": "2018-03-17T20:56:18Z",
              "updatedAt": "2018-09-19T21:17:36Z"
            },
            {
              "originalPosition": 124,
              "body": "Ok.",
              "createdAt": "2018-03-17T20:57:14Z",
              "updatedAt": "2018-09-19T21:17:36Z"
            },
            {
              "originalPosition": 135,
              "body": "Ok.",
              "createdAt": "2018-03-17T20:58:10Z",
              "updatedAt": "2018-09-19T21:17:36Z"
            },
            {
              "originalPosition": 159,
              "body": "Ok.",
              "createdAt": "2018-03-17T20:59:04Z",
              "updatedAt": "2018-09-19T21:17:36Z"
            },
            {
              "originalPosition": 147,
              "body": "Seems Ok. Yet another pair of eyes might be nice.",
              "createdAt": "2018-03-17T21:02:42Z",
              "updatedAt": "2018-09-19T21:17:36Z"
            }
          ]
        }
      ]
    },
    {
      "number": 50,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk4NDgyMTk5",
      "title": "Per-user KDF ratchets for message protection",
      "url": "https://github.com/mlswg/mls-protocol/pull/50",
      "state": "CLOSED",
      "author": "Scratch-net",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "This PR is a work towards message protection for MLS. It specifies separate KDF ratchets per every user to eliminate possible nonce reuse.",
      "createdAt": "2018-06-30T15:48:57Z",
      "updatedAt": "2019-12-17T09:49:38Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "c81dd324d4e8a894766d5965c78f6d4ad68907ad",
      "headRepository": "Scratch-net/mls-protocol",
      "headRefName": "kdf",
      "headRefOid": "f53b1c6542b04d3be579bf180991c5f704311b8f",
      "closedAt": "2018-10-19T16:54:33Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "Scratch-net",
          "authorAssociation": "NONE",
          "body": "Hey @beurdouche, thanks! \r\nMade amends as per your comments, see my latest commit. The scheme still may need some love but overall I hope it became better ) ",
          "createdAt": "2018-07-17T06:37:18Z",
          "updatedAt": "2018-07-17T06:37:18Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Looks Good, Thanks Alexey ! : )",
          "createdAt": "2018-07-17T15:44:58Z",
          "updatedAt": "2018-07-17T15:44:58Z"
        },
        {
          "author": "Scratch-net",
          "authorAssociation": "NONE",
          "body": "fixed & squashed",
          "createdAt": "2018-07-17T15:47:33Z",
          "updatedAt": "2018-07-17T15:47:33Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "This was obsoleted by #54 ",
          "createdAt": "2018-10-19T16:54:33Z",
          "updatedAt": "2018-10-19T16:54:33Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM3NTQxMTUy",
          "commit": {
            "abbreviatedOid": "b27b441"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Hi Alexey, here are a few comments...\r\nI might have misunderstood stuff so, tell me if I did...\r\n",
          "createdAt": "2018-07-16T18:28:22Z",
          "updatedAt": "2019-12-17T09:49:18Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Maybe you want to use the `Epoch secret` instead which is the secret generated from mixing the previous `Init secret` and the `Update secret` (what I believe you call the \"root key\") ?\r\nThe other solution, which I use, is to fork from the \"message_master_secret\".",
              "createdAt": "2018-07-16T18:28:22Z",
              "updatedAt": "2018-07-17T15:47:22Z"
            },
            {
              "originalPosition": 14,
              "body": "This is unused in the diagram at the moment. I think adding a second figure before the existing one, starting from the s/Epoch secret/Whatever, would be nice...",
              "createdAt": "2018-07-16T18:38:48Z",
              "updatedAt": "2018-07-17T15:47:22Z"
            },
            {
              "originalPosition": 29,
              "body": "TreeKEM will provide you with the same Handshake Key Schedule so I believe that this works for TreeKEM as-well. Maybe add it, or remove the reference to ART ? : )",
              "createdAt": "2018-07-16T18:42:24Z",
              "updatedAt": "2018-07-17T15:47:22Z"
            },
            {
              "originalPosition": 36,
              "body": "I don't think this is correct, you need at least an HKDF expand here. \r\n(if you meant `Extract` as `Expand`, then you probably need an orther `Extract` just on top...)\r\nYou could also probably re-use the `Derive-Client-Secret(Secret, Index, Msg)` you defined earlier or you could do something in the following style (for example):\r\n\r\n```\r\n    \r\n                         Chain secret[N-1]  ----> HKDF_Expand (...) =\r\n                                   |              Key[N-1], Nonce[N-1]\r\n                                   V\r\n          Constant --->    HKDF-Extract\r\n                        = Chain secret[N] ----> HKDF_Expand (...) =\r\n                                    |           Key[N], Nonce[N]\r\n                                    V\r\n                                    ...\r\n\r\n```\r\n\r\nIn my case, I use the TLS style instead so both keys and nonces get mixed-back in...",
              "createdAt": "2018-07-16T18:44:37Z",
              "updatedAt": "2018-07-17T15:47:22Z"
            },
            {
              "originalPosition": 32,
              "body": "Use `~~~` as apparently 5 `~` is causing some trouble...\r\nhttps://github.com/ekr/mls-protocol/pull/52",
              "createdAt": "2018-07-16T19:12:48Z",
              "updatedAt": "2018-07-17T15:47:22Z"
            },
            {
              "originalPosition": 43,
              "body": "The 2nd and 3rd iterations of the chain are not needed.",
              "createdAt": "2018-07-16T19:21:48Z",
              "updatedAt": "2018-07-17T15:47:22Z"
            },
            {
              "originalPosition": 21,
              "body": "Do you mean \"message\" as the `Context` like is done in TLS (aka or the Handshake message causing the group's `Epoch secret` to change) here or just some label like \"client secret\" ?\r\nIn the later version, the syntax can just be called `label` instead and should be defined.\r\nIn both cases a length 255 bytes is largely enough...",
              "createdAt": "2018-07-16T19:36:12Z",
              "updatedAt": "2018-07-17T15:47:22Z"
            },
            {
              "originalPosition": 60,
              "body": "In MLS there are many epochs for many things, maybe `s/epoch/group epoch` would help clarity ?",
              "createdAt": "2018-07-16T19:45:37Z",
              "updatedAt": "2018-07-17T15:47:22Z"
            },
            {
              "originalPosition": 7,
              "body": "s/his/its or s/his/a ?",
              "createdAt": "2018-07-16T19:54:46Z",
              "updatedAt": "2018-07-17T15:47:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM3NjgyMjkz",
          "commit": {
            "abbreviatedOid": "a7d1809"
          },
          "author": "Scratch-net",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-17T05:43:59Z",
          "updatedAt": "2018-07-17T05:43:59Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Agree ) ",
              "createdAt": "2018-07-17T05:43:59Z",
              "updatedAt": "2018-07-17T15:47:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM3Njg1Nzgy",
          "commit": {
            "abbreviatedOid": "a7d1809"
          },
          "author": "Scratch-net",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-17T06:06:06Z",
          "updatedAt": "2018-07-17T06:06:06Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Fixed ",
              "createdAt": "2018-07-17T06:06:06Z",
              "updatedAt": "2018-07-17T15:47:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM3ODk0MTA0",
          "commit": {
            "abbreviatedOid": "69b7e63"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-17T15:44:02Z",
          "updatedAt": "2018-07-17T15:44:02Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Apple Keyboard ? When I press 9, 99 appears... ;P",
              "createdAt": "2018-07-17T15:44:02Z",
              "updatedAt": "2018-07-17T15:47:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM3ODk0ODMz",
          "commit": {
            "abbreviatedOid": "69b7e63"
          },
          "author": "Scratch-net",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-17T15:45:34Z",
          "updatedAt": "2018-07-17T15:45:34Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Ah, mess, no, windows ) fill fix",
              "createdAt": "2018-07-17T15:45:34Z",
              "updatedAt": "2018-07-17T15:47:22Z"
            }
          ]
        }
      ]
    },
    {
      "number": 51,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk4ODA1NDU0",
      "title": "Introducing TreeKEM as a Group Key Exchange for IETF 102",
      "url": "https://github.com/mlswg/mls-protocol/pull/51",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "functionality",
        "performance",
        "privacy",
        "security"
      ],
      "body": "This PR contains several changes that I just wanted to get in for the IETF 102 deadline.\r\n\r\n* Add TreeKEM as an option (leveraging some Beurdouche work)\r\n* Refactor GroupAdd to always do \"simulated UserAdd\"\r\n* Delete -> Remove\r\n",
      "createdAt": "2018-07-02T22:29:26Z",
      "updatedAt": "2019-12-17T09:47:07Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "54420306144c793c18e8aa32268844c341a626f4",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "treekem-rlb",
      "headRefOid": "802d499877be05c63be3a318088c29caee4121c7",
      "closedAt": "2018-07-02T22:33:49Z",
      "mergedAt": "2018-07-02T22:33:48Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "2a065e72717e7d15cee27e0b7fb464eab5b177c6"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 52,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAxNDY4ODcy",
      "title": "fix broken art",
      "url": "https://github.com/mlswg/mls-protocol/pull/52",
      "state": "MERGED",
      "author": "josephlhall",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "not sure what was happening here, but moving to the three tilde fixes it.",
      "createdAt": "2018-07-14T20:58:10Z",
      "updatedAt": "2019-12-17T09:45:27Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "702556a14b793923771f5a61e5d832e96bebf5ed",
      "headRepository": "josephlhall/mls-protocol",
      "headRefName": "master",
      "headRefOid": "8ce1e1185df9d987be8fda993e2ae67b3ad9ec48",
      "closedAt": "2018-07-16T16:10:04Z",
      "mergedAt": "2018-07-16T16:10:04Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "676785d1f4530b0627e194c161384bf2f9b40c64"
      },
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Thanks.",
          "createdAt": "2018-07-16T16:10:14Z",
          "updatedAt": "2018-07-16T16:10:14Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 53,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAxNjg5OTQz",
      "title": "Minor fixes for figure and text after adding TreeKEM",
      "url": "https://github.com/mlswg/mls-protocol/pull/53",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-07-16T16:22:10Z",
      "updatedAt": "2019-12-17T10:11:32Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "676785d1f4530b0627e194c161384bf2f9b40c64",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "upstream/beurdouche_fix_treekem",
      "headRefOid": "75370010be1794fc3a9111178b7dc725d7e92ae0",
      "closedAt": "2018-07-16T16:49:31Z",
      "mergedAt": "2018-07-16T16:49:31Z",
      "mergedBy": "raphaelrobert",
      "mergeCommit": {
        "oid": "c81dd324d4e8a894766d5965c78f6d4ad68907ad"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 54,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAxNjkwNzc3",
      "title": "Message Protection",
      "url": "https://github.com/mlswg/mls-protocol/pull/54",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "functionality",
        "performance",
        "privacy",
        "security"
      ],
      "body": "This is one of the options regarding Message Protection discussed in Montreal...",
      "createdAt": "2018-07-16T16:25:35Z",
      "updatedAt": "2019-12-17T09:44:40Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "2437780914c5d0325f08c53cad79258d8d4aa6b4",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "upstream/beurdouche_msgprotection",
      "headRefOid": "630e0594c70ee3da1a1954b906001ac401edf9f9",
      "closedAt": "2018-09-14T17:09:35Z",
      "mergedAt": "2018-09-14T17:09:35Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "eca365da10223eef64eda050427fc07c5f5ac254"
      },
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "@raphaelrobert Fixed ! Thanks Rapha\u00ebl !",
          "createdAt": "2018-08-29T15:45:11Z",
          "updatedAt": "2018-08-29T15:45:11Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUwMjg4ODUz",
          "commit": {
            "abbreviatedOid": "63204bf"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-08-28T19:50:58Z",
          "updatedAt": "2018-08-28T20:51:08Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "Why is this SHOULD and not a MUST? Presumably it's an interop failure if they don't, right?",
              "createdAt": "2018-08-28T19:50:59Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 61,
              "body": "Don't use the term non-repudiability here. It's a hot button. Say rather \"to authenticate the message from a particular member, signatures are required\"",
              "createdAt": "2018-08-28T19:52:00Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 63,
              "body": "The ciphersuite does not specify a signature scheme.",
              "createdAt": "2018-08-28T19:53:32Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 67,
              "body": "bound",
              "createdAt": "2018-08-28T19:53:55Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 73,
              "body": "This sentence is grammatically problematic. Provide the justification first and then the instruction.",
              "createdAt": "2018-08-28T19:54:40Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 76,
              "body": "This is not going to be obvious. You want to say something about what that bound is.",
              "createdAt": "2018-08-28T19:55:20Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 78,
              "body": "Is this just redundant with the previous sentence.",
              "createdAt": "2018-08-28T19:55:35Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 83,
              "body": "You can't just say this is obvious. You need to explain it.",
              "createdAt": "2018-08-28T19:55:55Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 88,
              "body": "summarized. Also, what's the colon doing after this sentence.",
              "createdAt": "2018-08-28T19:56:09Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 99,
              "body": "Why are you expanding with sender here? IT's not necessary if you did it previously. Similarly, put the \"mls app\" labels elsewhere and just do \"key\" and\"iv\"\r\n\r\nAlso, \"key\", and \"iv\" are ",
              "createdAt": "2018-08-28T19:57:02Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 135,
              "body": "You already said this.",
              "createdAt": "2018-08-28T19:57:27Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 140,
              "body": "I don't understand this text. You have separate chains for each sender, so why do you need to synchronize these.",
              "createdAt": "2018-08-28T19:58:06Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 151,
              "body": "This just all seems kind of confused about the model",
              "createdAt": "2018-08-28T19:59:59Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 210,
              "body": "See above about should, must, etc.",
              "createdAt": "2018-08-28T20:38:16Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 216,
              "body": "How do I know how long signature_length is? There's no guarantee that all algorithms will have fixed-length sigs.",
              "createdAt": "2018-08-28T20:39:05Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 221,
              "body": "a 4 GB group identifier seems very long. Is this supposed to be sonething different?",
              "createdAt": "2018-08-28T20:40:26Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 222,
              "body": "Should this just be |epoch|",
              "createdAt": "2018-08-28T20:40:37Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 226,
              "body": "Typically you would do this as opaque encrypted_content<0..2^32-1>;",
              "createdAt": "2018-08-28T20:41:12Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 240,
              "body": "This field does not seem to appear. Is it now called |generation|",
              "createdAt": "2018-08-28T20:41:47Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 245,
              "body": "It looks to me like this structure would let me transplant messages between groups, right? I get that nonrepudiation has that structure in general, but it seems worse in this case, because without signing the metadata I can transplant things undetectably.",
              "createdAt": "2018-08-28T20:44:27Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 250,
              "body": "reasonable.",
              "createdAt": "2018-08-28T20:44:49Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 254,
              "body": "What does enforced mean here? That the receiver or the sender?",
              "createdAt": "2018-08-28T20:47:43Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 258,
              "body": "traditional",
              "createdAt": "2018-08-28T20:47:50Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 269,
              "body": "How is it implemented above?",
              "createdAt": "2018-08-28T20:48:16Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 276,
              "body": "or the leaf keys, right?",
              "createdAt": "2018-08-28T20:50:01Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 282,
              "body": "This is pretty vague. At least leave a placeholder for a real discussion.",
              "createdAt": "2018-08-28T20:50:28Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 289,
              "body": "This whole section feels kind of rushed. What do (say) Wire and Allo use for keeping old keys?",
              "createdAt": "2018-08-28T20:51:02Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUwMzMxOTc3",
          "commit": {
            "abbreviatedOid": "63204bf"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Thanks @ekr ! I fixed bunch of issues you mentioned that weren't caught by previous reviews.\r\n\r\nI added a few TODOs to cover some of the items you suggested, but since the PR adds already a lot of text I didn't wanted to define more things (ie. like the way the signature algorithm is selected: ciphersuite or negotiation...). ",
          "createdAt": "2018-08-28T21:51:41Z",
          "updatedAt": "2018-08-28T22:11:11Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-08-28T21:51:41Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 61,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-08-28T21:57:54Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 67,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-08-28T21:57:58Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 73,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-08-28T21:58:00Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 76,
              "body": "Rephrased and added an [TODO]",
              "createdAt": "2018-08-28T21:58:02Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 78,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-08-28T21:58:04Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 83,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-08-28T21:58:05Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 88,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-08-28T21:58:10Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 99,
              "body": "Fixed. Label were leftovers, because the same diagram could be used for both per-participant and group chainings. Thanks !",
              "createdAt": "2018-08-28T21:58:20Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 135,
              "body": "Fixed.",
              "createdAt": "2018-08-28T21:58:28Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 140,
              "body": "Fixed, Thanks ! Leftovers from the multi-proposal PR.",
              "createdAt": "2018-08-28T21:58:32Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 151,
              "body": "Rewrote this ! Thanks",
              "createdAt": "2018-08-28T21:58:58Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 210,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-08-28T22:00:02Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 216,
              "body": "Went for `opaque signature<0..2^32-1>;`",
              "createdAt": "2018-08-28T22:00:28Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 221,
              "body": "Changed to a 32 byte identifier for now",
              "createdAt": "2018-08-28T22:00:52Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 222,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-08-28T22:01:18Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 226,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-08-28T22:01:22Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 240,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-08-28T22:02:06Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 245,
              "body": "Nice catch, as you said the signature must cover the metadata (typically gid, epoch, generation).\r\nI rephrased",
              "createdAt": "2018-08-28T22:03:47Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 250,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-08-28T22:03:51Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 254,
              "body": "I rephrased to something like \"Application messages should be padded to provide some resistance to traffic analysis\"",
              "createdAt": "2018-08-28T22:04:48Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 258,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-08-28T22:04:52Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 269,
              "body": "Added a TODO.",
              "createdAt": "2018-08-28T22:05:44Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 276,
              "body": "I rephrased and expanded to say that anything that can be used to re-derive keys should disappear as well.\r\n",
              "createdAt": "2018-08-28T22:06:52Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 282,
              "body": "Added a discussion item.",
              "createdAt": "2018-08-28T22:07:11Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 289,
              "body": "Javascript lol ?",
              "createdAt": "2018-08-28T22:07:31Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUwNDYwNjA2",
          "commit": {
            "abbreviatedOid": "e7e108f"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-29T08:47:48Z",
          "updatedAt": "2018-08-29T08:47:48Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "is not -> does not",
              "createdAt": "2018-08-29T08:47:48Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUwNDYwODcy",
          "commit": {
            "abbreviatedOid": "e7e108f"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-29T08:48:32Z",
          "updatedAt": "2018-08-29T08:56:15Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "his -> their",
              "createdAt": "2018-08-29T08:48:32Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 233,
              "body": "provide",
              "createdAt": "2018-08-29T08:52:54Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUwMzUzODc0",
          "commit": {
            "abbreviatedOid": "e7e108f"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-08-28T23:23:47Z",
          "updatedAt": "2018-08-31T22:14:41Z",
          "comments": [
            {
              "originalPosition": 178,
              "body": "But how does this work? You need to define the input to the signature fxn.",
              "createdAt": "2018-08-28T23:23:47Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 9,
              "body": "Doesn't basically everything here change the wire protocol",
              "createdAt": "2018-08-31T22:03:35Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 74,
              "body": "I would just have \"mls\" as part of the basic label in HKDF-Expand_Label",
              "createdAt": "2018-08-31T22:05:21Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 102,
              "body": "I think you want to say here that you should use signatures, but the rules about what algorithm are used are kind of separate.",
              "createdAt": "2018-08-31T22:06:15Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 110,
              "body": "each message sent.",
              "createdAt": "2018-08-31T22:06:34Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 113,
              "body": "I'm not sure what this says.\r\n",
              "createdAt": "2018-08-31T22:06:53Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 120,
              "body": "I'm not following this. The rules here require one AEAD per key/nonce pair.",
              "createdAt": "2018-08-31T22:07:24Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 142,
              "body": "If you use the nonce directly like this rather than as an IV mask on message seq, then you absolutely can never use the same keys twice.",
              "createdAt": "2018-08-31T22:08:42Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 180,
              "body": "There is no good reason for this restriction. It doesn't make the key schedule any easier.",
              "createdAt": "2018-08-31T22:09:35Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 186,
              "body": "This is still pretty confused. Because the application secrets are per-sender, and the nonce is derived directly, you absolutely must use each application secret once.\r\n\r\n",
              "createdAt": "2018-08-31T22:10:12Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 216,
              "body": "This section is in conflict with the previous section.",
              "createdAt": "2018-08-31T22:10:45Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 268,
              "body": "This is ungrammatical/",
              "createdAt": "2018-08-31T22:11:23Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 271,
              "body": "This is not a normative requirement, because the normative requirement is the structure below. Just move this to afterwards and then use it as an explanation for why.",
              "createdAt": "2018-08-31T22:11:50Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 313,
              "body": "1. This isn't a reasonable requirement because \"above\" is the entire app.\r\n2. The sender is the one who decides whether to pad but the receiver is the one you want to have constant time, so this is not an enforceable must.\r\n",
              "createdAt": "2018-08-31T22:13:31Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 322,
              "body": "This is ungrammatical. \r\n\r\n",
              "createdAt": "2018-08-31T22:14:17Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 328,
              "body": "Why?",
              "createdAt": "2018-08-31T22:14:27Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 334,
              "body": "No, see above.",
              "createdAt": "2018-08-31T22:14:37Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUxNTY0NDgw",
          "commit": {
            "abbreviatedOid": "234897d"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Thanks @ekr ! I made a bunch of changes to resolve your comments. It seems there was still some legacy text that was conflicting.",
          "createdAt": "2018-08-31T22:26:57Z",
          "updatedAt": "2018-08-31T23:58:58Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Added the `*` for all listed items.",
              "createdAt": "2018-08-31T22:26:57Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 74,
              "body": "I am keeping it for \"symmetry\" with the other labels.",
              "createdAt": "2018-08-31T22:29:55Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 102,
              "body": "I removed the last part of the sentence. We can add rules back when we deal with authentication later.",
              "createdAt": "2018-08-31T22:31:00Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 110,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-08-31T22:31:13Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 113,
              "body": "I rewrote the sentence, the intent was to say that the next application message is gonna be used to derive fresh AEAD key/nonce for the future message.",
              "createdAt": "2018-08-31T22:40:20Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 120,
              "body": "I removed this. It was a leftover from an old scenario where we could encrypt multiple messages under the same key.",
              "createdAt": "2018-08-31T22:48:31Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 142,
              "body": "Yes, I believe this is the intent, you wouldn't even get forward secrecy for messages otherwise.",
              "createdAt": "2018-08-31T22:49:11Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 180,
              "body": "I removed it, indeed this is not necessary for the current scenario, it was for the group-chaining scenario.\r\nTo get causal consistency, we only need senders to monotonically increment their generation.",
              "createdAt": "2018-08-31T22:51:15Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 186,
              "body": "I removed this because it was a leftover of the non-monotonic handling of the counters for the group-chaining version.",
              "createdAt": "2018-08-31T23:02:36Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 216,
              "body": "Fixed. Thanks !",
              "createdAt": "2018-08-31T23:08:34Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 268,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-08-31T23:15:07Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 271,
              "body": "Reordered and made a minor rewrite to eliminate more grammatical mistakes.",
              "createdAt": "2018-08-31T23:15:53Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 313,
              "body": "Fair enough, I slightly changed the paragraph and moved to say that the padding removal SHOULD be implemented in constant time.",
              "createdAt": "2018-08-31T23:27:03Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 322,
              "body": "Thanks, I reworked the phrasing.",
              "createdAt": "2018-08-31T23:40:35Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 328,
              "body": "I updated the text, actually we MUST NOT keep the previous application secret when we chain, we have to retain the key/nonce for an out-of-order message that we didn't receive yet otherwise I am quite sure we loose FS.",
              "createdAt": "2018-08-31T23:44:30Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 334,
              "body": "I removed that part, it was due to the group-chaining variant.",
              "createdAt": "2018-08-31T23:54:52Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUxNTc2MDQ0",
          "commit": {
            "abbreviatedOid": "50a4959"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Getting closer.",
          "createdAt": "2018-09-01T00:09:52Z",
          "updatedAt": "2018-09-01T00:14:15Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "Why in most cases? It should never happen.",
              "createdAt": "2018-09-01T00:09:52Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 86,
              "body": "This text generally seems like it needs work:\r\n\r\nThe rules are these:\r\n\r\n1. Senders MUST only use each secret once\r\n2. Receivers MUST delete an application secret once it has been used to successfully decrypt something.\r\n3. Receivers SHOULD delete application secrets once any newer application secret has been used but MAY keep the corresponding leaf keys around for some reasonable period.\r\n",
              "createdAt": "2018-09-01T00:12:10Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 66,
              "body": "This is ungrammatical.",
              "createdAt": "2018-09-01T00:13:03Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 127,
              "body": "My point is that this wasn't normative. It's just descriptive. So the MUST should not be capitalized.",
              "createdAt": "2018-09-01T00:13:37Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 146,
              "body": "Is it used for that? IT's more about message size side chanels.",
              "createdAt": "2018-09-01T00:14:00Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyMjM4NzE0",
          "commit": {
            "abbreviatedOid": "50a4959"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Thanks @ekr : )",
          "createdAt": "2018-09-04T20:25:35Z",
          "updatedAt": "2018-09-04T20:27:05Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-09-04T20:25:35Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 86,
              "body": "I rewrote this part. Thanks !",
              "createdAt": "2018-09-04T20:26:04Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 127,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-09-04T20:26:12Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 146,
              "body": "Yeah, tired I guess : ) Fixed, Thanks !",
              "createdAt": "2018-09-04T20:26:33Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzNzI0NDc4",
          "commit": {
            "abbreviatedOid": "aac4efd"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-09-10T11:07:38Z",
          "updatedAt": "2018-09-10T11:14:13Z",
          "comments": [
            {
              "originalPosition": 74,
              "body": "OK, but we should remove all of these",
              "createdAt": "2018-09-10T11:07:38Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 142,
              "body": "Well, this way you would get key reuse.",
              "createdAt": "2018-09-10T11:09:33Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 201,
              "body": "This doesn't seem quite right. You MUST discard those as soon as used.",
              "createdAt": "2018-09-10T11:10:26Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 225,
              "body": "This seems to duplicate the daigram above.",
              "createdAt": "2018-09-10T11:11:10Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 240,
              "body": "This duplicates a statement above",
              "createdAt": "2018-09-10T11:11:23Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 245,
              "body": "```\r\nopaque content<0..2^32-1>\r\n```",
              "createdAt": "2018-09-10T11:11:48Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 246,
              "body": "How is this actually going to work? There might be multiple signing keys, right?",
              "createdAt": "2018-09-10T11:12:27Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 279,
              "body": "You don't say how this structure is to be used.",
              "createdAt": "2018-09-10T11:13:15Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 277,
              "body": "```\r\nopaque content<0..2^32-1>;\r\n```",
              "createdAt": "2018-09-10T11:13:27Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 272,
              "body": "I would make a type for this.",
              "createdAt": "2018-09-10T11:13:46Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzNzMzNTgy",
          "commit": {
            "abbreviatedOid": "aac4efd"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-10T11:39:11Z",
          "updatedAt": "2018-09-10T12:08:18Z",
          "comments": [
            {
              "originalPosition": 74,
              "body": "Ok, I removed all of them for now. Though I liked the idea of having the \"MLS\" prefix in the label... ",
              "createdAt": "2018-09-10T11:39:11Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 142,
              "body": "That is not what I meant indeed, so I removed the `_[sender]` suffixes",
              "createdAt": "2018-09-10T11:40:48Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 201,
              "body": "Indeed, I made the requirement stronger...",
              "createdAt": "2018-09-10T11:47:59Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 225,
              "body": "Removed it.",
              "createdAt": "2018-09-10T12:02:18Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 240,
              "body": "I didn't find a good way to remove the duplication atm. Let's do this in the next iteration, someone more skilled in english than me should polish the text after anyway...",
              "createdAt": "2018-09-10T12:03:08Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 245,
              "body": "Fixed",
              "createdAt": "2018-09-10T12:03:17Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 246,
              "body": "We only have a single identity key per participant at the moment.",
              "createdAt": "2018-09-10T12:04:01Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 277,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-09-10T12:07:01Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 279,
              "body": "I rephrased to \"The signature used in the MLSPlaintext is computed over the MLSSignatureContent\r\nwhich covers the metadata ...\"",
              "createdAt": "2018-09-10T12:07:29Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzNzQzMDEx",
          "commit": {
            "abbreviatedOid": "660b41c"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-10T12:10:38Z",
          "updatedAt": "2018-09-10T12:10:38Z",
          "comments": [
            {
              "originalPosition": 272,
              "body": "I don't think that it is necessary to do it now; it seems quite self contained anyway...",
              "createdAt": "2018-09-10T12:10:38Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzOTg1ODEw",
          "commit": {
            "abbreviatedOid": "660b41c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I think this is ready to land with these comments addressed.",
          "createdAt": "2018-09-10T22:17:16Z",
          "updatedAt": "2018-09-10T22:31:54Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "This tag isn't necessary.  Kramdown automatically makes a tag of this character from the content of the heading.",
              "createdAt": "2018-09-10T22:17:16Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 81,
              "body": "If you're going to use `application_secret_[0]`, this should be `init_secret_[n]`.",
              "createdAt": "2018-09-10T22:18:04Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 240,
              "body": "This isn't necessary.  In practice, it will be provided by application context, and it will be authenticated by including it under the message signature.",
              "createdAt": "2018-09-10T22:22:24Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 244,
              "body": "This is redundant; the vector provides its own length.",
              "createdAt": "2018-09-10T22:22:45Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 272,
              "body": "Assuming we're going to land #59, It seems like we can just use the `GroupState`:\r\n\r\n```\r\nstruct {\r\n    GroupState state; // includes epoch, group_id\r\n    uint32 sender;\r\n    uint32 generation;\r\n    opaque content<0..2^32-1>;\r\n} MLSSignatureContent;\r\n```\r\n\r\nIf we agree that's the right path, we can just land this as-is, and I'll update #59 to patch it.",
              "createdAt": "2018-09-10T22:24:58Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 304,
              "body": "I don't think this is necessary.",
              "createdAt": "2018-09-10T22:26:36Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 246,
              "body": "For consistency with the prose above, I might call this an `Application` message, and `MLSPlaintext -> ApplicationPlaintext`.  It may be that once we get to handshake encryption, we'll want a record layer that's more TLS-like (and thus usable for encrypting both Application and Handshake messages.  But for now, this is specific to `Application` messages.",
              "createdAt": "2018-09-10T22:31:17Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0MDAyMzkw",
          "commit": {
            "abbreviatedOid": "660b41c"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "@bifurcation Fixed, Thanks :)",
          "createdAt": "2018-09-10T23:26:43Z",
          "updatedAt": "2018-09-10T23:43:24Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-09-10T23:26:43Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 81,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-09-10T23:27:42Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 244,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-09-10T23:29:50Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 240,
              "body": "This is because you think of it as an ID for the conversation, while I think of it as an ID over the conversation AND a specific set of users. Also, I don't think we should depend on the Application for this but the opposite.",
              "createdAt": "2018-09-10T23:34:57Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 246,
              "body": "Ack, fixed.",
              "createdAt": "2018-09-10T23:36:17Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 272,
              "body": "Let's patch it up on your side. I am still not convinced by the `GroupState` thing, so let's wait and see what others think :)",
              "createdAt": "2018-09-10T23:39:07Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 304,
              "body": "Removed, Thanks !",
              "createdAt": "2018-09-10T23:39:32Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0ODMzMDQ4",
          "commit": {
            "abbreviatedOid": "951c4d4"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-09-12T20:37:18Z",
          "updatedAt": "2018-09-12T20:39:02Z",
          "comments": [
            {
              "originalPosition": 129,
              "body": "Actually, it occurs to me that you have a simultaneous-send issue here -- two senders can chose to transmit based on the same application secret, and then you have nonce reuse, which I hear is bad.\r\n\r\nAt the IETF meeting, we had discussed two potential approaches here:\r\n\r\n1. Per-sender hash ratchets\r\n2. A single hash ratchet for the group folding in sender information at key/nonce generation time\r\n\r\nYou need to do one of those here.  I continue to prefer the second one, and it is a smaller delta on what you have here.  You would just need to change the \"\" in the nonce/key derivations to some encoding of the sender ID.",
              "createdAt": "2018-09-12T20:37:19Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 136,
              "body": "Is there a reason this is `Derive-Secret` instead of `Hkdf-Expand-Label` [as in TLS 1.3](https://tools.ietf.org/html/rfc8446#section-7.2)?",
              "createdAt": "2018-09-12T20:37:47Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 139,
              "body": "The diagram below this should be deleted.",
              "createdAt": "2018-09-12T20:38:40Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 146,
              "body": "Extra blank line",
              "createdAt": "2018-09-12T20:38:53Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0ODM5MDAx",
          "commit": {
            "abbreviatedOid": "951c4d4"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-12T20:53:06Z",
          "updatedAt": "2018-09-12T20:53:06Z",
          "comments": [
            {
              "originalPosition": 129,
              "body": "No they can't do it, maybe it is not clear enough but this is the per-sender chaining here, so the Participant application secret is used...",
              "createdAt": "2018-09-12T20:53:06Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0ODM5NDQy",
          "commit": {
            "abbreviatedOid": "951c4d4"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-12T20:54:14Z",
          "updatedAt": "2018-09-12T20:54:14Z",
          "comments": [
            {
              "originalPosition": 136,
              "body": "This is a secret to secret derivation so there is no need to expand yes ?",
              "createdAt": "2018-09-12T20:54:14Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0ODQwMTQ4",
          "commit": {
            "abbreviatedOid": "951c4d4"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-12T20:56:12Z",
          "updatedAt": "2018-09-12T20:56:12Z",
          "comments": [
            {
              "originalPosition": 129,
              "body": "\"each participant's Application secret chain looks as follows after the initial\r\nderivation:\"",
              "createdAt": "2018-09-12T20:56:12Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0ODU3MTk3",
          "commit": {
            "abbreviatedOid": "82a2030"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-12T21:45:05Z",
          "updatedAt": "2018-09-12T21:51:06Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "Thanks, this is clearer.  Two minor edits / quetions:\r\n\r\nHowever, the subscripts should indicate that this is a fanout.  I would propose having the root be something like `application_secret` (no subscript), then have the specific application secrets be double-subscripted, e.g., `app_secret_[sender]_[0]`.\r\n\r\nYou might want to use a separate label (app sender?) for this stage as opposed to the linear updates.",
              "createdAt": "2018-09-12T21:45:06Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 152,
              "body": "Same comment about subscripting",
              "createdAt": "2018-09-12T21:45:38Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0ODYyNTAw",
          "commit": {
            "abbreviatedOid": "82a2030"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-12T22:03:10Z",
          "updatedAt": "2018-09-12T22:04:49Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "Fixed, Thanks ! : )",
              "createdAt": "2018-09-12T22:03:10Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 152,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-09-12T22:03:21Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0ODY5OTAw",
          "commit": {
            "abbreviatedOid": "5a58f25"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-09-12T22:33:26Z",
          "updatedAt": "2018-09-12T22:33:26Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU1NTI2ODY3",
          "commit": {
            "abbreviatedOid": "5a58f25"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I'm going to approve this in the interest of moving forward, but it still is pretty rough.",
          "createdAt": "2018-09-14T14:42:53Z",
          "updatedAt": "2018-09-14T14:48:24Z",
          "comments": [
            {
              "originalPosition": 162,
              "body": "This is basically unreadable. I guess it's OK because it's in an OPEN ISSUE, but...",
              "createdAt": "2018-09-14T14:42:53Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 177,
              "body": "You probably need to sharpen this point becauseit's a much more important security consideration than the next two.",
              "createdAt": "2018-09-14T14:43:20Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 272,
              "body": "Please make an open issue marker.",
              "createdAt": "2018-09-14T14:43:51Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 271,
              "body": "\"to avoid...\" -> \"to prevent Group participants from impersonating\"",
              "createdAt": "2018-09-14T14:45:59Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 278,
              "body": "\"more than\"",
              "createdAt": "2018-09-14T14:46:13Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 280,
              "body": "\"leaking an interval\" isn't clear.",
              "createdAt": "2018-09-14T14:46:26Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 287,
              "body": "\"less susceptible to serve\" is ungrammatical",
              "createdAt": "2018-09-14T14:46:48Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 291,
              "body": "leaked to the adversary by the ciphertext length",
              "createdAt": "2018-09-14T14:47:07Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 295,
              "body": "padding with zero-valued bytes before AEAD encryption",
              "createdAt": "2018-09-14T14:47:21Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 300,
              "body": "at the MLS layer and above layers",
              "createdAt": "2018-09-14T14:47:41Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 309,
              "body": "If they are able to retrieve ... participants can decrypt",
              "createdAt": "2018-09-14T14:48:04Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU1NTUxMjY1",
          "commit": {
            "abbreviatedOid": "5a58f25"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Improvements according to Ekr's comments...",
          "createdAt": "2018-09-14T15:38:55Z",
          "updatedAt": "2018-09-14T16:44:56Z",
          "comments": [
            {
              "originalPosition": 162,
              "body": "I rewrote this. The issue is meant to make sure we make sure we have everything we need in the HKDF context to achieve our security goal. For a per-participant chaining like we have now, the current empty context seems ok, but we'll have to make sure.",
              "createdAt": "2018-09-14T15:38:55Z",
              "updatedAt": "2018-09-14T16:44:56Z"
            },
            {
              "originalPosition": 177,
              "body": "I added a mention to Forward Secrecy here.",
              "createdAt": "2018-09-14T16:20:09Z",
              "updatedAt": "2018-09-14T16:44:56Z"
            },
            {
              "originalPosition": 272,
              "body": "Done.",
              "createdAt": "2018-09-14T16:24:48Z",
              "updatedAt": "2018-09-14T16:44:56Z"
            },
            {
              "originalPosition": 271,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-09-14T16:26:15Z",
              "updatedAt": "2018-09-14T16:44:56Z"
            },
            {
              "originalPosition": 278,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-09-14T16:26:37Z",
              "updatedAt": "2018-09-14T16:44:56Z"
            },
            {
              "originalPosition": 280,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-09-14T16:27:30Z",
              "updatedAt": "2018-09-14T16:44:56Z"
            },
            {
              "originalPosition": 287,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-09-14T16:30:17Z",
              "updatedAt": "2018-09-14T16:44:56Z"
            },
            {
              "originalPosition": 291,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-09-14T16:33:43Z",
              "updatedAt": "2018-09-14T16:44:56Z"
            },
            {
              "originalPosition": 295,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-09-14T16:36:21Z",
              "updatedAt": "2018-09-14T16:44:56Z"
            },
            {
              "originalPosition": 300,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-09-14T16:36:34Z",
              "updatedAt": "2018-09-14T16:44:56Z"
            },
            {
              "originalPosition": 309,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-09-14T16:39:40Z",
              "updatedAt": "2018-09-14T16:44:56Z"
            }
          ]
        }
      ]
    },
    {
      "number": 55,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA4Njc2NTIz",
      "title": "Rename from draft-barnes to draft-ietf",
      "url": "https://github.com/mlswg/mls-protocol/pull/55",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Note: If you have an existing clone, you will need to delete `.targets.mk` at the root level of the clone in order for `make submit` to work. (`make` will still work fine)",
      "createdAt": "2018-08-15T20:46:06Z",
      "updatedAt": "2019-12-17T09:44:18Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "c81dd324d4e8a894766d5965c78f6d4ad68907ad",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "rename",
      "headRefOid": "2835872e13ecf62222239007306d5217e8f8ef21",
      "closedAt": "2018-08-15T20:47:26Z",
      "mergedAt": "2018-08-15T20:47:26Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "ab13578981f8eb60efced50f0b2573917a512a3d"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 56,
      "id": "MDExOlB1bGxSZXF1ZXN0MjEwMTI1ODk0",
      "title": "TLS 1.3 has become RFC 8446",
      "url": "https://github.com/mlswg/mls-protocol/pull/56",
      "state": "MERGED",
      "author": "loganaden",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-08-22T13:01:40Z",
      "updatedAt": "2019-12-17T09:44:07Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "2437780914c5d0325f08c53cad79258d8d4aa6b4",
      "headRepository": "loganaden/mls-protocol",
      "headRefName": "master",
      "headRefOid": "70c335ae15b7a2901a9ef9298e1bb85c63215fd8",
      "closedAt": "2018-08-31T21:40:44Z",
      "mergedAt": "2018-08-31T21:40:44Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "2e74d28dba77b3dc4d1345508347f6b916f01b38"
      },
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Thanks !",
          "createdAt": "2018-08-31T21:46:20Z",
          "updatedAt": "2018-08-31T21:46:20Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUxNTUwNTgz",
          "commit": {
            "abbreviatedOid": "70c335a"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-08-31T21:14:24Z",
          "updatedAt": "2018-08-31T21:14:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 58,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE0NDI1MTk3",
      "title": "Remove UserAdd",
      "url": "https://github.com/mlswg/mls-protocol/pull/58",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bifurcation"
      ],
      "labels": [
        "functionality",
        "security"
      ],
      "body": "I would like to remove the UserAdd functionality that's in the current document, and the GroupInitKey construct that supports it.  We will need to support a flow where a device can join without an explicit invite.  But that mechanism will also have to be limited,  since it leaks information out of the group.  It will be cleaner to get a GroupAdd-only system working first, then figure out how to add this back in.",
      "createdAt": "2018-09-10T19:54:42Z",
      "updatedAt": "2019-12-17T09:43:59Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "2e74d28dba77b3dc4d1345508347f6b916f01b38",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "remove-user-add",
      "headRefOid": "fdbbe78d3557df36b45b9d305bb376270d498a80",
      "closedAt": "2018-09-12T20:30:10Z",
      "mergedAt": "2018-09-12T20:30:10Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "f3f2fd32e77da19338c2e4915ddd0e8f1e233901"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0MDMxMjU5",
          "commit": {
            "abbreviatedOid": "223aa99"
          },
          "author": "suhasHere",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-11T02:31:33Z",
          "updatedAt": "2018-09-11T02:31:33Z",
          "comments": [
            {
              "originalPosition": 258,
              "body": "nit: should we include info about  identity frontier and ratcher_frontier inclusion in the above para ?",
              "createdAt": "2018-09-11T02:31:33Z",
              "updatedAt": "2018-09-12T20:29:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0MDMxNzU3",
          "commit": {
            "abbreviatedOid": "223aa99"
          },
          "author": "suhasHere",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-11T02:35:44Z",
          "updatedAt": "2018-09-11T02:35:44Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "since we no longer have groupInitKeys, should we remove the \"or group\" part of the sentence above ?",
              "createdAt": "2018-09-11T02:35:44Z",
              "updatedAt": "2018-09-12T20:29:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0MDMxOTE3",
          "commit": {
            "abbreviatedOid": "223aa99"
          },
          "author": "suhasHere",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "Small claritifcation questions .. otherwise LGTM\r\n\ud83d\udc4d ",
          "createdAt": "2018-09-11T02:37:03Z",
          "updatedAt": "2018-09-11T02:37:03Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0MTUyODM2",
          "commit": {
            "abbreviatedOid": "223aa99"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "I think the (temporary) simplification makes sense. LGTM except for the missing definitions mentioned in-line.",
          "createdAt": "2018-09-11T11:07:40Z",
          "updatedAt": "2018-09-11T11:08:51Z",
          "comments": [
            {
              "originalPosition": 258,
              "body": "I agree that those definitions would make sense.",
              "createdAt": "2018-09-11T11:07:40Z",
              "updatedAt": "2018-09-12T20:29:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0ODI5ODQw",
          "commit": {
            "abbreviatedOid": "223aa99"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-12T20:28:59Z",
          "updatedAt": "2018-09-12T20:28:59Z",
          "comments": [
            {
              "originalPosition": 258,
              "body": "Done, though note that this whole section will get overwritten by #59  :)",
              "createdAt": "2018-09-12T20:28:59Z",
              "updatedAt": "2018-09-12T20:29:57Z"
            }
          ]
        }
      ]
    },
    {
      "number": 59,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE0NDQ0MzQ0",
      "title": "Authn v2",
      "url": "https://github.com/mlswg/mls-protocol/pull/59",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bifurcation"
      ],
      "labels": [
        "functionality",
        "security"
      ],
      "body": "This PR reflects a concrete scheme on top of #58 that implements the authentication framework discussed on the list recently.  There are a few major changes:\r\n\r\n* Defines a `GroupState` structure that is incorporated into the key schedule and signatures\r\n* Adds a `Welcome` message that provisions a new member with roster and tree information\r\n* Removes the Merkle tree over group identities (and related definitions), since all participants now keep the full roster",
      "createdAt": "2018-09-10T21:06:48Z",
      "updatedAt": "2019-12-17T09:43:41Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "eca365da10223eef64eda050427fc07c5f5ac254",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "authn-v2",
      "headRefOid": "1e6c2915f1a1bcd9529f7d053930428b61fc60db",
      "closedAt": "2018-09-19T21:50:28Z",
      "mergedAt": "2018-09-19T21:50:28Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "414b7008c89986e21fc93a067ee174a1bc76e78d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzOTcyMDg1",
          "commit": {
            "abbreviatedOid": "bb1c658"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-09-10T21:32:54Z",
          "updatedAt": "2018-09-10T21:35:11Z",
          "comments": [
            {
              "originalPosition": 118,
              "body": "`transcript_hash` is not defined anywhere AFAICT",
              "createdAt": "2018-09-10T21:32:54Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 143,
              "body": "affects -> effects",
              "createdAt": "2018-09-10T21:34:24Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzOTg2MTk1",
          "commit": {
            "abbreviatedOid": "95f121c"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Globally I think this goes in the right direction but I have a few concerns:\r\n+ I am fine with removing `GroupAdd` for now\r\n- I would have preferred to keep the paragraph on TreeKEM\r\n- Even though I understand factoring out everything into  `GroupState` structure can be helpful, we should avoid using it for everything (like in the Key Schedule and Handshake messages <> Add) when we only need to use specific information. I think it was better before.",
          "createdAt": "2018-09-10T22:18:12Z",
          "updatedAt": "2018-09-10T23:23:20Z",
          "comments": [
            {
              "originalPosition": 256,
              "body": "Can you please replace`2^24-1` sizes by`2^32-1` instead ? I don't think we need more of this TLS nonsense to save one byte in the encoded length.",
              "createdAt": "2018-09-10T22:18:12Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 285,
              "body": "This doesn't mean anything... does it represent the maximum numbers of participants in the group ?",
              "createdAt": "2018-09-10T22:20:38Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 289,
              "body": "What do you mean by \"identity and public key for the holder of the slot\". Do you mean the current signature and encryption public keys ?\r\n(signature pubkey, which is currently the long term identity key in the rest of the text)",
              "createdAt": "2018-09-10T22:22:13Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 291,
              "body": "That seems very implementation specific. The concern of the spec is not to say that you should consume that space even it it is empty.",
              "createdAt": "2018-09-10T22:26:33Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 309,
              "body": "KeyExchange <> (Group operation = Handshake message)",
              "createdAt": "2018-09-10T22:29:18Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 350,
              "body": "Add or remove brackets on the other `transcript_hash`.",
              "createdAt": "2018-09-10T22:34:32Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 523,
              "body": "I don't like the \"key exchange\" terminology very much here, we even't are exchanging keys...",
              "createdAt": "2018-09-10T22:40:31Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 384,
              "body": "Why would you want pass the entire state here instead of just the message, the current secret and eventually the log ?",
              "createdAt": "2018-09-10T22:44:42Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 525,
              "body": "Can you explain the reasoning for having the entire GroupState here, it seems only useful for `Add` ?",
              "createdAt": "2018-09-10T22:46:27Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 542,
              "body": "I don't understand this change in terminology. We are not choosing between Diffie-Hellmann vs RSA here.. : )",
              "createdAt": "2018-09-10T22:49:03Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 562,
              "body": "Same, I think HandshakeType was fine...",
              "createdAt": "2018-09-10T22:49:42Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0MDQyMjk0",
          "commit": {
            "abbreviatedOid": "95f121c"
          },
          "author": "suhasHere",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-11T03:58:15Z",
          "updatedAt": "2018-09-11T03:58:15Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "nit: \"an Add message\"",
              "createdAt": "2018-09-11T03:58:15Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0MjI2ODQ3",
          "commit": {
            "abbreviatedOid": "95f121c"
          },
          "author": "suhasHere",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "I  think the overall direction seems good. Have few nits overall , but given we will be discussing the content at the interim , LGTM",
          "createdAt": "2018-09-11T14:21:55Z",
          "updatedAt": "2018-09-11T14:35:26Z",
          "comments": [
            {
              "originalPosition": 628,
              "body": "size repeated twice",
              "createdAt": "2018-09-11T14:21:56Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 256,
              "body": "Wondering where is __Credential__ defined ?",
              "createdAt": "2018-09-11T14:23:25Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 295,
              "body": "nit .. for readers beneifit , might be useful to explain the size formula ?",
              "createdAt": "2018-09-11T14:25:39Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 301,
              "body": "Wonder how the Welcome message race is resolved when multiple existing members end up adding the same new member?",
              "createdAt": "2018-09-11T14:26:27Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 308,
              "body": "reword .. each change --> each update to group state ?",
              "createdAt": "2018-09-11T14:27:10Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 259,
              "body": "transcript_hash description is missing below",
              "createdAt": "2018-09-11T14:27:48Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 396,
              "body": "Trying to understand the need for entire group state in generating the Label ? ",
              "createdAt": "2018-09-11T14:29:41Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 772,
              "body": "Remove message type isn't defined. ",
              "createdAt": "2018-09-11T14:34:23Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0NzkwNTY2",
          "commit": {
            "abbreviatedOid": "95f121c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-12T18:43:31Z",
          "updatedAt": "2018-09-12T18:43:31Z",
          "comments": [
            {
              "originalPosition": 285,
              "body": "Actually, this can be eliminated, since it can be derived from the length of the `tree` vector.",
              "createdAt": "2018-09-12T18:43:31Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0NzkxMjAz",
          "commit": {
            "abbreviatedOid": "95f121c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-12T18:45:05Z",
          "updatedAt": "2018-09-12T18:45:05Z",
          "comments": [
            {
              "originalPosition": 289,
              "body": "\"Public key\" == \"Signature public key\".  (\"Identity\" is whatever opaque string the application assigns)  Note that because this state can change, we're not committed to using long-term identity keys.",
              "createdAt": "2018-09-12T18:45:05Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0NzkyMDI5",
          "commit": {
            "abbreviatedOid": "95f121c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-12T18:47:05Z",
          "updatedAt": "2018-09-12T18:47:06Z",
          "comments": [
            {
              "originalPosition": 291,
              "body": "I don't know why you think this is implementation specific.  In the current system, there is an \"owner\" of each leaf in the tree, and the participants need to agree on the leaf-to-owner assignment.  So you can compress your storage locally, but you need to be able to reconstruct this vector.",
              "createdAt": "2018-09-12T18:47:05Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0NzkyNTE3",
          "commit": {
            "abbreviatedOid": "95f121c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-12T18:48:20Z",
          "updatedAt": "2018-09-12T18:48:21Z",
          "comments": [
            {
              "originalPosition": 309,
              "body": "I'll change `KeyExchange` to something else, maybe `GroupOperation`.",
              "createdAt": "2018-09-12T18:48:21Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0NzkzMTcz",
          "commit": {
            "abbreviatedOid": "95f121c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-12T18:49:53Z",
          "updatedAt": "2018-09-12T18:49:53Z",
          "comments": [
            {
              "originalPosition": 384,
              "body": "I don't know what you mean by log.  Anything you hash in here is something the endpoints have to agree on, or else they end up at different keys.  So the idea is to include everything we want the endpoints to agree on.",
              "createdAt": "2018-09-12T18:49:53Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0NzkzMzMw",
          "commit": {
            "abbreviatedOid": "95f121c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-12T18:50:15Z",
          "updatedAt": "2018-09-12T18:50:16Z",
          "comments": [
            {
              "originalPosition": 525,
              "body": "See the authentication discussion on the list.",
              "createdAt": "2018-09-12T18:50:15Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0ODE2MzQx",
          "commit": {
            "abbreviatedOid": "95f121c"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks @bifurcation ! I still think we should NOT use the entire group state everywhere in the key schedule but only what we need to get the cryptographic security properties we want, so I would prefer holding that change for a next iteration... Other than with fixes you marked as resolved, I think this is good to go :+1:",
          "createdAt": "2018-09-12T19:53:35Z",
          "updatedAt": "2018-09-12T20:31:11Z",
          "comments": [
            {
              "originalPosition": 291,
              "body": "I understand the text as:\r\nthe `size` represents the max number /\\ the length must be equal to the value\r\n==> the roster is as big as the max and not as the number of participants...\r\nwhich I interpreted as the way to store this in a flat buffer",
              "createdAt": "2018-09-12T19:53:35Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 384,
              "body": "I think I disagree with the fact that you need to use the entire group state every time to make sure everybody agrees on the same thing. Intuitively the previous definition encompassed all group operations through the Handshake messages (`Msg`), which includes the signatures, which is enough to get the weak authentication (group-membership) property. I think it is a good practice to include incrementally what we need to be able to prove the cryptographic security properties we want and not the opposite which is just gonna be annoying for proofs. I would strongly be in favor of keeping the previous definition for now.",
              "createdAt": "2018-09-12T20:21:31Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 396,
              "body": "Same comment here, I prefer the previous definition for now...",
              "createdAt": "2018-09-12T20:22:55Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 525,
              "body": "Maybe I misread but I couldn't find anything about that there.",
              "createdAt": "2018-09-12T20:25:34Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0OTEyMzMw",
          "commit": {
            "abbreviatedOid": "95f121c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-13T02:47:21Z",
          "updatedAt": "2018-09-13T02:47:21Z",
          "comments": [
            {
              "originalPosition": 256,
              "body": "Good catch, I forgot to do that.",
              "createdAt": "2018-09-13T02:47:21Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0OTEyNjk4",
          "commit": {
            "abbreviatedOid": "95f121c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-13T02:50:10Z",
          "updatedAt": "2018-09-13T02:50:10Z",
          "comments": [
            {
              "originalPosition": 301,
              "body": "Added an open issue.",
              "createdAt": "2018-09-13T02:50:10Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0OTI3NzA0",
          "commit": {
            "abbreviatedOid": "ebdbb4e"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "I think you are almost good to go here... : )",
          "createdAt": "2018-09-13T04:50:46Z",
          "updatedAt": "2018-09-13T05:40:04Z",
          "comments": [
            {
              "originalPosition": 295,
              "body": "Should that be `CredentialType` instead ?",
              "createdAt": "2018-09-13T04:50:46Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 285,
              "body": "This is still in the text...",
              "createdAt": "2018-09-13T04:53:23Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 323,
              "body": "Maybe you could use `2^32` instead ? There is no language support for `uint24_t` whatsoever. I think `2^16` would be too small to be future-proof but `2^24` is far too big so going to `2^32` would be fine... `2^24` or `2^48` are one of the bad things in TLS.\r\n(edited to remove the undesired aggressive tone : )... )*",
              "createdAt": "2018-09-13T04:54:18Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 289,
              "body": "`s/public key/signature public key/` still needs to be implemented, it is unclear otherwise",
              "createdAt": "2018-09-13T04:57:20Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 412,
              "body": "If we don't use the `_[N]` subscript to give the precise version of the secrets, maybe just use `GroupState` instead of `GroupState_n` ?",
              "createdAt": "2018-09-13T05:00:12Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 508,
              "body": "`key_exchange` is now called `GroupOperation`",
              "createdAt": "2018-09-13T05:02:31Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU1MTc4MTMx",
          "commit": {
            "abbreviatedOid": "ebdbb4e"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-09-13T16:59:33Z",
          "updatedAt": "2018-09-13T17:54:00Z",
          "comments": [
            {
              "originalPosition": 295,
              "body": "#L719 stipulates it should indeed be `CredentialType`",
              "createdAt": "2018-09-13T16:59:33Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 323,
              "body": "While `2^16` is roughly the order of magnitude until which MLS should work well, I agree that it should rather be `2^32` instead of `2^24`.",
              "createdAt": "2018-09-13T17:05:29Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 517,
              "body": "discared -> discard",
              "createdAt": "2018-09-13T17:11:02Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 537,
              "body": "The order is probably wrong, since the `Welcome` message should only be sent if the `Add` message succeeded. We should think some more about synchronicity issues that we want to avoid. \r\nIdeally the `Add` and `Welcome` message are on atomic operation in which all old and new members are notified at the same time. However since the existing member now waits for the `Add` to be successful before sending the (rather large) `Welcome`, there might be edge cases when the `Welcome` is never sent because the inviting member went offline too early.\r\nFor now I think we should keep this as an open issue. Going forward we should consider improvements, such as splitting the `Welcome` into a light header that gets reliably dispatched at the same time with the `Add` and a larger message containing the roster and the tree.",
              "createdAt": "2018-09-13T17:24:04Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 627,
              "body": "Obviously if the verification fails, none of the changes should be applied.",
              "createdAt": "2018-09-13T17:28:28Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU3MDE3ODU4",
          "commit": {
            "abbreviatedOid": "1e80e32"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-19T20:55:03Z",
          "updatedAt": "2018-09-19T20:55:03Z",
          "comments": [
            {
              "originalPosition": 295,
              "body": "Done.",
              "createdAt": "2018-09-19T20:55:03Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU3MDE4Mjg0",
          "commit": {
            "abbreviatedOid": "1e80e32"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-19T20:56:14Z",
          "updatedAt": "2018-09-19T20:56:14Z",
          "comments": [
            {
              "originalPosition": 323,
              "body": "I don't think this is as much of an implementation issue as you do; all the decoders out there just read the relevant bytes into a uint32_t and carry on.  But I'll change it for the moment; we can try to economize on bytes later.",
              "createdAt": "2018-09-19T20:56:14Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU3MDIwOTMy",
          "commit": {
            "abbreviatedOid": "1e80e32"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-19T21:03:06Z",
          "updatedAt": "2018-09-19T21:03:06Z",
          "comments": [
            {
              "originalPosition": 537,
              "body": "Note that there's an open issue for this a few lines further down.  I agree that this is a tricky sync to get right.  Shoving the Welcome message in the Add message might simplify this, but the cost of sending an O(N) size message to everyone seems steep. ",
              "createdAt": "2018-09-19T21:03:06Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU3MDI3NzQ0",
          "commit": {
            "abbreviatedOid": "1e6c291"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-09-19T21:22:20Z",
          "updatedAt": "2018-09-19T21:22:20Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU3MDMxNzc0",
          "commit": {
            "abbreviatedOid": "1e6c291"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-09-19T21:33:48Z",
          "updatedAt": "2018-09-19T21:33:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 60,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE2NzEzNjM3",
      "title": "Substitute AES-128-GCM with AES-256-GCM",
      "url": "https://github.com/mlswg/mls-protocol/pull/60",
      "state": "CLOSED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "recommendation",
        "security"
      ],
      "body": "",
      "createdAt": "2018-09-19T17:12:06Z",
      "updatedAt": "2019-12-17T09:43:05Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "eca365da10223eef64eda050427fc07c5f5ac254",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "aes-128-256",
      "headRefOid": "d26e72793725be04057201c025e82ae0be3649f5",
      "closedAt": "2018-09-20T10:58:29Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 61,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE2NzQ4NTAz",
      "title": "Fix broken links",
      "url": "https://github.com/mlswg/mls-protocol/pull/61",
      "state": "MERGED",
      "author": "katrielalex",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Previously they used to point to mlswg.github.io/... but that doesn't work now that we have a homepage there",
      "createdAt": "2018-09-19T19:22:11Z",
      "updatedAt": "2019-12-17T09:42:38Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "eca365da10223eef64eda050427fc07c5f5ac254",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "fix-links",
      "headRefOid": "ba2bb6ef1865e1cb9d7a13999e2344fbb07b226b",
      "closedAt": "2018-09-19T19:23:04Z",
      "mergedAt": "2018-09-19T19:23:04Z",
      "mergedBy": "katrielalex",
      "mergeCommit": {
        "oid": "2fe65163c761124496fb25310027db2e22357e72"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 62,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE2NzkwMTEw",
      "title": "Use nonces in ECIES derived from the shared secret ",
      "url": "https://github.com/mlswg/mls-protocol/pull/62",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "functionality",
        "performance",
        "security"
      ],
      "body": "This matches the behavior in TLS, and saves space (due to not having to send the nonce).",
      "createdAt": "2018-09-19T22:02:25Z",
      "updatedAt": "2019-12-17T09:42:29Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "414b7008c89986e21fc93a067ee174a1bc76e78d",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "treekem-revision",
      "headRefOid": "d03059bbc301cfbe48b573f46b8f07bf04d37040",
      "closedAt": "2018-09-19T22:22:39Z",
      "mergedAt": "2018-09-19T22:22:39Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "e73cea7d0a8257d50897f8d45410f1902bdc9c42"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Merging based on r+ from @beurdouche out of band",
          "createdAt": "2018-09-19T22:22:35Z",
          "updatedAt": "2018-09-19T22:22:35Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU3MDQxMzUx",
          "commit": {
            "abbreviatedOid": "564f214"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-19T22:04:22Z",
          "updatedAt": "2018-09-19T22:04:23Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "HKDF Expand Label ?",
              "createdAt": "2018-09-19T22:04:23Z",
              "updatedAt": "2018-09-19T22:15:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU3MDQxODU3",
          "commit": {
            "abbreviatedOid": "564f214"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-19T22:06:07Z",
          "updatedAt": "2018-09-19T22:06:07Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "No, just HKDF-Expand.  HKDF-Expand-Label isn't defined here (only in TLS), and in any case, we're using a different label.",
              "createdAt": "2018-09-19T22:06:07Z",
              "updatedAt": "2018-09-19T22:15:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU3MDQyNTMy",
          "commit": {
            "abbreviatedOid": "564f214"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-09-19T22:08:44Z",
          "updatedAt": "2018-09-19T22:08:44Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU3MDQyNjEw",
          "commit": {
            "abbreviatedOid": "564f214"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-19T22:09:03Z",
          "updatedAt": "2018-09-19T22:09:03Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Ack, this is good for me then...",
              "createdAt": "2018-09-19T22:09:03Z",
              "updatedAt": "2018-09-19T22:15:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU3MDQyNzcw",
          "commit": {
            "abbreviatedOid": "564f214"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-19T22:09:42Z",
          "updatedAt": "2018-09-19T22:09:42Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Though I think this is already the case... (at least in the paper)",
              "createdAt": "2018-09-19T22:09:42Z",
              "updatedAt": "2018-09-19T22:15:02Z"
            }
          ]
        }
      ]
    },
    {
      "number": 63,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE3MjI0NjE5",
      "title": "Allow bigger sizes for PQ primitives",
      "url": "https://github.com/mlswg/mls-protocol/pull/63",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "? follow-up",
        "functionality",
        "performance",
        "security"
      ],
      "body": "By discussing with MSR, I realized that some NIST PQ candidates can't be used easily by TLS because signatures can be bigger that `2^16` bytes.\r\n\r\nSince we already consume a lot for bandwidth, I am not concerned at all about two more bytes to encode the length of signatures on each ciphertext so I suggest we move to `opaque signature <0..2^32-1>` instead to be future-proof.\r\n",
      "createdAt": "2018-09-21T09:31:13Z",
      "updatedAt": "2019-12-17T10:10:54Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "eeecb749e3d74e141786c5574c3c05db8e8cd4ef",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "signatures_large",
      "headRefOid": "034501231be77bd49b647fcdef5886dff3deafd3",
      "closedAt": "2018-10-19T16:57:16Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "Having more flexibility with the payload size sounds reasonable.\r\nOne day having signatures that big if however another kind of challenge.",
          "createdAt": "2018-09-21T12:29:12Z",
          "updatedAt": "2018-09-21T12:29:12Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@beurdouche if you could fix the merge conflicts, I'm OK with this.",
          "createdAt": "2018-10-05T20:36:12Z",
          "updatedAt": "2018-10-05T20:36:12Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "As I said in the WG meeting, I don't think this is a good idea. If we end up having primitives this big, we are going to have lots of problems and will probably want a better architecture (e.g., signatures that batch multiple messages).",
          "createdAt": "2018-10-05T20:39:53Z",
          "updatedAt": "2018-10-05T20:39:53Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with EKR here.  PQ is probably going to require different designs, not just bigger crypto values.  If someone wants to make a concrete proposal for shimming in a PQ scheme here, which would run into these limits, I would be open to reconsidering this.",
          "createdAt": "2018-10-19T16:57:16Z",
          "updatedAt": "2018-10-19T16:57:16Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "FYI, even though this is closed this will be the basis of PQ experiment in real products, just with a different protocol version.\r\nPs: Please don't delete other people branches.",
          "createdAt": "2018-10-19T17:02:10Z",
          "updatedAt": "2018-10-19T17:02:10Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 64,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE4NDYyMDA5",
      "title": "Change from AES-GCM to AES-SIV",
      "url": "https://github.com/mlswg/mls-protocol/pull/64",
      "state": "CLOSED",
      "author": "galadran",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "? follow-up",
        "enhancement",
        "security"
      ],
      "body": "[Mailing List Post](https://mailarchive.ietf.org/arch/msg/mls/gvszahIKpQ5CYJG-ARwi9MGURGo)",
      "createdAt": "2018-09-26T21:34:33Z",
      "updatedAt": "2019-12-17T09:41:32Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "e73cea7d0a8257d50897f8d45410f1902bdc9c42",
      "headRepository": "galadran/mls-protocol",
      "headRefName": "aes-siv",
      "headRefOid": "39c128d8614267f32579f8e7e87d1450e07b0c2a",
      "closedAt": "2019-01-08T01:09:31Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not sure I see a lot of value here. The current discipline is one key per message, so is there a special reason to believe that clients will be careless about nonces.",
          "createdAt": "2018-09-27T03:45:03Z",
          "updatedAt": "2018-09-27T03:45:03Z"
        },
        {
          "author": "galadran",
          "authorAssociation": "NONE",
          "body": "> I'm not sure I see a lot of value here. The current discipline is one key per message, so is there a special reason to believe that clients will be careless about nonces.\r\n\r\nHi ekr, \r\n\r\nUsing one key per message just lifts the problem to a different layer, we're relying on implementers getting the state handling right and never reusing a key. (Since if they reuse a key, they will reuse a nonce). \r\n\r\nVerifying correct nonce/key usage is difficult. Using implicit nonces and testing for compatibility gives us an assurance that most uses are correct, but says little about edge cases which are hard to test exhaustively. With AES-GCM, these edge cases lead to an immediate loss of authenticity and possible total compromise. With AES-SIV, these edge cases have very minimal impact as the adversary only learns if the two plaintexts were equal.",
          "createdAt": "2018-09-27T06:52:20Z",
          "updatedAt": "2018-09-27T06:52:20Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, my question is: is there a special reason to be believe that MLS implementations will get this wrong as opposed to (say) TLS 1.3 or SRTP implementations, both of which use implicit nonces.",
          "createdAt": "2018-09-27T07:27:56Z",
          "updatedAt": "2018-09-27T07:27:56Z"
        },
        {
          "author": "galadran",
          "authorAssociation": "NONE",
          "body": "Yes.\r\n\r\n- MLS is many party as opposed to two \r\n- MLS is highly stateful in order to achieve PFS and PCS\r\n- MLS is asynchronous\r\n- MLS sessions are expected to continue despite a device suddenly losing power \r\n- MLS is a completely new and complex protocol\r\n\r\nI already described some of the situations in which SIV offers significant benefits over implicit nonces on the mailing list.\r\n\r\nFinally, it seems premature to declare implicit nonces to have fixed all the nonce issues in TLS. Let's give TLS 1.3 another decade (or two) before declaring it perfect. ",
          "createdAt": "2018-09-27T07:58:01Z",
          "updatedAt": "2018-09-27T07:58:01Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "On Thu, Sep 27, 2018 at 12:58 AM Dennis Jackson <notifications@github.com>\nwrote:\n\n>\n>    - MLS sessions are expected to continue despite a device suddenly\n>    losing power\n>\n> This last is the only one of these that seems particularly relevant, given\nthat each sender uses its own keys. I'd be interested in hearing from\nimplementors whether they consider this kind of state loss to be an issue.\n\n\n>\n> Finally, it seems premature to declare implicit nonces to have fixed all\n> the nonce issues in TLS. Let's give TLS 1.3 another decade (or two) before\n> declaring it perfect.\n>\nThis misrepresents what I said, which was nothing like claiming that TLS\n1.3 nonce handling was perfect.\n\nWith that said, I would again refer you to SRTP , which has used implicit\nnonces for a very long time. Do you have any evidence that nonce reuse has\nbeen a problem here?\n",
          "createdAt": "2018-09-27T08:04:27Z",
          "updatedAt": "2018-09-27T08:04:27Z"
        },
        {
          "author": "galadran",
          "authorAssociation": "NONE",
          "body": "> With that said, I would again refer you to SRTP , which has used implicit nonces for a very long time. Do you have any evidence that nonce reuse has been a problem here?\r\n\r\nI have no idea. Let's assume that SRTP has no nonce reuse problems. What is the conclusion?  \r\n\r\nI've described some of the differences between synchronous, essentially stateless, 2-party protocols and MLS. I've referenced a catastrophic nonce reuse attack which implicit nonces would not have mitigated (KRACK on WPA2). There are clear scenarios where SIV provides a tangible security benefit _in addition to_  implicit nonces. \r\n\r\nThere are reasons not to use SIV in applications like TLS, as SIV only encrypts at ~70% of the speed of GCM. However, I don't think they apply to us considering the public key operations we will be doing anyway. Equally in 2014 SIV was less widely supported, since then it has found its way into OpenSSL and BoringSSL. ",
          "createdAt": "2018-09-27T08:34:56Z",
          "updatedAt": "2018-09-27T08:34:56Z"
        },
        {
          "author": "grittygrease",
          "authorAssociation": "NONE",
          "body": "Following up on this. This suggestion was discussed at the first interim and there was not a lot of enthusiasm for making the change.",
          "createdAt": "2019-01-08T01:09:31Z",
          "updatedAt": "2019-01-08T01:09:31Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 65,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE4NDk0MzM5",
      "title": "Fix typos.",
      "url": "https://github.com/mlswg/mls-protocol/pull/65",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-09-27T00:50:17Z",
      "updatedAt": "2019-12-17T09:39:50Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "e73cea7d0a8257d50897f8d45410f1902bdc9c42",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "fix-typos",
      "headRefOid": "04ea1d1afbbf4b2d84e8fa304c4f622a3ff983c8",
      "closedAt": "2018-10-02T10:34:06Z",
      "mergedAt": "2018-10-02T10:34:05Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "04ea1d1afbbf4b2d84e8fa304c4f622a3ff983c8"
      },
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "@Bren2010 Hi Brendan ! Would you mind please revert the last of the 3 changes. Even though the sentence is not amazing and your change correct, I find it better to keep explicit the fact that the root should not be included, instead of having to infer it from the fact it has no siblings :) Thanks ! ",
          "createdAt": "2018-09-27T05:27:09Z",
          "updatedAt": "2018-09-27T05:27:09Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "You don't have to infer it -- direct paths are defined to never include the root node in the sentence just before.",
          "createdAt": "2018-09-27T06:08:54Z",
          "updatedAt": "2018-09-27T06:08:54Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 66,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE5NDUzODM1",
      "title": "Remove ART",
      "url": "https://github.com/mlswg/mls-protocol/pull/66",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "functionality",
        "security"
      ],
      "body": "There was agreement at the MLS interim of September 2018 to focus further development on TreeKEM, not ART.  This PR implements that change.",
      "createdAt": "2018-10-01T17:26:16Z",
      "updatedAt": "2019-12-17T09:39:44Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "e73cea7d0a8257d50897f8d45410f1902bdc9c42",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "no-art",
      "headRefOid": "1899cbab6da535c466537ef9c62ea4226c0d4096",
      "closedAt": "2018-10-01T20:27:30Z",
      "mergedAt": "2018-10-01T20:27:30Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "9b7d7e91dbcbd190d144b3435b2e5f516a6b6547"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the reviews, @beurdouche and @dwd ",
          "createdAt": "2018-10-01T20:27:25Z",
          "updatedAt": "2018-10-01T20:27:25Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTYwNDAzMTcx",
          "commit": {
            "abbreviatedOid": "67063f3"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-10-01T17:30:00Z",
          "updatedAt": "2018-10-01T17:31:35Z",
          "comments": [
            {
              "originalPosition": 190,
              "body": "s/primities/primitives",
              "createdAt": "2018-10-01T17:30:00Z",
              "updatedAt": "2018-10-01T20:26:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTYwNDA0NzA5",
          "commit": {
            "abbreviatedOid": "2136e1b"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-10-01T17:34:02Z",
          "updatedAt": "2018-10-01T17:34:02Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTYwNDY0NTI3",
          "commit": {
            "abbreviatedOid": "2136e1b"
          },
          "author": "dwd",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-10-01T20:10:08Z",
          "updatedAt": "2018-10-01T20:13:02Z",
          "comments": [
            {
              "originalPosition": 170,
              "body": "As below, s/primities/primitives/",
              "createdAt": "2018-10-01T20:10:08Z",
              "updatedAt": "2018-10-01T20:26:44Z"
            }
          ]
        }
      ]
    },
    {
      "number": 67,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE5NDY0NzMw",
      "title": "Remove double-join with the \"partial tree\" approach",
      "url": "https://github.com/mlswg/mls-protocol/pull/67",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement",
        "security"
      ],
      "body": "This PR updates the procedures for Add and Remove to remove double-joins.  The cost is a potential increase in the size of GroupOperation messages in the case of incomplete trees.\r\n\r\nDepends on #66 ",
      "createdAt": "2018-10-01T18:04:19Z",
      "updatedAt": "2019-12-17T09:39:08Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "8b353d63adf2b10df7f6e8ade88e8a996aaf6c63",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "resolution",
      "headRefOid": "082b47553fc3015a07e4dc38ad9fa1fe38bc035d",
      "closedAt": "2018-10-22T11:43:58Z",
      "mergedAt": "2018-10-22T11:43:58Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "53675bf8ea04a57300f13bda13039dd6cca197be"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTYwNDU5MDQ3",
          "commit": {
            "abbreviatedOid": "7a7cd37"
          },
          "author": "josephlhall",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-01T19:55:29Z",
          "updatedAt": "2018-10-01T19:55:29Z",
          "comments": [
            {
              "originalPosition": 95,
              "body": "Don't need the twiddles in the markdown if it's not pre-formatted?",
              "createdAt": "2018-10-01T19:55:29Z",
              "updatedAt": "2018-10-21T19:17:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTYwNDYwMTU1",
          "commit": {
            "abbreviatedOid": "7a7cd37"
          },
          "author": "josephlhall",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-01T19:58:22Z",
          "updatedAt": "2018-10-01T19:58:23Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "\"node 2 is [] (the empty list)\"",
              "createdAt": "2018-10-01T19:58:22Z",
              "updatedAt": "2018-10-21T19:17:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTYwNDYwMjgz",
          "commit": {
            "abbreviatedOid": "7a7cd37"
          },
          "author": "josephlhall",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-01T19:58:43Z",
          "updatedAt": "2018-10-01T19:58:43Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "\"node 3 is the list [A, CD]\"",
              "createdAt": "2018-10-01T19:58:43Z",
              "updatedAt": "2018-10-21T19:17:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTYyMjcxNzU2",
          "commit": {
            "abbreviatedOid": "79f6172"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-10-06T22:13:46Z",
          "updatedAt": "2018-10-06T22:41:12Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "This leaks the group secret of the current epoch to the new participant.",
              "createdAt": "2018-10-06T22:13:46Z",
              "updatedAt": "2018-10-21T19:17:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTYyMjcyODE3",
          "commit": {
            "abbreviatedOid": "79f6172"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-06T23:13:07Z",
          "updatedAt": "2018-10-06T23:13:07Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "If we go for the solution proposed on the mailing list, this should be the hash of the current group secret and the other members should perform the hash as they process the Add message.",
              "createdAt": "2018-10-06T23:13:07Z",
              "updatedAt": "2018-10-21T19:17:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTYyMjg0MTQ0",
          "commit": {
            "abbreviatedOid": "79f6172"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-10-07T09:47:31Z",
          "updatedAt": "2018-10-07T10:21:11Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "Isn't it the public key of the sibling node to whom you encrypt to and not the public key of the node you send ? \r\nYou compute that one from the new secret, but BTW I don't think we explain how to derive the public enc keys of a node from the secret at the moment.",
              "createdAt": "2018-10-07T09:47:31Z",
              "updatedAt": "2018-10-21T19:17:59Z"
            },
            {
              "originalPosition": 145,
              "body": "I think I have the same understanding here. This must definitely be a hash otherwise it will reveal not only the current epoch secret but also all previous ones defeating basically FS and PCS all together. I can take care of fixing it in a separate PR if you want...",
              "createdAt": "2018-10-07T10:13:40Z",
              "updatedAt": "2018-10-21T19:17:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2NjA1MDIx",
          "commit": {
            "abbreviatedOid": "79f6172"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-19T16:39:25Z",
          "updatedAt": "2018-10-19T16:39:25Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "You guys have an off-by-one error :)  This is the `init_secret` at the **output** of the current epoch's key schedule, not the input.  So it can't be used to derive the current epoch secret.\r\n\r\nThe whole reason that we have an `init_secret` (as opposed to chaining from one `epoch_secret` to the next) is so that you can give it to someone to allow them to initialize without giving away the current epoch secrets.  \r\n\r\n@beurdouche not sure what you mean about going backward.  Key schedule is all HDKFing along, so it's not reversible.",
              "createdAt": "2018-10-19T16:39:25Z",
              "updatedAt": "2018-10-21T19:17:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2NjA1MTAx",
          "commit": {
            "abbreviatedOid": "79f6172"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-19T16:39:38Z",
          "updatedAt": "2018-10-19T16:39:38Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "In any case, I'll add some notes to clarify.",
              "createdAt": "2018-10-19T16:39:38Z",
              "updatedAt": "2018-10-21T19:17:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2NjA5NTA1",
          "commit": {
            "abbreviatedOid": "ad73080"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-19T16:52:39Z",
          "updatedAt": "2018-10-19T16:52:39Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "Suppose you've got the following structure:\r\n\r\n```\r\n   D2\r\n  /  \\\r\n /    \\\r\nD1    Sib\r\n```\r\n\r\n... where `D1` and `D2` are on the direct path, and `Sib` is not.  Then the encrypted value that's transmitted is `(pk(D2), Enc(pk(Sib); secret(D2)))`.  \r\n\r\nI'll revise to try to make this clearer.",
              "createdAt": "2018-10-19T16:52:39Z",
              "updatedAt": "2018-10-21T19:17:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2NjE2OTE0",
          "commit": {
            "abbreviatedOid": "ad73080"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-19T17:13:52Z",
          "updatedAt": "2018-10-19T17:13:53Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "Well I understand how you read it but the diagram is ill-numbered then, because the `init_secret` is actually at the *input* of the the key schedule. The very first one is the `init_secret[0] = {0}` and is actually needed.",
              "createdAt": "2018-10-19T17:13:52Z",
              "updatedAt": "2018-10-21T19:17:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2NjE5NzA0",
          "commit": {
            "abbreviatedOid": "79f6172"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-19T17:21:19Z",
          "updatedAt": "2018-10-19T17:21:20Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "I don't think you understand us regarding the Group operation transcript. If it is not a hash, it contains all group operation messages since the beginning of the group. You can trivially process all these and compute all keys for all previous application messages hence trivially defeating all secrecy.  It also works for future messages as long as the participant you compromise doesn't update. This needs to be a hash, I don't understand why you would think this is safe. @raphaelrobert ?",
              "createdAt": "2018-10-19T17:21:19Z",
              "updatedAt": "2018-10-21T19:17:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2NjI4NDUw",
          "commit": {
            "abbreviatedOid": "ad73080"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-19T17:44:56Z",
          "updatedAt": "2018-10-19T17:44:56Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "Oh, I think it is safe because in order to process the GroupOperation messages, you need to have one of the corresponding private keys, which means you need to be in the group!\r\n\r\nI'm happy to convert the transcript to a hash (there's no reason for anyone to have the whole thing, unlike the roster and the tree).  But I don't think it's necessary for this to be secure.",
              "createdAt": "2018-10-19T17:44:56Z",
              "updatedAt": "2018-10-21T19:17:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2NjM2MDIw",
          "commit": {
            "abbreviatedOid": "ad73080"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-19T18:05:03Z",
          "updatedAt": "2018-10-19T18:05:04Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "cf #73 ",
              "createdAt": "2018-10-19T18:05:04Z",
              "updatedAt": "2018-10-21T19:17:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2NjM4NTYz",
          "commit": {
            "abbreviatedOid": "ad73080"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Ok with #73 ",
          "createdAt": "2018-10-19T18:12:15Z",
          "updatedAt": "2018-10-19T18:12:15Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2NzU0MzM0",
          "commit": {
            "abbreviatedOid": "90c452d"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-20T16:22:35Z",
          "updatedAt": "2018-10-20T16:22:35Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "Ok, the terminology was not clear for `init_secret`. If it is the group secret of the next epoch, it works of course.\r\nAnd #73 seems to take care of the transcript (I'll review separately).",
              "createdAt": "2018-10-20T16:22:35Z",
              "updatedAt": "2018-10-21T19:17:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2NzU0NzU0",
          "commit": {
            "abbreviatedOid": "ad73080"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "I suppose it is because this PR is WIP, but the Remove HS section is still the old one with double-joins.",
          "createdAt": "2018-10-20T16:36:18Z",
          "updatedAt": "2018-10-20T17:01:15Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "This reads strange (but it's its correct). Maybe go for:\r\n\r\n\"This way the next epoch's group secret is pre-computed for the new member. The current epoch's group secret is not revealed to the new member.\"",
              "createdAt": "2018-10-20T16:36:19Z",
              "updatedAt": "2018-10-21T19:17:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2Nzk3NDcz",
          "commit": {
            "abbreviatedOid": "082b475"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-10-21T19:22:22Z",
          "updatedAt": "2018-10-21T19:22:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 68,
      "id": "MDExOlB1bGxSZXF1ZXN0MjIyNjY4ODY0",
      "title": "updating 2119 paragraph",
      "url": "https://github.com/mlswg/mls-protocol/pull/68",
      "state": "MERGED",
      "author": "seanturner",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Including the \"new\" 2119 paragraph.",
      "createdAt": "2018-10-13T18:58:01Z",
      "updatedAt": "2018-10-14T12:31:18Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "eeecb749e3d74e141786c5574c3c05db8e8cd4ef",
      "headRepository": "seanturner/mls-protocol",
      "headRefName": "2119-lang",
      "headRefOid": "12496ac1fa6f5404d1aedc9cffa1874bd731f4b7",
      "closedAt": "2018-10-14T12:31:18Z",
      "mergedAt": "2018-10-14T12:31:18Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "69b098c129fd32d4181722bf4492cc80dae6e426"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 69,
      "id": "MDExOlB1bGxSZXF1ZXN0MjIyNjY5MTQ0",
      "title": "renaming s5.1",
      "url": "https://github.com/mlswg/mls-protocol/pull/69",
      "state": "MERGED",
      "author": "seanturner",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "There are two \"Terminology\" sections so I renamed the 2nd one \"Tree Computations Terminology\" to match the reference in s2.",
      "createdAt": "2018-10-13T19:03:16Z",
      "updatedAt": "2018-10-14T12:33:10Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "eeecb749e3d74e141786c5574c3c05db8e8cd4ef",
      "headRepository": "seanturner/mls-protocol",
      "headRefName": "s5.1_title",
      "headRefOid": "d670cd478ff65e51b1d37e8bc518cb8667f1d850",
      "closedAt": "2018-10-14T12:33:10Z",
      "mergedAt": "2018-10-14T12:33:10Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "939cab2b414518f26ac18b592b1d9ba9c5d6c6e1"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 71,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI0MzU5MDY1",
      "title": "Add explicit key confirmation",
      "url": "https://github.com/mlswg/mls-protocol/pull/71",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "functionality",
        "security"
      ],
      "body": "At the MLS interim, the major feedback regarding authentication was that it would be good practice to provide explicit key confirmation.  This PR adds an explicit confirmation field to Handshake messages, containing a MAC over the proposed (updated) state of the group, together with the latest handshake message.",
      "createdAt": "2018-10-19T17:32:38Z",
      "updatedAt": "2019-12-17T09:38:12Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "d160a02d4729899dfeedbac381a2380661e23993",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "authn-v3",
      "headRefOid": "c55b9f3fb07f0531b08130aa4a0dce29c8fcb516",
      "closedAt": "2018-10-22T12:49:45Z",
      "mergedAt": "2018-10-22T12:49:45Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "4e243852e9abd5391e3a38273322860d6bd58262"
      },
      "comments": [
        {
          "author": "jmillican",
          "authorAssociation": "COLLABORATOR",
          "body": "Reflecting on offline conversation here:\r\n\r\nThis PR derives a new key, then calculates the MAC over both the HS message and the group state; that others verify. PR 72 derives a new key, then sends that to the others to verify they all got the same key. We assume that, as the key was derived from a tree with this group state, it must be correct.\r\n\r\nThese appear to test basically the same property, but I probably prefer this PR unless we can formally verify that they have the same properties (or at least the relevant ones); in which case 72 is a little more efficient.",
          "createdAt": "2018-10-21T19:45:03Z",
          "updatedAt": "2018-10-21T19:45:03Z"
        },
        {
          "author": "jmillican",
          "authorAssociation": "COLLABORATOR",
          "body": "So one question would be under what circumstances would this verify something that won't be verified by failing AEAD on any associated messages that decrypt? Or is it more just that we've now decoupled updates and message sending, so without a failing AEAD we need this to confirm too?",
          "createdAt": "2018-10-21T19:48:39Z",
          "updatedAt": "2018-10-21T19:48:39Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, @jmillican.  Absolutely agree that this needs more discussion.  I'll send a ping on the list shortly.",
          "createdAt": "2018-10-21T23:27:18Z",
          "updatedAt": "2018-10-21T23:27:18Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@jmillican To answer your question, yes, the idea here is to fail before you get to the AEAD stage.  In the spec before this PR merged, group members that arrived at different states would have different keys, but they would never find out that was the case until there was an AEAD failure.  With this PR (or #72), a peer know that if processing of a Handshake message succeeds, then it has the same GroupState as the sender.",
          "createdAt": "2018-10-22T12:51:51Z",
          "updatedAt": "2018-10-22T12:51:51Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2Nzk4Mjc2",
          "commit": {
            "abbreviatedOid": "c55b9f3"
          },
          "author": "jmillican",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Agreed that we need further discussion with academics, and modelling of the properties, but this seems good to provisionally merge.",
          "createdAt": "2018-10-21T19:49:59Z",
          "updatedAt": "2018-10-21T19:49:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 72,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI0MzYwNzcw",
      "title": "Add explicit key confirmation (alternate approach)",
      "url": "https://github.com/mlswg/mls-protocol/pull/72",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "duplicate"
      ],
      "body": "This PR is an alternative approach to #71.  Instead of using an explicit MAC, we derive a confirmation value in the key schedule and just publish that.  Since the key schedule already folds in the GroupState (and thus the transcript of GroupOperations), the only gap here is that the signature on the Handshake message isn't included.",
      "createdAt": "2018-10-19T17:40:04Z",
      "updatedAt": "2019-12-17T10:11:25Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "d160a02d4729899dfeedbac381a2380661e23993",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "authn-v3.1",
      "headRefOid": "d4a638ced4276b262c7ff4923870ea662c946398",
      "closedAt": "2019-01-07T22:37:16Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing in light of WG discussion preferring the other approach.",
          "createdAt": "2019-01-07T22:37:16Z",
          "updatedAt": "2019-01-07T22:37:16Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2NjM3NDQw",
          "commit": {
            "abbreviatedOid": "d4a638c"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-19T18:09:10Z",
          "updatedAt": "2018-10-19T18:09:11Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Can't we send the next `init_secret`instead ?",
              "createdAt": "2018-10-19T18:09:10Z",
              "updatedAt": "2018-10-19T18:09:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2NjUwODI5",
          "commit": {
            "abbreviatedOid": "d4a638c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-19T18:46:28Z",
          "updatedAt": "2018-10-19T18:46:28Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "That seems bad, since the `init_secret` feeds into the next `epoch_secret`.  It does get mixed with the `update_secret` there, but it would still would make me even more worried than this proposal does.",
              "createdAt": "2018-10-19T18:46:28Z",
              "updatedAt": "2018-10-19T18:46:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2NjY1MDI5",
          "commit": {
            "abbreviatedOid": "d4a638c"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-19T19:28:04Z",
          "updatedAt": "2018-10-19T19:28:04Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Indeed it is preferable to avoid it. I was just wondering if we can reuse something we already have...",
              "createdAt": "2018-10-19T19:28:04Z",
              "updatedAt": "2018-10-19T19:28:04Z"
            }
          ]
        }
      ]
    },
    {
      "number": 73,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI0MzY0OTM5",
      "title": "Convert transcript to a hash",
      "url": "https://github.com/mlswg/mls-protocol/pull/73",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement",
        "privacy",
        "security"
      ],
      "body": "There is no reason for the members of a conversation to keep the whole history of group operations, but they should agree on it.",
      "createdAt": "2018-10-19T17:56:23Z",
      "updatedAt": "2019-12-17T09:37:27Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "d160a02d4729899dfeedbac381a2380661e23993",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "transcript-hash",
      "headRefOid": "713d2d90532c90b9cacb426a698eaf4560de3018",
      "closedAt": "2018-10-19T18:46:37Z",
      "mergedAt": "2018-10-19T18:46:37Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "8b353d63adf2b10df7f6e8ade88e8a996aaf6c63"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2NjM2OTg4",
          "commit": {
            "abbreviatedOid": "713d2d9"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-10-19T18:07:47Z",
          "updatedAt": "2018-10-19T18:07:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 74,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI0NTY1NjY5",
      "title": "Add note that new clients should send an update to preserve efficienc\u2026",
      "url": "https://github.com/mlswg/mls-protocol/pull/74",
      "state": "MERGED",
      "author": "jmillican",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "performance",
        "recommendation"
      ],
      "body": "Add note that new clients should send an update to preserve efficiency of the protocol.",
      "createdAt": "2018-10-21T20:08:30Z",
      "updatedAt": "2019-12-17T09:37:12Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "8b353d63adf2b10df7f6e8ade88e8a996aaf6c63",
      "headRepository": "jmillican/mls-protocol",
      "headRefName": "new_client_updates",
      "headRefOid": "9fb9bf4bd350717d49fd73594d2a0853268f011a",
      "closedAt": "2018-10-21T22:40:49Z",
      "mergedAt": "2018-10-21T22:40:49Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "cd707b3ee6a1ef0e1f8fe8616b6ebb5b574567b3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2ODA0MjEy",
          "commit": {
            "abbreviatedOid": "9fb9bf4"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-10-21T22:40:43Z",
          "updatedAt": "2018-10-21T22:40:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 75,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI0NjkxMDEz",
      "title": "Editorial fixes pre -02",
      "url": "https://github.com/mlswg/mls-protocol/pull/75",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-10-22T14:02:13Z",
      "updatedAt": "2019-12-17T09:36:47Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "4e243852e9abd5391e3a38273322860d6bd58262",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "editorial-pre-02",
      "headRefOid": "96ee6caba66e17e44cd9cf1e4f8a572f7e628c76",
      "closedAt": "2018-10-22T14:02:34Z",
      "mergedAt": "2018-10-22T14:02:34Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "a9a6ae277c0502843108bdabb7407e49253624f9"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 77,
      "id": "MDExOlB1bGxSZXF1ZXN0MjMyOTY5MTEz",
      "title": "Trivial fix \"leaf leaf\" to \"the leaf\"",
      "url": "https://github.com/mlswg/mls-protocol/pull/77",
      "state": "MERGED",
      "author": "keaston",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-11-22T12:51:40Z",
      "updatedAt": "2019-12-17T09:36:41Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "a9a6ae277c0502843108bdabb7407e49253624f9",
      "headRepository": "keaston/mls-protocol",
      "headRefName": "patch-1",
      "headRefOid": "a3da181a9942bb2f6eb739787a3d9cb431f31b3f",
      "closedAt": "2018-11-26T14:41:41Z",
      "mergedAt": "2018-11-26T14:41:41Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "d99882ca4e8d8af57c3d88dd23352c47438a1152"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 78,
      "id": "MDExOlB1bGxSZXF1ZXN0MjM1OTA0ODcw",
      "title": "Change order of fields in UserInitKey struct",
      "url": "https://github.com/mlswg/mls-protocol/pull/78",
      "state": "MERGED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "algorithm is now before identity_key for easier parsing",
      "createdAt": "2018-12-04T17:58:41Z",
      "updatedAt": "2019-12-17T09:36:30Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "d99882ca4e8d8af57c3d88dd23352c47438a1152",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "userinitkey-details",
      "headRefOid": "73c506384b662b0e69e29760c3111ebde3e82c62",
      "closedAt": "2018-12-04T17:59:53Z",
      "mergedAt": "2018-12-04T17:59:53Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "1d6f0276cd0ec57e29205b084c2f5289a80d8815"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed.  I also ran into this problem in my implementation.",
          "createdAt": "2018-12-04T17:59:47Z",
          "updatedAt": "2018-12-04T17:59:47Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 79,
      "id": "MDExOlB1bGxSZXF1ZXN0MjM1OTEwNzgx",
      "title": "Add ciphersuites and signature schemes",
      "url": "https://github.com/mlswg/mls-protocol/pull/79",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial",
        "recommendation"
      ],
      "body": "Need some actual values here for interop.  Signature scheme values are a subset of those in RFC 8446.\r\n\r\n@raphaelrobert - Do you think we should go ahead and define the higher-security-level ciphersuites as well as signature algorithms?",
      "createdAt": "2018-12-04T18:19:23Z",
      "updatedAt": "2019-12-17T09:35:07Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "1d6f0276cd0ec57e29205b084c2f5289a80d8815",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "ciphersuites",
      "headRefOid": "46b3dc1d8b9d22fe63f595543414e58355bd938b",
      "closedAt": "2018-12-04T18:36:21Z",
      "mergedAt": "2018-12-04T18:36:21Z",
      "mergedBy": "raphaelrobert",
      "mergeCommit": {
        "oid": "4353050b38578c43e65428e9e22527a6a640e2c4"
      },
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "Looks good to me! We can always re-introduce Ed448 with X448 later.",
          "createdAt": "2018-12-04T18:36:07Z",
          "updatedAt": "2018-12-04T18:36:07Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 80,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQwNjQ1NzQw",
      "title": "Welcome improvements",
      "url": "https://github.com/mlswg/mls-protocol/pull/80",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "bug",
        "editorial",
        "privacy",
        "security"
      ],
      "body": "This PR addresses two outstanding issues with Welcome messages:\r\n\r\n1. Welcome messages were not encrypted for the new member, so that the information in them (in particular, init secrets) were not appropriately protected.\r\n\r\n2. The protocol overview had not been updated to include the Welcome-based add flow.",
      "createdAt": "2018-12-22T17:32:51Z",
      "updatedAt": "2019-12-17T09:34:51Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "4353050b38578c43e65428e9e22527a6a640e2c4",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "welcome-crypt",
      "headRefOid": "8e5cd2acc2bb997345a58892b25e99513917c614",
      "closedAt": "2019-01-04T20:03:54Z",
      "mergedAt": "2019-01-04T20:03:54Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "95fe9d4169c03a7335e3be4d494729c46bd6d752"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg3NTk4NTYy",
          "commit": {
            "abbreviatedOid": "8e5cd2a"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-12-22T17:39:36Z",
          "updatedAt": "2018-12-22T17:46:23Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Note to self: there is no need to send it to the group, indeed. A nice thing might be for the group to have optional knowledge of who invited someone to the group.",
              "createdAt": "2018-12-22T17:39:36Z",
              "updatedAt": "2018-12-22T17:46:23Z"
            }
          ]
        }
      ]
    },
    {
      "number": 81,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQyMzU5MDI0",
      "title": "Bugfixes for GroupState, Welcome and UserInitKeys",
      "url": "https://github.com/mlswg/mls-protocol/pull/81",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "bug",
        "editorial"
      ],
      "body": "This PR fixes several small issues I encountered while bringing my implementation more up to date. \r\n\r\n* When I changed `GroupState` to allow blanks in the tree, I failed to update `Welcome` accordingly\r\n* Credentials should dictate what signature scheme they will be used with, and once that's the case, we no longer need to indicate what algorithm is in use in cases where the signer's credential is known\r\n* `UserInitKeys` should come with a credential, not just a public key\r\n* The confirmation value is easier to parse as an opaque vector value than as an array whose size depends on the ciphersuite in use",
      "createdAt": "2019-01-04T20:03:00Z",
      "updatedAt": "2019-12-17T09:34:17Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "95fe9d4169c03a7335e3be4d494729c46bd6d752",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "bugfixes",
      "headRefOid": "d4ba9a453512d1d723efcf86f517c9bc041fe885",
      "closedAt": "2019-01-07T22:39:20Z",
      "mergedAt": "2019-01-07T22:39:20Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "e76abde308ed36d07907c3777245b187b4f95d17"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg5NTkxNTM1",
          "commit": {
            "abbreviatedOid": "d4ba9a4"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-01-05T09:28:57Z",
          "updatedAt": "2019-01-05T09:31:37Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Should that just be `Credential` ? Otherwise `BasicCredential` should probably be used in \"UserInitKey\".",
              "createdAt": "2019-01-05T09:28:57Z",
              "updatedAt": "2019-01-05T09:31:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkwMDI0MzQ2",
          "commit": {
            "abbreviatedOid": "d4ba9a4"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-07T22:35:49Z",
          "updatedAt": "2019-01-07T22:35:49Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "`Credential` is the generic object (with a type selector).  `BasicCredential`is a specific type of credential that just lists the required info (without, say, a signature from a CA).",
              "createdAt": "2019-01-07T22:35:49Z",
              "updatedAt": "2019-01-07T22:35:49Z"
            }
          ]
        }
      ]
    },
    {
      "number": 82,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQyMzY1MjI1",
      "title": "Simplify authentication calculations",
      "url": "https://github.com/mlswg/mls-protocol/pull/82",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement",
        "security"
      ],
      "body": "Looking at the signature and confirmation calculations in the current draft and comparing them to TLS, things seemed a bit complicated.  In TLS, we have the following:\r\n\r\n> CertificateVerify: A signature over the value Transcript-Hash(Handshake Context, Certificate)\r\n> Finished: A MAC over the value Transcript-Hash(Handshake Context, Certificate, CertificateVerify) using a MAC key derived from the base key.\r\n\r\nThis PR implements an analogous computation for MLS, where the signature in a message covers the transcript hash in the latest group state (which includes any changes to the roster ~ Certificate), and the confirmation MAC covers the transcript hash, plus the signature (i.e., the contents of CertificateVerify). ",
      "createdAt": "2019-01-04T20:32:31Z",
      "updatedAt": "2019-12-17T09:33:05Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "e76abde308ed36d07907c3777245b187b4f95d17",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "simplify-authn",
      "headRefOid": "b36ea7cbc0c573814d0762976addfa62e33c4c92",
      "closedAt": "2019-01-11T23:17:30Z",
      "mergedAt": "2019-01-11T23:17:30Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "c24590ebf8bf84e2cd738b45237b55da91861135"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Merging this despite CI failures because they seem to be spurious.",
          "createdAt": "2019-01-11T23:17:24Z",
          "updatedAt": "2019-01-11T23:17:24Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg5NTkxMzk2",
          "commit": {
            "abbreviatedOid": "2a86c81"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-01-05T09:22:32Z",
          "updatedAt": "2019-01-05T09:31:52Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Should that be `confirmation_data = signature_data || Handshake.signature` ?\r\n(otherwise `signature_data` seems unused)",
              "createdAt": "2019-01-05T09:22:32Z",
              "updatedAt": "2019-01-07T22:48:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkwMDIzODYy",
          "commit": {
            "abbreviatedOid": "2a86c81"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-07T22:34:18Z",
          "updatedAt": "2019-01-07T22:34:18Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "My intent was that \"signature_data\" would be the input to the signature calculation.  I'll revise to clarify that.",
              "createdAt": "2019-01-07T22:34:18Z",
              "updatedAt": "2019-01-07T22:48:29Z"
            }
          ]
        }
      ]
    },
    {
      "number": 83,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQyNDM1MDgz",
      "title": "Add dependencies for continuous build",
      "url": "https://github.com/mlswg/mls-protocol/pull/83",
      "state": "MERGED",
      "author": "katrielalex",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "We need xml2rfc and kramdown-rfc2629 to build the HTML version of the rfc. This adds that information in Ruby (resp Python) syntax so that build tools can pick it up.",
      "createdAt": "2019-01-05T11:19:20Z",
      "updatedAt": "2019-12-17T09:32:38Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "95fe9d4169c03a7335e3be4d494729c46bd6d752",
      "headRepository": "katrielalex/mls-protocol",
      "headRefName": "dependencies-for-build",
      "headRefOid": "7088ab33f1728cf434636d56d498df2832947b1d",
      "closedAt": "2019-01-05T11:21:17Z",
      "mergedAt": "2019-01-05T11:21:17Z",
      "mergedBy": "katrielalex",
      "mergeCommit": {
        "oid": "f9fa240fbb7cf38ad4fca54810b213045046bb4f"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 84,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ0MTgxMDUy",
      "title": "Garbage collection",
      "url": "https://github.com/mlswg/mls-protocol/pull/84",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement",
        "performance"
      ],
      "body": "Right now, we blank out leaf nodes when we remove their holders, but we never reduce the size of hte tree or repopulate interior blanks with new members.  This PR adds those functions:\r\n\r\n* Reduce the size of the tree and the roster when you remove from the right edge\r\n* Add an `index` field to the `Add` message, to enable new members to be added to blank slots in the tree, not just at the right edge.\r\n\r\nIn addition to performing \"garbage collection\", this change should make it easier to do a state resync -- just remove the desync'ed endpoint and add them back in the same spot.\r\n\r\nFixes #86 ",
      "createdAt": "2019-01-11T23:51:41Z",
      "updatedAt": "2019-12-17T09:32:27Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "c24590ebf8bf84e2cd738b45237b55da91861135",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "add-in-place",
      "headRefOid": "04027ef3fa995a0f56eebe7ff1c500a0f4462af1",
      "closedAt": "2019-03-06T08:44:27Z",
      "mergedAt": "2019-03-06T08:44:27Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "645961291858d86f74a41b0d9e4f257db9fb96a0"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@beurdouche Do you think this is ready to merge?  [Notes from the interim](https://github.com/mlswg/mls-protocol/issues/86#issuecomment-454579285) say it's OK as long as we can convince ourselves that truncation preserves the tree invariant. \r\n\r\nProof sketch: The tree invariant is a universal statement over nodes in the tree and members in the group:  \r\n\r\n![image](https://user-images.githubusercontent.com/75597/52915085-bb96fe80-329d-11e9-84c6-7cea21bd27b8.png)\r\n\r\nSince subtrees are just subsets of the set of nodes in the tree, if the tree invariant holds for a given tree, then it also holds for any subtree of that tree.  So since truncation just moves from a tree to a subtree, the invariant continues to hold.",
          "createdAt": "2019-02-17T15:24:15Z",
          "updatedAt": "2019-02-17T15:24:15Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEwNTA2ODY5",
          "commit": {
            "abbreviatedOid": "04027ef"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-03-05T06:12:40Z",
          "updatedAt": "2019-03-05T06:12:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 85,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ0MTk4NTI3",
      "title": "Update changelong with entries for -03",
      "url": "https://github.com/mlswg/mls-protocol/pull/85",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "I forgot to update the changelog before I published -03.  We should add that to the review criteria.  This will at least fix it for -04.",
      "createdAt": "2019-01-12T03:59:33Z",
      "updatedAt": "2019-12-17T09:32:04Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "c24590ebf8bf84e2cd738b45237b55da91861135",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "changelog",
      "headRefOid": "08c2e06bd1cc59068cfba50c0fcd5f3addcd50f9",
      "closedAt": "2019-01-22T22:02:35Z",
      "mergedAt": "2019-01-22T22:02:35Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "2c724a84f61b1909f2eca97392a2e8c94e58d0f9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk0Mjg1MTU4",
          "commit": {
            "abbreviatedOid": "08c2e06"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-01-18T21:14:30Z",
          "updatedAt": "2019-01-18T21:14:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 94,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ0Mjg4Nzgw",
      "title": "Update of the client/participent/member terminology with Architecture draft",
      "url": "https://github.com/mlswg/mls-protocol/pull/94",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [
        "beurdouche"
      ],
      "labels": [
        "terminology"
      ],
      "body": "Aligning the terminology across the two documents after discussion.",
      "createdAt": "2019-01-13T16:19:32Z",
      "updatedAt": "2019-12-17T09:31:57Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "953ce6a405380611c148824dabdfb5a5c4b1f59e",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "language",
      "headRefOid": "5eb65332726fe3146c9cfc041e9690805e5dd05e",
      "closedAt": "2019-02-26T16:05:41Z",
      "mergedAt": "2019-02-26T16:05:41Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "2cc376d55fe8ac6fd805b413fc9bbb217fbe784b"
      },
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Ok, I think this is ready, please have a look.. I believe the changes are reasonably concise, the use of client seems better in some places than participant was and doesn't feel odd to me.",
          "createdAt": "2019-02-25T15:24:09Z",
          "updatedAt": "2019-02-25T15:24:09Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA3NDU1Mjg5",
          "commit": {
            "abbreviatedOid": "5bbc64a"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-25T15:25:14Z",
          "updatedAt": "2019-02-25T15:25:15Z",
          "comments": [
            {
              "originalPosition": 154,
              "body": "I'll remove that line in a separate commit, since we currently don't have UserAdd",
              "createdAt": "2019-02-25T15:25:15Z",
              "updatedAt": "2019-02-26T09:13:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA3NDkxNDA5",
          "commit": {
            "abbreviatedOid": "5bbc64a"
          },
          "author": "eomara",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2019-02-25T16:21:49Z",
          "updatedAt": "2019-02-25T16:21:49Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA3NjgxMDAx",
          "commit": {
            "abbreviatedOid": "5bbc64a"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-02-25T23:00:45Z",
          "updatedAt": "2019-02-25T23:08:51Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Subject/verb agreement \"Users ... needs\".  Re-introducing \"A group of...\" would fix this.",
              "createdAt": "2019-02-25T23:00:45Z",
              "updatedAt": "2019-02-26T09:13:27Z"
            },
            {
              "originalPosition": 28,
              "body": "Let's not capitalize terms, just be consistent.",
              "createdAt": "2019-02-25T23:01:39Z",
              "updatedAt": "2019-02-26T09:13:27Z"
            },
            {
              "originalPosition": 52,
              "body": "This doesn't need a `(\\*)`, since it's not a breaking change.",
              "createdAt": "2019-02-25T23:02:09Z",
              "updatedAt": "2019-02-26T09:13:27Z"
            },
            {
              "originalPosition": 28,
              "body": "Likewise in a bunch of places below.",
              "createdAt": "2019-02-25T23:03:12Z",
              "updatedAt": "2019-02-26T09:13:27Z"
            },
            {
              "originalPosition": 124,
              "body": "This reads awkwardly.  Suggest deleting \", members of a group,\"",
              "createdAt": "2019-02-25T23:05:04Z",
              "updatedAt": "2019-02-26T09:13:27Z"
            },
            {
              "originalPosition": 347,
              "body": "I might rephrase this as \"The client joining the group...\"",
              "createdAt": "2019-02-25T23:07:41Z",
              "updatedAt": "2019-02-26T09:13:27Z"
            },
            {
              "originalPosition": 365,
              "body": "This would read better as singular, \"... the new member SHOULD...\"",
              "createdAt": "2019-02-25T23:08:12Z",
              "updatedAt": "2019-02-26T09:13:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA3ODMxNjQ1",
          "commit": {
            "abbreviatedOid": "4629a73"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Done, thanks for the review. I'll let you merge this.",
          "createdAt": "2019-02-26T09:04:06Z",
          "updatedAt": "2019-02-26T09:14:07Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "I just removed capitalization everywhere.",
              "createdAt": "2019-02-26T09:04:06Z",
              "updatedAt": "2019-02-26T09:14:07Z"
            },
            {
              "originalPosition": 14,
              "body": "Fixed.",
              "createdAt": "2019-02-26T09:04:14Z",
              "updatedAt": "2019-02-26T09:14:07Z"
            },
            {
              "originalPosition": 52,
              "body": "Fixed.",
              "createdAt": "2019-02-26T09:04:22Z",
              "updatedAt": "2019-02-26T09:14:07Z"
            },
            {
              "originalPosition": 124,
              "body": "Fixed.",
              "createdAt": "2019-02-26T09:06:14Z",
              "updatedAt": "2019-02-26T09:14:07Z"
            },
            {
              "originalPosition": 347,
              "body": "Fixed.",
              "createdAt": "2019-02-26T09:07:16Z",
              "updatedAt": "2019-02-26T09:14:07Z"
            },
            {
              "originalPosition": 365,
              "body": "Fixed",
              "createdAt": "2019-02-26T09:08:01Z",
              "updatedAt": "2019-02-26T09:14:07Z"
            },
            {
              "originalPosition": 154,
              "body": "I did that as well.",
              "createdAt": "2019-02-26T09:12:40Z",
              "updatedAt": "2019-02-26T09:14:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4MDQzODg3",
          "commit": {
            "abbreviatedOid": "5eb6533"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-26T15:58:48Z",
          "updatedAt": "2019-02-26T15:58:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 99,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ0NTU3MTU2",
      "title": "[ci] Add certified to the bundler dependencies",
      "url": "https://github.com/mlswg/mls-protocol/pull/99",
      "state": "MERGED",
      "author": "katrielalex",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "I hypothesise that the CI is failing because I forgot a dependency.\r\n\r\nNot sure that's actually true, but in the spirit of \"move fast and break things\" I'm just merging it anyway and let's see if it fixes it.",
      "createdAt": "2019-01-14T19:20:56Z",
      "updatedAt": "2019-12-17T09:31:03Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "c24590ebf8bf84e2cd738b45237b55da91861135",
      "headRepository": "katrielalex/mls-protocol",
      "headRefName": "certified",
      "headRefOid": "cfeceda1553206ff8f3fc84952197e6b7d239899",
      "closedAt": "2019-01-14T19:24:31Z",
      "mergedAt": "2019-01-14T19:24:31Z",
      "mergedBy": "katrielalex",
      "mergeCommit": {
        "oid": "9723c82a5056576d7e0c7e789896e61404b0e454"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 106,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ1OTkwMTc2",
      "title": "Small edits: formatting, typos, and wording",
      "url": "https://github.com/mlswg/mls-protocol/pull/106",
      "state": "CLOSED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "beurdouche"
      ],
      "labels": [
        "editorial"
      ],
      "body": "I focused on 3 main things in this edit, which are reflected in the 3 commits:\r\n\r\n1. Looking at the HTML-rendered output, there were some structs that were already backtick-literal and some that were not. For the sake of consistency and readability, I literalized all structs and variable names that occur in prose. I also chose to leave function names alone, since it felt appropriate that they be written in the font of the rest of the paragraph.\r\n2. There were 3 obvious typos. The first one was \"it its\" where it meant \"its\", the second one was \"participants\" where it meant \"participant's\" (I'm sorry, this edit was actually in the formatting commit but it should've been in the typo commit), and the third was was listing \"P-256\" as the hashing algorithm for one of the ciphersuites.\r\n3. There was a lot of wording like \"direct path from the leaf to the root node\" but the wording set up in section 5.1 is \"direct path of the node\", so I changed all instances of the former to the latter for consistency's sake. There were also some uses of \"non-updated sibling\" where the term \"copath\" could be used. I'm least confident about this change, since it sounds a bit obtuse, but it's nice to stick to the terminology that has been used previously.\r\n\r\nOf course, I'm open to any and all disagreements. To whomever reads this: thank you for your time.",
      "createdAt": "2019-01-18T22:22:08Z",
      "updatedAt": "2019-12-17T09:30:31Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "9723c82a5056576d7e0c7e789896e61404b0e454",
      "headRepository": "rozbb/mls-protocol",
      "headRefName": "master",
      "headRefOid": "b02216dff9beb3656bd9b6dddfd833195e6f67c4",
      "closedAt": "2019-01-22T22:01:21Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Thank you for the review, we'll look into it ASAP.",
          "createdAt": "2019-01-18T22:45:31Z",
          "updatedAt": "2019-01-18T22:45:31Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "This is done, I cherry picked 3 out of 4 commits, made minor corrections and merged the changes via (PR #111) opened an issue for the consistency of using backticks that I will discuss with other editors later (Issue #110). Thanks you, this was helpful !",
          "createdAt": "2019-01-22T22:01:20Z",
          "updatedAt": "2019-01-22T22:01:20Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 109,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ2NzU5NjAy",
      "title": "Fix typos reported by @rozbb",
      "url": "https://github.com/mlswg/mls-protocol/pull/109",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2019-01-22T21:32:18Z",
      "updatedAt": "2019-12-17T09:30:23Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "9723c82a5056576d7e0c7e789896e61404b0e454",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_typos",
      "headRefOid": "4e79c4b30736d85f4e197f62af7802a98c9c9515",
      "closedAt": "2019-01-22T21:32:26Z",
      "mergedAt": "2019-01-22T21:32:26Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "2d24b27744808cf36c5d37453b96c6cb1d3b4608"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 111,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ2NzY2NTYw",
      "title": "Merging some commits from PR #106",
      "url": "https://github.com/mlswg/mls-protocol/pull/111",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "The very first commit from PR #106 (6ba86ff561484a9eb96012e3b55b49f23cb8f9e9) was removed and a separate Issue #110 is filled for unifying the use of \"`\" and \"_\".",
      "createdAt": "2019-01-22T21:57:37Z",
      "updatedAt": "2019-01-22T22:20:16Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "2d24b27744808cf36c5d37453b96c6cb1d3b4608",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_merge_rozbb",
      "headRefOid": "582bf53bdf29d5c0fa2d15440c4547cb6fa81026",
      "closedAt": "2019-01-22T21:58:36Z",
      "mergedAt": "2019-01-22T21:58:36Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "c7881095922a9a790e0012b5916ccfa929426d93"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 113,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ2Nzg3Nzcz",
      "title": "Algorithm agility and ciphersuites (Issue #95)",
      "url": "https://github.com/mlswg/mls-protocol/pull/113",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "? follow-up",
        "functionality"
      ],
      "body": "DO NOT MERGE: Work in Progress\r\n\r\nDiscussion: Is this how we should define a ciphersuite -> (KEM,SYM,SIG,HASH) ?",
      "createdAt": "2019-01-22T23:26:03Z",
      "updatedAt": "2019-12-20T10:26:06Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "55183cc33ff09b3a4bc9dbc20e4323ca104661f8",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_ciphersuites",
      "headRefOid": "94c9f928d151cb8d85742932d8e7988cf9a68b4e",
      "closedAt": "2019-07-01T22:23:35Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "In addition to the two comments inline, note that there's an additional complication here due to `Derive-Key-Pair` -- if we do this decoupling, then we need to also have a requirement that the hash function in use produces enough entropy for the curve in use.  E.g., you wouldn't want to use Ed448 with SHA-256.",
          "createdAt": "2019-02-17T15:35:54Z",
          "updatedAt": "2019-02-17T15:35:54Z"
        },
        {
          "author": "katrielalex",
          "authorAssociation": "MEMBER",
          "body": "I am trying to fix up the CI and it looks like this PR is actually broken:\r\n\r\n```\r\n4:13:00 PM: Error: Unable to validate the XML document: draft-ietf-mls-protocol.xml\r\n4:13:00 PM:  <string>: Line 726: IDREF attribute target references an unknown ID \"SHS\"\r\n4:13:00 PM:  <string>: Line 736: IDREF attribute target references an unknown ID \"SHS\"\r\n4:13:00 PM:  <string>: Line 788: IDREF attribute target references an unknown ID \"SHS\"\r\n4:13:00 PM:  <string>: Line 730: IDREF attribute target references an unknown ID \"RFC8032\"\r\n4:13:00 PM:  <string>: Line 694: IDREF attribute target references an unknown ID \"RFC7919\"\r\n4:13:00 PM:  <string>: Line 733: IDREF attribute target references an unknown ID \"RFC8017\"\r\n4:13:00 PM:  <string>: Line 724: IDREF attribute target references an unknown ID \"ECDSA\"\r\n4:13:00 PM:  <string>: Line 691: IDREF attribute target references an unknown ID \"DSS\"\r\n4:13:00 PM:  <string>: Line 725: IDREF attribute target references an unknown ID \"DSS\"\r\n4:13:00 PM:  <string>: Line 727: IDREF attribute target references an unknown ID \"X690\"\r\n4:13:00 PM:  <string>: Line 788: IDREF attribute target references an unknown ID \"RFC7539\"\r\n4:13:00 PM: make: *** [draft-ietf-mls-protocol.htmltmp] Error 1\r\n```",
          "createdAt": "2019-02-17T16:21:07Z",
          "updatedAt": "2019-02-17T16:21:07Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "@bifurcation I'll try to work a bit more on this tomorrow. Anything controversial or missing ?",
          "createdAt": "2019-03-10T17:59:23Z",
          "updatedAt": "2019-03-10T17:59:23Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Specifically, the next two subsections just before \"Credentials\" should probably be removed or merged.",
          "createdAt": "2019-03-10T18:06:00Z",
          "updatedAt": "2019-03-10T18:06:00Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this one is well stale by now.  Still an issue that merits consideration, but needs a fresh PR.",
          "createdAt": "2019-07-01T22:23:35Z",
          "updatedAt": "2019-07-01T22:23:35Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0NTY2NTY3",
          "commit": {
            "abbreviatedOid": "d1f9f2f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-02-17T15:32:31Z",
          "updatedAt": "2019-02-17T15:34:07Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "If we're going to decouple like this, then we should just incorporate the TLS algorithm identifiers by reference.",
              "createdAt": "2019-02-17T15:32:31Z",
              "updatedAt": "2019-02-25T17:55:27Z"
            },
            {
              "originalPosition": 71,
              "body": "Let's not do RSA-PSS.  I don't think anyone is asking for it.",
              "createdAt": "2019-02-17T15:32:59Z",
              "updatedAt": "2019-02-25T17:55:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA3MzUxODY3",
          "commit": {
            "abbreviatedOid": "d1f9f2f"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-25T11:52:00Z",
          "updatedAt": "2019-02-25T11:52:01Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "I actually agree with this and will remove it. I liked the idea of aligning on TLS but randomness issues related to this are not something we want.",
              "createdAt": "2019-02-25T11:52:00Z",
              "updatedAt": "2019-02-25T17:55:27Z"
            }
          ]
        }
      ]
    },
    {
      "number": 114,
      "id": "MDExOlB1bGxSZXF1ZXN0MjUxNDY0ODAw",
      "title": "Use a KDF instead of a hash function to get keys for parent nodes",
      "url": "https://github.com/mlswg/mls-protocol/pull/114",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "enhancement",
        "security"
      ],
      "body": "For now, I've only touched the sections until the \"Cryptographic Objects\" section, which seems to be outdated anyway. Once those are updated at some point, I'm happy to help moving from hashing to KDF-derivation there as well.",
      "createdAt": "2019-02-08T13:28:48Z",
      "updatedAt": "2019-12-17T09:28:35Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "2c724a84f61b1909f2eca97392a2e8c94e58d0f9",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "master",
      "headRefOid": "6856b0d868c01965c753989545bb93de8728d9cd",
      "closedAt": "2019-02-08T13:43:20Z",
      "mergedAt": "2019-02-08T13:43:20Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "d43ff0ae3c0fb0c33429f505359ba72b96b00ab1"
      },
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Thanks Konrad ! : )",
          "createdAt": "2019-02-08T13:43:37Z",
          "updatedAt": "2019-02-08T13:43:37Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxNTgzMTky",
          "commit": {
            "abbreviatedOid": "6856b0d"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-08T13:43:14Z",
          "updatedAt": "2019-02-08T13:43:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 115,
      "id": "MDExOlB1bGxSZXF1ZXN0MjUxNDk3NzA4",
      "title": "Key Schedule uses the transcript_hash instead of the raw group_state",
      "url": "https://github.com/mlswg/mls-protocol/pull/115",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "enhancement",
        "security"
      ],
      "body": "This is an attempt to solve #90 and #107.",
      "createdAt": "2019-02-08T15:14:10Z",
      "updatedAt": "2019-12-17T09:28:04Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "d43ff0ae3c0fb0c33429f505359ba72b96b00ab1",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_ks",
      "headRefOid": "7fc6322db0407543712be1e7ae16cee321625ce3",
      "closedAt": "2019-02-21T11:27:51Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Note that there is a need to handle messages that are not exactly Group Operations such as the Welcome message. (I think it should be considered as a Group Operation and be added in the Group State transcript hash)",
          "createdAt": "2019-02-08T15:19:56Z",
          "updatedAt": "2019-02-08T15:19:56Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Closing this in favor of #123 (which does not touch the way we pass the Group State to Derive Secret at all, we can do this in a different PR if need be.)",
          "createdAt": "2019-02-21T11:27:51Z",
          "updatedAt": "2019-02-21T11:27:51Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0NTY2MzY4",
          "commit": {
            "abbreviatedOid": "7fc6322"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-02-17T15:27:54Z",
          "updatedAt": "2019-02-17T15:31:21Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "If you're going to change `Derive-Secret` to `HKDF-Expand-Label`, then you need to chance these instances as well.  Alternatively, you could just define `Derive-Secret` in terms of `HKDF-Expand-Label`, basically as an abbreviation to make this diagram flow better.",
              "createdAt": "2019-02-17T15:27:55Z",
              "updatedAt": "2019-02-17T15:31:21Z"
            },
            {
              "originalPosition": 61,
              "body": "I would prefer that we not make this change, i.e., that we set the context to the serialized group state.  Changing from the group state to the transcript hash has bigger implications than just changing how the hashes are arranged.  That is, let's do #107 in this PR, and #90 later.  Note that this would also obviate the OPEN ISSUE below.",
              "createdAt": "2019-02-17T15:29:20Z",
              "updatedAt": "2019-02-17T15:31:21Z"
            },
            {
              "originalPosition": 106,
              "body": "Nit: Extra blank line.",
              "createdAt": "2019-02-17T15:30:31Z",
              "updatedAt": "2019-02-17T15:31:21Z"
            },
            {
              "originalPosition": 98,
              "body": "You could note here that this is the same as the TLS encoding of `sender` as a `uint32`.  Which is probably in fact how I would implement it.",
              "createdAt": "2019-02-17T15:31:11Z",
              "updatedAt": "2019-02-17T15:31:21Z"
            }
          ]
        }
      ]
    },
    {
      "number": 116,
      "id": "MDExOlB1bGxSZXF1ZXN0MjUxNTAyMTkx",
      "title": "Rename ECIES to HPKE",
      "url": "https://github.com/mlswg/mls-protocol/pull/116",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "terminology"
      ],
      "body": "This does not handle the removal of DH uses instead of KEM which will be done as part of Issue #95 / PR #113 ...",
      "createdAt": "2019-02-08T15:27:18Z",
      "updatedAt": "2019-12-17T09:25:19Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "d43ff0ae3c0fb0c33429f505359ba72b96b00ab1",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_hpke",
      "headRefOid": "08c4f25a17656a85a7ab537da1160d9d769b201f",
      "closedAt": "2019-02-21T10:59:53Z",
      "mergedAt": "2019-02-21T10:59:53Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "07a1b0a3703a5930a1a2dece74d05aadbd1b15e7"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I would be happier if this PR were moving the draft to use draft-barnes-cfrg-hpke, which is one of the changes I had in mind for -04.  Do you think that's premature?",
          "createdAt": "2019-02-17T15:14:18Z",
          "updatedAt": "2019-02-17T15:14:18Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0NTY1NDE5",
          "commit": {
            "abbreviatedOid": "6dff904"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-02-17T15:04:38Z",
          "updatedAt": "2019-02-17T15:12:25Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Since we're moving to a more KEM-like framework, it might be good to also change this from `ephemeral_key` to something like `encapsulated_key`.\r\n\r\nAlso, while you're working here, please go ahead and increase the size of the `ciphertext` field.",
              "createdAt": "2019-02-17T15:04:38Z",
              "updatedAt": "2019-02-21T10:58:00Z"
            },
            {
              "originalPosition": 16,
              "body": "Also, the reason I had `DH` there was to distinguish from `SignaturePublicKey`.  Just having `PubilcKey` vs. `SignaturePublicKey` seems less clear.  What about `KEMPublicKey` or `HPKEPublicKey`?",
              "createdAt": "2019-02-17T15:06:08Z",
              "updatedAt": "2019-02-21T10:58:00Z"
            },
            {
              "originalPosition": 60,
              "body": "I'm inclined to go ahead and change this out for a reference to the CFRG HPKE draft.  If that doesn't get adopted by CFRG for some reason, we can always revert.",
              "createdAt": "2019-02-17T15:10:53Z",
              "updatedAt": "2019-02-21T10:58:00Z"
            },
            {
              "originalPosition": 89,
              "body": "This OPEN ISSUE can be deleted.  The Welcome Message is encrypted as of -03; I just neglected to remove this comment.",
              "createdAt": "2019-02-17T15:12:18Z",
              "updatedAt": "2019-02-21T10:58:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0NzE5MDIw",
          "commit": {
            "abbreviatedOid": "6dff904"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-18T10:35:17Z",
          "updatedAt": "2019-02-18T11:07:08Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Using `encapsulated_key` and `KEMPublicKey` look ok, yes.",
              "createdAt": "2019-02-18T10:35:18Z",
              "updatedAt": "2019-02-21T10:58:00Z"
            },
            {
              "originalPosition": 89,
              "body": "Fixed.",
              "createdAt": "2019-02-18T10:44:12Z",
              "updatedAt": "2019-02-21T10:58:00Z"
            },
            {
              "originalPosition": 60,
              "body": "Ok, I removed the description and added an informative reference to HPKE.",
              "createdAt": "2019-02-18T11:01:42Z",
              "updatedAt": "2019-02-21T10:58:00Z"
            },
            {
              "originalPosition": 16,
              "body": "I removed this as we can point to the HPKE draft to get how the HPKECiphertext is internally organized.\r\nThere is still a sentence saying what the argument of HPKE Encrypt (node_secrets) are.",
              "createdAt": "2019-02-18T11:06:36Z",
              "updatedAt": "2019-02-21T10:58:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA2MjQyMTkw",
          "commit": {
            "abbreviatedOid": "08c4f25"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-21T10:59:22Z",
          "updatedAt": "2019-02-21T10:59:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 120,
      "id": "MDExOlB1bGxSZXF1ZXN0MjUzNzIzNDE1",
      "title": "WIP: Introduce a common framing layer",
      "url": "https://github.com/mlswg/mls-protocol/pull/120",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement",
        "security"
      ],
      "body": "This PR introduces a common framing layer that is used to encapsulate both Handshake and Application messages, encrypted or unencrypted.  The most significant impact is that in order to make signing logic common to both of these cases, the signature now covers only the message in question, as opposed to also covering the transcript.    \r\n\r\nFixes #101 ",
      "createdAt": "2019-02-17T16:44:23Z",
      "updatedAt": "2019-12-17T09:25:09Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "2cc376d55fe8ac6fd805b413fc9bbb217fbe784b",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "common-framing",
      "headRefOid": "304fd874a0dffba54c1f2fc161b401fd9898cc3b",
      "closedAt": "2019-04-22T21:24:42Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "As a general rule, I think we should not prefix structs with \"MLS\" as it adds no semantic value",
          "createdAt": "2019-02-27T09:34:02Z",
          "updatedAt": "2019-02-27T09:34:02Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I added some prose in the latest round of commits that should clarify what's going on here.  I think that should address most of the comments. \r\n\r\n@raphaelrobert - regarding the \"MLS\" prefix, I'm inclined to keep it, because (1) it mirrors TLS, and (2) just having Plaintext and Ciphertext seems odd to me.",
          "createdAt": "2019-02-27T23:34:01Z",
          "updatedAt": "2019-02-27T23:34:01Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing in favor of #131 ",
          "createdAt": "2019-04-22T21:24:42Z",
          "updatedAt": "2019-04-22T21:24:42Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4NDAzMDMx",
          "commit": {
            "abbreviatedOid": "72c6fda"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "How to handle the application secret generation in this common framework is interesting, we can either always include it or having it only in the case of Application messages which will degrade the symmetry.",
          "createdAt": "2019-02-27T09:04:45Z",
          "updatedAt": "2019-02-27T09:27:38Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "The signature must cover everything including the content type",
              "createdAt": "2019-02-27T09:04:45Z",
              "updatedAt": "2019-02-27T23:31:35Z"
            },
            {
              "originalPosition": 18,
              "body": "`sig_len` is undefined.",
              "createdAt": "2019-02-27T09:06:23Z",
              "updatedAt": "2019-02-27T23:31:35Z"
            },
            {
              "originalPosition": 19,
              "body": "If we are gonna do this, I would prefer `opaque signature<0..2^16-1>`\r\notherwise if the ciphersuite* gives the length of the signature we don't need this.",
              "createdAt": "2019-02-27T09:07:30Z",
              "updatedAt": "2019-02-27T23:31:35Z"
            },
            {
              "originalPosition": 35,
              "body": "I am confused now, why is there a second signature here ?\r\nIn both cases there is a signature that covers the content of `group_id`, `epoch`, `sender` and `content type` no ?",
              "createdAt": "2019-02-27T09:09:06Z",
              "updatedAt": "2019-02-27T23:31:35Z"
            },
            {
              "originalPosition": 42,
              "body": "While this is weakly-authenticated via the AEAD it should be in the MLSPlaintext header as well and covered by the signature (especially in the case of an Application message) to avoid forgery from an adversarial member who is not the sender.",
              "createdAt": "2019-02-27T09:12:35Z",
              "updatedAt": "2019-02-27T23:31:35Z"
            },
            {
              "originalPosition": 153,
              "body": "I can do that when this PR is merged.",
              "createdAt": "2019-02-27T09:13:30Z",
              "updatedAt": "2019-02-27T23:31:35Z"
            },
            {
              "originalPosition": 42,
              "body": "It is also worth noting that this field even if not technically needed in the case of a Handshake message might be able to use this to advertise a counter for application messages previously sent by the sender, hence allowing recipients to know if they received all app messages from the sender. We could limit that to the previous epoch or not... Maybe there is something there or not...",
              "createdAt": "2019-02-27T09:18:44Z",
              "updatedAt": "2019-02-27T23:31:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4NDIwNjc3",
          "commit": {
            "abbreviatedOid": "72c6fda"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-27T09:42:07Z",
          "updatedAt": "2019-02-27T09:42:08Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Why would content ever be labelled invalid?",
              "createdAt": "2019-02-27T09:42:07Z",
              "updatedAt": "2019-02-27T23:31:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4NDI2Mjc1",
          "commit": {
            "abbreviatedOid": "72c6fda"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-27T09:53:18Z",
          "updatedAt": "2019-02-27T10:08:51Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Do we need another epoch field, as well as another group_id field? Both should be implicitly verified upon successful decryption with the group secret from the epoch contained in MLSCiphertext, right?",
              "createdAt": "2019-02-27T09:59:17Z",
              "updatedAt": "2019-02-27T23:31:35Z"
            },
            {
              "originalPosition": 44,
              "body": "What do we need the sender field for in MLSCiphertext? We might even get some sort of identity hiding if we leave it out :-)",
              "createdAt": "2019-02-27T10:02:36Z",
              "updatedAt": "2019-02-27T23:31:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4NDM0NDI5",
          "commit": {
            "abbreviatedOid": "72c6fda"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-27T10:09:49Z",
          "updatedAt": "2019-02-27T10:09:50Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "What is the generation field for exactly?",
              "createdAt": "2019-02-27T10:09:49Z",
              "updatedAt": "2019-02-27T23:31:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4NDM2ODk5",
          "commit": {
            "abbreviatedOid": "72c6fda"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-27T10:14:31Z",
          "updatedAt": "2019-02-27T10:14:32Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "On the contrary, the inner one is the one we use, you don't want to sign a large padding.\r\nWhat is important is that the inner one must cover those fields as done the message protection section.",
              "createdAt": "2019-02-27T10:14:31Z",
              "updatedAt": "2019-02-27T23:31:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4NDM4MjY1",
          "commit": {
            "abbreviatedOid": "72c6fda"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-27T10:17:03Z",
          "updatedAt": "2019-02-27T10:17:04Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "We do not need to actually copy them twice indeed, only the outer one in `Ciphertext` is needed, but they need to be covered by both the AEAD and the internal signature.",
              "createdAt": "2019-02-27T10:17:04Z",
              "updatedAt": "2019-02-27T23:31:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4NDQxOTc4",
          "commit": {
            "abbreviatedOid": "72c6fda"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-27T10:24:32Z",
          "updatedAt": "2019-02-27T10:24:32Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Ok, then we're assuming that `group_id`, `sender` and `epoch` are still part of the `Handshake` struct? I was wondering if we could somehow avoid redundancy here.",
              "createdAt": "2019-02-27T10:24:32Z",
              "updatedAt": "2019-02-27T23:31:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4NDY1NzAx",
          "commit": {
            "abbreviatedOid": "72c6fda"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-27T11:15:13Z",
          "updatedAt": "2019-02-27T11:15:14Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "My initial interpretation was incorrect but, if I am correct now, above this should be removed.",
              "createdAt": "2019-02-27T11:15:13Z",
              "updatedAt": "2019-02-27T23:31:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4NDY4MDAz",
          "commit": {
            "abbreviatedOid": "72c6fda"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-27T11:20:01Z",
          "updatedAt": "2019-02-27T11:20:02Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "I was misunderstanding Richard's idea at first. I believe the idea is to encrypt the `Plaintext` with different keys depending if it is `Handshake` or `Application`. In that scenario, you need the `sender` and the `generation` in the clear to know which key to pick in the case of an Application message. Note that @raphaelrobert and I are thinking on suggesting to encrypt these under the the group key to hide them if necessary, we'll discuss this at some point. *Note that if this is the intent here, the ContentType must also be outside to know if this is an Application message or an Handshake message*.",
              "createdAt": "2019-02-27T11:20:01Z",
              "updatedAt": "2019-02-27T23:31:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4NDY4Njk2",
          "commit": {
            "abbreviatedOid": "72c6fda"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-27T11:21:46Z",
          "updatedAt": "2019-02-27T11:21:46Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "Why do you need the sender, though? Both handshake and application keys derived from the groupkey should be sender-independent.",
              "createdAt": "2019-02-27T11:21:46Z",
              "updatedAt": "2019-02-27T23:31:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4NDcyNTcx",
          "commit": {
            "abbreviatedOid": "72c6fda"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-27T11:30:59Z",
          "updatedAt": "2019-02-27T11:31:00Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "Which key do you pick when receiving an application message ? :) ",
              "createdAt": "2019-02-27T11:30:59Z",
              "updatedAt": "2019-02-27T23:31:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4NDgwMDk2",
          "commit": {
            "abbreviatedOid": "72c6fda"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-27T11:49:56Z",
          "updatedAt": "2019-02-27T11:49:56Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "I'm confused. The key for handshake encryption is derived from the `group_key`, right? So why do we need to know the sender? We only need the `group_id` and the `epoch` to derive the key if I understand correctly.",
              "createdAt": "2019-02-27T11:49:56Z",
              "updatedAt": "2019-02-27T23:31:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4NTI1NjMz",
          "commit": {
            "abbreviatedOid": "72c6fda"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-27T13:39:04Z",
          "updatedAt": "2019-02-27T13:39:04Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "The idea is that the ContentType is used to mark where the padding bytes (all zero) end, so it needs to be non-zero.",
              "createdAt": "2019-02-27T13:39:04Z",
              "updatedAt": "2019-02-27T23:31:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4OTEwOTY3",
          "commit": {
            "abbreviatedOid": "304fd87"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-28T06:43:48Z",
          "updatedAt": "2019-02-28T06:43:49Z",
          "comments": [
            {
              "originalPosition": 242,
              "body": "Do I understand correctly that the fields that represent information that is shared between the different structs are not actually part of the encoded data structure but rather are just meant to be pointers to the respective \"outer\" struct? If that is the case, I think we should stay true to the principle of having the structs represent what is actually part of the data structure that is encoded and not what is composed locally to compute signatures. Please do correct me if I'm wrong in my understanding of the spec here.",
              "createdAt": "2019-02-28T06:43:49Z",
              "updatedAt": "2019-02-28T06:43:49Z"
            }
          ]
        }
      ]
    },
    {
      "number": 121,
      "id": "MDExOlB1bGxSZXF1ZXN0MjUzNzI0MDQ5",
      "title": "cleanup netlify bundle cache before building",
      "url": "https://github.com/mlswg/mls-protocol/pull/121",
      "state": "MERGED",
      "author": "katrielalex",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "",
      "createdAt": "2019-02-17T16:53:35Z",
      "updatedAt": "2019-12-17T09:24:52Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "d43ff0ae3c0fb0c33429f505359ba72b96b00ab1",
      "headRepository": "katrielalex/mls-protocol",
      "headRefName": "remove-insecure-content",
      "headRefOid": "661ff0adb31e403488f83cabea1c55278946381d",
      "closedAt": "2019-02-17T17:04:35Z",
      "mergedAt": "2019-02-17T17:04:35Z",
      "mergedBy": "katrielalex",
      "mergeCommit": {
        "oid": "f60def4a09159e073075d0f14c7545d3f77600d7"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 122,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU0NjU0Mzcz",
      "title": "fix small typo in GroupState struct",
      "url": "https://github.com/mlswg/mls-protocol/pull/122",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": ":-)",
      "createdAt": "2019-02-20T14:17:14Z",
      "updatedAt": "2019-12-17T09:24:29Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "f60def4a09159e073075d0f14c7545d3f77600d7",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "master",
      "headRefOid": "439f4c5bd4fa3887d71e344acf70a96b7e0fd25c",
      "closedAt": "2019-02-20T20:41:43Z",
      "mergedAt": "2019-02-20T20:41:43Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "b78817cc5e7c2fc1c12ab85d5faa96b474941435"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, @kkohbrok !",
          "createdAt": "2019-02-20T20:41:28Z",
          "updatedAt": "2019-02-20T20:41:28Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA1OTg4MTg4",
          "commit": {
            "abbreviatedOid": "439f4c5"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-20T20:41:35Z",
          "updatedAt": "2019-02-20T20:41:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 123,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU0OTg1ODAy",
      "title": "Fix for Application Key Schedule and define HKDF-Expand-Label",
      "url": "https://github.com/mlswg/mls-protocol/pull/123",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Fix for #107",
      "createdAt": "2019-02-21T11:26:37Z",
      "updatedAt": "2019-12-17T09:24:22Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "07a1b0a3703a5930a1a2dece74d05aadbd1b15e7",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_aks",
      "headRefOid": "f5c57dbbc4f3cd8b2e5cd80f933f4ba67362de9e",
      "closedAt": "2019-02-21T11:40:08Z",
      "mergedAt": "2019-02-21T11:40:08Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "bb233f54baa405d2097e1e8b29275ca2fb77b889"
      },
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "@bifurcation This might not be completely ideal, because of the group state but it currently does not change the key schedule, I am merging this because we need it for correct interop but feel free to get back to discuss a better way to do this in details.",
          "createdAt": "2019-02-21T11:39:58Z",
          "updatedAt": "2019-02-21T11:39:58Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA2MjU2Njg5",
          "commit": {
            "abbreviatedOid": "9bfc544"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-21T11:35:47Z",
          "updatedAt": "2019-02-21T11:35:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 124,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU1MDMwMzAz",
      "title": "Message protection improvements",
      "url": "https://github.com/mlswg/mls-protocol/pull/124",
      "state": "MERGED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bug",
        "editorial"
      ],
      "body": " - Specify padding length\r\n - Rename struct Application to ApplicationMessage",
      "createdAt": "2019-02-21T13:50:21Z",
      "updatedAt": "2019-12-17T09:23:54Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "4803d5f85902e09dbcd01806191deaca1c7984c3",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "raphaelrobert-messageprotection",
      "headRefOid": "332cb79e143fd9773da1f46d52be641f9a845380",
      "closedAt": "2019-02-21T14:41:31Z",
      "mergedAt": "2019-02-21T14:41:31Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "43f92bfd13a4e4e1b7066d149ecb1d9e34c7ee79"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA2MzQwMjMx",
          "commit": {
            "abbreviatedOid": "332cb79"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-21T14:41:22Z",
          "updatedAt": "2019-02-21T14:41:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 126,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU1NjA2ODI2",
      "title": "Editorial: some fixes for #108",
      "url": "https://github.com/mlswg/mls-protocol/pull/126",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Fixes for points 1, 2, 4, 7 in #108.",
      "createdAt": "2019-02-23T10:52:48Z",
      "updatedAt": "2019-03-10T18:08:42Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "55183cc33ff09b3a4bc9dbc20e4323ca104661f8",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_108",
      "headRefOid": "f450134461bfe95504d0c6fdc83a60f8c804eff4",
      "closedAt": "2019-02-25T22:27:06Z",
      "mergedAt": "2019-02-25T22:27:06Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "759389f547817016f58a7de5af22e299fd4ba255"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA3NjY4MzAw",
          "commit": {
            "abbreviatedOid": "f450134"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-25T22:26:57Z",
          "updatedAt": "2019-02-25T22:26:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 127,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU1ODM0MTIx",
      "title": "Rephrased sentence in Add section.",
      "url": "https://github.com/mlswg/mls-protocol/pull/127",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "There is no \"leaf_secret\" field in GroupState. While there might be one in the group state struct that the implementation maintains locally, I think it's safe to recommend copying everything from the GroupState object as it's defined earlier in the document.",
      "createdAt": "2019-02-25T10:28:16Z",
      "updatedAt": "2019-12-17T09:22:27Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "55183cc33ff09b3a4bc9dbc20e4323ca104661f8",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "master",
      "headRefOid": "7a0b47676a5df8e54024e0ed0e0ea21d459c9061",
      "closedAt": "2019-02-25T22:30:24Z",
      "mergedAt": "2019-02-25T22:30:24Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "524fbec5d97fd7a6888bfcd26b7269711b6c95df"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA3NjY5Mjk2",
          "commit": {
            "abbreviatedOid": "7a0b476"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-25T22:29:26Z",
          "updatedAt": "2019-02-25T22:29:26Z",
          "comments": []
        }
      ]
    },
    {
      "number": 128,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU1OTkzOTU5",
      "title": "Multiple minor editorial fixes",
      "url": "https://github.com/mlswg/mls-protocol/pull/128",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2019-02-25T18:15:26Z",
      "updatedAt": "2019-03-10T18:08:40Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "55183cc33ff09b3a4bc9dbc20e4323ca104661f8",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_editorial",
      "headRefOid": "a380ef7b790cc92578906c29217fe2b0076c5e76",
      "closedAt": "2019-02-26T08:55:11Z",
      "mergedAt": "2019-02-26T08:55:11Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "953ce6a405380611c148824dabdfb5a5c4b1f59e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA3NjgwNTAy",
          "commit": {
            "abbreviatedOid": "07c2518"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I'm approving these changes given the current state of the document, but I filed #129 because the KDF stuff is broken.\r\n\r\nPlease make HPKE a normative reference (since it's required to implement).  Since it's an Internet-Draft, you don't need to add it to the references section, you can just reference it directly as `{{!I-D.barnes-cfrg-hpke}}` and the Markdown processor will add the reference.  (Change the `!` to `?` for an informative reference.)",
          "createdAt": "2019-02-25T22:59:16Z",
          "updatedAt": "2019-02-25T22:59:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 131,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU2NjQ1Nzky",
      "title": "Legacy - Common Framing serving as a base for PR  #153 and #155",
      "url": "https://github.com/mlswg/mls-protocol/pull/131",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "duplicate"
      ],
      "body": "Alternative to #120 to solve #101",
      "createdAt": "2019-02-27T11:39:35Z",
      "updatedAt": "2019-12-17T10:12:56Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "3b8b9350dc5f1d21cf52714208e3af4fbeab7998",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_101",
      "headRefOid": "be8f5a4a548b0e4c4f603e06de740c7def97918a",
      "closedAt": "2019-05-01T02:12:24Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Current todo before we can merge this: Proverif/Tamarin model. The intuition is that this is fine because the signature covers all the metadata, to be safe, the second AAD could take the ciphertext of the sender data + tag...",
          "createdAt": "2019-04-04T19:29:16Z",
          "updatedAt": "2019-04-04T19:29:16Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjIyOTk4MzU4",
          "commit": {
            "abbreviatedOid": "8980d61"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-04-04T20:56:40Z",
          "updatedAt": "2019-04-04T21:10:13Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "If you're going to use `Derive-Secret`, you need to derive an intermediate secret, not a key, since `Derive-Secret` produces an output of size Hash.length.  If you want to derive a key here, you want `HKDF-Expand-Label`. \r\n\r\nIt's an extra hash invocation, but it seems a bit more consistent to derive a handshake_secret and handshake_encryption_key",
              "createdAt": "2019-04-04T20:56:40Z",
              "updatedAt": "2019-04-05T08:27:37Z"
            },
            {
              "originalPosition": 32,
              "body": "`marker = 1`",
              "createdAt": "2019-04-04T20:57:09Z",
              "updatedAt": "2019-04-05T08:27:37Z"
            },
            {
              "originalPosition": 53,
              "body": "Nit: I would call this `sender_data_nonce`",
              "createdAt": "2019-04-04T21:02:35Z",
              "updatedAt": "2019-04-05T08:27:37Z"
            },
            {
              "originalPosition": 45,
              "body": "I would prefer if this struct had everything that was not necessary for encryption.  That way if you're not encrypting Handshake messages, you just send this struct instead.  So I would add back:\r\n\r\n* Group ID\r\n* Content type\r\n* Signature",
              "createdAt": "2019-04-04T21:03:33Z",
              "updatedAt": "2019-04-05T08:27:37Z"
            }
          ]
        }
      ]
    },
    {
      "number": 132,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU3MDQ4NDU5",
      "title": "Some propositions for minor changes in structure and wording of the Handshake section.",
      "url": "https://github.com/mlswg/mls-protocol/pull/132",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "The handshake section felt a bit \"flat\" to me, so I introduced some more structure. Also, every section describing the handling of the individual message types mentioned verifying the signature, which was already covered in the general description of how to handle Handshake messages. I realize this Section might change somewhat with the generic framing approach, so feel free to ignore this particular PR, if you want to tackle these points there.\r\n\r\nUpdate: I also found what I think is an small error in the instructions of how to process an Add message: The position of the newly added credential in the list of members has to match the position of the newly added leaf node in the tree. This necessitates that it happens _after_ the leaf node is added. The last commit updates the Add instructions accordingly.",
      "createdAt": "2019-02-28T12:21:52Z",
      "updatedAt": "2019-12-17T09:20:44Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "2cc376d55fe8ac6fd805b413fc9bbb217fbe784b",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "master",
      "headRefOid": "d64909c8875f7f953b4b472d7a03e014dd34267d",
      "closedAt": "2019-05-16T15:02:56Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The text has changed quite a bit in the meantime and I don't think my comments are very relevant anymore.\r\n\r\nClosing.",
          "createdAt": "2019-05-16T15:02:56Z",
          "updatedAt": "2019-05-16T15:02:56Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 133,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU4MTkxOTI0",
      "title": "Add version negotiation fields",
      "url": "https://github.com/mlswg/mls-protocol/pull/133",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "functionality"
      ],
      "body": "This just adds some fields for devices to declare their version support in UserInitKey and for group members to declare what version the group is using in WelcomeInfo.  Obviously, more subtlety will be needed, but this seems like an OK shim for -04.\r\n\r\nCf. #105 ",
      "createdAt": "2019-03-05T05:44:49Z",
      "updatedAt": "2019-12-17T09:20:28Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "2cc376d55fe8ac6fd805b413fc9bbb217fbe784b",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "versioning",
      "headRefOid": "99750d3adcc907ac819238bd458bee2cfda51d41",
      "closedAt": "2019-03-11T04:45:45Z",
      "mergedAt": "2019-03-11T04:45:45Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "4cc5f56547952cae0d2a1530da7d7d3723178a68"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjExNDc2MTg1",
          "commit": {
            "abbreviatedOid": "99750d3"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-03-06T21:12:12Z",
          "updatedAt": "2019-03-06T21:12:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 134,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU4NjM3MTYy",
      "title": "Tree Hash",
      "url": "https://github.com/mlswg/mls-protocol/pull/134",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "functionality",
        "security"
      ],
      "body": "As discussed on the list, this PR replaces the explicit tree and roster inputs to the key schedule with a \"tree hash\" construct.\r\n\r\n@beurdouche - Given this, do you think we need to keep the `transcript_hash` field around?  It seems like in TLS and similar, the transcript hash is there to ensure that the parties agree on things like identities, but we're encoding all that explicitly.\r\n\r\nFixes #90 ",
      "createdAt": "2019-03-06T09:20:45Z",
      "updatedAt": "2019-12-17T10:14:03Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "194aeef46bf6b12f90ffa489b50aae5a5fada3b3",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "tree-hash",
      "headRefOid": "36d619f71f6e551cdd2ce141c8b510788473f409",
      "closedAt": "2019-05-01T01:14:03Z",
      "mergedAt": "2019-05-01T01:14:03Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "3f14893110df64b367e0ae1f09410ddae45b4be5"
      },
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "This is roughly what we do for the TreeKEM paper (I believe we don't re-mix the identities at each op. if I am correct). This seem to cover enough so it's good. I'll try to have a deeper look tomorrow, but this looks reasonable at first glance. It covers both the identities/roster and the group operations, (quid of the welcome message ?) so yes this makes the transcript hash redundant it seems :) I'll get back asap. \r\n\r\nEdit: as discussed before let's keep the transcript hash for now.",
          "createdAt": "2019-03-06T21:36:00Z",
          "updatedAt": "2019-05-01T10:36:02Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If the goal is to have a new data structure that combined and replaces the ratchet tree and roster, then parent and leaf nodes should be storing a lot more information. Namely, if this to be used as a ratchet tree, all nodes need to have associated public keys and private keys, and parent nodes should retain a hash of their children. No need to store node secrets, though. They're never used after private key derivation.",
          "createdAt": "2019-04-17T18:11:05Z",
          "updatedAt": "2019-04-17T18:11:05Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think the definition of Resolution should be in the Tree Computation Terminology section, not the Ratchet Tree Contents section",
          "createdAt": "2019-04-19T17:39:50Z",
          "updatedAt": "2019-04-19T17:39:50Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI3OTA3OTMx",
          "commit": {
            "abbreviatedOid": "47177af"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-17T17:55:04Z",
          "updatedAt": "2019-04-17T17:55:04Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Typo: \"this section define a scheme\" should be \"this section defines a scheme\"",
              "createdAt": "2019-04-17T17:55:04Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI4NzY4Mjg2",
          "commit": {
            "abbreviatedOid": "cf40ebb"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-19T17:37:49Z",
          "updatedAt": "2019-04-19T17:37:49Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "Typo: `ot` -> `to`",
              "createdAt": "2019-04-19T17:37:49Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMwMzA2MTE5",
          "commit": {
            "abbreviatedOid": "16e4717"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-24T19:17:17Z",
          "updatedAt": "2019-04-24T19:17:17Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "Editorial: \"in that order\" seems redundant or meaningless here",
              "createdAt": "2019-04-24T19:17:17Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMwMzA3Mjc3",
          "commit": {
            "abbreviatedOid": "16e4717"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-24T19:20:00Z",
          "updatedAt": "2019-04-24T19:20:00Z",
          "comments": [
            {
              "originalPosition": 124,
              "body": "Remove \"the secret values\". The only secret a node holds is an optional private key",
              "createdAt": "2019-04-24T19:20:00Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMwMzA3OTk2",
          "commit": {
            "abbreviatedOid": "16e4717"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-04-24T19:21:36Z",
          "updatedAt": "2019-04-24T19:44:05Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "Ditto: remove \"secret value and\", replace \"are known\" -> \"is known\"",
              "createdAt": "2019-04-24T19:21:36Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            },
            {
              "originalPosition": 134,
              "body": "Typo (unless you really mean it): \"descendent\" -> \"descendant\". The latter is how it's spelled everywhere else in the doc",
              "createdAt": "2019-04-24T19:23:56Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            },
            {
              "originalPosition": 136,
              "body": "For specificity \"secrets\" -> \"private keys\"",
              "createdAt": "2019-04-24T19:24:24Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            },
            {
              "originalPosition": 143,
              "body": "No need to quote \"direct path\" here. The term has already introduced and used non-quotatively in the previous section",
              "createdAt": "2019-04-24T19:26:12Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            },
            {
              "originalPosition": 145,
              "body": "Auxiliary point: a path secret is made for the root node, but the root node does not appear in the direct path. Using saying that ps[n] is generated \"along the direct path\" may not be wrong, but it does seem a bit misleading. Thoughts?",
              "createdAt": "2019-04-24T19:28:25Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            },
            {
              "originalPosition": 221,
              "body": "Double check this with me: If I am at the leaf, I am _my_ public key, and zero encrypted copies of _my_ path secret (this is `pk(ns[0])   |   [nothing]` in the diagram)\r\n\r\nIf I am a level up, I am encrypting _my_ public key, and 1 encrypted copy of _my_ path secret (this is `pk(ns[1])   |   E(pk(A), ps[1])` in the diagram).\r\n\r\nSo this should say:\r\n\r\n* The public key for the node\r\n* Zero or more copies of the node's path secret, encrypted for someone in the resolution of the node's sibling\r\n\r\nOr, since that last detail is mentioned below, just \"Zero or more encrypted copies of the node's path secret\"",
              "createdAt": "2019-04-24T19:39:47Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMwNTM5MDg2",
          "commit": {
            "abbreviatedOid": "16e4717"
          },
          "author": "psyoptix",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-25T09:25:12Z",
          "updatedAt": "2019-04-25T09:25:13Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "To me \"in that order\" somewhat clarifies that \"left.child || right.child\" is meant here and not \"right.child || left.child\". Clear yet though would be something like: \r\n\r\nThe resolution of a blank intermediate node is the result of concatenating the resolution of its right child to the end of the resolution of its left child.",
              "createdAt": "2019-04-25T09:25:12Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMwNTUxOTg2",
          "commit": {
            "abbreviatedOid": "16e4717"
          },
          "author": "psyoptix",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-25T09:51:12Z",
          "updatedAt": "2019-04-25T10:57:18Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "I think the first primitive to be fixed is a (CPA secure) KEM. ECDH is probably the most interesting class of KEMs but not the only ones worth considering. E.g. A post quantum KEM, say Kyber, (or maybe DH over modular integers) may also be valid choices here for some MLS users.",
              "createdAt": "2019-04-25T09:51:12Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            },
            {
              "originalPosition": 348,
              "body": "The text description doesn't seem to match the structs. \r\n * The `public_key_hash` field is missing from the `ParentNodeHashInput` struct. To make it consistent with the text I think the `public_key` should be replaced with `opaque public_key_hash<0..255>;` or something like that. \r\n * Also, for completeness, we might want to add something like the following struct as it's mentioned in the text (e.g. to make the `hash_type` field precise) :\r\n\r\n`struct {\r\n  uint8 hash_type = 2;\r\n  optional <HPKEPublicKey> node_public_key;\r\n} ParentNodeInfo`\r\n\r\nMore generally though, I have some comments/questions about this section:\r\n* Why include `LeafNodeInfo` in `LeafNodeHashInput` directly but for parent nodes use *the hash of* `ParentNodeInfo` in `ParentNodeHashInput` instead (at least according to the text)? I don't see why the extra hash of NodeInfo makes sense for parents but not for leaves... Either both or neither no?\r\n* What is the purpose of `hash_type`? If domain separation why is that needed and why is hash_type sufficient?\r\n* On a related note, as defined now all blank leaves will have the same hash. Even internal nodes can have the same hash if they are both roots of identical sub-trees of blank nodes. I'm not sure its a problem... but if so one clean way to avoid this is to including `leaf_index` in the `LeafNodeHashInput` struct as a tie-breaker.",
              "createdAt": "2019-04-25T10:04:50Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            },
            {
              "originalPosition": 533,
              "body": "Make clear if node or leaf index is meant here. E.g. \"represents the index of the member among the leaves of the ratchet tree\" --> \"represents the leaf index of the ratchet tree leaf assigned to the sender\"",
              "createdAt": "2019-04-25T10:56:23Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMwNjU2MDA2",
          "commit": {
            "abbreviatedOid": "16e4717"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-25T13:43:58Z",
          "updatedAt": "2019-04-25T13:43:59Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "I clarified in the next paragraph, \"for each node in the direct path of the leaf, as well as\r\nthe root\".  I wonder if we should just change the definition of dirpath to include the root?",
              "createdAt": "2019-04-25T13:43:58Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMwNjU4NjEy",
          "commit": {
            "abbreviatedOid": "16e4717"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-25T13:48:11Z",
          "updatedAt": "2019-04-25T13:48:11Z",
          "comments": [
            {
              "originalPosition": 221,
              "body": "Correct.  The encrypted copies are for the resolution of the non-updated child, and the leaf node has no children.  And yes, the \"parent\" in the second bullet shouldn't be there.",
              "createdAt": "2019-04-25T13:48:11Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMwNjYzNTg0",
          "commit": {
            "abbreviatedOid": "16e4717"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-25T13:56:02Z",
          "updatedAt": "2019-04-25T13:56:03Z",
          "comments": [
            {
              "originalPosition": 533,
              "body": "Done.",
              "createdAt": "2019-04-25T13:56:03Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMwNjY0MTAy",
          "commit": {
            "abbreviatedOid": "16e4717"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-25T13:56:48Z",
          "updatedAt": "2019-04-25T13:56:49Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "Good point.  Refactored to say we need:\r\n\r\n1. An HPKE ciphersuite (including KEM)\r\n2. A Derive-Key-Pair function that produces a key pair for that KEM from a secret",
              "createdAt": "2019-04-25T13:56:48Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMwNjk3MjUz",
          "commit": {
            "abbreviatedOid": "16e4717"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-25T14:48:36Z",
          "updatedAt": "2019-04-25T14:48:36Z",
          "comments": [
            {
              "originalPosition": 348,
              "body": "My thinking with the pre-hashing of the parent nodes values is that if someone were providing incomplete views of the tree together with proofs, then the proof could just include the hash instead of the value.  But on further reflection, I think this is a mistake since (a) the only contents of the node are an `optional<HPKEPublicKey>` and (b) that's not meaningfully different from its hash.  So I've just eliminated the `_hash` part.\r\n\r\nRe `hash_type` - TBH, I'm basically just copy/pasting from [Certificate Transparency](https://tools.ietf.org/html/rfc6962#section-2.1) here; open to arguments either way.  Maybe @beurdouche has some thoughts here?\r\n\r\nRe blank nodes - Even more, a blank subtree anywhere in the tree will have the same value.  I had considered just throwing the node index into all the hashes for diversity.  But I don't really see an issue here -- why do we need to distinguish between blanks in different places? Given that in the ultimate root hash they'll end up tied with non-blank stuff and locked into their position that way.\r\n",
              "createdAt": "2019-04-25T14:48:36Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMyMDc3NzA2",
          "commit": {
            "abbreviatedOid": "e9b283b"
          },
          "author": "psyoptix",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-30T09:41:57Z",
          "updatedAt": "2019-04-30T09:41:57Z",
          "comments": [
            {
              "originalPosition": 348,
              "body": "Thought a bit more about hash_type. For Merkle Trees (as in Certificate Transparency) the prefix to the hash inputs are definitely needed to separate leaf and internal node hashing domains. Otherwise MTs trivially aren't binding. E.g. given any target data set d={d(0),...,d(n)} it would be easy to make a new data point {d'} such that MT(d) = MT(d').\r\n\r\nFor MLS I'm suspect tree hashes may already be binding even without including hash_type. But justifying that would require subtle & messy reasoning including exactly how optional structs, HPKEPublicKey, SignaturesPK, Certificates, etc. are all serialized.\r\n\r\nBut that discussion can be entirely avoided by including hash_type as you have done. To see binding: hash_type ensures that for 2 tree's to have the same tree hash value they must have the same set of nodes and edges. (Otherwise two hash calls has differing hash_type inputs but results in the same output which is a collision on the underlying hash func). That in turn, means the trees must have the same set of labels for all nodes since otherwise we again have a collision somewhere. Ergo tree hash is binding.\r\n\r\nMuch cleaner. :-) So I've come round to the inclusion of hash_type even if I'm not convinced its strictly necessary.",
              "createdAt": "2019-04-30T09:41:57Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMyMzIwODY0",
          "commit": {
            "abbreviatedOid": "e9b283b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-30T18:02:13Z",
          "updatedAt": "2019-04-30T18:02:14Z",
          "comments": [
            {
              "originalPosition": 348,
              "body": "Thanks!  Belt and suspenders!",
              "createdAt": "2019-04-30T18:02:14Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMxNTc3MDQ1",
          "commit": {
            "abbreviatedOid": "e9b283b"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-04-29T09:13:24Z",
          "updatedAt": "2019-04-30T19:09:03Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "This is not technically required for everyone but mostly for clients intending to add or remove, I would probably weaken this requirement, now or later.",
              "createdAt": "2019-04-29T09:18:53Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            },
            {
              "originalPosition": 134,
              "body": "Indeed the public leaves are necessary",
              "createdAt": "2019-04-29T09:19:33Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            },
            {
              "originalPosition": 139,
              "body": "It is interesting that you think of a \"secret state of the tree\". In my opinion, there is no such thing because TreeKEM will give you with agreement over the public tree but not the secret one except for the the node private kem key.\r\nThe best way to think about this, is that TreeKEM provides each sub-group (singleton or not) with a shared secret that you can recompute from a leaf secret and a public tree.",
              "createdAt": "2019-04-29T09:26:12Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            },
            {
              "originalPosition": 145,
              "body": "s/MLS/TreeKEM",
              "createdAt": "2019-04-29T09:27:23Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            },
            {
              "originalPosition": 226,
              "body": "a set of public values",
              "createdAt": "2019-04-29T09:31:19Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            },
            {
              "originalPosition": 228,
              "body": "s/Other members/Each recipient\r\n\r\nThey use the values, or the content of the updated nodes, not the nodes",
              "createdAt": "2019-04-29T09:32:05Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            },
            {
              "originalPosition": 234,
              "body": "You don't tell to whom you are sending.\r\nMaybe a notion of \"generalized\" (or whatever) sibling (all non-blank root of sub-trees of a direct sibling) is missing ?",
              "createdAt": "2019-04-29T09:37:16Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            },
            {
              "originalPosition": 246,
              "body": "What happens for a blank node ?",
              "createdAt": "2019-04-29T09:39:28Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            },
            {
              "originalPosition": 253,
              "body": "Convoluted",
              "createdAt": "2019-04-29T09:40:41Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            },
            {
              "originalPosition": 303,
              "body": "I had trouble to understand the sentence for some reason... :)",
              "createdAt": "2019-04-30T19:08:02Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMyNDY5ODY5",
          "commit": {
            "abbreviatedOid": "e9b283b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-01T01:03:02Z",
          "updatedAt": "2019-05-01T01:03:02Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "Softened to \"we generally assume\".",
              "createdAt": "2019-05-01T01:03:02Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMyNDcwNTcz",
          "commit": {
            "abbreviatedOid": "e9b283b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-01T01:08:27Z",
          "updatedAt": "2019-05-01T01:08:28Z",
          "comments": [
            {
              "originalPosition": 234,
              "body": "That \"generalized sibling\" is the resolution of the sibling.",
              "createdAt": "2019-05-01T01:08:28Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMyNDcwNjAz",
          "commit": {
            "abbreviatedOid": "e9b283b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-01T01:08:44Z",
          "updatedAt": "2019-05-01T01:08:44Z",
          "comments": [
            {
              "originalPosition": 246,
              "body": "The resolution stage accounts for blanks.",
              "createdAt": "2019-05-01T01:08:44Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMyNDcwODQ5",
          "commit": {
            "abbreviatedOid": "e9b283b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-01T01:10:29Z",
          "updatedAt": "2019-05-01T01:10:30Z",
          "comments": [
            {
              "originalPosition": 253,
              "body": "Let's discuss in a follow-on.",
              "createdAt": "2019-05-01T01:10:29Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMyNDcxMDU5",
          "commit": {
            "abbreviatedOid": "e9b283b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-01T01:12:03Z",
          "updatedAt": "2019-05-01T01:12:03Z",
          "comments": [
            {
              "originalPosition": 303,
              "body": "Probably because it's poorly written ;)  I rewrote it to hopefully be clearer.",
              "createdAt": "2019-05-01T01:12:03Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            }
          ]
        }
      ]
    },
    {
      "number": 135,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU4NzkxOTQ1",
      "title": " Address difference between roster and tree index ",
      "url": "https://github.com/mlswg/mls-protocol/pull/135",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Just stumbled across the difference again. I being a little more explicit about this a good way of preventing implementation error regarding mix-up of indices.",
      "createdAt": "2019-03-06T16:32:49Z",
      "updatedAt": "2019-12-17T09:19:11Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "645961291858d86f74a41b0d9e4f257db9fb96a0",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "patch-1",
      "headRefOid": "65624d827701373f9657c57b5942d82dfa78c645",
      "closedAt": "2019-03-11T05:08:21Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that this should not be merged.  There is a factor-of-2 issue here (which I have run into in my implementation), but I think the right answer is to remove the distinction between leaves and roster slots, as suggested in #134.",
          "createdAt": "2019-03-11T05:08:21Z",
          "updatedAt": "2019-03-11T05:08:21Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjExNDc2MDE0",
          "commit": {
            "abbreviatedOid": "65624d8"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "I believe this is just using Leaf numbering in that case instead of Node numbering. I am fine with keeping two numbering methods here as long as we make that more explicit. I would prefer avoiding these divisions even though this is correct.",
          "createdAt": "2019-03-06T21:11:52Z",
          "updatedAt": "2019-03-06T21:11:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 136,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU4ODY4NTM0",
      "title": "Fixed example in 'Ratchet Tree Update' section",
      "url": "https://github.com/mlswg/mls-protocol/pull/136",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Previously, it was KEMing to the root key, which is not in the resolution of the coPath of B.",
      "createdAt": "2019-03-06T20:28:55Z",
      "updatedAt": "2019-12-17T09:18:27Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "645961291858d86f74a41b0d9e4f257db9fb96a0",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "patch-2",
      "headRefOid": "2dbeb47f15b72504d8c5a907c150c1514a7a2e6c",
      "closedAt": "2019-03-11T05:06:24Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "This PR now seems like a noop, so closing.  Feel free to reopen if there's actually something to do here.",
          "createdAt": "2019-03-11T05:06:24Z",
          "updatedAt": "2019-03-11T05:06:24Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjExNDc2NzQ0",
          "commit": {
            "abbreviatedOid": "0d1aa4f"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "This seems incorrect, the update is along B-E-G so the F node is not recovered, you do send pk(G) and G to both C and D.",
          "createdAt": "2019-03-06T21:13:22Z",
          "updatedAt": "2019-03-06T21:13:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 138,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU5ODQ1NTcz",
      "title": "Include a hash of the WelcomeInfo in the Add message",
      "url": "https://github.com/mlswg/mls-protocol/pull/138",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "bug",
        "security"
      ],
      "body": "This addresses the authentication issue in -03 noted on the mailing list.",
      "createdAt": "2019-03-11T06:24:16Z",
      "updatedAt": "2019-12-17T09:18:13Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "4cc5f56547952cae0d2a1530da7d7d3723178a68",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "welcome-hash",
      "headRefOid": "cad1dc8451d32b4ca3bd185abef76c3a2f2e13b2",
      "closedAt": "2019-03-11T06:25:30Z",
      "mergedAt": "2019-03-11T06:25:30Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "703216af0327dca5c32e731e4a500f95826be97d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyNjczNTQw",
          "commit": {
            "abbreviatedOid": "cad1dc8"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-03-11T06:25:01Z",
          "updatedAt": "2019-03-11T06:25:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 139,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU5OTMwNjYx",
      "title": "Initial definition of the KDF and the Derive-Key-Pair function",
      "url": "https://github.com/mlswg/mls-protocol/pull/139",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "functionality",
        "security"
      ],
      "body": "Initial attempt to solve #129. This defines the KDF as discussed in #129 and relocates the DH computation obligation and verification as part of the Derive-Key-Pair function definition.",
      "createdAt": "2019-03-11T11:33:02Z",
      "updatedAt": "2019-12-17T09:17:30Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "3b8b9350dc5f1d21cf52714208e3af4fbeab7998",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_129_kdf",
      "headRefOid": "de6832fbd453c4d5a5a3ace3c4ed7d0d9bcae5c5",
      "closedAt": "2019-03-15T14:46:01Z",
      "mergedAt": "2019-03-15T14:46:01Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "cda41739560803a05af8407a018f0db2bb85e948"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixing my own review comments here, since @beurdouche appears to be offline and we need to publish -04.",
          "createdAt": "2019-03-15T14:38:04Z",
          "updatedAt": "2019-03-15T14:38:04Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE0MDExMjMy",
          "commit": {
            "abbreviatedOid": "c8b1b9c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-03-13T15:03:11Z",
          "updatedAt": "2019-03-13T15:16:32Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "Everything from here down should be deleted, and replaced with the existing definitions that have been deleted in this PR.",
              "createdAt": "2019-03-13T15:04:31Z",
              "updatedAt": "2019-03-15T14:40:54Z"
            },
            {
              "originalPosition": 12,
              "body": "Nope, this is the node secret, which I don't think needs the extra word.",
              "createdAt": "2019-03-13T15:11:50Z",
              "updatedAt": "2019-03-15T14:40:54Z"
            },
            {
              "originalPosition": 16,
              "body": "There's no reason to delete this para.  It's still true that the key pair from the node derives from the node secret.  You just need to edit it to revert back to what it said before #114, namely that the key pair comes from the node secret via Derive-Key-Pair.",
              "createdAt": "2019-03-13T15:13:35Z",
              "updatedAt": "2019-03-15T14:40:54Z"
            },
            {
              "originalPosition": 36,
              "body": "I would move this back up to where you deleted a chunk. Instead of \"The contents of a parent node...\", you should say something like \"The tree is always updated along a direct path from a leaf to the root... [path secrets, node secrets]\"",
              "createdAt": "2019-03-13T15:15:43Z",
              "updatedAt": "2019-03-15T14:40:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE1MDY4OTk1",
          "commit": {
            "abbreviatedOid": "c61c277"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-03-15T14:36:49Z",
          "updatedAt": "2019-03-15T14:36:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 141,
      "id": "MDExOlB1bGxSZXF1ZXN0MjY1MTE0MTg3",
      "title": "Added public_key_index to Add message",
      "url": "https://github.com/mlswg/mls-protocol/pull/141",
      "state": "CLOSED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "The original text says \"Set the leaf node in the tree at position index to a new node containing the public key from the UserInitKey in the Add corresponding to the ciphersuite in use\". Although it's never explicitly stated, the implication is that a UserInitKey can have at most 1 DhPublicKey per ciphersuite.\r\n\r\nI think a `public_key_index` could make errors somewhat nicer. I would rather have the issue be that the Adder picked incomensurate ciphersuite, as opposed to saying that the option to Add exists, but there's no consistent way to pick the public key index.\r\n\r\nIncluding an index could also open up the option of publishing large, long-lived UserInitKeys that can get downloaded and used over time (I'm not sure if this fits our model as-is, though).\r\n\r\nThoughts?",
      "createdAt": "2019-03-27T21:49:36Z",
      "updatedAt": "2019-12-17T09:16:46Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "cda41739560803a05af8407a018f0db2bb85e948",
      "headRepository": "rozbb/mls-protocol",
      "headRefName": "master",
      "headRefOid": "447ef431b68d99bee3a6d0c4ef1f7aa9cba482bd",
      "closedAt": "2019-04-17T16:49:05Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah, ok. Nevermind that last point then. This is just a small semantic matter. I think the adder should explicitly pick a pubkey, rather than letting it be implicitly chosen, subject to an assumed constraint. \r\n\r\nOne concern here is also misuse. While writing my implementation, I was tempted to search for the first index of `cipher_suites` that matched the current ciphersuite, and then use that. But that would be a subtle bug, and the lack of a check there would put GroupStates out of sync. I think specifying an index and making sure the ciphersuite matches is less error-prone.\r\n\r\nAlso, the spec does not currently specify any constraints on `cipher_suites`, other than the one relating to its length. If this PR is rejected, I'll happily disambiguate this in a separate PR.",
          "createdAt": "2019-03-28T00:33:37Z",
          "updatedAt": "2019-03-28T00:33:37Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "The way you pick the ciphersuite is left to you and if you pick ciphersuite J in the list, you pick key J. Do you mean that the one-to-one key/ciphersuite mapping is not explicit enough in the sentence I pointed earlier ? ",
          "createdAt": "2019-03-28T00:48:19Z",
          "updatedAt": "2019-03-28T00:48:19Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I thought there's no choice involved. The only `init_key` you _can_ pick is the one that corresponds to the current ciphersuite. I just think that that method, while perfectly well-defined and doable, is more prone to error than having the adder explicitly choose the `init_key` index and including it in the Add message.\r\n\r\nAnd yes, I believe that the one-to-one key/ciphersuite correspondence is not explicit enough. I didn't know that that was a condition until I read the Add subsection of the Handshake section in the spec.",
          "createdAt": "2019-03-28T19:12:21Z",
          "updatedAt": "2019-03-28T19:12:21Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing because the `index -> tree_index` change is wrong and doesn't belong here. Also I shouldn't have based this on my `master`. I'll redo this change in a sec.",
          "createdAt": "2019-04-17T16:49:05Z",
          "updatedAt": "2019-04-17T16:49:05Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE5NzcyNDg1",
          "commit": {
            "abbreviatedOid": "447ef43"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "The UserInitKey is one-time-use and contains a single ephemeral HPKE public key per algorithm. Reusing these keys across groups is just a very bad idea. Section 6 mandates:\r\n```\r\nThe init_keys array MUST have the same length as the cipher_suites\r\n   array, and each entry in the init_keys array MUST be a public key for\r\n   the asymmetric encryption scheme defined in the cipher_suites array\r\n   and used in the HPKE construction for TreeKEM.\r\n```",
          "createdAt": "2019-03-27T23:21:42Z",
          "updatedAt": "2019-03-27T23:21:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 143,
      "id": "MDExOlB1bGxSZXF1ZXN0MjY3MTI3MTM1",
      "title": "Fixes to tree manipulation in Remove",
      "url": "https://github.com/mlswg/mls-protocol/pull/143",
      "state": "MERGED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "This clears up the wording around how to prune the ratchet tree on a Remove operation. Previously, it could be interpreted as \"remove nodes from the tree until the rightmost node is not null\", but this is not what is intended by the authors, and it also has the ability to produce invalid trees (i.e., trees with an even number of elements).\r\n\r\nThe second change is to do the truncation _after_ doing the Blank propogation up the direct path of the removed leaf. Note that the order of these steps doesn't matter in that they produce the same resulting tree. However, if we blank after pruning, an implementor would have to take care to not to try to blank out previously-removed nodes. Prune-then-blank is a little easier to reason about.\r\n\r\nThe third change is a semantic fix. It is clear from the last paragraph in this section that the root node should be blanked, but the text only said to blank the direct path of the leaf, which does not include the root node. I just added that part in.",
      "createdAt": "2019-04-03T16:40:27Z",
      "updatedAt": "2019-12-17T09:16:40Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "cda41739560803a05af8407a018f0db2bb85e948",
      "headRepository": "rozbb/mls-protocol",
      "headRefName": "truncate-fix",
      "headRefOid": "0baffe3b5272d03eaf83c6c6b9413d5ae27a6ebf",
      "closedAt": "2019-05-02T14:36:36Z",
      "mergedAt": "2019-05-02T14:36:36Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "c56e7e9d8990a89cdf51ab31df681e4f8ba1cda6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI4NzE3MTQx",
          "commit": {
            "abbreviatedOid": "1afcbda"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-04-19T14:51:00Z",
          "updatedAt": "2019-04-19T14:55:53Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "This is redundant, given that the root path is on the direct path of every node.  Unless there's some definition that comes up one short?",
              "createdAt": "2019-04-19T14:51:00Z",
              "updatedAt": "2019-05-02T14:33:46Z"
            },
            {
              "originalPosition": 13,
              "body": "I would prefer not to have the \"(clearing...\" parts.  There's no such thing as a zero-member group, so it would be better to simply disallow Remove on a one-member group.",
              "createdAt": "2019-04-19T14:54:51Z",
              "updatedAt": "2019-05-02T14:33:46Z"
            },
            {
              "originalPosition": 13,
              "body": "Though now that I say that, I realize that requirement is not totally trivial to enforce, since the last remaining member could have any index.  But it still seems like the most semantically clear approach.",
              "createdAt": "2019-04-19T14:55:47Z",
              "updatedAt": "2019-05-02T14:33:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI5MTY0NTQy",
          "commit": {
            "abbreviatedOid": "1afcbda"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-22T17:47:52Z",
          "updatedAt": "2019-04-22T17:47:53Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "What's the issue exactly with a zero-member group? You can't semantically do anything with it, so you just get a useless object at the end of the `Remove`, and you have no choice but to throw it out.",
              "createdAt": "2019-04-22T17:47:52Z",
              "updatedAt": "2019-05-02T14:33:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI5MTY0ODA2",
          "commit": {
            "abbreviatedOid": "1afcbda"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-22T17:48:29Z",
          "updatedAt": "2019-04-22T17:48:29Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "From section 5.1: \"The direct path of a root is the empty list, and of any other node is the concatenation of that node with the direct path of its parent.\"\r\n\r\nDirect paths do not contain the root node.",
              "createdAt": "2019-04-22T17:48:29Z",
              "updatedAt": "2019-05-02T14:33:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMyMzE4NzE4",
          "commit": {
            "abbreviatedOid": "1afcbda"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-30T17:57:52Z",
          "updatedAt": "2019-04-30T17:57:52Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Well, that's the problem -- you can't do anything with it.  So it seems like it shouldn't be a valid state.",
              "createdAt": "2019-04-30T17:57:52Z",
              "updatedAt": "2019-05-02T14:33:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMyMzI2MDE3",
          "commit": {
            "abbreviatedOid": "1afcbda"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-30T18:12:41Z",
          "updatedAt": "2019-04-30T18:12:41Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Ah, I was going to say \"bad states are states that are semantically incorrect, and there's nothing incorrect about an empty group\" but I found a reason why it's not correct (at least for me): `signer_index` is not `optional` in my GroupState object. If the roster is empty, then there is no valid value for `signer_index`. Since this is necessarily an invalid state, I agree that zero-member groups should be disallowed. I'll make an update to reflect this prohibition for Removes.",
              "createdAt": "2019-04-30T18:12:41Z",
              "updatedAt": "2019-05-02T14:33:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMyNzAyNTEy",
          "commit": {
            "abbreviatedOid": "5f670e3"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-01T18:49:47Z",
          "updatedAt": "2019-05-01T18:53:36Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "The receiver POV here seems more useful, i.e., \"If a member of a group receives a Remove message where the `removed` index is equal to the `sender` index, then the recipient MUST reject the message as malformed.\"  That's not to say we can't have both, though.\r\n\r\nMight tee this up better if you said \"remove one or more **other** members from the group\" (emphasis only for here, not for the doc).",
              "createdAt": "2019-05-01T18:49:47Z",
              "updatedAt": "2019-05-02T14:33:46Z"
            },
            {
              "originalPosition": 39,
              "body": "We're coming down to kind of a matter of taste here, since I don't really like discussing things that are impossible :)  How about we compromise with the following:\r\n\r\n* Leave these clarifications out of the instruction bullets\r\n* Add a para afterward of the form \"Note that there is always at least one non-blank...\"",
              "createdAt": "2019-05-01T18:53:28Z",
              "updatedAt": "2019-05-02T14:33:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMyNzA1NjY0",
          "commit": {
            "abbreviatedOid": "3f25fb1"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-01T18:56:27Z",
          "updatedAt": "2019-05-01T18:56:27Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "agreed. That will also give room to mention that the same argument holds for tree truncation",
              "createdAt": "2019-05-01T18:56:27Z",
              "updatedAt": "2019-05-02T14:33:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMyODIwMDIz",
          "commit": {
            "abbreviatedOid": "f358deb"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-02T01:31:11Z",
          "updatedAt": "2019-05-02T13:22:36Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Could we delete this for now (also below) and handle it as a follow-on?  This seems non-trivial to resolve, and I want to ship draft-05 tomorrow.",
              "createdAt": "2019-05-02T01:31:12Z",
              "updatedAt": "2019-05-02T14:33:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzMDQ0ODQ0",
          "commit": {
            "abbreviatedOid": "0baffe3"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-05-02T14:34:58Z",
          "updatedAt": "2019-05-02T14:34:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 146,
      "id": "MDExOlB1bGxSZXF1ZXN0MjcwMDE5ODky",
      "title": "Tree based app keyschedule",
      "url": "https://github.com/mlswg/mls-protocol/pull/146",
      "state": "MERGED",
      "author": "psyoptix",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "performance",
        "security"
      ],
      "body": "Basic idea: \r\n - Application Key Schedule consists of a left balanced binary tree of secrets (the \"AS Tree\") and one symmetric ratchet per group member. The AS Tree has the same node/edge structure as the ratchet tree for that epoch. Members are assigned the same leaves.\r\n\r\n- Each node in the AS Tree is assigned a secret. The root's secret = application_secret. The secrets of children are derived from that of their parent.\r\n\r\n- The secret of a leaf is the initial secret of a symmetric hash ratchet. The ratchet generates the key/nonce sequence used by the leaf's group member to encrypt messages during that epoch.\r\n\r\n\r\n\r\nOther comments:\r\n- I included a \"Deletion Schedule\": keys, nonces are 'consumed' if they are used to encrypt or successfully decrypt a message. secrets are 'consumed' if value derived from it is consumed. Any consumed value must be immediately deleted for reasons of forward secrecy. \r\n\r\n- I was very generous with contexts for all calls to HKDF. E.g. I included Hash(GroupState_[n]) in the context of every call to HKDF. True, I dont think its neccesary to prove security against more coarse adversarial models (e.g. that only do all-or-nothing state leakage). Still, as a matter of the \"defense in depth\" principle I think including as much relevant context as possible during all key/secret derivation is a good idea. Albeit only as long as the price (in computation, complexity, etc) is not to high. To that end, I purposefully use Hash(GroupState_[n]) in the context as it is short, needs only to be computed once at the start of the epoch and can then be used to very cheaply to construct all contexts needed for the rest of the new application key schedule.\r\n\r\n- Disclaimer: I'm a bit of a noob when it comes to Markdown, RFCs and github so forgive me (and tell me!) if I've done something wrong here.\r\n\r\nCo-contributors: Benjamin Beurbouche, Sandro Coretti, Yevgeniy Dodis,",
      "createdAt": "2019-04-12T13:49:51Z",
      "updatedAt": "2019-12-17T09:16:22Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "74987e2b70e3bc5c2e02b0092d5bbb21cb7ae1eb",
      "headRepository": "psyoptix/mls-protocol",
      "headRefName": "tree-based-app-keysched",
      "headRefOid": "feb096db828cc1bdce2cf34e63832ebc023e4bf6",
      "closedAt": "2019-07-08T13:43:56Z",
      "mergedAt": "2019-07-08T13:43:56Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "811235cf469e5238f7f0a088d985d0afd0ff4c9d"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Merging this despite outstanding comments.  @beurdouche and I will handle our requested edits in a couple of follow-up PRs.",
          "createdAt": "2019-07-08T13:43:44Z",
          "updatedAt": "2019-07-08T13:43:44Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU2NTc1Njgx",
          "commit": {
            "abbreviatedOid": "82b931f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-07-01T21:42:07Z",
          "updatedAt": "2019-07-01T22:08:51Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Nit: tags of this form (lower-cased, spaces-to-dashes) are automatically generated by the tooling.  Same comment below.",
              "createdAt": "2019-07-01T21:42:07Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 19,
              "body": "\"user\" -> \"client\"",
              "createdAt": "2019-07-01T21:42:38Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 66,
              "body": "Might be helpful to expand \"AS\" on first use here.  I assume you mean \"application secret\"? ",
              "createdAt": "2019-07-01T21:43:10Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 111,
              "body": "We have been using uint32s for indices elsewhere, to be conservative about size.",
              "createdAt": "2019-07-01T21:44:44Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 149,
              "body": "What's the reasoning behind using the context you do here?  It seems like it would be simpler if you didn't have to keep around that context data.  For example, suppose you did something like the following:\r\n\r\n```\r\n           astree_node_[IndexOf(V)]_secret\r\n                     |\r\n                     +--> HKDF-Expand-Label(.,\"left\", \"\", Hash.length)\r\n                     |    = astree_node_[IndexOf(V.leftChild)]_secret\r\n                     |\r\n                     +--> HKDF-Expand-Label(.,\"right\", \"\", Hash.length)\r\n                          = astree_node_[IndexOf(V.rightChild)]_secret\r\n```\r\n\r\nThat would assure you have the diversity you need because every leaf in the tree would be derived via a different \"left\" / \"right\" path.",
              "createdAt": "2019-07-01T21:49:24Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 149,
              "body": "Nit: Stylistically:\r\n* Slightly nicer to have both results on the right as above\r\n* I think we've been using more `snake_case`, so, e.g., `V.right_child`",
              "createdAt": "2019-07-01T21:51:03Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 194,
              "body": "Same comment here about context.  Why can't we just use a fixed label [like TLS does](https://tools.ietf.org/html/rfc8446#section-7.2)?\r\n\r\n```\r\n       application_traffic_secret_N+1 =\r\n           HKDF-Expand-Label(application_traffic_secret_N,\r\n                             \"traffic upd\", \"\", Hash.length)\r\n```",
              "createdAt": "2019-07-01T21:53:54Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 194,
              "body": "Also, a `leaf_index` should just be a `uint32`.  Did you mean for that to be an identity?",
              "createdAt": "2019-07-01T21:55:26Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 196,
              "body": "BasicCredential is an instance of Credential, so just refer to the identity in the credential.  Or just eliminate all of this :)",
              "createdAt": "2019-07-01T21:55:53Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 240,
              "body": "Nit: Unfortunate resonance between \"More precisely... More generally...\"",
              "createdAt": "2019-07-01T21:57:06Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 240,
              "body": "Seems like you could express this by saying a secret is consumed if:\r\n\r\n* It is used to encrypt or decrypt a message\r\n* Any secret derived from it has been consumed",
              "createdAt": "2019-07-01T21:58:27Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 261,
              "body": "A diagram might help here.  E.g., in the following scenario...\r\n\r\n```\r\n      G\r\n    /   \\\r\n   /     \\\r\n  E       F\r\n / \\     / \\\r\nA0  B0  C0  D0 -+- KD0\r\n            |   |\r\n            |   +- ND0\r\n            |\r\n            D1 -+- KD1\r\n            |   |\r\n            |   +- ND1\r\n            |\r\n            D2 -+- KD2\r\n                |\r\n                +- ND2\r\n```\r\n\r\nWhen KD1/ND1 are used to decrypt a message, the following are:\r\n* Consumed: G, F, D0, D1, KD1, ND1\r\n* Not necessarily consumed: E, A0, B0, C0, KD0, ND0, D2, KD2, ND2",
              "createdAt": "2019-07-01T22:07:13Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 266,
              "body": "Here's the citation you want: https://tools.ietf.org/html/rfc8446#ref-AEAD-LIMITS",
              "createdAt": "2019-07-01T22:07:58Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NjQxMjM2",
          "commit": {
            "abbreviatedOid": "82b931f"
          },
          "author": "psyoptix",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-07T20:11:54Z",
          "updatedAt": "2019-07-07T20:11:55Z",
          "comments": [
            {
              "originalPosition": 149,
              "body": "Here was my thought process which lead to the schedule in the PR.\r\n\r\nA property of left/right tree schedule i'm not a fan of: if nodes v and u end up with the same key then their children (and grandchildren, etc.) will have the same key too.\r\n\r\nSo add IndexOf(V.left_child) as context to Derive-Secret. However this still means if, in 2 different epochs a node in the AS Tree ends has the same key then so will its children. Thats why I added the Hash(GroupState_[n]).\r\n\r\nTo be clear, its not like I have a concrete attack. Its more of a \"best practice\" & \"defense in depth\" situation. IMO different pairs of keys having the same relation to each other make me nervous.\r\n\r\nI also hoped that since Hash(GroupState_[n]) only needs to computed once, is a short string (e.g. fits into even lower cache levels) and can be blindly plugged in to all Derive-Secret calls the price for this approach wasn't too great.\r\n\r\nSo for now I've not made any changes here. However, I dont fell all *that* strongly about it. So if you do, or there's push back from others as well then feel free to change it.",
              "createdAt": "2019-07-07T20:11:54Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NjQxNTM5",
          "commit": {
            "abbreviatedOid": "82b931f"
          },
          "author": "psyoptix",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-07T20:20:40Z",
          "updatedAt": "2019-07-07T20:20:41Z",
          "comments": [
            {
              "originalPosition": 194,
              "body": "My reasoning here is the same as I explained above: no 2 keys should have the same relation -> defence in depth.\r\n\r\nIMO TLS is designed for greater packets per second than MLS (and probably aims to run on weaker devices like IoT stuff too) so it makes sense for TLS to care a lot about being efficient. MLS though is meant for lower packet rate (on at least a cellphone level device) so I think its worth spending a small number of extra cycles and memory access for reasons of best practice.\r\n\r\nJust as before, I'll leave it up to you which way to go though.",
              "createdAt": "2019-07-07T20:20:40Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NjQxNjYx",
          "commit": {
            "abbreviatedOid": "82b931f"
          },
          "author": "psyoptix",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-07T20:24:33Z",
          "updatedAt": "2019-07-07T20:24:34Z",
          "comments": [
            {
              "originalPosition": 194,
              "body": "Oh. yeah, that wasn't too consistent. I mean leaf_index to denote the number of the leaf assigned to the owner of the ratchet, not their identity. \r\n\r\nAll I really care about for that the value is that its unique to a given ratchet and that its easy to determine the value for any client in the group. So using a full identity seems like an over kill. The index of the client's leaf should be enough.\r\n\r\nI edited things to (hopefully) make that clearer and more consistent.",
              "createdAt": "2019-07-07T20:24:33Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NjQyMjgy",
          "commit": {
            "abbreviatedOid": "82b931f"
          },
          "author": "psyoptix",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-07T20:42:40Z",
          "updatedAt": "2019-07-07T20:42:40Z",
          "comments": [
            {
              "originalPosition": 196,
              "body": "Its gone. Full identity wasn't needed. Leaf Index will do.",
              "createdAt": "2019-07-07T20:42:40Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NjQyNDQ5",
          "commit": {
            "abbreviatedOid": "82b931f"
          },
          "author": "psyoptix",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-07T20:46:11Z",
          "updatedAt": "2019-07-07T20:46:12Z",
          "comments": [
            {
              "originalPosition": 194,
              "body": "FYI I also removed the hashing of HashRatCont[i,j]. Now it just goes in the context as is instead of being hashed first.",
              "createdAt": "2019-07-07T20:46:11Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NjQyODI5",
          "commit": {
            "abbreviatedOid": "82b931f"
          },
          "author": "psyoptix",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-07T20:56:10Z",
          "updatedAt": "2019-07-07T20:56:10Z",
          "comments": [
            {
              "originalPosition": 240,
              "body": "Agreed on compression encrypt/decrypt into one line.\r\n\r\nFor the second point I went with \"any key, secret or nonce\" instead of \"any secret\" just to be clear that nonce's are included here (as they're normally not thought of as secrets).",
              "createdAt": "2019-07-07T20:56:10Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NjQ1Nzcy",
          "commit": {
            "abbreviatedOid": "822f18c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-07T22:21:48Z",
          "updatedAt": "2019-07-07T22:22:00Z",
          "comments": [
            {
              "originalPosition": 149,
              "body": "I can see why it's appealing to have each derivation entail a different relation.  Maybe we can accommodate that a bit more elegantly by moving the GroupContext hash into the definition of Derive-Secret (since that's all that is used for context anyway), and defining a Derive-Application-Secret function that gives us the knobs we need to vary things as we go down the tree and the ratchets.  Here's a sketch that should be copy-paste-able into the text here:\r\n\r\n```\r\nHKDF-Expand-Label(Secret, Label, Context, Length) =\r\n    HKDF-Expand(Secret, HkdfLabel, Length)\r\n\r\nWhere HkdfLabel is specified as:\r\n\r\nstruct {\r\n    uint16 length = Length;\r\n    opaque label<7..255> = \"mls10 \" + Label;\r\n    opaque context<0..2^32-1> = Context;\r\n} HkdfLabel;\r\n\r\nDerive-Secret(Secret, Label) =\r\n    HKDF-Expand-Label(Secret, Label, Hash(GroupContext_[n]), Hash.length)\r\n\r\nstruct {\r\n  uint32 node;\r\n  uint32 generation;\r\n  opaque role<0..255>;\r\n} ApplicationContext;\r\n\r\nDerive-Application-Secret(secret, node, generation, role) =\r\n  DeriveSecret(secret, ApplicationContext(node, generation, role) \r\n\r\nastree_node_[IndexOf(V)]_secret\r\n        |\r\n        |\r\n        +--> Derive-Application-Secret(., V.left_child, 0, \"tree\")\r\n        |    = astree_node_[IndexOf(V.left_child)]_secret\r\n        |\r\n        +--> Derive-Application-Secret(., V.right_child, 0, \"tree\")\r\n             = astree_node_[IndexOf(V.right_child)]_secret\r\n\r\napplication_[i]_[j]_secret\r\n      |\r\n      +--> Derive-Application-Secret(., 2*i, j, \"key\")\r\n      |    = application_[i]_[j+1]_nonce\r\n      |\r\n      +--> Derive-Application-Secret(., 2*i, j, \"nonce\")\r\n      |    = application_[i]_[j+1]_key\r\n      |\r\n      V\r\nHKDF-Application-Secret(., 2*i, j, \"secret\")\r\n= application_[i]_[j+1]_secret\r\n```",
              "createdAt": "2019-07-07T22:21:48Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4ODQxNDE4",
          "commit": {
            "abbreviatedOid": "822f18c"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "Oki. I have some doubts about many complexities introduced in order to add redundant context in the key derivations which also diverge from the TLS style. I propose to merge this now, as we agreed on the main design at the interim, and do a run of cleanup-simplifications among editors before releasing the draft so that we restore simplicity. We'll then be able to debate over the details as part of our next round of reviews on the draft.",
          "createdAt": "2019-07-08T11:27:03Z",
          "updatedAt": "2019-07-08T13:30:59Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "It is either \"at most\" one symmetric ratchet per group member or you can say one for each sender in the epoch.",
              "createdAt": "2019-07-08T11:27:04Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 16,
              "body": "It is not the \"Application Key Schedule\" which is the way to compute the keys but the \"Application Secret Tree\" which is the data structure that contains computed secrets and keys. Also, I don't think you can escape keeping the entire Application Secret Tree because as a receiver you have to be able to compute any Application Secret Chain.",
              "createdAt": "2019-07-08T11:31:13Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 64,
              "body": "This block is not necessary, it adds no value as it is perfectly described in the text above.",
              "createdAt": "2019-07-08T11:43:12Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 73,
              "body": "This is called the `GroupContext`",
              "createdAt": "2019-07-08T11:46:19Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 122,
              "body": "s/`GroupState`/`GroupContext`",
              "createdAt": "2019-07-08T11:52:38Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 72,
              "body": "Remove parenthesis",
              "createdAt": "2019-07-08T11:53:20Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 138,
              "body": "The only information added for key-separation to the output of this secret is the `node_index` because the `GroupContext` is already in the root application secret. In TreeKEM we add the hash of the left subtree in the context because we build the tree derivations from leaves to the root which is convenient. As it is not the case here, I would either have more things in the `ASTreeContext` (but I don't have an immediate idea of what we could add) or remove this layer and pass the `node_index` directly instead.",
              "createdAt": "2019-07-08T12:09:22Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 194,
              "body": "Once again, this is already in all previous derivations.\r\nI think I see why you would add it but in some sense if you have a collision on the KDF outputs, either this is pure coincidence and adding this information is irrelevant, or you have an attack on your KDF and adding context won't save you.",
              "createdAt": "2019-07-08T12:38:12Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 194,
              "body": "In general I would prefer to stick to the TLS style instead of adding more complexity for debatable reasons :)",
              "createdAt": "2019-07-08T12:38:49Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 214,
              "body": "Again here, what is the reason to add the gshash? There is basically no good reason to change what was previously on the spec except if it were for doing what Richard suggested and create a `Derive-Application-Secret` function.\r\nEven worse, the `HashRatCont[i,j+1]` is not gonna change anything about the probability of collisions for your KDF outputs between parallel chains...",
              "createdAt": "2019-07-08T12:44:50Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 194,
              "body": "I agree with Richard here, this is introducing too much complexity for debatable reasons. Would we claim the probability of colliding KDF outputs is gonna be reduced by this ? I guess not. `astree_node_[i]_secret` already mixed in the index of the leaf of the ASTree.",
              "createdAt": "2019-07-08T12:49:46Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 240,
              "body": "You need to introduce `S`",
              "createdAt": "2019-07-08T12:51:19Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 261,
              "body": "D2 needs to be consumed because you already derived KD2 and ND2. D3 is missing.",
              "createdAt": "2019-07-08T12:54:04Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 280,
              "body": "This will not render properly",
              "createdAt": "2019-07-08T12:54:58Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 280,
              "body": "D3 is missing from the diagram",
              "createdAt": "2019-07-08T12:56:08Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 286,
              "body": "Again, if KD2 and ND2 have been derived, D2 has been killed and D3 is missing",
              "createdAt": "2019-07-08T12:56:12Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 266,
              "body": "It is not \"during each epoch\" it is for each encryption, and it is not a number of messages but an amount of data that counts. Since you derive a fresh key and nonce, your AEAD bound is fresh for each application message anyway, so it is for each application message.",
              "createdAt": "2019-07-08T13:01:36Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 149,
              "body": "Here is an proposal for this which is an hybrid of your two suggestions:\r\n```\r\nHKDF-Expand-Label(Secret, Label, Context, Length) =\r\n    HKDF-Expand(Secret, HkdfLabel, Length)\r\n\r\nWhere HkdfLabel is specified as:\r\n\r\nstruct {\r\n    uint16 length = Length;\r\n    opaque label<7..255> = \"mls10 \" + Label;\r\n    opaque context<0..2^32-1> = Context;\r\n} HkdfLabel;\r\n\r\nDerive-Secret(Secret, Label) =\r\n    HKDF-Expand-Label(Secret, Label, Hash(GroupContext_[n]), Hash.length)\r\n\r\nstruct {\r\n  uint32 node;\r\n  uint32 generation;\r\n  opaque role<0..255>;\r\n} ApplicationContext;\r\n\r\nDerive-Application-Secret(secret, node, generation, role) =\r\n  DeriveSecret(secret, ApplicationContext(node, generation, role) \r\n\r\nastree_node_[IndexOf(V)]_secret\r\n        |\r\n        |\r\n        +--> Derive-Application-Secret(., V.left_child, 0, \"tree\")\r\n        |    = astree_node_[IndexOf(V.left_child)]_secret\r\n        |\r\n        +--> Derive-Application-Secret(., V.right_child, 0, \"tree\")\r\n             = astree_node_[IndexOf(V.right_child)]_secret\r\n\r\n\r\napplication_[i]_[j]_secret\r\n      |\r\n      +--> HKDF-Expand-Label(.,\"nonce\", \"\", nonce_length)\r\n      |    = write_nonce_[i]_[j]\r\n      |\r\n     +--> HKDF-Expand-Label(.,\"key\", \"\", key_length)\r\n     |    = write_key_[i]_[j] \r\n    V\r\nDerive-Application-Secret(., 2*i, 0, \"sender\")\r\n= application_[i]_[j+1]_secret\r\n\r\n```\r\nThis is slightly different in the sense that we have basically don't change our current way of deriving keys and nonces from an application secret.",
              "createdAt": "2019-07-08T13:17:32Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4OTM4ODY4",
          "commit": {
            "abbreviatedOid": "feb096d"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T14:25:07Z",
          "updatedAt": "2019-07-08T14:25:07Z",
          "comments": [
            {
              "originalPosition": 286,
              "body": "That's wrong.  D2 isn't consumed until KD2 or ND2 is consumed.",
              "createdAt": "2019-07-08T14:25:07Z",
              "updatedAt": "2019-07-08T14:25:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4OTQwNDY3",
          "commit": {
            "abbreviatedOid": "feb096d"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T14:27:24Z",
          "updatedAt": "2019-07-08T14:27:24Z",
          "comments": [
            {
              "originalPosition": 286,
              "body": "Hmm, I disagree that breaks FS. D3, KD2 and ND2 are derived at the same time from D2 which is consumed at this occasion.",
              "createdAt": "2019-07-08T14:27:24Z",
              "updatedAt": "2019-07-08T14:27:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MTQ3NzE5",
          "commit": {
            "abbreviatedOid": "feb096d"
          },
          "author": "psyoptix",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T20:47:22Z",
          "updatedAt": "2019-07-08T20:47:23Z",
          "comments": [
            {
              "originalPosition": 261,
              "body": "Deriving a value doesnt mean the parent needs to be consumed. Only when the derived values are actually used/consumed does the parent need to be consumed. My understanding of this example is that only KD1/ND1 are used but not KD2/ND2. So D2 doesn't need to be consumed yet.",
              "createdAt": "2019-07-08T20:47:22Z",
              "updatedAt": "2019-07-08T20:47:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MTQ4NTIw",
          "commit": {
            "abbreviatedOid": "feb096d"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T20:49:03Z",
          "updatedAt": "2019-07-08T20:49:03Z",
          "comments": [
            {
              "originalPosition": 261,
              "body": "Again, if D2 gets leaked, it strictly worse than leaking D3 because you get KD2 and ND2 as well...",
              "createdAt": "2019-07-08T20:49:03Z",
              "updatedAt": "2019-07-08T20:49:03Z"
            }
          ]
        }
      ]
    },
    {
      "number": 147,
      "id": "MDExOlB1bGxSZXF1ZXN0MjcxNDAwODQz",
      "title": "Added public_key_index to Add message",
      "url": "https://github.com/mlswg/mls-protocol/pull/147",
      "state": "CLOSED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "This is a more correct version of #141. See there for prior conversation.",
      "createdAt": "2019-04-17T17:26:19Z",
      "updatedAt": "2019-12-17T09:16:07Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "cda41739560803a05af8407a018f0db2bb85e948",
      "headRepository": "rozbb/mls-protocol",
      "headRefName": "add-public-key-index",
      "headRefOid": "752d17bd3a7ac2f8ca592ff57d71d6f3f2e6d886",
      "closedAt": "2019-04-30T17:56:34Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I would prefer that we not take this approach, but instead tighten up the requirements for uniqueness in the cipher_suites array, in which case there is no ambiguity in the current approach.\r\n\r\nIf we're going to go this explicit-index route, then you would at least need to require that the recipient verify that `cipher_suites[i] == group.cipher_suite`.  But that seems more fragile than indexing by cipher suite, since the recipient can omit this check and end up trying to re-use key shares across groups.",
          "createdAt": "2019-04-19T14:48:16Z",
          "updatedAt": "2019-04-19T14:48:16Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I argue that `cipher_suites[i] == group.cipher_suite` is actually less fragile than indexing by ciphersuite. I have ciphersuite information encoded in all my DH and AEAD key types, so even if I were to forget that check, I would get a runtime error very quickly, which is a good thing.\r\n\r\nBut if I were to forget to check for uniqueness of ciphersuites, it could result in two members deriving disagreeing yet valid GroupStates. I think that this situation is harder to diagnose than the above.\r\n\r\nStill, I won't push too hard on this if everyone else is in agreement that it's not necessary.",
          "createdAt": "2019-04-19T17:57:02Z",
          "updatedAt": "2019-04-19T17:57:02Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I am inclined to close this with no action.  @beurdouche @raphaelrobert wdyt?",
          "createdAt": "2019-04-25T15:10:34Z",
          "updatedAt": "2019-04-25T15:10:34Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "@bifurcation Yes, I agree with closing this.",
          "createdAt": "2019-04-29T08:52:52Z",
          "updatedAt": "2019-04-29T08:52:52Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 148,
      "id": "MDExOlB1bGxSZXF1ZXN0MjcxNDQ3ODIw",
      "title": "Added that users SHOULD verify pubkeys in an Update",
      "url": "https://github.com/mlswg/mls-protocol/pull/148",
      "state": "MERGED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "recommendation",
        "security"
      ],
      "body": "Adding this check would be the first step in recognizing that an Update operation may have maliciously excluded a person from the group.",
      "createdAt": "2019-04-17T19:57:16Z",
      "updatedAt": "2019-12-17T09:15:38Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "cda41739560803a05af8407a018f0db2bb85e948",
      "headRepository": "rozbb/mls-protocol",
      "headRefName": "verify-update-pubkeys",
      "headRefOid": "d75db3092eed43b52df71249c80680198ca07bcf",
      "closedAt": "2019-04-29T08:45:48Z",
      "mergedAt": "2019-04-29T08:45:48Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "242746778e96d2d865f916e36b3518104117a283"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "This would go better in the \"Ratchet Tree Updates\" section, right after \"Derive secret values for ancestors of that node using the KDF keyed with the decrypted secret\".  That would align better with where in the code you want the checks to be.  Other than that, LGTM.",
          "createdAt": "2019-04-19T14:39:25Z",
          "updatedAt": "2019-04-19T14:39:25Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixed",
          "createdAt": "2019-04-19T18:02:04Z",
          "updatedAt": "2019-04-19T18:02:04Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Thanks Michael !",
          "createdAt": "2019-04-29T08:46:55Z",
          "updatedAt": "2019-04-29T08:46:55Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI5MjU1NzIx",
          "commit": {
            "abbreviatedOid": "3551fbb"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-04-22T21:20:43Z",
          "updatedAt": "2019-04-22T21:20:43Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI5MjU2ODky",
          "commit": {
            "abbreviatedOid": "3551fbb"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-22T21:23:37Z",
          "updatedAt": "2019-04-22T21:23:37Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Editorial: \"Members\" -> \"The recipient\"",
              "createdAt": "2019-04-22T21:23:37Z",
              "updatedAt": "2019-04-25T23:12:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMwMjkyNTEw",
          "commit": {
            "abbreviatedOid": "866e4a4"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-24T18:47:33Z",
          "updatedAt": "2019-04-24T18:47:33Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Done",
              "createdAt": "2019-04-24T18:47:33Z",
              "updatedAt": "2019-04-25T23:12:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMxNTY1Njky",
          "commit": {
            "abbreviatedOid": "d75db30"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-04-29T08:44:17Z",
          "updatedAt": "2019-04-29T08:44:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 149,
      "id": "MDExOlB1bGxSZXF1ZXN0MjcxNDUwNjA0",
      "title": "Did a bunch of clarification around path secrets",
      "url": "https://github.com/mlswg/mls-protocol/pull/149",
      "state": "CLOSED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "A few things:\r\n\r\n1. Restructured the sections \"Ratchet Tree Nodes and Tree Updates\" and \"Ratchet Tree Updates\" into \"Ratchet Tree Nodes\" and \"Ratchet Tree Updates\". I also put them next to each other, whereas before the \"Blank Nodes and Resolution\" section came between them.\r\n2. Removed node secrets from the set of things that a node must contain. There is no need for this. The node secret is used precisely once\u2014to derive the node's keypair. It needn't be stored after that.\r\n3. Clarified things and made the terminology more consistent. For example, the diagram in the previous \"Ratchet Tree Updates\" section only referred to \"secrets\" without specification (because there used to only be node secrets). There were also statements that referred to node secrets when they meant path secrets. These should be fixed now.\r\n4. Renamed `RatchetNode::node_secrets` to `RatchetNode::path_secrets`",
      "createdAt": "2019-04-17T20:06:22Z",
      "updatedAt": "2019-12-17T09:15:19Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "cda41739560803a05af8407a018f0db2bb85e948",
      "headRepository": "rozbb/mls-protocol",
      "headRefName": "path-secret-cleanup",
      "headRefOid": "887f86762d2d962c47ac3fdc59802b788643e5ae",
      "closedAt": "2019-04-24T19:44:46Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@rozbb Could you please verify that #134 has the required changes in it?  (And thus that this PR can be closed.)",
          "createdAt": "2019-04-22T21:25:34Z",
          "updatedAt": "2019-04-22T21:25:50Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yup, looks like everything made it in. See #134 for further comments.",
          "createdAt": "2019-04-24T19:44:46Z",
          "updatedAt": "2019-04-24T19:44:46Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 151,
      "id": "MDExOlB1bGxSZXF1ZXN0MjcyMDA5MTU1",
      "title": "A couple of minor fixes",
      "url": "https://github.com/mlswg/mls-protocol/pull/151",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "* Clean up some OPEN ISSUES that aren't open any more\r\n* Make the welcome/add diagram clearer",
      "createdAt": "2019-04-19T14:22:21Z",
      "updatedAt": "2019-12-17T09:15:08Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "cda41739560803a05af8407a018f0db2bb85e948",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "minor-fixes",
      "headRefOid": "b42e702fdfec54197159a27bd29f0bfa5c84a3da",
      "closedAt": "2019-04-22T21:17:17Z",
      "mergedAt": "2019-04-22T21:17:17Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "24efba91dd3c679a27d9c96158707cfee3b09df3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI4NzA5MTIz",
          "commit": {
            "abbreviatedOid": "ee358ac"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-04-19T14:26:08Z",
          "updatedAt": "2019-04-19T14:26:08Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI4NzY0MDQy",
          "commit": {
            "abbreviatedOid": "ee358ac"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-19T17:24:39Z",
          "updatedAt": "2019-04-19T17:24:40Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "This should be `Add(A->AB)`",
              "createdAt": "2019-04-19T17:24:39Z",
              "updatedAt": "2019-04-22T21:16:00Z"
            }
          ]
        }
      ]
    },
    {
      "number": 152,
      "id": "MDExOlB1bGxSZXF1ZXN0MjcyNzY5NjU3",
      "title": "Make epochs unpredictable",
      "url": "https://github.com/mlswg/mls-protocol/pull/152",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "? follow-up",
        "privacy"
      ],
      "body": "As discussed on the mailing list, further reduces the ability of the Delivery Service to infer what's going on in the group.",
      "createdAt": "2019-04-23T14:58:25Z",
      "updatedAt": "2019-12-20T10:11:51Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "24efba91dd3c679a27d9c96158707cfee3b09df3",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "random-epoch",
      "headRefOid": "d465e0110be01424eb06a37681d2693fa371c768",
      "closedAt": "2019-07-01T22:22:49Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "psyoptix",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I see we use HMAC to derive epoch_[n] which forces explicit truncation of HMACs output (to 4 bytes). Why not use HMAC-Expand instead? It's already used in another place by MLS so should already be available and it already takes the desired output length as a third parameter.",
          "createdAt": "2019-04-24T12:10:59Z",
          "updatedAt": "2019-04-24T12:10:59Z"
        },
        {
          "author": "psyoptix",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm sure this is a silly question so please humor me... :-)\r\n\r\nIn the GroupOperation struct there is a select command which, I think, results in one of 4 struct types (e.g. \"Init\", \"Add\", etc) being chosen depending on the value of msg_type. But I dont see the actual *name* for that struct member being defined there (say, \"msg\"). Is it missing...  or am I just missing something? :-)\r\n\r\nIn case there's no bug here and I'm just not familiar with that syntax could someone point me to a resource where I can read up on it?",
          "createdAt": "2019-04-24T12:21:33Z",
          "updatedAt": "2019-04-24T12:21:33Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the comments, @psyoptix \r\n\r\nRe: `HKDF-Expand` -- Yeah, this is a good idea.  I'll refactor to use that.  It's still just one HKDF instantiation, after all.\r\n\r\nRe: `GroupOperation` -- According to [the syntax specification](https://tools.ietf.org/html/rfc8446#section-3.8), the field names are optional, but I would be fine including them.  Want to send a small PR for that?",
          "createdAt": "2019-04-24T12:59:53Z",
          "updatedAt": "2019-04-24T12:59:53Z"
        },
        {
          "author": "psyoptix",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yup, so as expected the issue lies with my knowledge of the correct syntax not with the doc so nevermind. :-) thanks for the reference by the way.\r\n\r\n(and as long as we're never referring to that member there's no need in giving it a name so the definition is fine as is.)",
          "createdAt": "2019-04-24T15:47:17Z",
          "updatedAt": "2019-04-24T15:47:17Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@beurdouche based on your comments in #155 do you want to push this to draft-06?",
          "createdAt": "2019-05-01T02:13:06Z",
          "updatedAt": "2019-05-01T02:13:06Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "> @beurdouche based on your comments in #155 do you want to push this to draft-06?\r\n\r\nYes, that is not a difficult issue but I think handling unpredicatable epoch and unpredictable group_id makes sense. That might be a short discussion topic at the interim ?",
          "createdAt": "2019-05-01T10:32:44Z",
          "updatedAt": "2019-05-01T10:32:44Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "> > @beurdouche based on your comments in #155 do you want to push this to draft-06?\r\n> \r\n> Yes, that is not a difficult issue but I think handling unpredicatable epoch and unpredictable group_id makes sense. That might be a short discussion topic at the interim ?\r\n\r\nat the same time*",
          "createdAt": "2019-05-01T10:33:13Z",
          "updatedAt": "2019-05-01T10:33:13Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I fully support the intention of this, but it is not clear to me how the DS can enforce total order on HS messages if the epochs are no longer comparable.",
          "createdAt": "2019-07-01T12:07:16Z",
          "updatedAt": "2019-07-01T12:07:16Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this until we have a better theory for the overall environment (e.g., how server assist would work).",
          "createdAt": "2019-07-01T22:22:49Z",
          "updatedAt": "2019-07-01T22:22:49Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "This can be discussed as part of \"Server assist\".",
          "createdAt": "2019-12-20T10:11:51Z",
          "updatedAt": "2019-12-20T10:11:51Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 153,
      "id": "MDExOlB1bGxSZXF1ZXN0MjcyOTA5NzE0",
      "title": "Common framing, consolidated",
      "url": "https://github.com/mlswg/mls-protocol/pull/153",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "duplicate"
      ],
      "body": "I started off trying to just edit #131 to be landable, but as I looked at it, it seemed like we had accreted enough complexity that a refactor was in order.  So this PR mostly rewrites the sections related to encryption keys and message framing, hopefully in a way that's clearer to the reader.  For the most part, though, the technical bits are the same as in #131.  There are a couple of innovations here:\r\n\r\n* Using \"masking\" instead of AEAD for sender data encryption (cf. [QUIC header protection](https://tools.ietf.org/html/draft-ietf-quic-tls-17#section-5.4)). This saves 28 bytes of overhead, but there's no longer authentication except in the content AEAD.  This change could be done as a follow-on PR, but it seemed brief enough to include here.\r\n\r\n* I eliminated the `group_id` field in the messages, since it seems plausible that we could rely on applications to provide that.    The benefit of this is that the wire image that MLS itself presents (in `MLSCiphertext`) is entirely opaque to the delivery service (even if the DS might add some context that indicates the group ID).",
      "createdAt": "2019-04-23T22:07:28Z",
      "updatedAt": "2019-12-17T10:14:59Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "24efba91dd3c679a27d9c96158707cfee3b09df3",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "rlb-framing-v2",
      "headRefOid": "acfac1345e571fd9190279afb759088bd9cb94a5",
      "closedAt": "2019-05-01T02:12:24Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Draft implementation here: https://github.com/cisco/mlspp/pull/48",
          "createdAt": "2019-04-24T14:03:39Z",
          "updatedAt": "2019-04-24T14:03:39Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMxNTk5MTAy",
          "commit": {
            "abbreviatedOid": "acfac13"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "Ok, globally I think this is quite good, but there are a few changes I think we should revert so I made the fixes on top of this PR in \r\nhttps://github.com/mlswg/mls-protocol/pull/155",
          "createdAt": "2019-04-29T10:09:15Z",
          "updatedAt": "2019-04-30T19:00:38Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "It is not only \"within the epoch\" but across the epochs as well.",
              "createdAt": "2019-04-29T10:11:06Z",
              "updatedAt": "2019-04-30T19:00:38Z"
            },
            {
              "originalPosition": 136,
              "body": "What can we say about Encryption here ?",
              "createdAt": "2019-04-29T10:14:33Z",
              "updatedAt": "2019-04-30T19:00:38Z"
            },
            {
              "originalPosition": 187,
              "body": "The `ContentType` should be somewhere here. It cannot be only inside, otherwise the DS cannot enforce total ordering of the HS messages. (It would force total ordering of application messages as well)",
              "createdAt": "2019-04-30T10:18:54Z",
              "updatedAt": "2019-04-30T19:00:38Z"
            },
            {
              "originalPosition": 186,
              "body": "Group ID is missing here. (See my point below)",
              "createdAt": "2019-04-30T10:21:06Z",
              "updatedAt": "2019-04-30T19:00:38Z"
            },
            {
              "originalPosition": 194,
              "body": "I don't think we should do this, this is quite a pain to add an unspecified requirement that the GID is somehow communicated out of band or via an ad-hoc way to the recipient.",
              "createdAt": "2019-04-30T10:22:10Z",
              "updatedAt": "2019-04-30T19:00:38Z"
            },
            {
              "originalPosition": 34,
              "body": "This seem like an unnecessary source of complexity, I would be fine with putting everything inside.",
              "createdAt": "2019-04-30T18:51:48Z",
              "updatedAt": "2019-04-30T19:00:38Z"
            },
            {
              "originalPosition": 49,
              "body": "I am not sure about \"sender\", as it is not sender specific. \"sender info\" ?",
              "createdAt": "2019-04-30T18:52:30Z",
              "updatedAt": "2019-04-30T19:00:38Z"
            },
            {
              "originalPosition": 69,
              "body": "There is no chain for the Handshake message. We are missing a definition to derive a key/nonce for handshake message. This should probably be sender specific as well to avoid two different sender to encrypt using the same key.",
              "createdAt": "2019-04-30T18:55:22Z",
              "updatedAt": "2019-04-30T19:00:38Z"
            },
            {
              "originalPosition": 245,
              "body": "This should probably be called `MLSCiphertextContent` then",
              "createdAt": "2019-04-30T18:57:13Z",
              "updatedAt": "2019-04-30T19:00:38Z"
            },
            {
              "originalPosition": 264,
              "body": "This should probably be called `MLSCiphertextAAD` and the AAD can now be the public prefix of the ciphertext on the wire.",
              "createdAt": "2019-04-30T18:58:07Z",
              "updatedAt": "2019-04-30T19:00:38Z"
            },
            {
              "originalPosition": 282,
              "body": "I think this should be removed.",
              "createdAt": "2019-04-30T18:58:27Z",
              "updatedAt": "2019-04-30T19:00:38Z"
            },
            {
              "originalPosition": 303,
              "body": "If we remove, this must be 8",
              "createdAt": "2019-04-30T18:58:41Z",
              "updatedAt": "2019-04-30T19:00:38Z"
            },
            {
              "originalPosition": 307,
              "body": "I really like this.",
              "createdAt": "2019-04-30T18:59:18Z",
              "updatedAt": "2019-04-30T19:00:38Z"
            }
          ]
        }
      ]
    },
    {
      "number": 155,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjc0ODQ5MDcy",
      "title": "Common framing, consolidated with modifications",
      "url": "https://github.com/mlswg/mls-protocol/pull/155",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "functionality",
        "performance",
        "privacy",
        "security"
      ],
      "body": "This PR is updates Richard's changes with a few adjustments:\r\n\r\n- Merge master;\r\n- Fix missing definition to derive key/nonce used for encryption of Handshake messages;\r\n- Delete the \"remove_confirmation\" function for simplicity. It has a very low cost anyway;\r\n- Revert to having the GID and the epoch in the clear, otherwise there is a need for a magic channel to communicate it to the recipient. We can eventually do it but this should be discussed seriously in Berlin;\r\n- Revert the masking of the content type, (keeps masking for sender and generation) otherwise it seem to force plaintext OR the Delivery Service to have access to the sender_data_secret. It seem impossible to only order Handshake messages otherwise.",
      "createdAt": "2019-04-30T18:59:46Z",
      "updatedAt": "2019-12-17T09:13:23Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "3f14893110df64b367e0ae1f09410ddae45b4be5",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_101bis",
      "headRefOid": "c13bd759241ef2bb6139e36bbcdaeccffc0977c7",
      "closedAt": "2019-05-02T15:31:25Z",
      "mergedAt": "2019-05-02T15:31:25Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "d7f01dba19742ee95735496fa4a14bfa0434c0b9"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@raphaelrobert Last call on this one.  If I don't hear from you by the morning ET, I'm going to merge this.",
          "createdAt": "2019-05-02T01:29:39Z",
          "updatedAt": "2019-05-02T01:29:39Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Note that this PR will be pretty immediately updated by #156, which reverts the \"masking\" parts to use AEAD, in order to make analysis simpler for this revision.",
          "createdAt": "2019-05-02T15:31:08Z",
          "updatedAt": "2019-05-02T15:31:08Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMyNDc2MTUy",
          "commit": {
            "abbreviatedOid": "02164b7"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Overall, this looks pretty close.  OK to merge once we get these comments addressed.  I'm slightly sad to lose the extra masking, but we can handle that as a follow-on.",
          "createdAt": "2019-05-01T01:56:21Z",
          "updatedAt": "2019-05-01T02:11:29Z",
          "comments": [
            {
              "originalPosition": 106,
              "body": "s/\"[sender]\"/[sender]/",
              "createdAt": "2019-05-01T01:56:21Z",
              "updatedAt": "2019-05-02T15:21:43Z"
            },
            {
              "originalPosition": 109,
              "body": "Ditto here.",
              "createdAt": "2019-05-01T01:56:30Z",
              "updatedAt": "2019-05-02T15:21:43Z"
            },
            {
              "originalPosition": 102,
              "body": "This text assumes that there's only a need for one handshake message to be sent per epoch.  I realize that should be true in most cases, but I'm concerned about things like retries leading to nonce reuse.  This is why in #153, I had handshake keys follow the same path as application keys.  This also allows code reuse.\r\n",
              "createdAt": "2019-05-01T02:00:27Z",
              "updatedAt": "2019-05-02T15:21:43Z"
            },
            {
              "originalPosition": 125,
              "body": "s/sender/ap sender/ ?",
              "createdAt": "2019-05-01T02:00:53Z",
              "updatedAt": "2019-05-02T15:21:43Z"
            },
            {
              "originalPosition": 102,
              "body": "Oh, I see you have conveniently not deleted that text :)  So I would just delete the text you've added up here.",
              "createdAt": "2019-05-01T02:01:40Z",
              "updatedAt": "2019-05-02T15:21:43Z"
            },
            {
              "originalPosition": 52,
              "body": "In general, I've been using lower-case \"handshake message\", since we don't have a Handshake struct any more.",
              "createdAt": "2019-05-01T02:02:39Z",
              "updatedAt": "2019-05-02T15:21:43Z"
            },
            {
              "originalPosition": 222,
              "body": "s/type/content_type/",
              "createdAt": "2019-05-01T02:03:23Z",
              "updatedAt": "2019-05-02T15:21:43Z"
            },
            {
              "originalPosition": 246,
              "body": "\"Concatenating\" is not quite right, since it's a bit more complex than that.  Maybe \"Gather the required metadata:\"",
              "createdAt": "2019-05-01T02:04:44Z",
              "updatedAt": "2019-05-02T15:21:43Z"
            },
            {
              "originalPosition": 260,
              "body": "Also content_type now, right?",
              "createdAt": "2019-05-01T02:05:28Z",
              "updatedAt": "2019-05-02T15:21:43Z"
            },
            {
              "originalPosition": 285,
              "body": "It occurs to me that there's not actually a `length` field in `MLSPlaintext`.  Let's just use `length_of_content`, in parallel to `length_of_padding`.    ",
              "createdAt": "2019-05-01T02:08:01Z",
              "updatedAt": "2019-05-02T15:21:43Z"
            },
            {
              "originalPosition": 294,
              "body": "\"a handshake_key\".  But really you need to change this to say \"an unused generation from it's application or handshake key chain\"",
              "createdAt": "2019-05-01T02:08:47Z",
              "updatedAt": "2019-05-02T15:21:43Z"
            },
            {
              "originalPosition": 308,
              "body": "This is impossible.  The masking is based on the ciphertext, so you can't use the masked values as an input to the encryption.  Just use the plain values.",
              "createdAt": "2019-05-01T02:09:57Z",
              "updatedAt": "2019-05-02T15:21:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMyNTM4Mjk3",
          "commit": {
            "abbreviatedOid": "fa15000"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Ok, so I've merged master and made changes according to your comments.\r\nI think there is only one point remaining to be discussed but it is quite interesting... :)",
          "createdAt": "2019-05-01T10:50:50Z",
          "updatedAt": "2019-05-01T11:25:07Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "My way of thinking of this is that, since the Delivery Service has to provide total ordering of the handshake messages, each message will be processed after the other. In the case where two clients A, B emit HS messages in the same epoch [N], the Delivery Service will accept one (say mA) and reject the other (mB): B has to first process mA to get to the new epoch and group state [N+1], then it has to re-encrypt in the new epoch ([N+1]). I might be wrong but I think that this is necessary for everyone to end-up in the same state...\r\n\r\nIn the mechanism you describe, my understanding is that handshake_secret chain would live in the same epoch N. Because B needs to move to epoch [N+1] anyways, it would have to keep it's handshake_secret_[N]_[1] alive.\r\n\r\nI think this could be fine, but since we have to move to epoch [N+1] anyway, my proposal is just for B to use handshake_secret_[N+1]_[0] directly which allows everybody to kill all HS secrets from the previous epoch.\r\nIf I am correct, because of the fact that there is the [sender] in the derivation of the key/nonce, there cannot be a key/nonce reuse:\r\n- Even if two senders would send the same HS message, the keys would be different\r\n- Since you only encrypt at most one HS message per epoch, there is no more risk for reusing than what we have for application messages.\r\n\r\nIn some sense all the handshake secrets for the previous epoch are gone immediately and there is no need for book-keeping handshake_secrets from a previous epoch. Note that regarding code reuse, we can add the [sender] to the application key/nonce derivation so that these derivations only differ by the label... :)\r\n\r\nDoes that make sense and what do you think ? ;)\r\nB.\r\n\r\n",
              "createdAt": "2019-05-01T10:50:50Z",
              "updatedAt": "2019-05-02T15:21:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMyNzA1NDg4",
          "commit": {
            "abbreviatedOid": "fa15000"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-01T18:56:01Z",
          "updatedAt": "2019-05-01T18:57:38Z",
          "comments": [
            {
              "originalPosition": 322,
              "body": "\"a handshake key\"",
              "createdAt": "2019-05-01T18:56:01Z",
              "updatedAt": "2019-05-02T15:21:43Z"
            },
            {
              "originalPosition": 323,
              "body": "\"a handshake message\"",
              "createdAt": "2019-05-01T18:56:16Z",
              "updatedAt": "2019-05-02T15:21:43Z"
            },
            {
              "originalPosition": 102,
              "body": "I can live with that for now.  Please remove the para starting \"The same rules are used to generate a sequence of keys and nonces for handshake encryption\"\r\n\r\nI see what you're saying, I don't feel 100% confident that we won't get wedged by this in practice.  And I dislike the extra code paths.  But we can merge with this flavor and ask the WG.\r\n",
              "createdAt": "2019-05-01T18:57:30Z",
              "updatedAt": "2019-05-02T15:21:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMyNzIwMDkz",
          "commit": {
            "abbreviatedOid": "fa15000"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-01T19:34:11Z",
          "updatedAt": "2019-05-01T19:39:14Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "I agree, there might be a better solution but I don't immediately have it.\r\nShould I add an open issue or something ?",
              "createdAt": "2019-05-01T19:34:11Z",
              "updatedAt": "2019-05-02T15:21:43Z"
            },
            {
              "originalPosition": 322,
              "body": "Fixed, thanks !",
              "createdAt": "2019-05-01T19:34:31Z",
              "updatedAt": "2019-05-02T15:21:43Z"
            },
            {
              "originalPosition": 323,
              "body": "Fixed, thanks !",
              "createdAt": "2019-05-01T19:34:34Z",
              "updatedAt": "2019-05-02T15:21:43Z"
            }
          ]
        }
      ]
    },
    {
      "number": 156,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjc1NDAyOTk0",
      "title": " Revert QUIC-like masking of sender_data in favor of AEAD ",
      "url": "https://github.com/mlswg/mls-protocol/pull/156",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "security"
      ],
      "body": "",
      "createdAt": "2019-05-02T15:07:09Z",
      "updatedAt": "2019-12-17T09:12:36Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "d7f01dba19742ee95735496fa4a14bfa0434c0b9",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_revert_masking",
      "headRefOid": "acc56c5fd1d5691bc5b9a10a251de0a397c508ee",
      "closedAt": "2019-05-02T17:45:14Z",
      "mergedAt": "2019-05-02T17:45:13Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "8f938ed1188b0d6f4decbfd77b96a4a041557f7b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzMDgwNjA5",
          "commit": {
            "abbreviatedOid": "05a5606"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-02T15:33:12Z",
          "updatedAt": "2019-05-02T15:34:13Z",
          "comments": [
            {
              "originalPosition": 266,
              "body": "Nit: This would be a little clearer as `sender_data_nonce`",
              "createdAt": "2019-05-02T15:33:12Z",
              "updatedAt": "2019-05-02T15:47:11Z"
            },
            {
              "originalPosition": 370,
              "body": "`sender_data_nonce`",
              "createdAt": "2019-05-02T15:33:35Z",
              "updatedAt": "2019-05-02T15:47:11Z"
            },
            {
              "originalPosition": 304,
              "body": "`sender_data_nonce`",
              "createdAt": "2019-05-02T15:34:10Z",
              "updatedAt": "2019-05-02T15:47:11Z"
            }
          ]
        }
      ]
    },
    {
      "number": 163,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjc5NzkxNzE3",
      "title": "Reorder blanking and update in the Remove operation",
      "url": "https://github.com/mlswg/mls-protocol/pull/163",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "functionality",
        "performance",
        "security"
      ],
      "body": "Fixes #162 ",
      "createdAt": "2019-05-17T08:07:38Z",
      "updatedAt": "2019-12-17T09:12:15Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "564ee2662e4eeac93a854edf3a6ab44eb46cb6d6",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_remove",
      "headRefOid": "50bc327f2e5d65832713c93e0c2ab7588be0a4d1",
      "closedAt": "2019-05-24T14:01:35Z",
      "mergedAt": "2019-05-24T14:01:35Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "46b8ece169e2bf0eb6771eac4396f144199032e4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQxNDc3MTkz",
          "commit": {
            "abbreviatedOid": "7c3f16c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-05-23T22:16:11Z",
          "updatedAt": "2019-05-23T22:18:01Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "We should note here that the blanking should be temporary / undone after this computation.  The generation of messages should not change the sender's state.",
              "createdAt": "2019-05-23T22:16:11Z",
              "updatedAt": "2019-05-24T08:48:03Z"
            },
            {
              "originalPosition": 15,
              "body": "Also, you should go ahead and truncate here, which will save you unnecessary derivations.  So:\r\n\r\n* Before: Encrypt / blank\r\n* After: Blank / Truncate / Encrypt\r\n\r\nSame change in the processing logic below.\r\n\r\n",
              "createdAt": "2019-05-23T22:17:47Z",
              "updatedAt": "2019-05-24T08:48:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQxNzU4MDc4",
          "commit": {
            "abbreviatedOid": "50bc327"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-05-24T14:01:23Z",
          "updatedAt": "2019-05-24T14:01:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 164,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjc5NzkzMzcw",
      "title": "Rename UserInitKey to ClientInitKey",
      "url": "https://github.com/mlswg/mls-protocol/pull/164",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "terminology"
      ],
      "body": "Fixes #137 ",
      "createdAt": "2019-05-17T08:13:37Z",
      "updatedAt": "2019-12-17T09:11:56Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "46b8ece169e2bf0eb6771eac4396f144199032e4",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_clientinitkey",
      "headRefOid": "72056b8116d31326a9f84855cde0ae08007715dd",
      "closedAt": "2019-05-24T14:04:36Z",
      "mergedAt": "2019-05-24T14:04:36Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "0d849622508cebd6d9c769dd0388fa17d15fd083"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Overall, this seems OK.  Just using \"InitKey\" would be clear and less wordy.",
          "createdAt": "2019-05-23T22:05:08Z",
          "updatedAt": "2019-05-23T22:05:08Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "I tried this and that led people to confuse `init key` and `init secret`",
          "createdAt": "2019-05-24T08:17:42Z",
          "updatedAt": "2019-05-24T08:17:42Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 165,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjc5ODIzODc4",
      "title": "Fix typo after change in the MLSCiphertextContent struct",
      "url": "https://github.com/mlswg/mls-protocol/pull/165",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Fix for #158",
      "createdAt": "2019-05-17T09:47:39Z",
      "updatedAt": "2019-12-17T09:11:49Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "8f938ed1188b0d6f4decbfd77b96a4a041557f7b",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_158",
      "headRefOid": "f2fe8ec26565404ef0e6c4d79a61bea0dc50a84f",
      "closedAt": "2019-05-17T09:47:55Z",
      "mergedAt": "2019-05-17T09:47:55Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "99b311924a9b619fd1e03d4eecd21619bbada6be"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 166,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjc5ODI2NjI3",
      "title": "GroupState is not a group state, renaming to GroupContext",
      "url": "https://github.com/mlswg/mls-protocol/pull/166",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "terminology"
      ],
      "body": "Fix for #159",
      "createdAt": "2019-05-17T09:55:35Z",
      "updatedAt": "2019-12-17T09:11:37Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "99b311924a9b619fd1e03d4eecd21619bbada6be",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_159",
      "headRefOid": "66e4cbdbd11018983d9bca9dcf742aa42d92b57f",
      "closedAt": "2019-05-24T08:25:52Z",
      "mergedAt": "2019-05-24T08:25:52Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "564ee2662e4eeac93a854edf3a6ab44eb46cb6d6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQxNDc0MjI2",
          "commit": {
            "abbreviatedOid": "1e7c031"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Approved with the one comment fixed.",
          "createdAt": "2019-05-23T22:06:30Z",
          "updatedAt": "2019-05-23T22:07:06Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "It's not partial, it's a summary / commitment.\r\n\r\n\"Each member of the group maintains a GroupContext object that summarizes the state of the group:\"",
              "createdAt": "2019-05-23T22:06:30Z",
              "updatedAt": "2019-05-24T08:24:54Z"
            }
          ]
        }
      ]
    },
    {
      "number": 167,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjc5OTA5NjY1",
      "title": "Fix incorrect definition of update_secret",
      "url": "https://github.com/mlswg/mls-protocol/pull/167",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bug",
        "editorial"
      ],
      "body": "\"The update secret resulting from this change is the path secret for the\r\nroot node of the ratchet tree.\" is suspicious because in the derivation, the index for both the `path_secret` and `node_secret` is the same as the level of the node. It should be the `path_secret[n+1]` \"above the root\" and not \"for the root\" (`path_secret[n]`which is the one used to derive the `node_secret[n]` of the root)...",
      "createdAt": "2019-05-17T14:14:52Z",
      "updatedAt": "2019-12-17T09:11:21Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "99b311924a9b619fd1e03d4eecd21619bbada6be",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_us",
      "headRefOid": "a2f0e8d905bdfa3a957ae956f65ddf0bb4d4f6bc",
      "closedAt": "2019-05-23T22:11:28Z",
      "mergedAt": "2019-05-23T22:11:28Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "6e672188c590c2dbd34fd1369b3b6e1d6da8fda8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQxNDc1NjM3",
          "commit": {
            "abbreviatedOid": "a2f0e8d"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-05-23T22:11:05Z",
          "updatedAt": "2019-05-23T22:11:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 169,
      "id": "MDExOlB1bGxSZXF1ZXN0MjgwODU0NzEz",
      "title": "Notion of virtual client when secrets are shared accross devices",
      "url": "https://github.com/mlswg/mls-protocol/pull/169",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "terminology"
      ],
      "body": "",
      "createdAt": "2019-05-21T16:13:29Z",
      "updatedAt": "2019-12-17T09:10:38Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "99b311924a9b619fd1e03d4eecd21619bbada6be",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_145",
      "headRefOid": "98c9c8355975854ddfd5934a25d34b7ef1efe24b",
      "closedAt": "2019-05-23T22:12:06Z",
      "mergedAt": "2019-05-23T22:12:06Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "cefc48b64e3651fafeab56c6413fdd75bef4c4c5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQxNDc1OTA2",
          "commit": {
            "abbreviatedOid": "98c9c83"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-05-23T22:12:00Z",
          "updatedAt": "2019-05-23T22:12:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 170,
      "id": "MDExOlB1bGxSZXF1ZXN0MjgxODE3MDMz",
      "title": "Confirmation and transcript improvements",
      "url": "https://github.com/mlswg/mls-protocol/pull/170",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "bug",
        "security"
      ],
      "body": "This PR addresses two issues that were noted in draft-05, one that is definitely a bug, and one that should improve security analysis.\r\n\r\n* In draft-05, a circular dependency was introduced, wherein the confirmation MAC was calculated from the transcript, which includes the GroupOperation, which includes the confirmation MAC.  Here we move the confirmation MAC up to the MLSPlaintext object to avoid this circularity.\r\n\r\n* In all prior versions, the transcript covered only the GroupOperation objects, not the sender metadata or signatures.  Here we cover the whole MLSPlaintext object, but in \"staggered\" form -- the confirmation MAC and signature aren't entered into the transcript until the next epoch.\r\n\r\nFixes #157 ",
      "createdAt": "2019-05-23T23:21:53Z",
      "updatedAt": "2019-12-17T09:10:21Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "0d849622508cebd6d9c769dd0388fa17d15fd083",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "circular-confirmation",
      "headRefOid": "9132e357ce338c34d3fa95b93c1b5e5eb7598df4",
      "closedAt": "2019-05-30T15:29:57Z",
      "mergedAt": "2019-05-30T15:29:57Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "7602f683a6e9ba79cdb732814314a259d8738cb2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQzODQ1MDY1",
          "commit": {
            "abbreviatedOid": "dcf19f5"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-05-30T14:58:54Z",
          "updatedAt": "2019-05-30T15:03:09Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Why do we need the `content_type` field? I think it will effectively always be set to `handshake`, since we go from one epoch to another.",
              "createdAt": "2019-05-30T14:58:54Z",
              "updatedAt": "2019-05-30T15:24:52Z"
            },
            {
              "originalPosition": 38,
              "body": "I'm not sure we have to introduce the notion of an intermediate hash, since it will never be used independently. We could just define the transcript hash as:\r\n\r\n```\r\ntranscript_hash_[n] = Hash(transcript_hash_[n-1] || MLSPlaintextOpAuthData_[n-1] || MLSPlaintextOpContent_[n]);\r\n```",
              "createdAt": "2019-05-30T15:01:35Z",
              "updatedAt": "2019-05-30T15:24:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQzODU0NTY2",
          "commit": {
            "abbreviatedOid": "dcf19f5"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-30T15:15:35Z",
          "updatedAt": "2019-05-30T15:15:35Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "The idea of the intermediate hash is that an implementation could go ahead and update the transcript hash to this state and be done with MLSPlaintext_[n-1], so it wouldn't need to keep that around..  I'll add some text to clarify.",
              "createdAt": "2019-05-30T15:15:35Z",
              "updatedAt": "2019-05-30T15:24:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQzODU4OTE4",
          "commit": {
            "abbreviatedOid": "dcf19f5"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-30T15:22:59Z",
          "updatedAt": "2019-05-30T15:23:00Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I agree that in practice this field will be constant, but I like keeping the alignment with the MLSPlaintext struct.  I'll add an annotation to clarify.",
              "createdAt": "2019-05-30T15:23:00Z",
              "updatedAt": "2019-05-30T15:24:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQzODYyMTgy",
          "commit": {
            "abbreviatedOid": "9132e35"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-30T15:28:31Z",
          "updatedAt": "2019-05-30T15:28:32Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "That makes sense",
              "createdAt": "2019-05-30T15:28:31Z",
              "updatedAt": "2019-05-30T15:28:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQzODYyMjQz",
          "commit": {
            "abbreviatedOid": "9132e35"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-05-30T15:28:38Z",
          "updatedAt": "2019-05-30T15:28:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 171,
      "id": "MDExOlB1bGxSZXF1ZXN0MjgxODM1NTYx",
      "title": "Specify an Init message",
      "url": "https://github.com/mlswg/mls-protocol/pull/171",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "functionality"
      ],
      "body": "This is something we've been meaning to do for a while, and just haven't gotten around to.\r\n\r\nThe Init message directly creates a group with a specified member list.  The cost of group creation is O(N) DH operations for the sender, and O(1) for receivers.",
      "createdAt": "2019-05-24T01:19:33Z",
      "updatedAt": "2019-12-17T10:15:51Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "a3ac74a28e2417f9d08fe45375298db7bb7b3315",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "init",
      "headRefOid": "5eede135df0e4568fe3a63e02f5aeb78b86cc503",
      "closedAt": "2019-07-08T13:54:59Z",
      "mergedAt": "2019-07-08T13:54:59Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "a0f465ae7d3e692ec39ab7db7f7a52d70039f96d"
      },
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "This now has an OPEN ISSUE regarding the fact that we'll need to add PKE encryption for that message, as agreed out of band, let's merge this and add encryption in the next iteration.",
          "createdAt": "2019-07-08T13:55:04Z",
          "updatedAt": "2019-07-08T13:55:04Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NjM2Njgy",
          "commit": {
            "abbreviatedOid": "7a83868"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-07T17:54:32Z",
          "updatedAt": "2019-07-07T18:01:26Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Haven't we renamed `UserInitKey` to `ClientInitKey` recently?",
              "createdAt": "2019-07-07T17:54:33Z",
              "updatedAt": "2019-07-08T13:49:22Z"
            },
            {
              "originalPosition": 20,
              "body": "If we were to allow a warmed-up tree, we would have to replace `path` with a list of public keys, but I think we should do this in future version.",
              "createdAt": "2019-07-07T17:57:46Z",
              "updatedAt": "2019-07-08T13:49:22Z"
            },
            {
              "originalPosition": 45,
              "body": "It's not clear to me how the members learn about the path secrets. The creator would have to KEm secrets to each leaf node individually I suppose.",
              "createdAt": "2019-07-07T18:01:18Z",
              "updatedAt": "2019-07-08T13:49:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NjQ0MTIy",
          "commit": {
            "abbreviatedOid": "7a83868"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-07T21:33:49Z",
          "updatedAt": "2019-07-07T21:33:50Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Yes, we have.  And in general, this needed a merge from master, which I have done.",
              "createdAt": "2019-07-07T21:33:50Z",
              "updatedAt": "2019-07-08T13:49:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NjQ0NTYw",
          "commit": {
            "abbreviatedOid": "7a83868"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-07T21:45:14Z",
          "updatedAt": "2019-07-07T21:45:15Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "You would actually want a giant vector of `DirectPathNode` values, where each private key was encrypted to the `2^level` receipients below it.  But I agree we should punt this to a future version.",
              "createdAt": "2019-07-07T21:45:14Z",
              "updatedAt": "2019-07-08T13:49:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NjQ0Nzgw",
          "commit": {
            "abbreviatedOid": "7a83868"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-07T21:51:43Z",
          "updatedAt": "2019-07-07T21:51:43Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "The members get path secrets from the DirectPath, just like in an Update.  Note that the DirectPath `path` attribute here has linear size: Each path secret is encrypted directly to the leaves under it.  I've added a clarification.",
              "createdAt": "2019-07-07T21:51:43Z",
              "updatedAt": "2019-07-08T13:49:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NzQ1NjQ1",
          "commit": {
            "abbreviatedOid": "8721907"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "Similarly to the `Add` for a new member, this is a PKE operation: the encryption of this message is missing from the description. This message needs to be encrypted to each client otherwise it leaks all public keys of the tree which would otherwise be protected under the common framing.\r\n\r\nA secondary question appears as a consequence. There is static key reuse for the leaves until they update, we designed HPKE so that it should be fine but I would still add an [OPEN ISSUE] for it.",
          "createdAt": "2019-07-08T08:09:55Z",
          "updatedAt": "2019-07-08T08:32:14Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "nit. s/working back to/derive secrets up-to/ ?",
              "createdAt": "2019-07-08T08:09:55Z",
              "updatedAt": "2019-07-08T13:49:22Z"
            },
            {
              "originalPosition": 44,
              "body": "nit. `adequate` seems inadequate; replace by `field` ?",
              "createdAt": "2019-07-08T08:11:35Z",
              "updatedAt": "2019-07-08T13:49:22Z"
            },
            {
              "originalPosition": 20,
              "body": "I think the current scenario looks fine. In the scenario were we would break the secrecy invariant and allow warmup and pre-populating nodes, there is an performance optimization: we can just send the public and the secret part of the tree independently to avoid large numbers of PKE of a large payload. In that scenario I would suggest encrypting the pre-warmed public tree encrypted under a fresh AEAD key/nonce and PKE encrypt the key and the nonce to the recipient along with the new path secret of its parent.",
              "createdAt": "2019-07-08T08:21:31Z",
              "updatedAt": "2019-07-08T13:49:22Z"
            }
          ]
        }
      ]
    },
    {
      "number": 172,
      "id": "MDExOlB1bGxSZXF1ZXN0MjgyMDgyNjQ3",
      "title": "DirectPathNode contains encrypted node secrets, not path secrets",
      "url": "https://github.com/mlswg/mls-protocol/pull/172",
      "state": "CLOSED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The paragraph below the changed field refers to `node_secrets`, not `encrypted_path_secrets`.",
      "createdAt": "2019-05-24T16:30:36Z",
      "updatedAt": "2019-05-30T15:39:27Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "0d849622508cebd6d9c769dd0388fa17d15fd083",
      "headRepository": "rozbb/mls-protocol",
      "headRefName": "directpathnode-node-secrets",
      "headRefOid": "af21d6c81bf8f8ecd6ef61bcd6ae708e6d17f0be",
      "closedAt": "2019-05-30T15:39:27Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "This is incorrect.  The sender needs to transmit the path secret, so that the receivers can compute the hashes up the tree.  \r\n\r\nYou're correct that there's a mismatch between the struct definition and the prose below.  I've fixed this in #176.",
          "createdAt": "2019-05-30T15:39:27Z",
          "updatedAt": "2019-05-30T15:39:27Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 173,
      "id": "MDExOlB1bGxSZXF1ZXN0MjgyMDg0NDI2",
      "title": "Formatting: removed `\\_` where it was syntactically incorrect",
      "url": "https://github.com/mlswg/mls-protocol/pull/173",
      "state": "MERGED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "The underscore character does not have to be escaped in code environments. This applies to the inline (backticks) as well as block (tildes) variants.",
      "createdAt": "2019-05-24T16:36:59Z",
      "updatedAt": "2019-12-17T09:08:50Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "7602f683a6e9ba79cdb732814314a259d8738cb2",
      "headRepository": "rozbb/mls-protocol",
      "headRefName": "backslash-underscore",
      "headRefOid": "c12be2c8a3e2fe913f4a0e81854308aa86298852",
      "closedAt": "2019-05-30T15:32:14Z",
      "mergedAt": "2019-05-30T15:32:13Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "8c7cbca1e568b47394b1d89c73dbeaebe3f62afb"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 175,
      "id": "MDExOlB1bGxSZXF1ZXN0MjgzNzAxOTI5",
      "title": "Typo fix",
      "url": "https://github.com/mlswg/mls-protocol/pull/175",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Race condition between #166 and #170 ",
      "createdAt": "2019-05-30T15:33:07Z",
      "updatedAt": "2019-12-17T09:08:03Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "8c7cbca1e568b47394b1d89c73dbeaebe3f62afb",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "circular-confirmation",
      "headRefOid": "779adb41d09c2fe99c55b61483bd3b26aa58d184",
      "closedAt": "2019-05-30T15:33:23Z",
      "mergedAt": "2019-05-30T15:33:23Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "b7498970e5dc1a8b4eb1a3db8db699e4dd1f5698"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 176,
      "id": "MDExOlB1bGxSZXF1ZXN0MjgzNzAzODg1",
      "title": "Use correct field names",
      "url": "https://github.com/mlswg/mls-protocol/pull/176",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "@rozbb pointed out this disconnect in #172, but the fix needs to be the other way around.",
      "createdAt": "2019-05-30T15:38:31Z",
      "updatedAt": "2019-12-17T09:07:56Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "b7498970e5dc1a8b4eb1a3db8db699e4dd1f5698",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "path-secret-typo",
      "headRefOid": "facd7a383ec8952072d0ead3c30daae16824a4fe",
      "closedAt": "2019-05-30T15:38:44Z",
      "mergedAt": "2019-05-30T15:38:44Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "112b535e77f1122e434c2a49492393d15bf19aa8"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 178,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg2MzQyNDM5",
      "title": "Fix transcript so that new members get the right information",
      "url": "https://github.com/mlswg/mls-protocol/pull/178",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "bug",
        "security"
      ],
      "body": "While trying to implement #170 [in mlspp](https://github.com/cisco/mlspp/pull/48), I noticed that the confirmation and transcript hash calculations in draft-06 do not actually allow a new participant to join the transcript hash.  Since the `transcript_hash` value is sent, and not the `intermediate_hash` value, the new joiner is missing the auth data necessary to compute the next `transcript_hash` value.  \r\n\r\nTo fix this and clarify terminology, this PR makes the following changes:\r\n\r\n* `transcript_hash` becomes `confirmed_transcript_hash`, since this is what goes into the confirmation MAC\r\n* `intermediate_hash` becomes `interim_transcript_hash`\r\n* `WelcomeInfo` is updated to refer to the `interim_transcript_hash`\r\n",
      "createdAt": "2019-06-07T21:44:10Z",
      "updatedAt": "2019-12-17T09:07:42Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "112b535e77f1122e434c2a49492393d15bf19aa8",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "transcript-fix",
      "headRefOid": "c77e0755b0fcdfc582d7ec58845032a39250ad96",
      "closedAt": "2019-07-08T14:20:28Z",
      "mergedAt": "2019-07-08T14:20:28Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "00b0b55a4c52953640ff13125c4e6f19fa4c5b79"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4OTM1Mzk1",
          "commit": {
            "abbreviatedOid": "c77e075"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "This looks ok. If we want, merging `Welcome` and `Add` messages like in the TreeKEM paper would probably avoid some pain here. Merging.",
          "createdAt": "2019-07-08T14:20:14Z",
          "updatedAt": "2019-07-08T14:20:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 179,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg2MzQ0Mzcy",
      "title": "Add Beurdouche as a co-author",
      "url": "https://github.com/mlswg/mls-protocol/pull/179",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "@beurdouche has been doing a lot of work, and I just noticed he's not on the list of co-authors.  In addition to recognizing his contribution, this will enable him to push new Internet-Draft versions.",
      "createdAt": "2019-06-07T21:53:29Z",
      "updatedAt": "2019-12-17T09:06:43Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "112b535e77f1122e434c2a49492393d15bf19aa8",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "add-beurdouche",
      "headRefOid": "af877ca3eb8c50a1bbfe6095756d7186aa5e221c",
      "closedAt": "2019-06-07T23:24:34Z",
      "mergedAt": "2019-06-07T23:24:34Z",
      "mergedBy": "jmillican",
      "mergeCommit": {
        "oid": "a3ac74a28e2417f9d08fe45375298db7bb7b3315"
      },
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "\ud83d\udc4d",
          "createdAt": "2019-06-07T23:14:31Z",
          "updatedAt": "2019-06-07T23:14:31Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ3MzM2NzI4",
          "commit": {
            "abbreviatedOid": "af877ca"
          },
          "author": "jmillican",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Absolutely, Beurdouche should definitely be in the co-authors list.",
          "createdAt": "2019-06-07T23:12:25Z",
          "updatedAt": "2019-06-07T23:12:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 183,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkyMDY0ODQx",
      "title": "Multiple clarifications around Framing",
      "url": "https://github.com/mlswg/mls-protocol/pull/183",
      "state": "MERGED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2019-06-26T16:18:07Z",
      "updatedAt": "2019-12-17T09:06:22Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "a3ac74a28e2417f9d08fe45375298db7bb7b3315",
      "headRepository": "rozbb/mls-protocol",
      "headRefName": "mlsplaintext-signature",
      "headRefOid": "edd48b4d01c2ca99c9f8cbc2c263699311ddb3f0",
      "closedAt": "2019-07-01T22:14:28Z",
      "mergedAt": "2019-07-01T22:14:28Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "74987e2b70e3bc5c2e02b0092d5bbb21cb7ae1eb"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU2NTcyODM1",
          "commit": {
            "abbreviatedOid": "3390169"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-01T21:34:17Z",
          "updatedAt": "2019-07-01T21:34:52Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Nit: Spaces around the `-` characters",
              "createdAt": "2019-07-01T21:34:17Z",
              "updatedAt": "2019-07-01T21:53:13Z"
            }
          ]
        }
      ]
    },
    {
      "number": 184,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkyMDcyMzQw",
      "title": "Clarify how HPKE ciphertexts are computed",
      "url": "https://github.com/mlswg/mls-protocol/pull/184",
      "state": "MERGED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2019-06-26T16:39:53Z",
      "updatedAt": "2019-12-17T09:06:15Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "a3ac74a28e2417f9d08fe45375298db7bb7b3315",
      "headRepository": "rozbb/mls-protocol",
      "headRefName": "hpke-encrypt",
      "headRefOid": "f18d0d28f87af9998e74659172e4b658596e35ff",
      "closedAt": "2019-07-01T22:14:12Z",
      "mergedAt": "2019-07-01T22:14:12Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "12b572eb379a571ff7830337201e3549f7912989"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU2NTcxNDY1",
          "commit": {
            "abbreviatedOid": "a501c5f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-07-01T21:30:31Z",
          "updatedAt": "2019-07-01T21:31:00Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "This should be `ephemeral_key, context`.  The lack of the `ephemeral_key` output is a bug in the current spec, and will be fixed in the [upcoming version](https://github.com/cfrg/draft-irtf-cfrg-hpke/blame/master/draft-irtf-cfrg-hpke.md#L323).",
              "createdAt": "2019-07-01T21:30:31Z",
              "updatedAt": "2019-07-01T21:55:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU2NTg2MTYy",
          "commit": {
            "abbreviatedOid": "f18d0d2"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-01T22:14:06Z",
          "updatedAt": "2019-07-01T22:14:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 186,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk1MzQ4NTg1",
      "title": "Enable new joiners to decrypt an encrypted Add message",
      "url": "https://github.com/mlswg/mls-protocol/pull/186",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "bug",
        "functionality",
        "security"
      ],
      "body": "Prior drafts enabled encryption of handshake messages, via the common framing structure.  This had the unfortunate effect of making it impossible to add new members!  If an Add is sent encrypted, then the new joiner had no way to get the key to decrypt it.\r\n\r\nThis PR adds the key and nonce for the Add encryption to the corresponding WelcomeInfo structure.  This maintains the confidentiality of the Add because the WelcomeInfo is encrypted to the new joiner, while providing the new joiner the key material it needs to decrypt the Add.",
      "createdAt": "2019-07-08T13:59:06Z",
      "updatedAt": "2019-12-17T09:06:07Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "a0f465ae7d3e692ec39ab7db7f7a52d70039f96d",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "add-decrypt-fix",
      "headRefOid": "60c7dcc4c1589cfc7627e1b9419b537cf67b0e68",
      "closedAt": "2019-07-08T14:03:35Z",
      "mergedAt": "2019-07-08T14:03:35Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "3ffeab09b5b78142c5093899e21571fc5c98a410"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4OTIzNTI1",
          "commit": {
            "abbreviatedOid": "60c7dcc"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "I think we'll need to carefully study the impact of this one but this seems fine for now.\r\nIn the future aligning the way we do `Init` and `Add` (for the new member) which both are PKE operations will probably allow us to merge `Welcome` and `Add` and remove that issue all together.",
          "createdAt": "2019-07-08T14:03:06Z",
          "updatedAt": "2019-07-08T14:03:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 187,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk1MzYyMTUy",
      "title": "Simplify AS tree/ratchet computations",
      "url": "https://github.com/mlswg/mls-protocol/pull/187",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial",
        "security"
      ],
      "body": "This PR implements a collection of comments on #146.  It aims to achieve the goal stated by @psyoptix of having every derivation have a different relationship, but with a simpler construction.",
      "createdAt": "2019-07-08T14:29:43Z",
      "updatedAt": "2019-12-17T09:05:41Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "00b0b55a4c52953640ff13125c4e6f19fa4c5b79",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "app-key-simplify",
      "headRefOid": "c3e5b8289a18175481905ce6025c2cdc7b74f83d",
      "closedAt": "2019-07-08T16:42:55Z",
      "mergedAt": "2019-07-08T16:42:55Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "6461f45e0db6a1d6719cfeebffce9005d6766200"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4OTQ1NjAw",
          "commit": {
            "abbreviatedOid": "e546ea8"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-07-08T14:34:43Z",
          "updatedAt": "2019-07-08T14:40:57Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "This is undefined.",
              "createdAt": "2019-07-08T14:34:43Z",
              "updatedAt": "2019-07-08T16:28:37Z"
            },
            {
              "originalPosition": 27,
              "body": "`V` is just horrible, can you just call it `n`,`ni` or `i` for node, node index or index instead ?",
              "createdAt": "2019-07-08T14:36:44Z",
              "updatedAt": "2019-07-08T16:28:37Z"
            },
            {
              "originalPosition": 36,
              "body": "This is useless, it is described just above.",
              "createdAt": "2019-07-08T14:37:20Z",
              "updatedAt": "2019-07-08T16:28:37Z"
            },
            {
              "originalPosition": 113,
              "body": "Useless",
              "createdAt": "2019-07-08T14:37:54Z",
              "updatedAt": "2019-07-08T16:28:37Z"
            },
            {
              "originalPosition": 141,
              "body": "This is not an App-Secret derivation here, I would prefer to stick to a standard HKDF-Expand-Label for these.",
              "createdAt": "2019-07-08T14:38:56Z",
              "updatedAt": "2019-07-08T16:28:37Z"
            },
            {
              "originalPosition": 174,
              "body": "If KD2 and ND2 are on the diagram, I would prefer D3 to be there as well. The reader should see those as derived at the same time by consuming D2.",
              "createdAt": "2019-07-08T14:40:43Z",
              "updatedAt": "2019-07-08T16:28:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4OTUwNjI0",
          "commit": {
            "abbreviatedOid": "e546ea8"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T14:42:04Z",
          "updatedAt": "2019-07-08T14:42:04Z",
          "comments": [
            {
              "originalPosition": 141,
              "body": "But I agree that it make sense for the app-secret to app-secret derivation below. ",
              "createdAt": "2019-07-08T14:42:04Z",
              "updatedAt": "2019-07-08T16:28:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MDA0OTA3",
          "commit": {
            "abbreviatedOid": "e546ea8"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T16:02:19Z",
          "updatedAt": "2019-07-08T16:02:19Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Having it called out as an equation, in the notation used below, is useful.",
              "createdAt": "2019-07-08T16:02:19Z",
              "updatedAt": "2019-07-08T16:28:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MDA1MjI1",
          "commit": {
            "abbreviatedOid": "e546ea8"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T16:02:54Z",
          "updatedAt": "2019-07-08T16:02:55Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "As above, disagree :)",
              "createdAt": "2019-07-08T16:02:55Z",
              "updatedAt": "2019-07-08T16:28:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MDA1NzQ1",
          "commit": {
            "abbreviatedOid": "e546ea8"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T16:03:49Z",
          "updatedAt": "2019-07-08T16:03:49Z",
          "comments": [
            {
              "originalPosition": 141,
              "body": "Do you think this is harmful, or just un-aesthetic?  The goal here is to preserve Jo\u00ebl's invariant that every derivation has different context.  ",
              "createdAt": "2019-07-08T16:03:49Z",
              "updatedAt": "2019-07-08T16:28:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MDA2Njcz",
          "commit": {
            "abbreviatedOid": "e546ea8"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T16:05:19Z",
          "updatedAt": "2019-07-08T16:05:20Z",
          "comments": [
            {
              "originalPosition": 174,
              "body": "As I said in the discussion on #146, this doesn't follow.  Just because you've generated KD2 and ND2 doesn't mean you have to derive forward to D3.  That's only required when you consume one of KD2/ND2.",
              "createdAt": "2019-07-08T16:05:19Z",
              "updatedAt": "2019-07-08T16:28:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MDIwNTY2",
          "commit": {
            "abbreviatedOid": "c3e5b82"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Ok, I think this is good enough : )",
          "createdAt": "2019-07-08T16:30:53Z",
          "updatedAt": "2019-07-08T16:30:53Z",
          "comments": []
        }
      ]
    },
    {
      "number": 188,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk1MzcwMzMz",
      "title": "Add Jo\u00ebl Alwen as a contributor",
      "url": "https://github.com/mlswg/mls-protocol/pull/188",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2019-07-08T14:47:41Z",
      "updatedAt": "2019-12-17T09:04:20Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "00b0b55a4c52953640ff13125c4e6f19fa4c5b79",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_contributors_joel",
      "headRefOid": "ed59ca2ee6069d86b1fc9d593c9d684f73850b8c",
      "closedAt": "2019-07-08T14:47:48Z",
      "mergedAt": "2019-07-08T14:47:47Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "f391dd3cab275d6ef27b0650ae51fff9e84eba56"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 189,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk1NDMyMjU5",
      "title": "Minor editorial updates",
      "url": "https://github.com/mlswg/mls-protocol/pull/189",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Update change log for draft-07\r\nNo conflicting PRs so I did break many lines that were too long.\r\nFix a few minor editorial issues after merging the tree-based application key schedule.",
      "createdAt": "2019-07-08T17:38:33Z",
      "updatedAt": "2019-12-17T09:04:03Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "6461f45e0db6a1d6719cfeebffce9005d6766200",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_app_tree_editorial",
      "headRefOid": "41da6e386aa26175beda20893d48e6acbe18b2e3",
      "closedAt": "2019-07-08T18:40:09Z",
      "mergedAt": "2019-07-08T18:40:09Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "b5053f283705da4dd22d134d8e9eb78893160540"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MDU3MzYz",
          "commit": {
            "abbreviatedOid": "97c90d2"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T17:41:52Z",
          "updatedAt": "2019-07-08T17:52:53Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "Nit: You could probably move this up to the previous line.   Since there's not a blank line, it's not a new paragraph.",
              "createdAt": "2019-07-08T17:43:07Z",
              "updatedAt": "2019-07-08T18:39:35Z"
            },
            {
              "originalPosition": 201,
              "body": "It seems like this OPEN ISSUE is obsoleted by the new key schedule.",
              "createdAt": "2019-07-08T17:43:43Z",
              "updatedAt": "2019-07-08T18:39:35Z"
            },
            {
              "originalPosition": 201,
              "body": "Actually, I would just replace the whole discussion of application keys here with a forward reference to the application key schedule section.  All you need here is the stuff that's required to underestand the message framing, namely the idea of \"generations\".  So maybe just put a short summary, e.g.:\r\n\r\n> For application messages, a chain of keys is derived for each sender in a similar fashion. This allows forward secrecy at the level of application messages within and out of an epoch.  A step in this chain (the second subscript) is called a \"generation\". The details of application key derivation are described in {{message-protection}}.\r\n\r\nAnd delete the remainder of this section.",
              "createdAt": "2019-07-08T17:46:51Z",
              "updatedAt": "2019-07-08T18:39:35Z"
            },
            {
              "originalPosition": 556,
              "body": "Nit: `).` -> `.)`",
              "createdAt": "2019-07-08T17:51:09Z",
              "updatedAt": "2019-07-08T18:39:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MDgxMDc0",
          "commit": {
            "abbreviatedOid": "97c90d2"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T18:27:37Z",
          "updatedAt": "2019-07-08T18:27:38Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "Done",
              "createdAt": "2019-07-08T18:27:37Z",
              "updatedAt": "2019-07-08T18:39:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MDg3NDY0",
          "commit": {
            "abbreviatedOid": "41da6e3"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-08T18:40:03Z",
          "updatedAt": "2019-07-08T18:40:03Z",
          "comments": []
        }
      ]
    },
    {
      "number": 190,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk1NDY1MDc4",
      "title": "Add Michael Rosenberg to contributors",
      "url": "https://github.com/mlswg/mls-protocol/pull/190",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2019-07-08T19:24:40Z",
      "updatedAt": "2019-12-17T09:03:55Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "b5053f283705da4dd22d134d8e9eb78893160540",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "rozbb",
      "headRefOid": "f7d0e28fd2e527c856316c3f989d47268153a492",
      "closedAt": "2019-07-08T20:04:32Z",
      "mergedAt": "2019-07-08T20:04:32Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "1ada0d00ef3cc112406c6d5b1d5f9d24ca645670"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 191,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk1NDcyMDUz",
      "title": "Be clear about what HPKE algorithms to use",
      "url": "https://github.com/mlswg/mls-protocol/pull/191",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2019-07-08T19:48:04Z",
      "updatedAt": "2019-12-17T09:03:49Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "b5053f283705da4dd22d134d8e9eb78893160540",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "hpke-suites",
      "headRefOid": "9c77668541388ac11e48f0c62ea6989465eefd8b",
      "closedAt": "2019-07-08T20:05:18Z",
      "mergedAt": "2019-07-08T20:05:18Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "3fead6a16cc806916b2518c4190ef66cc2d25d69"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 192,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk5NDc3ODcy",
      "title": "Made it clear that Init messages MUST be sent unencrypted",
      "url": "https://github.com/mlswg/mls-protocol/pull/192",
      "state": "CLOSED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "It took me a few reads to gather that that was the purpose of Init messages. The OPEN ISSUE actually cleared it up for me.",
      "createdAt": "2019-07-19T20:33:58Z",
      "updatedAt": "2019-12-17T09:03:40Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "3fead6a16cc806916b2518c4190ef66cc2d25d69",
      "headRepository": "rozbb/mls-protocol",
      "headRefName": "init-necessity",
      "headRefOid": "e0e622ea86de27a5c2f3c94203c9d3313acf96d3",
      "closedAt": "2019-11-14T17:59:52Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Obsoleted by #239 ",
          "createdAt": "2019-11-14T17:59:52Z",
          "updatedAt": "2019-11-14T17:59:52Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc2NjQyMTk0",
          "commit": {
            "abbreviatedOid": "099ca26"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-19T15:34:11Z",
          "updatedAt": "2019-08-19T15:34:35Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Nit: \"When shared\" is unnecessary.  ",
              "createdAt": "2019-08-19T15:34:11Z",
              "updatedAt": "2019-08-19T16:37:54Z"
            }
          ]
        }
      ]
    },
    {
      "number": 193,
      "id": "MDExOlB1bGxSZXF1ZXN0MzAzOTQ1MDQ3",
      "title": "Fix formatting issues.",
      "url": "https://github.com/mlswg/mls-protocol/pull/193",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2019-08-02T22:13:54Z",
      "updatedAt": "2019-12-17T09:08:36Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "3fead6a16cc806916b2518c4190ef66cc2d25d69",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2019.7.0",
      "headRefOid": "679d0ccdcf214a44ac8690fc5ae71ac7c0a73a1d",
      "closedAt": "2019-08-19T15:30:50Z",
      "mergedAt": "2019-08-19T15:30:50Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "996280ee06a12ce7d51975bf929284cb59de7c3f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc2NjM5MzYw",
          "commit": {
            "abbreviatedOid": "679d0cc"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-19T15:29:35Z",
          "updatedAt": "2019-08-19T15:29:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 194,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA1Mjg1ODQz",
      "title": "Clarified and Changed WelcomeInfo Secrets",
      "url": "https://github.com/mlswg/mls-protocol/pull/194",
      "state": "CLOSED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-08-07T19:21:00Z",
      "updatedAt": "2019-11-14T17:59:34Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "3fead6a16cc806916b2518c4190ef66cc2d25d69",
      "headRepository": "rozbb/mls-protocol",
      "headRefName": "fresh-handshake-encryption",
      "headRefOid": "fc2379f180b1ee46f8159bee10b498ffcfc64d29",
      "closedAt": "2019-11-14T17:59:34Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The last commit above implements my proposal for using `handshake_secret` & `sender_key_secret` instead of `handshake_key` & `handshake_nonce` for the `WelcomeInfo`s preceding an encrypted `Add`.\r\n\r\nI implemented it on top of the wording changes because I think those are important regardless.\r\n\r\nFeel free to reject the last commit and just take the first two.",
          "createdAt": "2019-08-16T16:51:06Z",
          "updatedAt": "2019-08-16T16:51:06Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Obsoleted by #239 ",
          "createdAt": "2019-11-14T17:59:28Z",
          "updatedAt": "2019-11-14T17:59:28Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc2NjUyNjU5",
          "commit": {
            "abbreviatedOid": "09d6335"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-08-19T15:50:33Z",
          "updatedAt": "2019-08-19T16:00:58Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "I don't think the \"after\" here is right.  The `init_secret`, `handshake_secret`, and `sender_data_secret` are all derived before the Add/Welcome are constructed.  Then in the update to the next epoch, the Add message is included in the transcript (with the all-zero update secret), and now the new joiner is included.",
              "createdAt": "2019-08-19T15:50:34Z",
              "updatedAt": "2019-08-19T17:29:22Z"
            },
            {
              "originalPosition": 67,
              "body": "In ASCII art:\r\n\r\n```\r\n                 init_secret_[n-1]\r\n                       |\r\n                       V\r\nupdate_secret -> epoch_secret_[n]\r\n                       |\r\n                       +--> sender_data_secret <~~ provided in WelcomeInfo\r\n                       |\r\n                       +--> handshake_secret   <~~ provided in WelcomeInfo\r\n                       |\r\n                       +--> application_secret <~~ secret from new joiner\r\n                       |\r\n                       +--> confirmation_key   <~~ secret from new joiner\r\n                       |\r\n                       V\r\n                 init_secret_[n]               <~~ provided in WelcomeInfo\r\n                       |\r\n                       V\r\n            0 -> epoch_secret_[n]              <~~ new joiner can compute this\r\n```",
              "createdAt": "2019-08-19T15:59:17Z",
              "updatedAt": "2019-08-19T17:29:22Z"
            },
            {
              "originalPosition": 40,
              "body": "`sender_data_secret`",
              "createdAt": "2019-08-19T15:59:55Z",
              "updatedAt": "2019-08-19T17:29:22Z"
            },
            {
              "originalPosition": 41,
              "body": "\"Unframing\" isn't used elsewhere.  Maybe \"HandshakeEncryptionSecrets\"?",
              "createdAt": "2019-08-19T16:00:34Z",
              "updatedAt": "2019-08-19T17:29:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc2NjY4MzE4",
          "commit": {
            "abbreviatedOid": "09d6335"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-19T16:17:45Z",
          "updatedAt": "2019-08-19T16:17:45Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "Agreed, I think I worded this very poorly. If I changed _after_ to _before_ would that resolve this?",
              "createdAt": "2019-08-19T16:17:45Z",
              "updatedAt": "2019-08-19T17:29:22Z"
            }
          ]
        }
      ]
    },
    {
      "number": 195,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA1MzY1MjEy",
      "title": "Tightened up wording in AS tree deletion sched",
      "url": "https://github.com/mlswg/mls-protocol/pull/195",
      "state": "MERGED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2019-08-08T00:25:49Z",
      "updatedAt": "2019-12-17T09:02:24Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "3fead6a16cc806916b2518c4190ef66cc2d25d69",
      "headRepository": "rozbb/mls-protocol",
      "headRefName": "astree-style-fixes",
      "headRefOid": "f5ce6498803fcb88322707decfe838bc17618bbe",
      "closedAt": "2019-08-19T16:10:34Z",
      "mergedAt": "2019-08-19T16:10:34Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "4e60ddcd16df6ed524f64bf701fc4126594e4157"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc2NjY0MTQ1",
          "commit": {
            "abbreviatedOid": "f5ce649"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-19T16:10:09Z",
          "updatedAt": "2019-08-19T16:10:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 196,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA1NjYzMTA4",
      "title": "Cleaned up beginning of Cryptographic Objects section",
      "url": "https://github.com/mlswg/mls-protocol/pull/196",
      "state": "MERGED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "One of the issues was that the ciphersuites were subsubsections in a section, so it got rendered as\r\n```\r\n6.1) Curve25519, SHA-256, and AES-128-GCM\r\n  6.1.1) P-256, SHA-256, and AES-128-GCM\r\n```\r\nwhich is odd.\r\n\r\nAlso, previously, the beginning of the Cryptographic Objects section talked about ciphersuites and public keys. I moved their descriptions to where they are more relevant.\r\n\r\nFinally, I replaced \"cipher suite\" with \"ciphersuite\", since the latter had 25 occurrences while the former had 2.",
      "createdAt": "2019-08-08T16:48:26Z",
      "updatedAt": "2019-12-17T09:02:03Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "f7142b7c206fca6217ac87aeae76c9ea2db67c06",
      "headRepository": "rozbb/mls-protocol",
      "headRefName": "cleanup-crypto-objects",
      "headRefOid": "cf5b19766eaf75678010de52dac80b5d1ddcb0e8",
      "closedAt": "2019-09-19T14:05:41Z",
      "mergedAt": "2019-09-19T14:05:41Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "1a201118d76925dcc1e9b31138299798d71cc90f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc2NjY2NzYy",
          "commit": {
            "abbreviatedOid": "6ef4669"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-08-19T16:14:50Z",
          "updatedAt": "2019-08-19T16:50:23Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "We still need this definition. Maybe put it under the `CipherSuite` enum, as with `SignaturePublicKey` and the `SignatureScheme` enum.",
              "createdAt": "2019-08-19T16:14:50Z",
              "updatedAt": "2019-09-19T14:04:25Z"
            },
            {
              "originalPosition": 17,
              "body": "Also, some descriptive text like you added for `SignaturePublicKey` would be helpful.",
              "createdAt": "2019-08-19T16:15:22Z",
              "updatedAt": "2019-09-19T14:04:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkwNTkwOTQ2",
          "commit": {
            "abbreviatedOid": "2af5a2a"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-09-19T14:03:44Z",
          "updatedAt": "2019-09-19T14:03:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 197,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA2MjY0Mjk2",
      "title": "Minor edit",
      "url": "https://github.com/mlswg/mls-protocol/pull/197",
      "state": "MERGED",
      "author": "seanieb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "The operations in the lifecycle of a group has been reduced to three.",
      "createdAt": "2019-08-11T08:08:39Z",
      "updatedAt": "2019-12-17T09:01:47Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "3fead6a16cc806916b2518c4190ef66cc2d25d69",
      "headRepository": "seanieb/mls-protocol",
      "headRefName": "patch-1",
      "headRefOid": "9743c0e671eb1c18894703f18aff1e44d9ce5b94",
      "closedAt": "2019-08-13T13:10:54Z",
      "mergedAt": "2019-08-13T13:10:54Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "483c2b2d87c4e2911a7428ea38d04bae938258dc"
      },
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Thank you !",
          "createdAt": "2019-08-13T13:10:48Z",
          "updatedAt": "2019-08-13T13:10:48Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 198,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA2ODk5NDc1",
      "title": "Initial design for the key schedule Exporter",
      "url": "https://github.com/mlswg/mls-protocol/pull/198",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "functionality",
        "security"
      ],
      "body": "",
      "createdAt": "2019-08-13T13:10:05Z",
      "updatedAt": "2019-12-20T21:58:45Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "3eee58aa2ba2896a0f28fb9e1c6df16245b6fee7",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_exporter",
      "headRefOid": "d7e67c208d70a846b3aa32bd70596bec3c990049",
      "closedAt": "2019-12-10T20:50:14Z",
      "mergedAt": "2019-12-10T20:50:14Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "d1c8986d3ef932ae4a7cc05b4172d2762428fcd0"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Note: There's a consistency issue around Derive-Secret, for which I filed #264 for follow-up.",
          "createdAt": "2019-12-10T20:49:52Z",
          "updatedAt": "2019-12-10T20:49:52Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc2Njg4MDIx",
          "commit": {
            "abbreviatedOid": "6b4e77a"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-19T16:55:02Z",
          "updatedAt": "2019-08-19T17:02:29Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "It seems like if the application wants to get the full FS / PCS benefits, they need to refresh every time the epoch changes.  Is there a reason you're limiting things here?\r\n\r\nAlso, a nit: \"Add\" and \"Remove\" have only one capital letter.",
              "createdAt": "2019-08-19T16:55:02Z",
              "updatedAt": "2019-12-10T16:58:38Z"
            },
            {
              "originalPosition": 22,
              "body": "This is different from the [TLS construction](https://tools.ietf.org/html/rfc8446#section-7.5)\r\n\r\n```\r\n   TLS-Exporter(label, context_value, key_length) =\r\n       HKDF-Expand-Label(Derive-Secret(Secret, label, \"\"),\r\n                         \"exporter\", Hash(context_value), key_length)\r\n```\r\n\r\nNotice that the \"Derive-Secret\" is missing from the construction in the PR.  What's the reasoning here?",
              "createdAt": "2019-08-19T17:00:12Z",
              "updatedAt": "2019-12-10T16:58:38Z"
            },
            {
              "originalPosition": 22,
              "body": "In a similar vein, it might be useful to say something about labels, as the [TLS exporter RFC does](https://tools.ietf.org/html/rfc5705#section-4).  For example, do we want to have a registry?",
              "createdAt": "2019-08-19T17:02:00Z",
              "updatedAt": "2019-12-10T16:58:38Z"
            },
            {
              "originalPosition": 39,
              "body": "Nit: Extra blank line.",
              "createdAt": "2019-08-19T17:02:14Z",
              "updatedAt": "2019-12-10T16:58:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE4NTY1NDYw",
          "commit": {
            "abbreviatedOid": "f01c1cd"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-18T19:14:08Z",
          "updatedAt": "2019-11-18T19:14:08Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "Fixed",
              "createdAt": "2019-11-18T19:14:08Z",
              "updatedAt": "2019-12-10T16:58:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE4NTY1NzA1",
          "commit": {
            "abbreviatedOid": "f01c1cd"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-18T19:14:28Z",
          "updatedAt": "2019-11-18T19:14:28Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "Fixed",
              "createdAt": "2019-11-18T19:14:28Z",
              "updatedAt": "2019-12-10T16:58:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE4NTY3MTE5",
          "commit": {
            "abbreviatedOid": "f01c1cd"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-18T19:16:47Z",
          "updatedAt": "2019-11-18T19:16:47Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Fix pending... Any intuition about the registry story ?",
              "createdAt": "2019-11-18T19:16:47Z",
              "updatedAt": "2019-12-10T16:58:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI5OTgzMTY1",
          "commit": {
            "abbreviatedOid": "d06d021"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-10T16:43:41Z",
          "updatedAt": "2019-12-10T16:43:42Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Nit: \"functionalities\"",
              "createdAt": "2019-12-10T16:43:42Z",
              "updatedAt": "2019-12-10T16:58:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMwMTM1MjI1",
          "commit": {
            "abbreviatedOid": "d7e67c2"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-12-10T20:50:08Z",
          "updatedAt": "2019-12-10T20:50:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 200,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA4NzQwODQ0",
      "title": "Non-destructive add",
      "url": "https://github.com/mlswg/mls-protocol/pull/200",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "functionality",
        "performance",
        "security"
      ],
      "body": "This PR attempts to implement the \"non-destructive add\" proposal discussed at IETF 105.  Instead of blanking nodes on add, we keep track of \"unmerged leaves\" below each intermediate node.  This involves a bit more complexity in the tree state that is passed around, but avoids unnecessary blank nodes.",
      "createdAt": "2019-08-19T19:01:28Z",
      "updatedAt": "2019-12-17T09:00:41Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "41a2389abf922fe0c3dbcc1ec67e2ddbd7416ec2",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "non-destructive-add",
      "headRefOid": "064353ecff9d84b719a1333d53e785c2593642c5",
      "closedAt": "2019-11-14T17:22:49Z",
      "mergedAt": "2019-11-14T17:22:49Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "d7ca4817c58cf48fd1ddc23dea5be4b5e89595fa"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "As discussed in the interim: Remove processing should be updated such that for each node in the removed node's direct path:\r\n\r\n* If the removed leaf is in `unmerged_leaves` for the node, then just remove it from that list\r\n* Otherwise, blank the node",
          "createdAt": "2019-10-01T21:55:22Z",
          "updatedAt": "2019-10-01T21:55:22Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE2NjgxNzI2",
          "commit": {
            "abbreviatedOid": "e6585cf"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-11-14T02:36:01Z",
          "updatedAt": "2019-11-14T03:00:37Z",
          "comments": [
            {
              "originalPosition": 135,
              "body": "\"if a node\"",
              "createdAt": "2019-11-14T02:36:01Z",
              "updatedAt": "2019-11-14T16:17:11Z"
            },
            {
              "originalPosition": 140,
              "body": "Less confusing: \"A member may not know the private keys of all the intermediate nodes that they're below. Such a member has an _unmerged_ leaf. Encrypting to an intermediate node requires encrypting to the node's public key, as well as the public keys of all the unmerged leaves below it. A leaf is unmerged when...\"",
              "createdAt": "2019-11-14T02:54:06Z",
              "updatedAt": "2019-11-14T16:17:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3MTI4MjQ1",
          "commit": {
            "abbreviatedOid": "064353e"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-14T17:22:43Z",
          "updatedAt": "2019-11-14T17:22:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 201,
      "id": "MDExOlB1bGxSZXF1ZXN0MzEwNTQ1MjA5",
      "title": "Define enum values for ProtocolVersion.",
      "url": "https://github.com/mlswg/mls-protocol/pull/201",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2019-08-23T21:51:50Z",
      "updatedAt": "2019-12-17T09:00:21Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "4e60ddcd16df6ed524f64bf701fc4126594e4157",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2019.8.0",
      "headRefOid": "cbcaf629136d5a5f5b0a36735cbf9c278621e6ef",
      "closedAt": "2019-09-09T21:40:27Z",
      "mergedAt": "2019-09-09T21:40:27Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "b8eed965739bae912b971e6156a377656f1884c0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg1ODAwNDIw",
          "commit": {
            "abbreviatedOid": "cbcaf62"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-09-09T21:40:09Z",
          "updatedAt": "2019-09-09T21:40:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 203,
      "id": "MDExOlB1bGxSZXF1ZXN0MzEyODA4Nzk5",
      "title": "HPKECiphertext takes generic KEM output, not a public key.",
      "url": "https://github.com/mlswg/mls-protocol/pull/203",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Currently you assume that the KEM's output is an ephemeral public key, but that's only true for Diffie-Hellman-type constructions.",
      "createdAt": "2019-08-30T16:31:33Z",
      "updatedAt": "2019-12-17T08:59:49Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "b8eed965739bae912b971e6156a377656f1884c0",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2019.8.1",
      "headRefOid": "f7814c1c8673c75028c2465658a53d7227813f3d",
      "closedAt": "2019-09-19T13:57:41Z",
      "mergedAt": "2019-09-19T13:57:40Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "e3c6e466c17ea3ca41e2be3551ad432775b3b23e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkwNTg2MTk5",
          "commit": {
            "abbreviatedOid": "f7814c1"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-09-19T13:57:29Z",
          "updatedAt": "2019-09-19T13:57:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 204,
      "id": "MDExOlB1bGxSZXF1ZXN0MzEyODE2MTg2",
      "title": "Update ClientInitKey to contain only one ciphersuite.",
      "url": "https://github.com/mlswg/mls-protocol/pull/204",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement"
      ],
      "body": "",
      "createdAt": "2019-08-30T16:57:33Z",
      "updatedAt": "2019-12-17T08:55:47Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "b8eed965739bae912b971e6156a377656f1884c0",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2019.8.2",
      "headRefOid": "a8dc485abcf7cd5b9b8ac2da5d36e097bea1d56e",
      "closedAt": "2019-09-19T13:59:26Z",
      "mergedAt": "2019-09-19T13:59:26Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "f7142b7c206fca6217ac87aeae76c9ea2db67c06"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg1Nzk3NDQ5",
          "commit": {
            "abbreviatedOid": "43c21b7"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks for this proposal, @Bren2010.  I agree it's a useful simplification.  I've suggested a couple of minor changes.",
          "createdAt": "2019-09-09T21:33:23Z",
          "updatedAt": "2019-09-09T21:39:15Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Please don't re-wrap text that hasn't been modified.  It makes the history unnecessarily complicated.",
              "createdAt": "2019-09-09T21:33:23Z",
              "updatedAt": "2019-09-11T16:59:55Z"
            },
            {
              "originalPosition": 59,
              "body": "Please move this to the first slot in the struct.  That way we can have a very simple protocol invariant -- the first two octets of the InitKey tell you the format of the rest.  (We should write down these invariants, but that's for a different PR.)",
              "createdAt": "2019-09-09T21:37:22Z",
              "updatedAt": "2019-09-11T16:59:55Z"
            },
            {
              "originalPosition": 70,
              "body": "Maybe say \"one or more ClientInitKeys\"",
              "createdAt": "2019-09-09T21:38:03Z",
              "updatedAt": "2019-09-11T16:59:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg2OTMzMTMx",
          "commit": {
            "abbreviatedOid": "43c21b7"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-11T16:54:21Z",
          "updatedAt": "2019-09-11T16:54:21Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "Protocol version is only one octet, is there something else you want here?",
              "createdAt": "2019-09-11T16:54:21Z",
              "updatedAt": "2019-09-11T16:59:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkwNTg3MTQz",
          "commit": {
            "abbreviatedOid": "a8dc485"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-09-19T13:58:44Z",
          "updatedAt": "2019-09-19T13:59:19Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "Misstatement on my part, sorry.",
              "createdAt": "2019-09-19T13:58:44Z",
              "updatedAt": "2019-09-19T13:59:19Z"
            }
          ]
        }
      ]
    },
    {
      "number": 208,
      "id": "MDExOlB1bGxSZXF1ZXN0MzE3ODk5MjM4",
      "title": "Add authenticated_data to the mls message.",
      "url": "https://github.com/mlswg/mls-protocol/pull/208",
      "state": "MERGED",
      "author": "psla",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "functionality",
        "privacy"
      ],
      "body": "[As previously discussed](https://mailarchive.ietf.org/arch/msg/mls/jB5ygAJs3P8TLkduj6Q9vFWmSJI), this is a proposal to add AAD to the application messages.\r\n\r\nThere are many motivations to do this:\r\n\u2022 It's a 'cheap' feature to add (although it could potentially be misused)\r\n\u2022 It avoids duplicate content: if there is a content that needs to be authenticated, but also needs to be visible to the server, the only solution today is to repeat it in the header (to the server) and then in the encrypted body.\r\n\u2022 Modern ciphers already provide support for AAD, and MLS takes advantage of this. In fact most(all?) of the fields in the header are authenticated already.\r\n\u2022 This field is optional(as in: can be empty), which means that it doesn't have to be used in the implementation.\r\n\r\nThe primary benefit is for the server to have access to the fields that are otherwise authenticated, but are not part of MLS message. Typically, the server has another encryption mechanism with the client (e.g. TLS) and as such client-server communication is already secure. As a matter of fact, handshake messages can already be transported in plaintext (in case server needs to examine their content), but application messages are not allowed to have any plaintext content, even though server may need to examine some metadata as well.\r\n\r\nA couple of thoughts that may be worth discussing: \r\n* what should be the max size of authenticated_data (I assumed 32KB, just like application message)\r\n* whether *authenticated data* should be offered only as part of *application*, or both *handshake message* and *application message*. It is fair to consider it only for an *application message*, though for simplicity I added it to both message types. Happy to change it based on general preferences.",
      "createdAt": "2019-09-16T14:08:37Z",
      "updatedAt": "2019-12-17T08:57:09Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "d8672cf6e78d781a5ff6f9e238ee6b0db3b3f026",
      "headRepository": "psla/mls-protocol",
      "headRefName": "aead",
      "headRefOid": "06c0317832918f15e7ccab3a9e0b5c8a992441fb",
      "closedAt": "2019-10-11T22:49:04Z",
      "mergedAt": "2019-10-11T22:49:04Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "968cdceceb7fa389e092c111ebd29d5600b0b68c"
      },
      "comments": [
        {
          "author": "eomara",
          "authorAssociation": "COLLABORATOR",
          "body": "@bifurcation per our discussion in London, we agreed to accept this change. you mentioned other places need to be updated,  which one? ",
          "createdAt": "2019-10-09T03:24:22Z",
          "updatedAt": "2019-10-09T03:24:22Z"
        },
        {
          "author": "psla",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> this AAD field is AEAD authenticated but does not seem covered by the signature, while probably should.\r\nI don't quite understand how to address this comment. I believe I added it to the signature, maybe I missed something\r\n\r\n> ** Sign the plaintext metadata -- the group ID, epoch, sender index, and  content type **as well as the authenticated data** and message content\r\n\r\nCan you clarify which part is missing the AAD?",
          "createdAt": "2019-10-09T15:42:28Z",
          "updatedAt": "2019-10-09T15:42:28Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@beurdouche i think you're wrong here.  In {{content-signing-and-encryption}}, we have the following:\r\n\r\n>  The signature covers the plaintext metadata and message content, i.e., all fields of MLSPlaintext except for the signature field.\r\n\r\nI think this is ready to go as soon as @psla fixes the two minor comments we have (order of fields and `[]` vs `<>` notation).",
          "createdAt": "2019-10-10T13:55:35Z",
          "updatedAt": "2019-10-10T13:55:35Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Note that in general, the `MLSCiphertextSenderDataAAD` and `MLSCiphertextContentAAD` are the prefix of their ciphertext which means you have to put the new `authenticated_data` field you added at the correct position in both of those too... : )",
          "createdAt": "2019-10-11T15:40:07Z",
          "updatedAt": "2019-10-11T15:40:39Z"
        },
        {
          "author": "psla",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Are you saying that `MLSCiphertextSenderDataAAD` needs it as well? That would lead to two AAD blobs, right? One of which would be encrypted? (I am a bit fuzzy about the relation between `MLSCiphertextContentAAD` and encrypted_sender_data (which is encrypted `MLSCiphertextSenderDataAAD`, right?)\r\n\r\nI added it there, but I don't fully understand it. Please take another look.",
          "createdAt": "2019-10-11T18:22:53Z",
          "updatedAt": "2019-10-11T18:22:53Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@beurdouche  - I agree with @psla that it doesn't seem necessary to include the `authenticated_data` in the `MLSCiphertextSenderDataAAD`.  Do you have a specific issue in mind?",
          "createdAt": "2019-10-11T19:19:43Z",
          "updatedAt": "2019-10-11T19:19:43Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Ok, I am quite exhausted this week, so my clarity is low sorry\u2026\r\nI think I confused the positionning of the new field in the MLSPlaintext vs the MLSCiphertext\r\n\r\nIt all depends where you place the new field in the MLSCiphertext, right ?!\r\nIn the current design for the AEADs is that the thing you authenticate is the prefix of\r\nthe ciphertext you are decrypting...\r\n\r\nSo if the new field is just after the content type in the MLSCiphertext\r\nit is part of the prefix of the encrypted sender data and has to be included in the SenderDataAAD but it is also in the prefix of the content so it has to also be in the ContentAAD.\r\n\r\nIf the new field is placed between the encrypted SenderData and the encrypted Content\r\nit is just a prefix of the second one and should appear only in the ContentAAD.\r\n\r\nDo I make sense ? :)\r\nB.",
          "createdAt": "2019-10-11T19:49:13Z",
          "updatedAt": "2019-10-11T19:50:46Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "If we espouse that theory (not clear that it necessarily holds, but let's go with it for now), the question is where you draw the line between metadata and content.  Compare the current state with two cases (a) and (b):\r\n\r\n```\r\nNOW              A.               B.\r\n\r\ngroup_id         group_id         group_id\r\nepoch            epoch            epoch\r\nsender           sender           sender\r\ncontent_type     content_type     content_type\r\n============     ============     aad\r\ncontent          aad              ============\r\nsignature        content          content\r\n                 signature        signature\r\n```\r\n\r\nBasically, the `=====` turns into the sender_data in the MLSCiphertext.  In case (B), you would want the AAD in the `SenderDataAAD`; in case (A) you would not.  I don't really see a reason why we need to assume case (B), so since case (A) is a bit simpler, I'm inclined to go that way.  Simpler in the sense that the AAD is used as AAD exactly once, together with the protected content.",
          "createdAt": "2019-10-11T20:13:04Z",
          "updatedAt": "2019-10-11T20:13:04Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Those were my proposals\u2026\r\nMy preference goes to Fig 8 but I don\u2019t have a strong opinion.\r\n<img width=\"640\" alt=\"New field\" src=\"https://user-images.githubusercontent.com/1193431/66683688-5eaae700-ec78-11e9-8af4-ff7f59a761d5.png\">\r\n\r\n",
          "createdAt": "2019-10-11T20:41:30Z",
          "updatedAt": "2019-10-11T20:42:17Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, even better illustration than mine!  OK, when you put it that way, I can see the appeal of including the AAD in the sender data.  Though I admit this is mostly an aesthetic point, not one that I have any security analysis to back up.\r\n\r\n@psla would you mind moving the AAD to above the `sender_data_nonce` in all cases?  Then I think this is ready to merge.",
          "createdAt": "2019-10-11T20:57:53Z",
          "updatedAt": "2019-10-11T20:57:53Z"
        },
        {
          "author": "psla",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It makes sense to me too now. Thanks. I think I addressed it.",
          "createdAt": "2019-10-11T22:05:49Z",
          "updatedAt": "2019-10-11T22:05:49Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk0ODM2MDAx",
          "commit": {
            "abbreviatedOid": "eda3fb3"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-30T09:00:12Z",
          "updatedAt": "2019-09-30T09:00:17Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Nit: I would put this just below the content_type field, just to preserve parallelism (`MLSCiphertext.ciphertext -> MLSPlaintext.operation/application_data`)",
              "createdAt": "2019-09-30T09:00:13Z",
              "updatedAt": "2019-10-11T22:05:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk5MjE4Nzk0",
          "commit": {
            "abbreviatedOid": "eda3fb3"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "Two big caveats:\r\n- this AAD field is AEAD authenticated but does not seem covered by the signature, while probably should.\r\n- we agreed to this change under the condition of a big flashing warning that the `send/receive_group_operation_with_aad` functions in the API MUST be separate from the normal ones at the api level. This is missing here.",
          "createdAt": "2019-10-09T07:35:38Z",
          "updatedAt": "2019-10-09T07:56:07Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "`opaque` already encompass the length, I believe.",
              "createdAt": "2019-10-09T07:35:38Z",
              "updatedAt": "2019-10-11T22:05:27Z"
            },
            {
              "originalPosition": 4,
              "body": "Also it would avoid interleaving plaintexts and ciphertexts...",
              "createdAt": "2019-10-09T07:39:46Z",
              "updatedAt": "2019-10-11T22:05:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk5NTA3Mzg1",
          "commit": {
            "abbreviatedOid": "eda3fb3"
          },
          "author": "psla",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-09T15:37:07Z",
          "updatedAt": "2019-10-09T15:42:35Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "I was inspired by\r\n```\r\n    opaque content[length_of_content];\r\n```\r\nabove (in MLSCiphertextContent). Is that one also incorrect?",
              "createdAt": "2019-10-09T15:37:07Z",
              "updatedAt": "2019-10-11T22:05:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAwMDgyMzA0",
          "commit": {
            "abbreviatedOid": "eda3fb3"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-10T13:50:36Z",
          "updatedAt": "2019-10-10T13:52:37Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "This can just be the same definition as in the `MLSCiphertext` object.  The only reason for the `[]` notation w.r.t. content is the weird encoding of `MLSCiphertextContent`, which IIRC is about to get reverted.",
              "createdAt": "2019-10-10T13:50:36Z",
              "updatedAt": "2019-10-11T22:05:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAwMjIwNDEw",
          "commit": {
            "abbreviatedOid": "eda3fb3"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "I missed that indeed, feel free to fix the `<>` `[]` and we'll merge the PR, I'll put the API recommendation in the architecture document. For the record, even though people at the interim kind of agree this mechanism was ok, I am still very skeptical about it because I am certain people will misuse it...\r\n",
          "createdAt": "2019-10-10T17:07:29Z",
          "updatedAt": "2019-10-10T17:07:29Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAwNzQ4Mjcw",
          "commit": {
            "abbreviatedOid": "eda3fb3"
          },
          "author": "psla",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-11T15:04:32Z",
          "updatedAt": "2019-10-11T15:19:14Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I agree. Done!",
              "createdAt": "2019-10-11T15:04:32Z",
              "updatedAt": "2019-10-11T22:05:27Z"
            },
            {
              "originalPosition": 40,
              "body": "Done.\r\nI also renamed it to authenticated_data instead of authenticated_content, in order to keep the naming the same. (I was in the pickle here, since the data struct is called 'MLSCiphertextConterntAAD' and then the field inside is called authenticated_data. I initially thought that calling it authenticated_content will be better, but I believe it's better to keep the same name all over the place).",
              "createdAt": "2019-10-11T15:06:32Z",
              "updatedAt": "2019-10-11T22:05:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAwOTU4MjAy",
          "commit": {
            "abbreviatedOid": "06c0317"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-11T22:48:54Z",
          "updatedAt": "2019-10-11T22:48:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 209,
      "id": "MDExOlB1bGxSZXF1ZXN0MzE5MDE5MjIx",
      "title": "Proposals and Commits",
      "url": "https://github.com/mlswg/mls-protocol/pull/209",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "functionality",
        "security"
      ],
      "body": "This PR implements the proposal discussed in Prague and on the mailing list, to separate GroupOperations into Proposals and Commits.  This change leaves the underlying ratchet tree operations untouched, but changes how these operations are folded into the overall key schedule.\r\n\r\nThis is also a fairly initial effort, with several OPEN ISSUEs noted.  The most important IMO is that we should allow a single MLSPlaintext to pack one or more Proposals along with a Commit, which makes it simpler to emulate the current behavior, and might allow us to get rid of the Init message.",
      "createdAt": "2019-09-18T22:07:05Z",
      "updatedAt": "2019-12-17T08:56:54Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "69739df60d07ee53c245ff9bbee7d391f1ce5b9d",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "proposals",
      "headRefOid": "1af815682b86f1bb659302553b72c57517e6c48d",
      "closedAt": "2019-11-14T15:37:05Z",
      "mergedAt": "2019-11-14T15:37:05Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "41a2389abf922fe0c3dbcc1ec67e2ddbd7416ec2"
      },
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Note: Need to stop truncating hash of proposal",
          "createdAt": "2019-10-01T13:24:04Z",
          "updatedAt": "2019-10-01T13:24:04Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "This is good. Thanks Richard !",
          "createdAt": "2019-11-14T15:37:00Z",
          "updatedAt": "2019-11-14T15:37:00Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkwMjUwMDc1",
          "commit": {
            "abbreviatedOid": "8b57a97"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-18T23:11:46Z",
          "updatedAt": "2019-09-19T00:04:55Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "more advanced",
              "createdAt": "2019-09-18T23:11:46Z",
              "updatedAt": "2019-11-14T15:33:44Z"
            },
            {
              "originalPosition": 132,
              "body": "hash over the whole transcript",
              "createdAt": "2019-09-18T23:15:15Z",
              "updatedAt": "2019-11-14T15:33:44Z"
            },
            {
              "originalPosition": 137,
              "body": "MLSPlaintext -> MLSPlaintextCommitAuthData?",
              "createdAt": "2019-09-18T23:43:00Z",
              "updatedAt": "2019-11-14T15:33:44Z"
            },
            {
              "originalPosition": 160,
              "body": "It's confusing to me why it's done the way that it is now. Can't you use the one ASTree to generate keys for everything?",
              "createdAt": "2019-09-18T23:44:28Z",
              "updatedAt": "2019-11-14T15:33:44Z"
            },
            {
              "originalPosition": 449,
              "body": "Maybe off-topic, but can we make it so that Adds always add to the first empty index?",
              "createdAt": "2019-09-18T23:52:16Z",
              "updatedAt": "2019-11-14T15:33:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkwNTk4OTAw",
          "commit": {
            "abbreviatedOid": "8b57a97"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-19T14:14:19Z",
          "updatedAt": "2019-09-19T14:14:20Z",
          "comments": [
            {
              "originalPosition": 449,
              "body": "That is the desire, but it runs into the problem that \"first\" isn't well-defined in a context where members might see two Add messages in different orders.  So the idea here is that the Committer acts as the arbiter and decides the order.",
              "createdAt": "2019-09-19T14:14:19Z",
              "updatedAt": "2019-11-14T15:33:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkwNzEzNzY0",
          "commit": {
            "abbreviatedOid": "8b57a97"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-19T17:07:26Z",
          "updatedAt": "2019-09-19T17:07:27Z",
          "comments": [
            {
              "originalPosition": 449,
              "body": "Doesn't the Commit message define an order over the Adds? You could\r\n```diff\r\n- AddCommit adds<0..2^16-1>;\r\n+ ProposalID adds<0..2^16-1>;\r\n```\r\nbecause the index is implicit",
              "createdAt": "2019-09-19T17:07:27Z",
              "updatedAt": "2019-11-14T15:33:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkwNzgzMjA2",
          "commit": {
            "abbreviatedOid": "8b57a97"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-19T19:09:10Z",
          "updatedAt": "2019-09-19T19:09:11Z",
          "comments": [
            {
              "originalPosition": 449,
              "body": "Oh, I see. Good point.  If I try hard, I can imagine scenarios where you would not want that (\"Each user gets 8 devices, so we're going to assign each user a slice of the tree\"), but for this first cut, I'm happy to have it simpler.  We can add the flexibility back if people ask for it.",
              "createdAt": "2019-09-19T19:09:10Z",
              "updatedAt": "2019-11-14T15:33:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkwODYzOTgz",
          "commit": {
            "abbreviatedOid": "9148b31"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-19T21:53:49Z",
          "updatedAt": "2019-09-19T21:53:50Z",
          "comments": [
            {
              "originalPosition": 160,
              "body": "It's a question of where you separate the handshake keys from the application keys.  You want them to be separate to simplify the analysis, so that the implication always goes Handshake => Application and not vice versa.\r\n\r\nIn the current draft, the nearest common ancestor is the epoch secret.  I think you're on the right track here, and a better design would be to use the AStree to fan out secrets per participant, then split out different keys for different uses at the leaves.\r\n\r\n@beurdouche should probably opine here, but in any case, it seems like a follow-on PR, not something to address here.",
              "createdAt": "2019-09-19T21:53:49Z",
              "updatedAt": "2019-11-14T15:33:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkwODY4NTAy",
          "commit": {
            "abbreviatedOid": "9148b31"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-19T22:05:54Z",
          "updatedAt": "2019-09-19T23:15:10Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "This needs to be there or else the sectioning gets messed up",
              "createdAt": "2019-09-19T22:05:54Z",
              "updatedAt": "2019-11-14T15:33:44Z"
            },
            {
              "originalPosition": 398,
              "body": "and are uniquely",
              "createdAt": "2019-09-19T22:26:59Z",
              "updatedAt": "2019-11-14T15:33:45Z"
            },
            {
              "originalPosition": 457,
              "body": "an MLSPlaintext",
              "createdAt": "2019-09-19T22:28:31Z",
              "updatedAt": "2019-11-14T15:33:45Z"
            },
            {
              "originalPosition": 505,
              "body": "This needs to be updated to be in line with new Add behavior",
              "createdAt": "2019-09-19T22:30:42Z",
              "updatedAt": "2019-11-14T15:33:45Z"
            },
            {
              "originalPosition": 599,
              "body": "Should implementations be required to incorporate all valid proposals that they know of? If not, meaning proposals have a chance of being dropped, how are they meant to be communicated to an end-user?",
              "createdAt": "2019-09-19T23:08:38Z",
              "updatedAt": "2019-11-14T15:33:45Z"
            },
            {
              "originalPosition": 601,
              "body": "Because proposals can't build on top of each other, you have weird cases like:\r\n\r\n1. Alice adds Bob to the group (without committing).\r\n2. Carol removes Bob from the group.\r\n\r\nIt implicitly requires Carol to Commit->Remove because she can't form her Remove proposal without first committing. Whatever API you expose to an application would have to understand this",
              "createdAt": "2019-09-19T23:09:16Z",
              "updatedAt": "2019-11-14T15:33:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkxMTE5MjQy",
          "commit": {
            "abbreviatedOid": "9148b31"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-20T12:03:00Z",
          "updatedAt": "2019-09-20T12:03:00Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "It's still there, it just got moved up in #196.  ",
              "createdAt": "2019-09-20T12:03:00Z",
              "updatedAt": "2019-11-14T15:33:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkxMTIwNjAw",
          "commit": {
            "abbreviatedOid": "9148b31"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-20T12:06:11Z",
          "updatedAt": "2019-09-20T12:19:38Z",
          "comments": [
            {
              "originalPosition": 505,
              "body": "Could you say more?  I already updated this to remove the reference to multiple ciphersuites in the CIK.",
              "createdAt": "2019-09-20T12:06:11Z",
              "updatedAt": "2019-11-14T15:33:45Z"
            },
            {
              "originalPosition": 599,
              "body": "This being a distributed system, there's always a risk of proposals being dropped.  One of the drawbacks of this proposal is that it increases the complexity of the retry logic.  Nonetheless, we can require that the Commit contain all proposals **known to the committer**. ",
              "createdAt": "2019-09-20T12:09:45Z",
              "updatedAt": "2019-11-14T15:33:45Z"
            },
            {
              "originalPosition": 601,
              "body": "This seems workable to me.  I would expect that the API just wouldn't mark Bob as added until the Add was committed, so Carol wouldn't even be able to form the Remove message until then.  ",
              "createdAt": "2019-09-20T12:19:23Z",
              "updatedAt": "2019-11-14T15:33:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkyNTkzMzA1",
          "commit": {
            "abbreviatedOid": "2fffe2b"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Lgtm besides last few comments\r\n\r\nEdit: Obviously you need to fix the key schedule as well before this is complete, but yeah.",
          "createdAt": "2019-09-24T17:39:54Z",
          "updatedAt": "2019-09-24T20:34:40Z",
          "comments": [
            {
              "originalPosition": 505,
              "body": "- \"Instead, the sender of the Commit message chooses a location for each added member and states it in the Commit message.\"\r\n- \"A member of the group applies an Add message at leaf index `index` specified in the Commit message by taking the following steps:\"\r\n\r\nYou're referencing an index which is now implicit",
              "createdAt": "2019-09-24T17:39:54Z",
              "updatedAt": "2019-11-14T15:33:45Z"
            },
            {
              "originalPosition": 776,
              "body": "There's a section below here, \"Merging Updates\", that I think you can remove. Merging multiple Commits doesn't make sense",
              "createdAt": "2019-09-24T20:29:59Z",
              "updatedAt": "2019-11-14T15:33:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkyODQ1NzM4",
          "commit": {
            "abbreviatedOid": "2fffe2b"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-25T06:09:27Z",
          "updatedAt": "2019-09-25T06:09:27Z",
          "comments": [
            {
              "originalPosition": 662,
              "body": "Typo: `path`\r\n\r\nAlso, if there's only a single DirectPath per epoch, won't this lead to trees becoming sparser (i.e., having fewer filled nodes) over time? It's fine as long as the root node is filled, but DirectPath messages might have to get bigger to accommodate the sparseness.",
              "createdAt": "2019-09-25T06:09:27Z",
              "updatedAt": "2019-11-14T15:33:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk0ODkyNTY2",
          "commit": {
            "abbreviatedOid": "2fffe2b"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-30T10:51:22Z",
          "updatedAt": "2019-09-30T10:51:22Z",
          "comments": [
            {
              "originalPosition": 662,
              "body": "The sparseness of the tree depends on how often all the members Commit. For example, if you have a group where only one person ever Commits, then the direct path above that person is the only one that will ever be populated, and MLS will degrade to \"encrypt every message to every person individually\" scheme.\r\n\r\nIf you have an application-level understanding of who needs to Commit and who's allowed to be lazy, it could be fine(?). It gives you a performance trade-off.",
              "createdAt": "2019-09-30T10:51:22Z",
              "updatedAt": "2019-11-14T15:33:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE2OTU5NTg3",
          "commit": {
            "abbreviatedOid": "8f506ec"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "A few changes needed, but I would be fine with fixing in subsequent PRs.",
          "createdAt": "2019-11-14T13:43:09Z",
          "updatedAt": "2019-11-14T14:56:11Z",
          "comments": [
            {
              "originalPosition": 114,
              "body": "I suppose ContentType should be defined above correct ? or is this a forward reference ?\r\n(It is not in the diff..)",
              "createdAt": "2019-11-14T13:44:51Z",
              "updatedAt": "2019-11-14T15:33:45Z"
            },
            {
              "originalPosition": 160,
              "body": "Mixing derivations of different uses of the keys is quite bad practice and difficult to mechanically prove in an unbounded setting. We might get back to a tree later: Joel has a nice idea in to make it usable in the mechanized context and he will be visiting us to discuss it. For functionality I don't think we actually have to do a Tree, we can include a sender's counter when calling the KDF to derive separate keys and advertise it on the wire in the new outer AAD field of the common framing.\r\n\r\n",
              "createdAt": "2019-11-14T13:50:27Z",
              "updatedAt": "2019-11-14T15:33:45Z"
            },
            {
              "originalPosition": 215,
              "body": "Yes, we probably should, we don't want the delivery service to process the Commit first and discard the associated proposal because it is from the previous epoch",
              "createdAt": "2019-11-14T13:57:30Z",
              "updatedAt": "2019-11-14T15:33:45Z"
            },
            {
              "originalPosition": 217,
              "body": "I think Update+Commit should be atomic",
              "createdAt": "2019-11-14T13:57:57Z",
              "updatedAt": "2019-11-14T15:33:45Z"
            },
            {
              "originalPosition": 340,
              "body": "s/protocol/protocol version",
              "createdAt": "2019-11-14T13:59:13Z",
              "updatedAt": "2019-11-14T15:33:45Z"
            },
            {
              "originalPosition": 342,
              "body": "?? s/Note/Record ??",
              "createdAt": "2019-11-14T13:59:52Z",
              "updatedAt": "2019-11-14T15:33:45Z"
            },
            {
              "originalPosition": 392,
              "body": "s/broadcast/broadcasted",
              "createdAt": "2019-11-14T14:01:26Z",
              "updatedAt": "2019-11-14T15:33:45Z"
            },
            {
              "originalPosition": 599,
              "body": "Yes. As we need to indicate all the proposal accepted and rejected by the committer so that other members know what proposals have been considered.",
              "createdAt": "2019-11-14T14:35:00Z",
              "updatedAt": "2019-11-14T15:33:45Z"
            },
            {
              "originalPosition": 601,
              "body": "Richard is correct here.",
              "createdAt": "2019-11-14T14:40:17Z",
              "updatedAt": "2019-11-14T15:33:45Z"
            }
          ]
        }
      ]
    },
    {
      "number": 210,
      "id": "MDExOlB1bGxSZXF1ZXN0MzE5Mjk3MDc2",
      "title": "Update changelog for recent PRs",
      "url": "https://github.com/mlswg/mls-protocol/pull/210",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2019-09-19T14:08:17Z",
      "updatedAt": "2019-12-17T08:56:16Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "1a201118d76925dcc1e9b31138299798d71cc90f",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "changelog-08",
      "headRefOid": "5d738bd4c395d1bf18597018d77dd06c50f381cb",
      "closedAt": "2019-09-19T14:08:39Z",
      "mergedAt": "2019-09-19T14:08:39Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "46e586329b16d9703ec321a83f79c70d6ed72c17"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Merging myself because this is trivial.",
          "createdAt": "2019-09-19T14:08:34Z",
          "updatedAt": "2019-09-19T14:08:34Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 213,
      "id": "MDExOlB1bGxSZXF1ZXN0MzIyNzg3Mzkz",
      "title": "Change ciphertext content to be standard TLS format.",
      "url": "https://github.com/mlswg/mls-protocol/pull/213",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement"
      ],
      "body": "I don't like the pattern of having a marker byte followed by zero-padding. It has to be parsed manually, backwards, unlike every other object in the protocol which all follow a common format.",
      "createdAt": "2019-09-30T13:38:21Z",
      "updatedAt": "2019-12-17T08:54:09Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "46e586329b16d9703ec321a83f79c70d6ed72c17",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2019.9.0",
      "headRefOid": "1c3a2a6757ba447965ea90e2e1942d9e930d42fb",
      "closedAt": "2019-10-01T10:48:09Z",
      "mergedAt": "2019-10-01T10:48:09Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "30c31565ce57843e10e36c69c8573da54d505a56"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreement at the interim was that people don't care about the overhead (for now), so we're going to go with the simpler, TLS-syntax-based structure.",
          "createdAt": "2019-10-01T10:47:36Z",
          "updatedAt": "2019-10-01T10:47:36Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk1MDUyNzA0",
          "commit": {
            "abbreviatedOid": "1c3a2a6"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-30T15:16:19Z",
          "updatedAt": "2019-09-30T22:02:57Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "In general, I would prefer that editorial changes be in separate PRs from substantive changes.  But this one is small enough that I'll let it slide.",
              "createdAt": "2019-09-30T15:16:19Z",
              "updatedAt": "2019-09-30T22:02:57Z"
            },
            {
              "originalPosition": 55,
              "body": "The current design is carried over from TLS's minimal-overhead, unlimited-length design.  Relative to the left-hand side of the diff, you've added an octet here and imposed a 2^16 length limit.  I would counter-offer the following proposal:\r\n\r\n```\r\nstruct {\r\n  uint8 zero_padding[length_of_padding];\r\n  ContentType content_type;\r\n  select(content_type) {...}\r\n  opaque signature<0..2^16-1>;\r\n} MLSCiphertextContent;\r\n```\r\n\r\nThat is, move the `content_type` inside the encrypted portion, use it as the marker byte (as in TLS), and put the padding at the front.  @raphaelrobert had made noises about the server not knowing which messages to queue if the `content_type` was opaque, but it seems like the clients do know and if the server offers scheduled and unscheduled service, can choose the appropriate type.",
              "createdAt": "2019-09-30T15:22:47Z",
              "updatedAt": "2019-09-30T22:02:57Z"
            }
          ]
        }
      ]
    },
    {
      "number": 218,
      "id": "MDExOlB1bGxSZXF1ZXN0MzIzMDk2ODMy",
      "title": "Favor not reusing ClientInitKey (SHOULD)",
      "url": "https://github.com/mlswg/mls-protocol/pull/218",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "recommendation",
        "security"
      ],
      "body": "This has been reported unclear multiple times. I strongly prefer forbidding reuse altogether.\r\nA validation mechanism is needed for the formal security proof, it can be implemented according to an expiration mechanism (see Architecture - 4.2.  Delivery Service Compromise)",
      "createdAt": "2019-10-01T05:52:10Z",
      "updatedAt": "2019-12-17T08:53:11Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "46e586329b16d9703ec321a83f79c70d6ed72c17",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_noreuse",
      "headRefOid": "5d3a24275f5822f9f2c2d08886502d9120b42cee",
      "closedAt": "2019-11-14T17:26:19Z",
      "mergedAt": "2019-11-14T17:26:19Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "39006cae700c2acdd769046911b6983c7d566c66"
      },
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "We need to allow Last Resort keys. Not sure what you mean by \"replay attacks\"",
          "createdAt": "2019-10-04T18:08:48Z",
          "updatedAt": "2019-10-04T18:08:48Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "> We need to allow Last Resort keys. Not sure what you mean by \"replay attacks\"\r\n\r\nI rewrote it in favor of using \"SHOULD NOT reuse\", which is true, except in case of last resort to avoid DOS, which we are willing to allow.\r\n\r\nNormal meaning... If I remember correctly, there is a cross channel forwarding attack (replay) possible on the first message in Signal when reusing prekeys (the last resort key) because it lacks some channel binding but I would have to check. I am working to make sure we don't suffer the same defect but I am documenting it in the mean time.",
          "createdAt": "2019-10-04T19:28:11Z",
          "updatedAt": "2019-10-04T19:28:11Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I can live with this for now; we can refine later.",
          "createdAt": "2019-11-14T17:26:10Z",
          "updatedAt": "2019-11-14T17:26:10Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExODY0NjI1",
          "commit": {
            "abbreviatedOid": "5d3a242"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-05T16:32:07Z",
          "updatedAt": "2019-11-05T16:35:21Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "This needs more elaboration.  InitKeys are used in Welcome/Init messages, so those messages could be replayed.  The result of that depends on how applications treat group IDs, since the group ID will be the same between the original and the replay.  If the client rejects Init/Welcome messages for group IDs where it is already a member, then there's no problem.  If the client allows duplicate group IDs, and thus accepts such Init/Welcome messages, then it will consider the replay a new session and accept the replayed messages within that session.  That session can be replayed up until the first time the new member updates, so there's even more reason to update on join.\r\n\r\nIf we're going to say something here, I would propose we focus the guidance on those considerations, instead of trying to prevent reuse (which isn't feasible anyway).\r\n\r\n* Applications SHOULD reject Init/Welcome with duplicate group IDs\r\n* Clients SHOULD update on join",
              "createdAt": "2019-11-05T16:32:07Z",
              "updatedAt": "2019-11-05T16:35:21Z"
            },
            {
              "originalPosition": 11,
              "body": "Multiple versions as well.",
              "createdAt": "2019-11-05T16:32:28Z",
              "updatedAt": "2019-11-05T16:35:22Z"
            },
            {
              "originalPosition": 9,
              "body": "I'm not sure I agree with this.  If you have a last resort key, an attacker can always force you to use it.  And as discussed below, there are alternative mitigations to the replay risks.",
              "createdAt": "2019-11-05T16:35:18Z",
              "updatedAt": "2019-11-05T16:35:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3MTMwMTg2",
          "commit": {
            "abbreviatedOid": "5d3a242"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-14T17:25:54Z",
          "updatedAt": "2019-11-14T17:25:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 219,
      "id": "MDExOlB1bGxSZXF1ZXN0MzIzMTA0MjEz",
      "title": "Fix application message truncation attack",
      "url": "https://github.com/mlswg/mls-protocol/pull/219",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "functionality",
        "security",
        "work in progress"
      ],
      "body": "2020/03/04 - Will be resolved by the next interim",
      "createdAt": "2019-10-01T06:17:00Z",
      "updatedAt": "2020-07-24T21:16:47Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "46e586329b16d9703ec321a83f79c70d6ed72c17",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_fix_truncation_attack",
      "headRefOid": "84a6d7b93fc914157066f41854489bb22f5adfc9",
      "closedAt": "2020-07-24T21:16:47Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't agree with this change. It's not MLS's job to enforce an order on messages, or enforce that messages don't get lost. If you want to ensure things, you can build your own mechanism and store it in the AAD of the messages. This also lets people build their own thing that's as strong/weak as they need:\r\n\r\n- Ensure per-peer message order, no messages lost: Each peer puts a counter in their AAD, \"This is my 7th message.\" and others can complain if they haven't seen message 6.\r\n- Ensure total message order: Each message has the hash of the last message in its AAD.\r\n- Maybe you have no mechanism because you're fine with messages getting lost.",
          "createdAt": "2019-10-01T12:53:15Z",
          "updatedAt": "2019-10-01T12:53:15Z"
        },
        {
          "author": "katrielalex",
          "authorAssociation": "MEMBER",
          "body": "I'd be happy to include in the AAD the length of the previous chain (\"PN\" in Signal's language), but I don't have strong feelings.",
          "createdAt": "2019-10-01T13:02:14Z",
          "updatedAt": "2019-10-01T13:02:14Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "> I don't agree with this change. It's not MLS's job to enforce an order on messages,\r\n> \r\nNobody is talking about this...\r\n> or enforce that messages don't get lost.\r\n> \r\nModern protocols gives you this property. I believe Signal does give you that, minimally, you should know if I drop all your messages.\r\n> If you want to ensure things, you can build your own mechanism and store it in the AAD of the messages. This also lets people build their own thing that's as strong/weak as they need:\r\n> \r\n> Ensure per-peer message order, no messages lost: Each peer puts a counter in their AAD, \"This is my 7th message.\" and others can complain if they haven't seen message 6.\r\n> Ensure total message order: Each message has the hash of the last message in its AAD.\r\n> Maybe you have no mechanism because you're fine with messages getting lost\r\nThis reasonning is completly the reverse of the MLS goals, we actually want to enforce as much\r\nas possible in the protocol and relax at the application level but definitely not let people design complex\r\nthings at the application level without any information callback from the protocol layer\r\n\r\n",
          "createdAt": "2019-10-01T13:17:29Z",
          "updatedAt": "2019-10-04T09:20:16Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "> This reasonning is completly the reverse of the MLS goals, we actually want to enforce as much\r\nas possible in the protocol\r\n\r\nWe leave a lot of things out of the protocol that are better handled at another layer, or where there are multiple acceptable solutions. \"Application message truncation attack\" is not an attack, it's just another way to say \"packet loss\" which is better handled at the TCP / application layer, because those are the layers that know how things are going to get lost.\r\n\r\nTLS, for example, doesn't know how to recover lost packets -- that's TCP's job. TLS also doesn't know how to do application-level retries -- that's the application's job.",
          "createdAt": "2019-10-04T17:56:36Z",
          "updatedAt": "2019-10-04T17:56:36Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I think that including the counter is a meaningful mechanism to ensure the DS behaves correctly. If possible at all, this should not be solved at the application layer. Naturally applications can ignore lost/suppressed messages if they so wish.\r\nTranscript consistency was one the properties discussed early on and this goes in the right direction at a very low cost.",
          "createdAt": "2019-10-04T18:54:06Z",
          "updatedAt": "2019-10-04T18:54:06Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "This PR has gotten quite stale and out of sync with the draft.  Closing for now.  @beurdouche holds the token to propose an alternate resolution to #160.",
          "createdAt": "2020-07-24T21:16:47Z",
          "updatedAt": "2020-07-24T21:16:47Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 220,
      "id": "MDExOlB1bGxSZXF1ZXN0MzIzMTA5MTE5",
      "title": "More requirements regarding state loss",
      "url": "https://github.com/mlswg/mls-protocol/pull/220",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "security"
      ],
      "body": "",
      "createdAt": "2019-10-01T06:33:16Z",
      "updatedAt": "2019-12-17T08:52:00Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "46e586329b16d9703ec321a83f79c70d6ed72c17",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_state_loss",
      "headRefOid": "332fb1dca48460d29ebbc4bb3302066c5b9aedc5",
      "closedAt": "2019-11-05T16:09:46Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "I mixed state loss and device loss by mistake, thank you. I removed the second part and put it in a separate place. Regarding the partial state loss, I am sure that Jon, Katriel or Raphael can give you good examples. ",
          "createdAt": "2019-10-04T18:59:13Z",
          "updatedAt": "2019-10-04T18:59:13Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this pending #93 \r\n",
          "createdAt": "2019-11-05T16:09:38Z",
          "updatedAt": "2019-11-05T16:09:38Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3MzU0NDUy",
          "commit": {
            "abbreviatedOid": "9978983"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-04T09:17:59Z",
          "updatedAt": "2019-10-04T09:18:00Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Note that this will be definitely needed to recover PCS if we do the signature key rotation.",
              "createdAt": "2019-10-04T09:18:00Z",
              "updatedAt": "2019-10-04T18:51:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3NjI3MzU5",
          "commit": {
            "abbreviatedOid": "9978983"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "This section doesn't make sense to me. In what situation would you only lose part of the group state? Why does losing the state for a group mean you have to expire all of your ClientInitKeys?",
          "createdAt": "2019-10-04T17:52:55Z",
          "updatedAt": "2019-10-04T17:52:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 221,
      "id": "MDExOlB1bGxSZXF1ZXN0MzIzMTM4Mjky",
      "title": "Precisions on authentication and IdentityKeys",
      "url": "https://github.com/mlswg/mls-protocol/pull/221",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "recommendation",
        "security"
      ],
      "body": "I couldn't find this written anywhere else and this is also related to a discussion about PCS with Cas and al.",
      "createdAt": "2019-10-01T08:03:35Z",
      "updatedAt": "2019-12-17T08:51:10Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "46e586329b16d9703ec321a83f79c70d6ed72c17",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_auth_control",
      "headRefOid": "d3048eacf93cf5c2d5645b72622d847ebdf87ce0",
      "closedAt": "2019-11-05T16:07:24Z",
      "mergedAt": "2019-11-05T16:07:24Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "69739df60d07ee53c245ff9bbee7d391f1ce5b9d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3NjMzODYz",
          "commit": {
            "abbreviatedOid": "d3048ea"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-04T18:05:16Z",
          "updatedAt": "2019-10-04T18:05:21Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "maybe just \"MUST be validated.\"",
              "createdAt": "2019-10-04T18:05:16Z",
              "updatedAt": "2019-10-04T18:05:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExODQ1Njk0",
          "commit": {
            "abbreviatedOid": "d3048ea"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-05T16:07:10Z",
          "updatedAt": "2019-11-05T16:07:15Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I don't think you can make this a MUST.  You can imagine applications that don't really care about authentication, but want all the other properties.  Also, there is no comparable requirement in TLS.",
              "createdAt": "2019-11-05T16:07:10Z",
              "updatedAt": "2019-11-05T16:07:15Z"
            }
          ]
        }
      ]
    },
    {
      "number": 229,
      "id": "MDExOlB1bGxSZXF1ZXN0MzI0NjgzODYy",
      "title": "Correction of three minor typos",
      "url": "https://github.com/mlswg/mls-protocol/pull/229",
      "state": "MERGED",
      "author": "pjunodsc",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "This PR corrects three minor typos.",
      "createdAt": "2019-10-04T13:35:34Z",
      "updatedAt": "2019-12-17T08:50:49Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "30c31565ce57843e10e36c69c8573da54d505a56",
      "headRepository": "pjunodsc/mls-protocol",
      "headRefName": "20191004_minor-typos",
      "headRefOid": "328effac7452a831836ebe43391d3d2caa30cbf7",
      "closedAt": "2019-10-04T13:36:22Z",
      "mergedAt": "2019-10-04T13:36:22Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "d8672cf6e78d781a5ff6f9e238ee6b0db3b3f026"
      },
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Thank you Pascal !",
          "createdAt": "2019-10-04T13:36:24Z",
          "updatedAt": "2019-10-04T13:36:24Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3NDc4MjY0",
          "commit": {
            "abbreviatedOid": "328effa"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-04T13:35:58Z",
          "updatedAt": "2019-10-04T13:35:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 230,
      "id": "MDExOlB1bGxSZXF1ZXN0MzI0ODA3ODQ1",
      "title": "Device loss and sig key compromise",
      "url": "https://github.com/mlswg/mls-protocol/pull/230",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "recommendation",
        "security"
      ],
      "body": "",
      "createdAt": "2019-10-04T18:55:21Z",
      "updatedAt": "2019-12-17T08:50:35Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "d8672cf6e78d781a5ff6f9e238ee6b0db3b3f026",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_sig_pcs",
      "headRefOid": "0cb0617030c1082a105b1af2b33654dffa9a7fe4",
      "closedAt": "2019-11-05T16:03:27Z",
      "mergedAt": "2019-11-05T16:03:27Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "d4362b8075dd5e42e1a45c721874409a82a7438f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExODQyNzM1",
          "commit": {
            "abbreviatedOid": "0cb0617"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-05T16:03:15Z",
          "updatedAt": "2019-11-05T16:03:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 232,
      "id": "MDExOlB1bGxSZXF1ZXN0MzI1NjM4Njk3",
      "title": "Fix resolution-related issue in ratchet tree update example",
      "url": "https://github.com/mlswg/mls-protocol/pull/232",
      "state": "CLOSED",
      "author": "pjunodsc",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2019-10-08T07:31:06Z",
      "updatedAt": "2019-12-17T10:17:38Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "d8672cf6e78d781a5ff6f9e238ee6b0db3b3f026",
      "headRepository": "pjunodsc/mls-protocol",
      "headRefName": "20191007_fix-copath",
      "headRefOid": "3feef3c8467ec01b781a03d7ff75dbdee621bd9e",
      "closedAt": "2019-11-14T18:20:46Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Obsoleted by #244 ",
          "createdAt": "2019-11-14T18:20:46Z",
          "updatedAt": "2019-11-14T18:20:46Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE2NjkwNjQ0",
          "commit": {
            "abbreviatedOid": "3feef3c"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-14T03:12:57Z",
          "updatedAt": "2019-11-14T03:12:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 233,
      "id": "MDExOlB1bGxSZXF1ZXN0MzI2NDQ3OTEx",
      "title": "Initialize new members directly into the current epoch",
      "url": "https://github.com/mlswg/mls-protocol/pull/233",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "functionality",
        "security"
      ],
      "body": "Fixes #223 \r\n\r\nDiscussion of security analysis in the issue.",
      "createdAt": "2019-10-09T21:04:28Z",
      "updatedAt": "2019-12-17T10:17:21Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "d8672cf6e78d781a5ff6f9e238ee6b0db3b3f026",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "welcome-current-epoch",
      "headRefOid": "e1e26b8f40ca5ebfa47c42f92cb8994957555846",
      "closedAt": "2019-11-11T19:29:58Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "Shouldn't we rebase this on the Proposals proposal? Otherwise we might just throw away a good part of this PR soon.",
          "createdAt": "2019-10-11T13:46:06Z",
          "updatedAt": "2019-10-11T13:46:06Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@raphaelrobert - Since there wasn't clear agreement on the Proposals PR, I went ahead and pulled this out.  If we are going to do Proposals, it won't be a bad rebase.  And in any case, doing this on its own made it a bit easier to do the supporting analysis.",
          "createdAt": "2019-10-11T22:50:12Z",
          "updatedAt": "2019-10-11T22:50:12Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this, as it looks like #209 is going to land soon.",
          "createdAt": "2019-11-11T19:29:08Z",
          "updatedAt": "2019-11-11T19:29:08Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 234,
      "id": "MDExOlB1bGxSZXF1ZXN0MzI2NDUzNDA2",
      "title": "Add downgrade protection to ClientInitKeys",
      "url": "https://github.com/mlswg/mls-protocol/pull/234",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "functionality",
        "security"
      ],
      "body": "Fixes #224 ",
      "createdAt": "2019-10-09T21:19:51Z",
      "updatedAt": "2019-12-17T08:49:01Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "517c83b3b83ae73d5bd58cff763245c771567d2e",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "cik-extensions",
      "headRefOid": "5f9c2ff63e822ff7a51832778834be942e03f8b6",
      "closedAt": "2019-11-14T17:58:54Z",
      "mergedAt": "2019-11-14T17:58:54Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "1ba65c11aee17962c22c85e1b2eb2250e3584a9c"
      },
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I think @bifurcation added what we discussed at the interim, but I agree with @beurdouche that we shouldn't label it as \"protection\" because of the lack of guarantees.\r\nIt is indeed just an information mechanism, but a number of questions are left open:\r\n - what should the client creating a group do if better ciphersuites /higher versions are advertised but the DS doesn't deliver the corresponding keys?\r\n - what should an added client do when it realises it was added with a sub-optimal ClientInitKey?\r\n - ...",
          "createdAt": "2019-10-11T09:28:30Z",
          "updatedAt": "2019-10-11T09:28:30Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "This now has a MUST for using the extensions to prevent downgrade.\r\n",
          "createdAt": "2019-11-14T17:09:23Z",
          "updatedAt": "2019-11-14T17:09:23Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAwMTk0MzAy",
          "commit": {
            "abbreviatedOid": "4d16799"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-10T16:21:41Z",
          "updatedAt": "2019-10-10T16:21:41Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAwMTk1NzE0",
          "commit": {
            "abbreviatedOid": "4d16799"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "This is not a downgrade protection mechanism. This is an information mechanism.\r\nThere is no rule here telling client receiving a `create` that they should refuse the state and how they should refuse it.",
          "createdAt": "2019-10-10T16:24:05Z",
          "updatedAt": "2019-10-10T16:24:05Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3MTE5NDM4",
          "commit": {
            "abbreviatedOid": "afc4965"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-14T17:09:02Z",
          "updatedAt": "2019-11-14T17:09:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 239,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM5NjY0MDkw",
      "title": "Welcome* == Init",
      "url": "https://github.com/mlswg/mls-protocol/pull/239",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "functionality",
        "security"
      ],
      "body": "This PR makes two major changes that are enabled by Proposals:\r\n\r\n* Multiple participants added in the same epoch receive the same Welcome message\r\n* Init is always a special case of Add\r\n\r\nPrior to Proposals, treating Init as a special case of Add led to a performance degradation (`n -> n log n`).  With Proposals, any number of Adds can be done with a single Commit (at `O(n)` cost), so there is no more degradation.  The result seems (IMO) much more elegant than before.\r\n\r\nThe main cost is that encryption of Welcome messages is now in two stages (three if you include the internal HPKE stage!), even if there is only one new member.\r\n\r\nDepends on #209 \r\nObsoletes #192 and #194 ",
      "createdAt": "2019-11-11T23:45:26Z",
      "updatedAt": "2019-12-17T08:47:53Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "39006cae700c2acdd769046911b6983c7d566c66",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "welcome-equals-init",
      "headRefOid": "292a51be8f9ebcc921349f2a2fa469873bb29583",
      "closedAt": "2019-11-14T17:56:48Z",
      "mergedAt": "2019-11-14T17:56:48Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "517c83b3b83ae73d5bd58cff763245c771567d2e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3MDk0MDM2",
          "commit": {
            "abbreviatedOid": "93de1be"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "I don't think that's far... Should we put CIK in leaves prior to this ?",
          "createdAt": "2019-11-14T16:33:45Z",
          "updatedAt": "2019-11-14T16:45:25Z",
          "comments": [
            {
              "originalPosition": 116,
              "body": "The creator chooses all CIKs and all secrets from its leaf to the root.",
              "createdAt": "2019-11-14T16:33:45Z",
              "updatedAt": "2019-11-14T17:56:40Z"
            },
            {
              "originalPosition": 121,
              "body": "I would prefer avoiding the requirement that the creator is at index 0 because it breaks privacy of its identity.\r\nWhen newcomers are included later on, it might be nice to not know immediately who is the creator.",
              "createdAt": "2019-11-14T16:35:29Z",
              "updatedAt": "2019-11-14T17:56:40Z"
            },
            {
              "originalPosition": 149,
              "body": "randomly chosen key and nonce",
              "createdAt": "2019-11-14T16:37:06Z",
              "updatedAt": "2019-11-14T17:56:40Z"
            },
            {
              "originalPosition": 186,
              "body": "MemberInfo is a bad name, welcome keypackage or something ?",
              "createdAt": "2019-11-14T16:39:08Z",
              "updatedAt": "2019-11-14T17:56:40Z"
            },
            {
              "originalPosition": 196,
              "body": "Same thing, for the name: `KeyPackage packages` or something ?",
              "createdAt": "2019-11-14T16:42:35Z",
              "updatedAt": "2019-11-14T17:56:40Z"
            },
            {
              "originalPosition": 212,
              "body": "What kind of error ?",
              "createdAt": "2019-11-14T16:43:31Z",
              "updatedAt": "2019-11-14T17:56:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3MTIzMzc3",
          "commit": {
            "abbreviatedOid": "93de1be"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Modulo fixes discussed with Richard",
          "createdAt": "2019-11-14T17:15:06Z",
          "updatedAt": "2019-11-14T17:15:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 240,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM5Njc1MjA1",
      "title": "External proposals",
      "url": "https://github.com/mlswg/mls-protocol/pull/240",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "functionality",
        "security"
      ],
      "body": "Depends on #209 \r\nFixes #104 ",
      "createdAt": "2019-11-12T00:38:48Z",
      "updatedAt": "2019-12-17T08:47:14Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "41a2389abf922fe0c3dbcc1ec67e2ddbd7416ec2",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "external-proposals",
      "headRefOid": "e543c19029d839ffe95e8ebd0a6c8597a0802290",
      "closedAt": "2019-11-14T17:16:11Z",
      "mergedAt": "2019-11-14T17:16:10Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "2eb798398763655082d43c22fab5e52d563ecd4b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3MDg3MjU3",
          "commit": {
            "abbreviatedOid": "e543c19"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "The signing key of external actors will be contained in the leaf in the case it is a CIK.",
          "createdAt": "2019-11-14T16:25:14Z",
          "updatedAt": "2019-11-14T16:25:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 241,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQwMDk4Mjc0",
      "title": "IANA Considerations and Ciphersuites",
      "url": "https://github.com/mlswg/mls-protocol/pull/241",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial",
        "functionality"
      ],
      "body": "This PR begins filling in the IANA Considerations section, starting with a Ciphersuites registry.  This addresses the concerns in #95 as discussed at the interim (2019-10), namely by reserving for vendor use chunk of the code points space large enough to be selected at random without huge risk of collision (2^12 values).\r\n\r\nDepends on #209 \r\nFixes #95 ",
      "createdAt": "2019-11-12T20:30:57Z",
      "updatedAt": "2019-12-17T08:46:40Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "41a2389abf922fe0c3dbcc1ec67e2ddbd7416ec2",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "iana",
      "headRefOid": "96599f8b82016f8ffd43941cb4d810e3f5362df2",
      "closedAt": "2019-11-14T17:17:24Z",
      "mergedAt": "2019-11-14T17:17:23Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "e03e5d74e59ba2aca912b6f454141a6d204bad3d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3MTI0NzU3",
          "commit": {
            "abbreviatedOid": "96599f8"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-14T17:17:17Z",
          "updatedAt": "2019-11-14T17:17:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 242,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQwMTYxMzUw",
      "title": "Pack multiple Proposals and a Commit together",
      "url": "https://github.com/mlswg/mls-protocol/pull/242",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is a light optimization over #209, removing the overhead of extra encryptions/signatures in the case where proposal(s) and a commit are sent at the same time.\r\n\r\nDepends on #209 ",
      "createdAt": "2019-11-12T23:25:11Z",
      "updatedAt": "2019-11-14T19:10:30Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "1ba65c11aee17962c22c85e1b2eb2250e3584a9c",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "multi",
      "headRefOid": "f8e5827a8d1c8a2b181cb8d6d9540fa4bc316f3c",
      "closedAt": "2019-11-14T18:08:49Z",
      "mergedAt": "2019-11-14T18:08:49Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "b3f7fe7c836cfd951fc638966ebd95f478324f7d"
      },
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Unfortunately, using a single content type enforces the DS to order everything while there is no reason to force ordering of proposals made for the same epoch.",
          "createdAt": "2019-11-14T16:16:53Z",
          "updatedAt": "2019-11-14T16:16:53Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "On conversation with @beurdouche - Will keep content types separate, but allow Commit to have proposals.",
          "createdAt": "2019-11-14T17:07:15Z",
          "updatedAt": "2019-11-14T17:07:15Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3MTUxMDI0",
          "commit": {
            "abbreviatedOid": "c9a0977"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Good to go modulo fix.",
          "createdAt": "2019-11-14T18:00:34Z",
          "updatedAt": "2019-11-14T18:00:34Z",
          "comments": []
        }
      ]
    },
    {
      "number": 243,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQwNzYzNDU2",
      "title": "Add GroupContext to signatures and AAD",
      "url": "https://github.com/mlswg/mls-protocol/pull/243",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "bug",
        "security"
      ],
      "body": "This makes MLSPlaintext signatures and DirectPath encryptions specific to a given group and epoch, to avoid copy/paste attacks.\r\n\r\n@Bren2010 - Note that this fixes #214 since DirectPath HPKE encryptions will have non-empty AAD, while Welcome messages will have none.\r\n\r\nDepends on #209 \r\nFixes #214 \r\nFixes #217 ",
      "createdAt": "2019-11-14T02:58:16Z",
      "updatedAt": "2019-12-17T08:43:17Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "41a2389abf922fe0c3dbcc1ec67e2ddbd7416ec2",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "inputs",
      "headRefOid": "34b3022a9ba40cb96114734915e7bb82af3c171c",
      "closedAt": "2019-11-14T17:18:25Z",
      "mergedAt": "2019-11-14T17:18:25Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "3bc25daa05026562a7221ca228498451ded9ceb4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3MTI1NDQy",
          "commit": {
            "abbreviatedOid": "34b3022"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-14T17:18:18Z",
          "updatedAt": "2019-11-14T17:18:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 244,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQxMTExNTYx",
      "title": "Some editorial fixes",
      "url": "https://github.com/mlswg/mls-protocol/pull/244",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Picking up some comments from @Bren2010 that I missed earlier, and fixing examples.\r\n\r\nObsoletes #232 ",
      "createdAt": "2019-11-14T18:19:38Z",
      "updatedAt": "2019-12-17T08:42:34Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "b3f7fe7c836cfd951fc638966ebd95f478324f7d",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "editorial",
      "headRefOid": "6961d3ec6915ecec9d7e8397cd6c4e7e7cb8d71a",
      "closedAt": "2019-11-14T18:20:18Z",
      "mergedAt": "2019-11-14T18:20:17Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "09110a985ad173c546c37707e90614ae54f7468a"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 245,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQxMTMxMzIz",
      "title": "Unpredictable epochs",
      "url": "https://github.com/mlswg/mls-protocol/pull/245",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "privacy",
        "work in progress"
      ],
      "body": "This allows for forks in the group history.",
      "createdAt": "2019-11-14T19:12:28Z",
      "updatedAt": "2020-01-28T23:35:24Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "09110a985ad173c546c37707e90614ae54f7468a",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "random-epoch",
      "headRefOid": "9eaa62caf6cfabdbc4ca6af64a73eb82e39e50ad",
      "closedAt": "2020-01-28T23:35:23Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I'm not sure I understand how the DS can do its job with this. To re-iterate what that is:\r\n\r\n - The DS needs to be the arbitrator in a race condition when two clients send a HS message based on the same previous epoch\r\n - In order to do so, it needs to be able to compare the new with the old epoch\r\n - It should additionally be able to detect when a HS message is not based on the previous and reject it\r\n\r\nThe above obviously works nicely with an incremental counter for epochs. I'd be happy if we can further obfuscate the epoch number, I'm just not sure what options we have that satisfy the above requirements.",
          "createdAt": "2019-11-14T20:10:13Z",
          "updatedAt": "2019-11-14T20:10:13Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Obsoleted by #281 ",
          "createdAt": "2020-01-28T23:35:23Z",
          "updatedAt": "2020-01-28T23:35:23Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3MjE0NzU2",
          "commit": {
            "abbreviatedOid": "9eaa62c"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-11-14T19:44:06Z",
          "updatedAt": "2019-11-14T19:44:19Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "- Stop truncating hashes!\r\n- What about the first epoch?",
              "createdAt": "2019-11-14T19:44:07Z",
              "updatedAt": "2019-11-14T19:44:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3MjE2NjA1",
          "commit": {
            "abbreviatedOid": "9eaa62c"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-14T19:47:16Z",
          "updatedAt": "2019-11-14T19:47:17Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I am more concerned* about loosing lexicographic ordering here. The DS wouldn't know how to reorder.",
              "createdAt": "2019-11-14T19:47:17Z",
              "updatedAt": "2019-11-14T19:47:53Z"
            }
          ]
        }
      ]
    },
    {
      "number": 246,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQxNzkwMzE0",
      "title": "Bugfixes in ClientInitKey, Commit, and Welcome",
      "url": "https://github.com/mlswg/mls-protocol/pull/246",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "bug",
        "editorial"
      ],
      "body": "1. The `client_init_key_id` is no longer needed, since CIKs are referenced by hash.\r\n2. ProposalIDs were no longer usable to refer to proposals since we enabled multiple proposals per MLSPlaintext\r\n3. The syntax description for Welcome was invalid",
      "createdAt": "2019-11-16T20:42:57Z",
      "updatedAt": "2020-01-30T10:57:33Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "26a327ca9c07381c3a8b9d717ff2641749195824",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "sg-bugfixes",
      "headRefOid": "13a4e3c8b0ee3e8b0145fb7c5bd8d6261f4b8520",
      "closedAt": "2020-01-29T22:06:29Z",
      "mergedAt": "2020-01-29T22:06:29Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "f52047aa4efc1e089c5bcd4c81c6eee6a90cefa5"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Merge with master obsoleted some changes.  I re-implemented the \"supported_version\"->\"version\" change, and added a \"key_id\" extension to address Benjamin's comment.",
          "createdAt": "2020-01-29T22:06:23Z",
          "updatedAt": "2020-01-29T22:06:23Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3OTg4MzY5",
          "commit": {
            "abbreviatedOid": "cef2419"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-16T20:47:36Z",
          "updatedAt": "2019-11-16T20:52:37Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I am quite sure that it is needed for lookup, the emitter should have the ability to validate it and you want to include it in the signature.",
              "createdAt": "2019-11-16T20:47:36Z",
              "updatedAt": "2020-01-29T22:04:57Z"
            },
            {
              "originalPosition": 9,
              "body": "I prefer `init_key` which conveys the fact that it is the very first KEM public key",
              "createdAt": "2019-11-16T20:48:23Z",
              "updatedAt": "2020-01-29T22:04:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3OTg4NjA3",
          "commit": {
            "abbreviatedOid": "cef2419"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-16T20:54:59Z",
          "updatedAt": "2019-11-16T20:54:59Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Why do you need it for lookup?  The only place it's referenced is Welcome, which references it by hash.",
              "createdAt": "2019-11-16T20:54:59Z",
              "updatedAt": "2020-01-29T22:04:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3OTg4NjE2",
          "commit": {
            "abbreviatedOid": "cef2419"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-16T20:55:19Z",
          "updatedAt": "2019-11-16T20:55:19Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "OK, sure, whatever :)",
              "createdAt": "2019-11-16T20:55:19Z",
              "updatedAt": "2020-01-29T22:04:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3OTg5MTU0",
          "commit": {
            "abbreviatedOid": "cef2419"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-16T21:10:34Z",
          "updatedAt": "2019-11-16T21:10:34Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "It might be fine to use the hash as an implicit identifier for outside the protocol for now but I suspect that in some applications we'll want the application to pick the identifier.",
              "createdAt": "2019-11-16T21:10:34Z",
              "updatedAt": "2020-01-29T22:04:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3OTg5NzQx",
          "commit": {
            "abbreviatedOid": "cef2419"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-16T21:27:47Z",
          "updatedAt": "2019-11-16T21:27:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 247,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQxNzkxMDc3",
      "title": "Welcome confirmation and key derivation",
      "url": "https://github.com/mlswg/mls-protocol/pull/247",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement",
        "security"
      ],
      "body": "1. Once a new member instantiates the group state, they can verify the confirmation MAC that was sent in the Commit that created the state.  This lets new members verify that they've joined correctly.  (It does not assure that they're seeing the same confirmation as anyone else.)\r\n\r\n2. Instead of generating a fresh key, we can simply provide the epoch key in the key package and derive the GroupInfo encryption key from it.  This avoids relying on fresh entropy, and makes it more difficult for the sender to provide different keys that will all decrypt and authenticate the GroupInfo.",
      "createdAt": "2019-11-16T20:52:47Z",
      "updatedAt": "2020-01-31T15:09:13Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "f52047aa4efc1e089c5bcd4c81c6eee6a90cefa5",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "welcome-confirmation",
      "headRefOid": "d460925cac306275e529a6c657e74eed653cf11b",
      "closedAt": "2020-01-31T15:09:13Z",
      "mergedAt": "2020-01-31T15:09:13Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "f5f308ddc3cbe8eae68867231e1d79242e6a512f"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "This appears to have been rendered obsolete by #265 ",
          "createdAt": "2020-01-29T21:47:50Z",
          "updatedAt": "2020-01-29T21:47:50Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Actually this is the nice one providing the nice properties, unlike #265 which breaks the cryptographic properties we expect from the secrecy invariant (see #277)",
          "createdAt": "2020-01-30T10:48:56Z",
          "updatedAt": "2020-01-30T10:48:56Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, thank you for reminding me of #277! I will rebase this and merge.  ",
          "createdAt": "2020-01-30T14:23:37Z",
          "updatedAt": "2020-01-30T14:23:37Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3OTg5NzEw",
          "commit": {
            "abbreviatedOid": "e54b510"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-16T21:27:03Z",
          "updatedAt": "2019-11-16T21:27:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 251,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQyMzEwOTI3",
      "title": "Initial proposal for PSK inputs",
      "url": "https://github.com/mlswg/mls-protocol/pull/251",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "functionality",
        "security"
      ],
      "body": "This is for injection of out-of-band shared entropy.",
      "createdAt": "2019-11-18T19:06:32Z",
      "updatedAt": "2019-12-20T21:58:46Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "c99d7c11318d78545a15973776b6bb1cf62833ea",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_psk",
      "headRefOid": "8fddd9af921b76f9b88bc41b9a65b4626c027b47",
      "closedAt": "2019-12-10T16:53:55Z",
      "mergedAt": "2019-12-10T16:53:55Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "3eee58aa2ba2896a0f28fb9e1c6df16245b6fee7"
      },
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Note that an alternative to this is to make PSK a proposal containing a PSK identifier.",
          "createdAt": "2019-11-19T10:42:07Z",
          "updatedAt": "2019-11-19T10:42:23Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI5OTkwNzQy",
          "commit": {
            "abbreviatedOid": "8fddd9a"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-12-10T16:53:45Z",
          "updatedAt": "2019-12-10T16:53:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 252,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQyMzg2NjMy",
      "title": "Bugfixes: fix a few typos in text and structs",
      "url": "https://github.com/mlswg/mls-protocol/pull/252",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2019-11-18T22:11:01Z",
      "updatedAt": "2019-12-20T21:58:51Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "09110a985ad173c546c37707e90614ae54f7468a",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_bugfixes",
      "headRefOid": "f45e0d7f4d3399c24b7c348629e2c5afd50fa1ca",
      "closedAt": "2019-12-10T16:34:35Z",
      "mergedAt": "2019-12-10T16:34:35Z",
      "mergedBy": "raphaelrobert",
      "mergeCommit": {
        "oid": "c99d7c11318d78545a15973776b6bb1cf62833ea"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, I noticed that too as I was implementing. I will fix it in a\n\u201creconciliation with implementation\u201d PR I\u2019m working on.\n\nOn Tue, Dec 10, 2019 at 17:17 Brendan McMillion <notifications@github.com>\nwrote:\n\n> *@Bren2010* commented on this pull request.\n> ------------------------------\n>\n> In draft-ietf-mls-protocol.md\n> <https://github.com/mlswg/mls-protocol/pull/252#discussion_r356308100>:\n>\n> > @@ -1007,7 +1007,7 @@ of a `ParentNodeHashInput` struct:\n>  ~~~~~\n>  struct {\n>      HPKEPublicKey public_key;\n> -    uint32_t unmerged_leaves<0..2^32-1>;\n> +    opaque unmerged_leaves<0..2^32-1>;\n>\n> I don't think this is meant to be opaque. It's an array of leave indices\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/mlswg/mls-protocol/pull/252?email_source=notifications&email_token=AAASOTLZJ2TOMGNUCJASGPDQYAIONA5CNFSM4JO22YFKYY3PNVWWK3TUL52HS4DFWFIHK3DMKJSXC5LFON2FEZLWNFSXPKTDN5WW2ZLOORPWSZGOCOXDH2A#pullrequestreview-330183656>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAASOTL43RIIDNHMYAWLOUDQYAIONANCNFSM4JO22YFA>\n> .\n>\n",
          "createdAt": "2019-12-11T01:02:45Z",
          "updatedAt": "2019-12-11T01:02:45Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMwMTgzNjU2",
          "commit": {
            "abbreviatedOid": "f45e0d7"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-10T22:17:08Z",
          "updatedAt": "2019-12-10T22:17:09Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I don't think this is meant to be opaque. It's an array of leave indices",
              "createdAt": "2019-12-10T22:17:09Z",
              "updatedAt": "2019-12-10T22:17:09Z"
            }
          ]
        }
      ]
    },
    {
      "number": 253,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQyMzg3MDUw",
      "title": "Initial version of the Tree of Signature",
      "url": "https://github.com/mlswg/mls-protocol/pull/253",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "security"
      ],
      "body": "",
      "createdAt": "2019-11-18T22:12:13Z",
      "updatedAt": "2020-01-06T07:39:31Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "a72f07db7bfbbc1294754149cc9354b01322f846",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_sigtree",
      "headRefOid": "9a1664a2f1575378df5860f3672c3463db39e3db",
      "closedAt": "2019-12-20T21:13:50Z",
      "mergedAt": "2019-12-20T21:13:50Z",
      "mergedBy": "raphaelrobert",
      "mergeCommit": {
        "oid": "6555b94c457b22c3bf623c0f6ee29e6e14a1ca3f"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "It seems like there's a major thing missing here, namely how the sender of a Commit transmits the new node signatures to the other members of the group.  We need something like that before this lands.\r\n\r\nThe most obvious approach would be to add a `signature` field to DirectPathNode, as you have with RatchetNode.",
          "createdAt": "2019-12-10T21:14:45Z",
          "updatedAt": "2019-12-10T21:14:45Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "It would also be handy to include in the intermediate node an indication of which leaf signed it.  Otherwise you have to do \"trial verifications\" (cf. trial decryption), which is expensive.",
          "createdAt": "2019-12-10T21:19:36Z",
          "updatedAt": "2019-12-10T21:19:36Z"
        },
        {
          "author": "kelrit",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> It seems like there's a major thing missing here, namely how the sender of a Commit transmits the new node signatures to the other members of the group. We need something like that before this lands.\r\n> \r\n> The most obvious approach would be to add a `signature` field to DirectPathNode, as you have with RatchetNode.\r\n\r\nWas this addressed? it's mentioned that the signature should be transmitted in \"Synchronizing Views of the Tree\" but there's no signature in the transmitted DirectPathNode",
          "createdAt": "2020-01-03T22:16:27Z",
          "updatedAt": "2020-01-03T22:16:27Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "@kelrit #287 changes the strategy for signing the tree, everything should be sorted out there.",
          "createdAt": "2020-01-06T07:39:31Z",
          "updatedAt": "2020-01-06T07:39:31Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM1NDkwMDc1",
          "commit": {
            "abbreviatedOid": "a670098"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-20T19:55:20Z",
          "updatedAt": "2019-12-20T19:57:21Z",
          "comments": [
            {
              "originalPosition": 135,
              "body": "This is a good starting point, we should see if we need something fancier in the future, like a Merkle tree (or reuse the node hashes).",
              "createdAt": "2019-12-20T19:55:21Z",
              "updatedAt": "2019-12-20T20:51:26Z"
            },
            {
              "originalPosition": 92,
              "body": "Isn't this where we discussed that the signer's index is missing?",
              "createdAt": "2019-12-20T19:57:01Z",
              "updatedAt": "2019-12-20T20:51:26Z"
            }
          ]
        }
      ]
    },
    {
      "number": 254,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQyMzkyNjM4",
      "title": "Initial work to use CIK in leaves and CIK rotation",
      "url": "https://github.com/mlswg/mls-protocol/pull/254",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "functionality",
        "security"
      ],
      "body": "",
      "createdAt": "2019-11-18T22:27:04Z",
      "updatedAt": "2019-12-20T21:58:36Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "d1c8986d3ef932ae4a7cc05b4172d2762428fcd0",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_leafcik",
      "headRefOid": "02fefcc1fecfc0e834d2b4e4a4724a4763e97264",
      "closedAt": "2019-12-20T10:08:53Z",
      "mergedAt": "2019-12-20T10:08:53Z",
      "mergedBy": "raphaelrobert",
      "mergeCommit": {
        "oid": "a72f07db7bfbbc1294754149cc9354b01322f846"
      },
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "I went back and watched the recording of the last interim to get some context for this PR, and the motivation given there isn't entirely clear to me. The reasoning given then was:\r\n- We want to allow rotation of identity key.\r\n- This helps authenticate the leaf key by signing it.\r\n\r\nBut if we want to allow rotating the identity key, what we need is an operation that changes the `credential` field of the leaf. Putting the entire CIK in the leaf doesn't help that. And I imagine that the leaf key would already be signed by the changes required for #253.",
          "createdAt": "2019-12-09T18:37:22Z",
          "updatedAt": "2019-12-09T18:37:22Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Note that this PR will need to change Commit as well -- the DirectPath in the commit sets the HPKEPublicKey in the sender's leaf node.  Suggested fix:\r\n\r\n1. Update DirectPath so that the first node in the path is the one above the leaf (not the leaf itself)\r\n2. Add a new ClientInitKey field to Commit that replaces the leaf\r\n\r\nThat's also forward-compatible with hash-based solutions to tree signing (cf. #253), since we can just define a ClientInitKey extension that contains the hash to be signed.",
          "createdAt": "2019-12-10T21:18:51Z",
          "updatedAt": "2019-12-10T21:18:51Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "To answer my own question, putting the entire CIK in the leaf (instead of just, say, a single signature) means the ratchet tree will contain information about node capabilities. This makes it possible for members being added to a group to detect downgrade attacks.",
          "createdAt": "2019-12-16T22:17:27Z",
          "updatedAt": "2019-12-16T22:17:27Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMyOTE5MTg0",
          "commit": {
            "abbreviatedOid": "68a533c"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-12-16T22:47:38Z",
          "updatedAt": "2019-12-16T23:19:15Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Would be better to stick with \"generating\"",
              "createdAt": "2019-12-16T22:47:39Z",
              "updatedAt": "2019-12-20T10:07:28Z"
            },
            {
              "originalPosition": 26,
              "body": "- we've never abbreviated this before, CIK -> ClientInitKey\r\n- lowercase, See -> see\r\n- remove \"the\" in front of \"path_secret[0]\"",
              "createdAt": "2019-12-16T23:03:43Z",
              "updatedAt": "2019-12-20T10:07:28Z"
            },
            {
              "originalPosition": 25,
              "body": "associated to -> associated with",
              "createdAt": "2019-12-16T23:05:48Z",
              "updatedAt": "2019-12-20T10:07:28Z"
            },
            {
              "originalPosition": 27,
              "body": "- remove \"value\"\r\n- generates -> generate",
              "createdAt": "2019-12-16T23:06:25Z",
              "updatedAt": "2019-12-20T10:07:28Z"
            },
            {
              "originalPosition": 28,
              "body": "\"intermediate nodes between the leaf and the root\" -> \"ancestor of its leaf\"",
              "createdAt": "2019-12-16T23:07:40Z",
              "updatedAt": "2019-12-20T10:07:28Z"
            },
            {
              "originalPosition": 230,
              "body": "I would leave this sentence how it was, \"Likewise, ...\"",
              "createdAt": "2019-12-16T23:18:39Z",
              "updatedAt": "2019-12-20T10:07:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMzMDkxNTMx",
          "commit": {
            "abbreviatedOid": "68a533c"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-17T08:12:36Z",
          "updatedAt": "2019-12-17T08:12:37Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Work in progress... There is an editorial discussion going on between the editors to see what we should keep in the PR. That's likely gonna be discussed at the interim.",
              "createdAt": "2019-12-17T08:12:36Z",
              "updatedAt": "2019-12-20T10:07:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMzMDkxNjY0",
          "commit": {
            "abbreviatedOid": "68a533c"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-17T08:12:53Z",
          "updatedAt": "2019-12-17T08:12:53Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Thanks !",
              "createdAt": "2019-12-17T08:12:53Z",
              "updatedAt": "2019-12-20T10:07:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM1MTY5MDU5",
          "commit": {
            "abbreviatedOid": "02fefcc"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-12-20T10:08:38Z",
          "updatedAt": "2019-12-20T10:08:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 255,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQyMzk1ODA5",
      "title": "Move epoch numbers to UInt64",
      "url": "https://github.com/mlswg/mls-protocol/pull/255",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "enhancement"
      ],
      "body": "",
      "createdAt": "2019-11-18T22:35:40Z",
      "updatedAt": "2019-12-20T21:58:50Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "09110a985ad173c546c37707e90614ae54f7468a",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_epoch",
      "headRefOid": "898e8629646f6976186edffa471c21e564347a0e",
      "closedAt": "2019-12-10T15:56:01Z",
      "mergedAt": "2019-12-10T15:56:00Z",
      "mergedBy": "raphaelrobert",
      "mergeCommit": {
        "oid": "6fc93429ad31553ca34f657f457da54272a962b0"
      },
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "#245 might invalidate this, but in the meantime we should go ahead with this!",
          "createdAt": "2019-11-28T14:07:33Z",
          "updatedAt": "2019-11-28T14:07:33Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI0MzA5MDc3",
          "commit": {
            "abbreviatedOid": "898e862"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-28T14:08:13Z",
          "updatedAt": "2019-11-28T14:08:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 256,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQyMzk3MjE5",
      "title": "Remove OPEN ISSUE: the entire group context is now in the signature",
      "url": "https://github.com/mlswg/mls-protocol/pull/256",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2019-11-18T22:39:57Z",
      "updatedAt": "2019-12-20T21:58:49Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "09110a985ad173c546c37707e90614ae54f7468a",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_rem_openissue",
      "headRefOid": "ca67895547bb4e9615fc51045e38a058949bd0ad",
      "closedAt": "2019-12-10T15:54:41Z",
      "mergedAt": "2019-12-10T15:54:41Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "c6bbdcd315d2201fb85681a3dc12d3d201135acf"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI5OTQzNjA5",
          "commit": {
            "abbreviatedOid": "ca67895"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-12-10T15:54:32Z",
          "updatedAt": "2019-12-10T15:54:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 257,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQyNDA5NzI3",
      "title": "Make clear that Commits are responsible for FS and PCS",
      "url": "https://github.com/mlswg/mls-protocol/pull/257",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2019-11-18T23:19:50Z",
      "updatedAt": "2019-12-20T21:58:47Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "09110a985ad173c546c37707e90614ae54f7468a",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_us_to_cs",
      "headRefOid": "6d6074ee4504ad7452353704479cd499035dd964",
      "closedAt": "2019-12-10T15:54:05Z",
      "mergedAt": "2019-12-10T15:54:05Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "5140d9417f022f9313ac4ae4eb7355f18a12d517"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI5OTQzMTM4",
          "commit": {
            "abbreviatedOid": "6d6074e"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-12-10T15:53:58Z",
          "updatedAt": "2019-12-10T15:53:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 259,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQzODYwNDM0",
      "title": "Remove blanking of nodes on Add, clarify language",
      "url": "https://github.com/mlswg/mls-protocol/pull/259",
      "state": "MERGED",
      "author": "kelrit",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "- Blanking on add (I think) was obsoleted by unmerged leaves\r\n- Add leaf to unmerged list for *non-blank* nodes on add\r\n- There are now four elements in each node",
      "createdAt": "2019-11-21T06:08:10Z",
      "updatedAt": "2019-12-17T08:36:57Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "09110a985ad173c546c37707e90614ae54f7468a",
      "headRepository": "kelrit/mls-protocol",
      "headRefName": "master",
      "headRefOid": "f9d003b76c69b80c429396ef90db54c847968300",
      "closedAt": "2019-11-21T08:55:01Z",
      "mergedAt": "2019-11-21T08:55:01Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "bff920cf70b0de0ae5e2a71ae85ddf66615fe443"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIwNzIwODc5",
          "commit": {
            "abbreviatedOid": "f9d003b"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Nice catch, Thank you !",
          "createdAt": "2019-11-21T08:54:54Z",
          "updatedAt": "2019-11-21T08:54:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 263,
      "id": "MDExOlB1bGxSZXF1ZXN0MzUxMTU2OTIx",
      "title": "Change special values to structed types for external senders",
      "url": "https://github.com/mlswg/mls-protocol/pull/263",
      "state": "MERGED",
      "author": "kelrit",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "discussion"
      ],
      "body": "Action item from Singapore: it seems better to specify directly in the message if we have an external sender instead of using reserved ranges.",
      "createdAt": "2019-12-10T01:40:21Z",
      "updatedAt": "2020-01-03T15:20:10Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "9426b880dace5a105405196b347e7e493f3677ac",
      "headRepository": "kelrit/mls-protocol",
      "headRefName": "master",
      "headRefOid": "d8bbe3d4e0692669d58a132ddab5d3d33d3d081b",
      "closedAt": "2020-01-03T15:20:09Z",
      "mergedAt": "2020-01-03T15:20:09Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "02bf13ebad9a8efd675f6c30c3261dcf6191f179"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMwMTQxMzg3",
          "commit": {
            "abbreviatedOid": "de1672b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "@kelrit - Overall I think this is on the right track.  A few comments that should be easy to address.",
          "createdAt": "2019-12-10T21:00:54Z",
          "updatedAt": "2019-12-10T21:10:12Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "I'm not sure \"authority\" is quite the semantic here.  Maybe just \"external\" or \"preconfigured\"?",
              "createdAt": "2019-12-10T21:00:54Z",
              "updatedAt": "2020-01-03T01:49:57Z"
            },
            {
              "originalPosition": 17,
              "body": "I think something like `new_member` might be clearer here.",
              "createdAt": "2019-12-10T21:01:46Z",
              "updatedAt": "2020-01-03T01:49:57Z"
            },
            {
              "originalPosition": 30,
              "body": "There's no need to use the full `Sender` struct here, since you have to be a member to send an `MLSCiphertext`; just use uint32.  In other words, encrypting an MLSPlaintext with `Sender.sender_type != member` is an error, and an MLSPlaintext decrypted from an MLSCiphertext always has `Sender.sender_type != member`.",
              "createdAt": "2019-12-10T21:06:14Z",
              "updatedAt": "2020-01-03T01:49:57Z"
            },
            {
              "originalPosition": 30,
              "body": "As a bonus, this makes it syntactically impossible for an external sender to send an MLSCiphertext.",
              "createdAt": "2019-12-10T21:06:47Z",
              "updatedAt": "2020-01-03T01:49:57Z"
            },
            {
              "originalPosition": 54,
              "body": "Don't need the tag; it's auto-generated from the title itself.",
              "createdAt": "2019-12-10T21:07:18Z",
              "updatedAt": "2020-01-03T01:49:57Z"
            },
            {
              "originalPosition": 76,
              "body": "Rather than ignoring, I would suggest that it MUST be zero.",
              "createdAt": "2019-12-10T21:07:56Z",
              "updatedAt": "2020-01-03T01:49:57Z"
            },
            {
              "originalPosition": 72,
              "body": "Note that `external` is not defined above, but probably should be :)\r\n\r\nAlso, this should be \"`external` or `new_member`\" (or whatever words we decide on).",
              "createdAt": "2019-12-10T21:08:56Z",
              "updatedAt": "2020-01-03T01:49:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMwMjc2NTUx",
          "commit": {
            "abbreviatedOid": "de1672b"
          },
          "author": "kelrit",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-11T03:11:35Z",
          "updatedAt": "2019-12-11T03:11:36Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "iiuc - the proposal is to treat all MLSPlaintexts as `member` sender types? That would mean external senders would need some other mechanism for sender? How can we differentiate between self add and a preconfigured sender?\r\n\r\nI'm confused by this comment - were you thinking this was in MLSSenderData?",
              "createdAt": "2019-12-11T03:11:35Z",
              "updatedAt": "2020-01-03T01:49:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM3ODYwMjcz",
          "commit": {
            "abbreviatedOid": "3efbcb1"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-02T21:10:48Z",
          "updatedAt": "2020-01-02T21:13:56Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "There's a difference between MLSPlaintext and MLSCiphertext here.  An MLSPlaintext can be constructed and sent by anyone; all you need is a signing key that is known to the group.  In order to construct an MLSCiphertext, you have to be a member of the group, since otherwise you won't have the right symmetric keys.  In other words, external senders can only send *unencrypted* messages to the group right now.  (I think Raphael is working on a PR to enable encryption to the group from outside.)",
              "createdAt": "2020-01-02T21:10:48Z",
              "updatedAt": "2020-01-03T01:49:57Z"
            },
            {
              "originalPosition": 45,
              "body": "In light of the above discussion, I would suggest adding a step to the encryption where the sender verifies that the `MLSPlaintext.sender.type == member`, then copies `MLSPlaintext.sender.sender` to `MLSCiphertext.sender`. ",
              "createdAt": "2020-01-02T21:12:50Z",
              "updatedAt": "2020-01-03T01:49:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM3OTI4Mzg0",
          "commit": {
            "abbreviatedOid": "3efbcb1"
          },
          "author": "kelrit",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-03T01:48:16Z",
          "updatedAt": "2020-01-03T01:48:17Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Yea - I think we are on the same page. MLSPlaintext can be sent by anyone (in or outside the group) so it needs a full Sender object to disambiguate. However MLSCiphertext needs only the sender index, which is done by keeping MLSSenderData as is.",
              "createdAt": "2020-01-03T01:48:16Z",
              "updatedAt": "2020-01-03T01:49:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM3OTI4NzI1",
          "commit": {
            "abbreviatedOid": "d8bbe3d"
          },
          "author": "kelrit",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-03T01:51:12Z",
          "updatedAt": "2020-01-03T01:51:12Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "It wasn't quite clear where that'd go; I re-organized the steps to be a little more clear and put in a check when constructing MLSSenderData objects (which is the only place in MLSCiphertext where the sender is identified)",
              "createdAt": "2020-01-03T01:51:12Z",
              "updatedAt": "2020-01-03T01:51:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM3OTQ3MzQw",
          "commit": {
            "abbreviatedOid": "d8bbe3d"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-03T04:38:06Z",
          "updatedAt": "2020-01-03T04:38:11Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Oh I see.  I was mistaken about what line we were looking at.  LGTM.",
              "createdAt": "2020-01-03T04:38:06Z",
              "updatedAt": "2020-01-03T04:38:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM3OTQ3Mzcz",
          "commit": {
            "abbreviatedOid": "d8bbe3d"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-03T04:38:23Z",
          "updatedAt": "2020-01-03T04:38:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 265,
      "id": "MDExOlB1bGxSZXF1ZXN0MzUxOTY2OTM1",
      "title": "Align spec text with implementation",
      "url": "https://github.com/mlswg/mls-protocol/pull/265",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "? follow-up",
        "bug"
      ],
      "body": "I have managed to implement Proposal / Commit in mlspp, but it required some modifications to the Welcome and Commit structs and processes.  Two major things to point out:\r\n\r\n* This PR proposes to send the same DirectPath to both new members and current members.  This avoids the need to have two code paths and special tree math to implant path secrets, at the cost of some bloat in the Welcome and Commit messages.\r\n\r\n* As a result, the sequencing of GroupContexts is a bit tricky.  The GroupContext used for encrypting/decrypting DirectPaths is an intermediate context -- the new group context, but *before the transcript is updated*.  \r\n\r\nAll that said, this version is [verified implementable](https://github.com/cisco/mlspp/pull/64).  The implementation exercise highlighted that the net effect of Proposal/Commit was to isolate basically all of the state management complexity to three methods in the client stack:\r\n\r\n* Processing of Welcome messages\r\n* Generation of Commit+Welcome messages\r\n* Processing of Commit messages\r\n\r\nThis PR reflects the algorithms for those three things.",
      "createdAt": "2019-12-11T15:16:43Z",
      "updatedAt": "2019-12-22T11:55:47Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "6555b94c457b22c3bf623c0f6ee29e6e14a1ca3f",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "impl",
      "headRefOid": "ac784c5acfc4415a5a42145f5a8fd7281ec02d65",
      "closedAt": "2019-12-22T11:46:01Z",
      "mergedAt": "2019-12-22T11:46:01Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "9426b880dace5a105405196b347e7e493f3677ac"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@beurdouche I added one minor change (order of fields) and rebased.  I think this is ready to merge.  I'm also about to drop offline for a bit, so please pull the trigger if it looks good to you.",
          "createdAt": "2019-12-21T20:15:47Z",
          "updatedAt": "2019-12-21T20:16:10Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Ack, I\u2019ll take a look in tonight or tomorrow morning and merge it.",
          "createdAt": "2019-12-21T20:26:00Z",
          "updatedAt": "2019-12-22T11:55:47Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "I am merging this now because it includes fixes we definitely need even though I note that I have one philosophical concern and one security concern...\r\n\r\n1. Multiplying the numbers of transcript hashes in the state is an implementation concern and not a protocol concern, I would much prefer keep only the real (confirmed) transcript hash. (The implementation should keep the current state and one provisional updated state but the struct shouldn't have to keep both)\r\n2. Sending the init_secret and the update_secret at once *seem* equivalent to sending the epoch secret but I don't think it is actually the case since it could be rejected by the DS, breaking the encryption key of that message would hence still have consequences even if the message is rejected. I'll open an issue for that.",
          "createdAt": "2019-12-22T11:45:54Z",
          "updatedAt": "2019-12-22T11:45:54Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMxMjc0MDI4",
          "commit": {
            "abbreviatedOid": "d589270"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Ok, this looks good to me. I think we don't have to derive that many keys in the main KS but that's ok for now, we can optimize later.",
          "createdAt": "2019-12-12T14:36:45Z",
          "updatedAt": "2019-12-12T15:20:01Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "I actually forgot about the fact we had typed vectors in the syntax, sorry about that... : )",
              "createdAt": "2019-12-12T14:36:46Z",
              "updatedAt": "2019-12-21T20:14:02Z"
            },
            {
              "originalPosition": 77,
              "body": "I guess we don't have to generate a Welcome message if there is no `add` proposals in the Commit.\r\nShould we clarify that here ?",
              "createdAt": "2019-12-12T14:41:11Z",
              "updatedAt": "2019-12-21T20:14:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMyODk5OTkw",
          "commit": {
            "abbreviatedOid": "d589270"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-12-16T22:08:00Z",
          "updatedAt": "2019-12-16T22:45:25Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "`Proposal proposal` (singular)",
              "createdAt": "2019-12-16T22:08:00Z",
              "updatedAt": "2019-12-21T20:14:02Z"
            },
            {
              "originalPosition": 68,
              "body": "Update line 1849 to reflect this change",
              "createdAt": "2019-12-16T22:39:16Z",
              "updatedAt": "2019-12-21T20:14:02Z"
            },
            {
              "originalPosition": 91,
              "body": "Nit: one space between sentences",
              "createdAt": "2019-12-16T22:42:16Z",
              "updatedAt": "2019-12-21T20:14:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMzNDc5NTgz",
          "commit": {
            "abbreviatedOid": "d589270"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-17T18:15:59Z",
          "updatedAt": "2019-12-17T18:15:59Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "Please also update MLSPlaintextSignatureInput",
              "createdAt": "2019-12-17T18:15:59Z",
              "updatedAt": "2019-12-21T20:14:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMzNDgwMTA5",
          "commit": {
            "abbreviatedOid": "d589270"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-17T18:16:50Z",
          "updatedAt": "2019-12-17T18:16:50Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "Please also change to the singular in MLSPlaintext",
              "createdAt": "2019-12-17T18:16:50Z",
              "updatedAt": "2019-12-21T20:14:02Z"
            }
          ]
        }
      ]
    },
    {
      "number": 274,
      "id": "MDExOlB1bGxSZXF1ZXN0MzU1ODA0ODQ5",
      "title": "Fix contexts and simplify key schedule",
      "url": "https://github.com/mlswg/mls-protocol/pull/274",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "? follow-up",
        "enhancement",
        "security",
        "work in progress"
      ],
      "body": "This is a fix for #264 as well as for missing context that was previously partially added in the messages but not in the Tree intermediate derivations.\r\n\r\nThe changes are centered around putting back the `transcript_hash` (aka the full history) to be what should be included as default context.",
      "createdAt": "2019-12-20T16:31:13Z",
      "updatedAt": "2020-03-04T18:20:44Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "a72f07db7bfbbc1294754149cc9354b01322f846",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_txh",
      "headRefOid": "072d87ecc57d5c7ee28f13e6aede6d00889c5927",
      "closedAt": "2020-03-04T18:20:43Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "@bifurcation Yes, this is still a \"Work in Progress\" and is labeled as such... :) \r\nIt will probably not be updated it before RWC... I'll ping when it is in a reasonable state.",
          "createdAt": "2019-12-28T16:07:55Z",
          "updatedAt": "2019-12-28T16:07:55Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing for now.  Happy to reconsider on refresh/rebase.",
          "createdAt": "2020-03-04T18:20:43Z",
          "updatedAt": "2020-03-04T18:20:43Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM2OTE5MTUy",
          "commit": {
            "abbreviatedOid": "072d87e"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-12-28T15:09:18Z",
          "updatedAt": "2019-12-28T15:17:35Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I would prefer to spell this out, if we have horizontal space",
              "createdAt": "2019-12-28T15:09:19Z",
              "updatedAt": "2019-12-28T15:17:35Z"
            },
            {
              "originalPosition": 54,
              "body": "I don't understand your proposal here.  The transcript hash you define has an odd structure -- it only covers the CommitContent, not the AuthData.  So the confirmation hashes and signatures are not covered.  It's as if the TLS transcript hash didn't include CertificateVerify or Finished.  Is that your intent?",
              "createdAt": "2019-12-28T15:12:58Z",
              "updatedAt": "2019-12-28T15:17:35Z"
            },
            {
              "originalPosition": 54,
              "body": "In any case, if you're going to remove the interim transcript hash, you need to do more radical surgery.   For example, MLSPlaintextCommitAuthData is no longer needed; likewise much of the prose below.",
              "createdAt": "2019-12-28T15:13:56Z",
              "updatedAt": "2019-12-28T15:17:35Z"
            },
            {
              "originalPosition": 16,
              "body": "Here and below, I would prefer if we expanded this.",
              "createdAt": "2019-12-28T15:15:15Z",
              "updatedAt": "2019-12-28T15:17:35Z"
            },
            {
              "originalPosition": 140,
              "body": "Nit: Extra blank line.",
              "createdAt": "2019-12-28T15:15:52Z",
              "updatedAt": "2019-12-28T15:17:35Z"
            }
          ]
        }
      ]
    },
    {
      "number": 275,
      "id": "MDExOlB1bGxSZXF1ZXN0MzU1ODExMDkx",
      "title": "Mandate expiration of ClientInitKeys and presence of some extensions",
      "url": "https://github.com/mlswg/mls-protocol/pull/275",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "enhancement",
        "ready to merge",
        "security"
      ],
      "body": "",
      "createdAt": "2019-12-20T16:48:44Z",
      "updatedAt": "2020-03-05T23:05:19Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "a72f07db7bfbbc1294754149cc9354b01322f846",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_expiration",
      "headRefOid": "35d2aa847080c2f24e44dd4fee0965495430276f",
      "closedAt": "2020-03-05T23:05:18Z",
      "mergedAt": "2020-03-05T23:05:18Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "3dc9603bfdc4ac4ef56391927988cb32654dd9cd"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM3ODU4MTUz",
          "commit": {
            "abbreviatedOid": "026f92f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-01-02T21:05:26Z",
          "updatedAt": "2020-01-02T21:06:43Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "There are two extensions here.  So if you mean both of them, you should say so.",
              "createdAt": "2020-01-02T21:05:26Z",
              "updatedAt": "2020-03-05T23:03:40Z"
            },
            {
              "originalPosition": 24,
              "body": "The need for this is not clear to me.  Let's discuss this at the interim before merging this PR.",
              "createdAt": "2020-01-02T21:06:28Z",
              "updatedAt": "2020-03-05T23:03:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5MDA5NTg3",
          "commit": {
            "abbreviatedOid": "a1daf63"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-04T18:16:06Z",
          "updatedAt": "2020-03-04T18:16:07Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "This was discussed at the interim, and people were comfortable with this requirement.",
              "createdAt": "2020-03-04T18:16:06Z",
              "updatedAt": "2020-03-05T23:03:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5MDA5NjE4",
          "commit": {
            "abbreviatedOid": "a1daf63"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-04T18:16:09Z",
          "updatedAt": "2020-03-04T18:16:09Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5MDUzMDIz",
          "commit": {
            "abbreviatedOid": "a1daf63"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-03-04T19:19:20Z",
          "updatedAt": "2020-03-04T19:34:52Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\nThese extensions MUST be always present in a ClientInitKey.\r\n```",
              "createdAt": "2020-03-04T19:19:20Z",
              "updatedAt": "2020-03-05T23:03:40Z"
            },
            {
              "originalPosition": 24,
              "body": "```suggestion\r\nThis extension MUST always be present in a ClientInitKey.\r\n```",
              "createdAt": "2020-03-04T19:20:44Z",
              "updatedAt": "2020-03-05T23:03:40Z"
            },
            {
              "originalPosition": 22,
              "body": "The expiration of ClientInitKeys is important for PCS, so setting to the maximum value shouldn't be encouraged. If you have keys that never expire and you're compromised, those keys can be used at any time in the future to \"add\" you to a group when they're actually giving the adversary access.\r\n\r\nLast Resort keys are a defense against DoS, when somebody sends you a lot of messages in a short period of time. As such, any ClientInitKey can be a Last Resort key, regardless of how long it's valid for, because nobody is checking how many times a specific key gets used.\r\n\r\nLast Resort keys are not a suitable defense against the user being offline for an arbitrary amount of time. Handling this securely probably requires more consideration.\r\n\r\nWe should recommend an application-specified maximum duration, and switch to a `(notBefore, notAfter)` system so that everyone know's the key's lifetime.",
              "createdAt": "2020-03-04T19:34:46Z",
              "updatedAt": "2020-03-05T23:03:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5OTc2ODAy",
          "commit": {
            "abbreviatedOid": "35d2aa8"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-05T23:05:11Z",
          "updatedAt": "2020-03-05T23:05:12Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "This would take things in a bit of a different direction, and needs more discussion.  I'm going to go ahead and merge this now, but feel free to file an issue.",
              "createdAt": "2020-03-05T23:05:11Z",
              "updatedAt": "2020-03-05T23:05:12Z"
            }
          ]
        }
      ]
    },
    {
      "number": 278,
      "id": "MDExOlB1bGxSZXF1ZXN0MzU3Mzg4MjQx",
      "title": "Review of sections 1-6.",
      "url": "https://github.com/mlswg/mls-protocol/pull/278",
      "state": "CLOSED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial",
        "ready for review (by editors)"
      ],
      "body": "- Rewrite some outdated sections related to proposals\r\n- Prefer \"forward secrecy\" and \"post-compromise security\" over variants\r\n- Prefer \"AES-GCM-128\" over variants\r\n- Prefer not to use \"i.e.\" and \"e.g.\"",
      "createdAt": "2019-12-28T04:28:26Z",
      "updatedAt": "2020-01-15T11:53:10Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "02bf13ebad9a8efd675f6c30c3261dcf6191f179",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2019.12.0",
      "headRefOid": "3c21673317fd2fad85a0201ad5002385ebbb57c4",
      "closedAt": "2020-01-15T11:53:10Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "@raphaelrobert @beurdouche Any objections to this being merged?",
          "createdAt": "2020-01-13T18:10:27Z",
          "updatedAt": "2020-01-13T18:10:27Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I think it's generally fine, but I'll let @beurdouche have the final say in this",
          "createdAt": "2020-01-14T17:13:13Z",
          "updatedAt": "2020-01-14T17:13:13Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Yes, it is globally fine, I will merge that soon enough as part of an editorial pass I will do.\n\n> On Jan 14, 2020, at 6:13 PM, raphaelrobert <notifications@github.com> wrote:\n> \n> \ufeff\n> I think it's generally fine, but I'll let @beurdouche have the final say in this\n> \n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub, or unsubscribe.\n",
          "createdAt": "2020-01-14T17:57:41Z",
          "updatedAt": "2020-01-14T17:57:41Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "I would like this merged sooner rather than later please",
          "createdAt": "2020-01-14T20:59:00Z",
          "updatedAt": "2020-01-14T20:59:00Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Ack\n\n> On Jan 14, 2020, at 9:59 PM, Brendan McMillion <notifications@github.com> wrote:\n> \n> \ufeff\n> I would like this merged sooner rather than later please\n> \n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub, or unsubscribe.\n",
          "createdAt": "2020-01-14T21:05:01Z",
          "updatedAt": "2020-01-14T21:05:01Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Merged+Editorial in #292 \r\nChanges in 5b2651d60babab8fd43d53d421e9db89e742d083",
          "createdAt": "2020-01-15T11:53:10Z",
          "updatedAt": "2020-01-15T11:53:10Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM2OTAwNzI5",
          "commit": {
            "abbreviatedOid": "3801af9"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-28T04:29:14Z",
          "updatedAt": "2019-12-28T04:29:15Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": ".editorconfig files are not a very common thing, but I'm curious if others think it would be helpful",
              "createdAt": "2019-12-28T04:29:14Z",
              "updatedAt": "2020-01-06T01:14:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM2OTExNzkx",
          "commit": {
            "abbreviatedOid": "3801af9"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-28T11:10:36Z",
          "updatedAt": "2019-12-28T11:10:36Z",
          "comments": [
            {
              "originalPosition": 270,
              "body": "FYI, this section is currently being rewritten in #279.",
              "createdAt": "2019-12-28T11:10:36Z",
              "updatedAt": "2020-01-06T01:14:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM3MTE3MjY0",
          "commit": {
            "abbreviatedOid": "0d0937e"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Two minor things, otherwise LGTM",
          "createdAt": "2019-12-30T14:12:07Z",
          "updatedAt": "2020-01-02T20:57:46Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "I don't agree with this.  The leaf key (pair) is the asymmetric key pair at the leaf, not the secret, and I like the explanation.  How about:\r\n\r\n> An HPKE key pair that can be used to encrypt to a specific client, so called because members' leaf keys are the leaves in the group's ratchet tree.",
              "createdAt": "2019-12-30T14:12:07Z",
              "updatedAt": "2020-01-06T01:14:49Z"
            },
            {
              "originalPosition": 46,
              "body": "Thanks, this description is better.  It seems like this is missing a step, though: the new members initialize from a `Welcome` message corresponding to the Commit.",
              "createdAt": "2019-12-30T14:13:58Z",
              "updatedAt": "2020-01-06T01:14:49Z"
            },
            {
              "originalPosition": 7,
              "body": "I don't have an opinion here.  @beurdouche @raphaelrobert ?",
              "createdAt": "2020-01-02T20:56:34Z",
              "updatedAt": "2020-01-06T01:14:49Z"
            }
          ]
        }
      ]
    },
    {
      "number": 279,
      "id": "MDExOlB1bGxSZXF1ZXN0MzU3NDQwOTky",
      "title": "Bring back more ciphersuites",
      "url": "https://github.com/mlswg/mls-protocol/pull/279",
      "state": "MERGED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "enhancement",
        "ready to merge"
      ],
      "body": "",
      "createdAt": "2019-12-28T11:06:55Z",
      "updatedAt": "2020-03-25T00:07:59Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "9426b880dace5a105405196b347e7e493f3677ac",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "raphael_ciphersuites",
      "headRefOid": "0606ce7c64730b54d569aef11c137142942a0927",
      "closedAt": "2020-03-05T22:57:09Z",
      "mergedAt": "2020-03-05T22:57:09Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "74380c5a193277e696d39a0d7554fd9243cd3d9b"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "It seems like we have a few separable issues here:\r\n1. Whether we require a single signature scheme for the whole group\r\n2. Whether signature schemes are included in the ciphersuite\r\n3. Whether we have an MTI ciphersuite / signature algorithm\r\n4. What new ciphersuites should be defined, and what algorithms should go in them\r\n\r\nLet's discuss this at the interim and maybe break this PR into a few bits",
          "createdAt": "2020-01-03T16:00:47Z",
          "updatedAt": "2020-01-03T16:00:47Z"
        },
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Note that specification required registries imply that there is a designated expert pool. I will add some text to create one. The text is very similar to the TLS DE pool text from [RFC8447](https://datatracker.ietf.org/doc/rfc8447/) with some tweaks that, hopefully, address the misunderstandings uncovered during non-standards track registry requests.\r\n\r\nNote the process is: (assuming that the IESG eventually approves this draft) When the IESG approves this draft, the responsible AD assigns some DEs (like 2-3 suggested by the WG chairs). These DEs are in charge of all registrations regardless of whether the draft comes from the WG or elsewhere as all requests go to the MLS DEs mailing list.",
          "createdAt": "2020-02-13T02:37:17Z",
          "updatedAt": "2020-02-13T02:37:17Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM2OTIxNTU1",
          "commit": {
            "abbreviatedOid": "7ac6156"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "The file no longer compiles, not sure why",
          "createdAt": "2019-12-28T16:20:10Z",
          "updatedAt": "2019-12-28T16:28:13Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Now the CipherSuite type is never defined",
              "createdAt": "2019-12-28T16:20:11Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            },
            {
              "originalPosition": 112,
              "body": "Please update line 810 to say that ciphersuites are defined by: KEM, AEAD, HASH, SIG.",
              "createdAt": "2019-12-28T16:22:58Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            },
            {
              "originalPosition": 131,
              "body": "Shouldn't the mandatory suite be P-256? X25519 has never been mandatory",
              "createdAt": "2019-12-28T16:25:36Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            },
            {
              "originalPosition": 27,
              "body": "I would make this section at the same level as \"Ciphersuites\" (so \"## Diffie-Hellman Groups\") and add explainer text that DH groups are used to build KEMs with HPKE",
              "createdAt": "2019-12-28T16:25:45Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            },
            {
              "originalPosition": 84,
              "body": "A ciphersuite is a combination of a protocol version and the set of cryptographic algorithms that should be used.",
              "createdAt": "2019-12-28T16:27:35Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM2OTIyMjI4",
          "commit": {
            "abbreviatedOid": "7ac6156"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-28T16:40:06Z",
          "updatedAt": "2019-12-28T16:40:06Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "It is defined in section \"MLS Ciphersuites\" as a two byte value now.",
              "createdAt": "2019-12-28T16:40:06Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM2OTIyMzIw",
          "commit": {
            "abbreviatedOid": "7ac6156"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-28T16:43:31Z",
          "updatedAt": "2019-12-28T16:43:32Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "The missing part would be the signature, but the context here is \"primitives to be used in group key computations\".\r\nI guess we could reference HPKE here.",
              "createdAt": "2019-12-28T16:43:32Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM2OTIyMzcw",
          "commit": {
            "abbreviatedOid": "7ac6156"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-28T16:45:02Z",
          "updatedAt": "2019-12-28T16:45:03Z",
          "comments": [
            {
              "originalPosition": 131,
              "body": "> Shouldn't the mandatory suite be P-256?\r\n\r\nWhy?\r\n\r\n> X25519 has never been mandatory\r\n\r\nIt has always been so far",
              "createdAt": "2019-12-28T16:45:02Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM2OTIyNDQx",
          "commit": {
            "abbreviatedOid": "7ac6156"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-28T16:47:51Z",
          "updatedAt": "2019-12-28T16:47:52Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "Thanks, will address this in another commit.",
              "createdAt": "2019-12-28T16:47:51Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM2OTIyNTc3",
          "commit": {
            "abbreviatedOid": "7ac6156"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-28T16:52:00Z",
          "updatedAt": "2019-12-28T16:52:00Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "I'll add the explainer, but I think it makes sense to keep it at this level, since it is about ciphersuites after all.",
              "createdAt": "2019-12-28T16:52:00Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM2OTIyNjk2",
          "commit": {
            "abbreviatedOid": "5f69d5f"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-28T16:55:59Z",
          "updatedAt": "2019-12-28T16:55:59Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "(added)",
              "createdAt": "2019-12-28T16:55:59Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM3NDYwODA0",
          "commit": {
            "abbreviatedOid": "7ac6156"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-12-31T22:54:22Z",
          "updatedAt": "2019-12-31T23:14:26Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "Signature algorithms are not part of the ciphersuite, they're specified in the credentials.",
              "createdAt": "2019-12-31T22:54:23Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            },
            {
              "originalPosition": 107,
              "body": "I would drop the versions; ciphers should be able to be used across versions.",
              "createdAt": "2019-12-31T22:55:04Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            },
            {
              "originalPosition": 108,
              "body": "This doesn't seem all that useful, I would drop it.",
              "createdAt": "2019-12-31T22:56:02Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            },
            {
              "originalPosition": 118,
              "body": "Instead of \"HPKE\", these should say \"DHKEM\".  Or we could just say that when a curve group is listed here, it indicates that DHKEM is in use.  I would prefer the latter, since it's more succinct.  Together with the above, that would get you back to something of similar size to what we have now, e.g., `MLS_X25519_AES128GCM_SHA256`",
              "createdAt": "2019-12-31T22:59:04Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            },
            {
              "originalPosition": 130,
              "body": "Adding an MTI should be a separate PR.",
              "createdAt": "2019-12-31T22:59:27Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            },
            {
              "originalPosition": 23,
              "body": "I think you need a bit more description here, just to say what a ciphersuite indicates, namely:\r\n\r\n* Parameters for an instance of HPKE\r\n* A KDF to be used \r\n* As a consequence, a Derive-Key-Pair function, as defined below.",
              "createdAt": "2019-12-31T23:07:20Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            },
            {
              "originalPosition": 23,
              "body": "Also, does `{{MLS Ciphersuites}}` actually work?  Might need to be `{{mls-ciphersuites}}`.",
              "createdAt": "2019-12-31T23:09:16Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            },
            {
              "originalPosition": 27,
              "body": "This extra section heading doesn't seem necessary.",
              "createdAt": "2019-12-31T23:10:08Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            },
            {
              "originalPosition": 54,
              "body": "Should we use HKDF instead of SHA directly?  In other words, make node secrets variable-length, where the length is determined by the KEM in use.\r\n\r\n* P256, X25519: 32 bytes\r\n* X448: 56 bytes\r\n* P521: 66 bytes\r\n\r\nAs a bonus, that would save a couple of hash invocations.",
              "createdAt": "2019-12-31T23:13:52Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM3NjY3MzA1",
          "commit": {
            "abbreviatedOid": "5f69d5f"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-02T13:55:42Z",
          "updatedAt": "2020-01-02T13:55:43Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "Have we decided on that? In theory there could be different signature algorithms for credentials and message signing. Since credentials are completely defined by the AS, it might be tricky to get consensus when picking the CIKs.",
              "createdAt": "2020-01-02T13:55:43Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM3NjY3NzE1",
          "commit": {
            "abbreviatedOid": "5f69d5f"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-02T13:56:50Z",
          "updatedAt": "2020-01-02T13:56:50Z",
          "comments": [
            {
              "originalPosition": 107,
              "body": "I wanted to avoid exactly that scenario, it could be dangerous to re-use ciphersuites between versions is the primitives are used for a different purpose in the new version. Being more explicit might be the safer choice here.",
              "createdAt": "2020-01-02T13:56:50Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM3NjY4MDI4",
          "commit": {
            "abbreviatedOid": "5f69d5f"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-02T13:57:39Z",
          "updatedAt": "2020-01-02T13:57:39Z",
          "comments": [
            {
              "originalPosition": 108,
              "body": "The idea is to give you a rough idea of the overall security level for informational purposes. Maybe @beurdouche can elaborate more on that.",
              "createdAt": "2020-01-02T13:57:39Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM3NjY4NzM5",
          "commit": {
            "abbreviatedOid": "5f69d5f"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-02T13:59:21Z",
          "updatedAt": "2020-01-02T13:59:21Z",
          "comments": [
            {
              "originalPosition": 118,
              "body": "The idea was to explicitly base this on what HPKE defines. This is just to emphasize that we want to use HPKE rather than some other KEM mechanism.",
              "createdAt": "2020-01-02T13:59:21Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM3NjY4ODcw",
          "commit": {
            "abbreviatedOid": "5f69d5f"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-02T13:59:42Z",
          "updatedAt": "2020-01-02T13:59:42Z",
          "comments": [
            {
              "originalPosition": 130,
              "body": "Why?",
              "createdAt": "2020-01-02T13:59:42Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM3NjcwNjIx",
          "commit": {
            "abbreviatedOid": "5f69d5f"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-02T14:04:05Z",
          "updatedAt": "2020-01-02T14:04:06Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "1) That's why I wanted to leave \"HPKE\" in the name of the ciphersuite\r\n2) I guess that should then go in line 809\r\n3) That's what we have in the \"Diffie-Hellmann groups section\"\r\n\r\nRegarding the notation for hyperlinks, I'll take your word for it",
              "createdAt": "2020-01-02T14:04:06Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM3NjcxNDcz",
          "commit": {
            "abbreviatedOid": "5f69d5f"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-02T14:06:12Z",
          "updatedAt": "2020-01-02T14:06:12Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "Unless there is a specific reasons not to do it (cc @beurdouche), I think it would be great to harmonise this. Having different hash algorithms in here makes no sense to me if it can be avoided.\r\n\r\n",
              "createdAt": "2020-01-02T14:06:12Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1NDgxMzE5",
          "commit": {
            "abbreviatedOid": "5f69d5f"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-20T18:39:06Z",
          "updatedAt": "2020-01-20T18:39:07Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "In the discussion at the last interim the consensus was to keep the signature algorithms as part of the ciphersuite.",
              "createdAt": "2020-01-20T18:39:06Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyMTUxMTE3",
          "commit": {
            "abbreviatedOid": "bb89ab8"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-03T10:24:44Z",
          "updatedAt": "2020-02-03T10:24:45Z",
          "comments": [
            {
              "originalPosition": 107,
              "body": "As discussed at the last interim, we want ciphersuites to be specific for a certain MLS protocol version.",
              "createdAt": "2020-02-03T10:24:45Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyMTUxNTM3",
          "commit": {
            "abbreviatedOid": "bb89ab8"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-03T10:25:27Z",
          "updatedAt": "2020-02-03T10:25:28Z",
          "comments": [
            {
              "originalPosition": 130,
              "body": "As discussed at the interim, we want to include the MTI.",
              "createdAt": "2020-02-03T10:25:27Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyMTUyMTA2",
          "commit": {
            "abbreviatedOid": "bb89ab8"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-03T10:26:24Z",
          "updatedAt": "2020-02-03T10:26:24Z",
          "comments": [
            {
              "originalPosition": 131,
              "body": "As  discussed at the last interim, we keep this MTI.",
              "createdAt": "2020-02-03T10:26:24Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyMTU0ODk1",
          "commit": {
            "abbreviatedOid": "1d59c9c"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-03T10:30:57Z",
          "updatedAt": "2020-02-03T10:30:57Z",
          "comments": [
            {
              "originalPosition": 118,
              "body": "HPKE changed to DHKEM",
              "createdAt": "2020-02-03T10:30:57Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyMTU1NzEz",
          "commit": {
            "abbreviatedOid": "1d59c9c"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-03T10:32:14Z",
          "updatedAt": "2020-02-03T10:32:15Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "done",
              "createdAt": "2020-02-03T10:32:14Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzMzA2NDYz",
          "commit": {
            "abbreviatedOid": "8f27146"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This seems to accurately reflect the consensus we had at the last interim, and there's nothing I can't live with otherwise.\r\n\r\nI will probably file a follow-up to convert the Derive-Key-Pair operations to use HKDF directly, as discussed, avoiding the need for intermediate `node_secret` values or truncation of SHA-512.",
          "createdAt": "2020-02-04T21:15:35Z",
          "updatedAt": "2020-02-04T21:15:35Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzNzI2NTg4",
          "commit": {
            "abbreviatedOid": "8f27146"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "There are some items missing that I believe we agreed on at the last in-person interim:\r\n- It's not clear from reading the PR that the signature scheme is now fixed per-group.\r\n  - Need to verify that CIKs correspond to current suite and express support for all algorithms currently used.\r\n- Recommendation that we be conservative when adding new suites in the future.\r\n- Justification for why the current suites are minimal.",
          "createdAt": "2020-02-05T13:48:58Z",
          "updatedAt": "2020-02-05T13:48:58Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3OTQyNjcx",
          "commit": {
            "abbreviatedOid": "6387082"
          },
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-13T04:04:18Z",
          "updatedAt": "2020-02-13T04:04:19Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I fixed this in mine. The anchor is {#anchor} and then you link in text with {{anchor}}.",
              "createdAt": "2020-02-13T04:04:18Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3OTQyNzE4",
          "commit": {
            "abbreviatedOid": "6387082"
          },
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-13T04:04:32Z",
          "updatedAt": "2020-02-13T04:04:32Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "I blew it away in mine.",
              "createdAt": "2020-02-13T04:04:32Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwNjg1MzE5",
          "commit": {
            "abbreviatedOid": "6387082"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-18T21:28:05Z",
          "updatedAt": "2020-02-18T21:38:20Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "- Please wrap this at 80-ish chars\r\n- \"field\"\r\n- Can it really be different?",
              "createdAt": "2020-02-18T21:28:05Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            },
            {
              "originalPosition": 49,
              "body": "The punctuation was correct before\r\nAlternatively, lower-case r in \"Recall\"",
              "createdAt": "2020-02-18T21:29:44Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            },
            {
              "originalPosition": 102,
              "body": "VALUE is represented\r\n8-bit",
              "createdAt": "2020-02-18T21:32:39Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            },
            {
              "originalPosition": 113,
              "body": "lower-case s in \"Signature\"",
              "createdAt": "2020-02-18T21:34:15Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            },
            {
              "originalPosition": 141,
              "body": "HKDF over SHA-256, AES-128-GCM for HPKE,",
              "createdAt": "2020-02-18T21:36:36Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            },
            {
              "originalPosition": 143,
              "body": "\"message encryption and authentication\"",
              "createdAt": "2020-02-18T21:37:44Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            }
          ]
        }
      ]
    },
    {
      "number": 281,
      "id": "MDExOlB1bGxSZXF1ZXN0MzU5MDUzODg5",
      "title": "Extend the epoch with a commit hash",
      "url": "https://github.com/mlswg/mls-protocol/pull/281",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discussion",
        "functionality"
      ],
      "body": "As discussed on the mailing list, this allows for fork detection.",
      "createdAt": "2020-01-03T16:54:55Z",
      "updatedAt": "2020-01-29T22:45:21Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "02bf13ebad9a8efd675f6c30c3261dcf6191f179",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "extended-epoch",
      "headRefOid": "35e927ac86a1b717095fb0cf80e049c3de7c1743",
      "closedAt": "2020-01-29T22:45:21Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I am withdrawing this proposal.  Discussion at the interim indicated that consideration of fork/merge cases is more complex than it might have seemed, and it's not clear that this extension is needed outside of those cases.\r\n\r\nAnd in any case, if something like this is needed, it seems like it can be done in an extension.",
          "createdAt": "2020-01-29T22:45:21Z",
          "updatedAt": "2020-01-29T22:45:21Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 282,
      "id": "MDExOlB1bGxSZXF1ZXN0MzU5MDYzNDE1",
      "title": "Specify an Ack message",
      "url": "https://github.com/mlswg/mls-protocol/pull/282",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discussion",
        "functionality",
        "security"
      ],
      "body": "",
      "createdAt": "2020-01-03T17:27:54Z",
      "updatedAt": "2020-01-12T17:06:01Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "02bf13ebad9a8efd675f6c30c3261dcf6191f179",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "ack",
      "headRefOid": "d2f5141521fee3592fa4aca0a3c0ae59138eeca3",
      "closedAt": "2020-01-12T17:04:57Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "After discussion at Jan 2020 interim, the current feeling is that Acks are not necessary at the moment.  We may re-add them later, once we have some more thorough analysis of recovery scenarios.",
          "createdAt": "2020-01-12T17:06:01Z",
          "updatedAt": "2020-01-12T17:06:01Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 283,
      "id": "MDExOlB1bGxSZXF1ZXN0MzU5MDcxNDQ1",
      "title": "Use the same ratchet for Handshake and Application keys",
      "url": "https://github.com/mlswg/mls-protocol/pull/283",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discussion",
        "privacy",
        "ready to merge",
        "security"
      ],
      "body": "The current draft uses a hash ratchet to derive single-use keys for application messages, but for handshake messages, re-uses the same key with a sequence of different nonces.  This results in a lot of unnecessary extra code.\r\n\r\nThis PR uses the same hash ratchet for handshake and application messages.  The only difference is in the base key for the hash ratchet.  In the application case, we use the AStree.  In the HS case, we derive the base keys directly from the handshake secret.  The lack of a tree in the HS case means that either the client will do a linear number of derivations on the first send/receive, or it will keep the handshake secret around and not get FS for handshake messages within the epoch.",
      "createdAt": "2020-01-03T17:57:34Z",
      "updatedAt": "2020-03-04T04:46:16Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "02bf13ebad9a8efd675f6c30c3261dcf6191f179",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "hs-key-chain",
      "headRefOid": "b1f18f441451aa7d16db3cbf9e0f5fbb66d86492",
      "closedAt": "2020-03-04T04:46:16Z",
      "mergedAt": "2020-03-04T04:46:15Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "081c42111a3b937c1f81ee611d24ae5cdba6b0b9"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@psyoptix - would appreciate your thoughts here\r\n",
          "createdAt": "2020-01-03T17:58:06Z",
          "updatedAt": "2020-01-03T17:58:06Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "As discussed on the PR call:\r\n* There's no point to FS for Proposals because clients have to cache the plaintext anyway\r\n* Given that, the \"flat derivation\" approach should be fine\r\n* We should have separate keys per sender to it easier to avoid nonce collisions\r\n* Unclear whether we should derive nonces on a hash ratchet or use a counter",
          "createdAt": "2020-01-29T14:33:04Z",
          "updatedAt": "2020-01-29T15:02:07Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3NDQzMTY4",
          "commit": {
            "abbreviatedOid": "b1f18f4"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-12T13:19:36Z",
          "updatedAt": "2020-02-12T13:19:37Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "There is a fundamental difference between application message sender ratchets and handshake message ratchets: the requirement for forward secrecy.\r\nFor application messages clients MUST delete old key material in order to obtain FS.\r\nFor handshake messages FS is not required. Moreover since there is no ordering requirement for Proposals clients should keep older key material around in order to be able to decrypt out-of-order handshake messages within one epoch.\r\nI think it's important to make that more clear.",
              "createdAt": "2020-02-12T13:19:36Z",
              "updatedAt": "2020-02-12T13:19:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3MjgwNjA0",
          "commit": {
            "abbreviatedOid": "b1f18f4"
          },
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Please merge when you have chance.",
          "createdAt": "2020-03-02T15:19:14Z",
          "updatedAt": "2020-03-02T15:19:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 285,
      "id": "MDExOlB1bGxSZXF1ZXN0MzU5MzYzODgz",
      "title": "Get rid of ignored proposals.",
      "url": "https://github.com/mlswg/mls-protocol/pull/285",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "security",
        "today! (?)"
      ],
      "body": "Ignored proposals don't make sense to me. How can they possibly add value? Also, re-structured section on Commits some.\r\n\r\n![mls-ignored-proposals](https://user-images.githubusercontent.com/416022/71790700-9ced4380-2fe6-11ea-843b-12b3609e9079.png)",
      "createdAt": "2020-01-06T02:12:37Z",
      "updatedAt": "2020-02-06T16:59:54Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "f5f308ddc3cbe8eae68867231e1d79242e6a512f",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2020.1.0",
      "headRefOid": "61a5623887240b7d99be71875eadc2758073664a",
      "closedAt": "2020-02-06T16:59:54Z",
      "mergedAt": "2020-02-06T16:59:54Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "6bca62edac0b77a530a0130101be1fa4c1c4105b"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm afraid the flow chart might not quite be that simple.  It is possible for there to be proposals that (1) don't appear in the Commit and (2) don't need to be re-sent.  The simplest case is when a member sends two Update messages within an epoch.  On the one hand, there's no practical need for them both to be included in the Commit, since one will overwrite the other.  On the other hand, at the same time, the new member shouldn't re-send the stale Update.   The idea of the `ignored` array was to provide a slot for these to be included in the Commit, but without the need for recipients to act on them.\r\n\r\n\r\n",
          "createdAt": "2020-01-07T00:12:23Z",
          "updatedAt": "2020-01-07T00:12:23Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "On a separate note, it would be helpful if you could base your different PRs on master, to make the specific changes clearer.",
          "createdAt": "2020-01-07T00:13:37Z",
          "updatedAt": "2020-01-07T00:13:37Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "In that specific example, the member is aware of all the Updates they've sent and can know to only expect one to be included.\r\n\r\nIn fact, the member can try to enforce a lot of things:\r\n- Re-send if no Update was included.\r\n- Re-send if the included Update isn't \"recent enough.\"\r\n- Re-send if the included Update isn't the most recent.\r\n\r\nThe member's own sense of what should/shouldn't be included is what matters here, not the comitter's.",
          "createdAt": "2020-01-09T03:36:41Z",
          "updatedAt": "2020-01-09T03:36:41Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I can agree that the difference between \"Proposal got dropped somewhere in the ether\" and \"Proposal was consciously ignored by the Committer\" is not really salient.  I'll post to the list to see if anyone else objects.",
          "createdAt": "2020-01-29T23:27:24Z",
          "updatedAt": "2020-01-29T23:27:24Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@beurdouche raised some concerns with this on the mailing list.  I proposed a compromise there, of the form:\r\n\r\n1. Specify that if a Committer receives two Updates proposals for the same leaf in the same epoch, then it MUST commit the latest one it received.\r\n2. State explicitly that the only Proposals that may be omitted from a Commit are:\r\n  - Invalid proposals (e.g., because of a bad signature, parsing error, reference to a non-existent leaf)\r\n  - Proposals whose effect on the tree is overwritten by another proposal, which at this point includes only:\r\n    - Updates for a leaf prior to the latest Update received by the committer\r\n    - Updates for a leaf for which there is a Remove in the epoch\r\n\r\n",
          "createdAt": "2020-02-04T21:18:46Z",
          "updatedAt": "2020-02-04T21:18:46Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@Bren2010 - How does that strike you?",
          "createdAt": "2020-02-04T21:18:57Z",
          "updatedAt": "2020-02-04T21:18:57Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Isn't that what's currently in the PR? The only difference is \"SHOULD prefer the most recent Update\" because it's not enforceable anyway",
          "createdAt": "2020-02-04T21:22:53Z",
          "updatedAt": "2020-02-04T21:22:53Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwNDk0NDg4",
          "commit": {
            "abbreviatedOid": "dee01e5"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-29T23:23:41Z",
          "updatedAt": "2020-01-29T23:23:41Z",
          "comments": []
        }
      ]
    },
    {
      "number": 286,
      "id": "MDExOlB1bGxSZXF1ZXN0MzU5MzY1ODk4",
      "title": "Editorial: Unclear that Commits always include an Update/refreshes the CIK for the committer.",
      "url": "https://github.com/mlswg/mls-protocol/pull/286",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial",
        "today! (?)"
      ],
      "body": "",
      "createdAt": "2020-01-06T02:25:41Z",
      "updatedAt": "2020-02-06T17:00:35Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "f5f308ddc3cbe8eae68867231e1d79242e6a512f",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2020.1.1",
      "headRefOid": "8f172730fc889091b1ff6ef89bd52db8d764ad64",
      "closedAt": "2020-02-06T17:00:34Z",
      "mergedAt": "2020-02-06T17:00:34Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "8260491cf8cfb50479ca120b37851264982f6efa"
      },
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "You can now rebase this on master for clarity.",
          "createdAt": "2020-01-15T11:56:04Z",
          "updatedAt": "2020-01-15T11:56:04Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwNDk3NTk0",
          "commit": {
            "abbreviatedOid": "3ae19ac"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This looks good, just one minor clarification",
          "createdAt": "2020-01-29T23:32:18Z",
          "updatedAt": "2020-01-29T23:32:41Z",
          "comments": [
            {
              "originalPosition": 89,
              "body": "It would be good to make clear that the Update in question is the `committer_update`.  Also, could you please check to make sure that DirectPath no longer touches the leaf?  Since we have split out Update and `committer_update`, DirectPath should start at the parent of the Committer.",
              "createdAt": "2020-01-29T23:32:18Z",
              "updatedAt": "2020-02-05T16:00:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxMDgyOTQw",
          "commit": {
            "abbreviatedOid": "3ae19ac"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-30T19:27:21Z",
          "updatedAt": "2020-01-30T19:27:21Z",
          "comments": [
            {
              "originalPosition": 89,
              "body": "https://github.com/mlswg/mls-protocol/pull/294",
              "createdAt": "2020-01-30T19:27:21Z",
              "updatedAt": "2020-02-05T16:00:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzNzYxMjE3",
          "commit": {
            "abbreviatedOid": "8ff6c00"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-05T14:33:48Z",
          "updatedAt": "2020-02-05T14:33:49Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Since an Update only contains a CIK, we should use the CIK right away here.",
              "createdAt": "2020-02-05T14:33:48Z",
              "updatedAt": "2020-02-05T16:00:04Z"
            }
          ]
        }
      ]
    },
    {
      "number": 287,
      "id": "MDExOlB1bGxSZXF1ZXN0MzU5NDI4ODc5",
      "title": "Switch to signing strategy using one signature per leaf.",
      "url": "https://github.com/mlswg/mls-protocol/pull/287",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discussion",
        "enhancement",
        "performance",
        "ready to merge",
        "security"
      ],
      "body": "",
      "createdAt": "2020-01-06T07:38:36Z",
      "updatedAt": "2020-02-06T17:01:00Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "f5f308ddc3cbe8eae68867231e1d79242e6a512f",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2020.1.2",
      "headRefOid": "cd67f82e44c74d98c420de3244660ca60c3e40b5",
      "closedAt": "2020-02-06T17:01:00Z",
      "mergedAt": "2020-02-06T17:01:00Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "2c478519074be70049fe4e028b4853e1c942864b"
      },
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "After the discussion at the interim I took a look again and I would like to bring up the following points:\r\n\r\n - The PR contains functional changes as well as editorial changes. I think it makes no sense to combine the two and the two kind of changes should be split in at least two PRs.\r\n - We discussed that enforcing the tree invariant is the minimum we need, there is still an ongoing discussion on what we want to guarantee regarding group agreement.\r\n - This PR covers more than just the direct path needed for the tree invariant, because the fields `left_hash` and `right_hash` are present in `ParentNodeHashInput`. Is this on done on purpose? If so, why?\r\n - I think it is not actually possible to verify the hash chain in a direct path other than in the direct path of the last Commit. The reason is that the hash chain breaks on all other direct paths because at some level the direct path gets overwritten by the direct path of the committer and the hashes are therefore no longer correct. The way forward would be to use a Merckle tree instead of a hash in the CIK extension (I think @bifurcation proposed that at some point).",
          "createdAt": "2020-01-14T17:07:54Z",
          "updatedAt": "2020-01-14T17:07:54Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "You can now rebase this on master for clarity.\r\nPlease avoid unrelated editorial as much as possible.",
          "createdAt": "2020-01-15T11:55:22Z",
          "updatedAt": "2020-01-15T11:55:22Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "As discussed on PR call:\r\n* People are generally OK going with this approach for now, pending further proofs\r\n* We should get #285 and #286 merged first",
          "createdAt": "2020-01-29T15:01:26Z",
          "updatedAt": "2020-01-29T15:01:26Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I think the last commits address my concerns.",
          "createdAt": "2020-01-29T15:56:01Z",
          "updatedAt": "2020-01-29T15:56:01Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "One more note here: It might be good to add an OPEN ISSUE to acknowledge the still-outstanding concerns about group agreement vs. deniability, , something like:\r\n\r\n> [[ OPEN ISSUE: This scheme, in which the tree hash covers the parent hash, is designed to allow for more deniable deployments, since a signature by a member covers only its direct path.  The other possible scheme, in which the parent hash covers the tree hash, provides better group agreement properties, since a member's signature covers the entire membership of the trees it is in.  Further discussion is needed to determine whether the benefits to deniability justify the harm to group agreement properties, or whether there are alternative approaches to deniability that could be compatible with the other approach. ]]",
          "createdAt": "2020-02-05T02:09:43Z",
          "updatedAt": "2020-02-05T02:09:43Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 288,
      "id": "MDExOlB1bGxSZXF1ZXN0MzU5Njc2ODY2",
      "title": "Typos",
      "url": "https://github.com/mlswg/mls-protocol/pull/288",
      "state": "MERGED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2020-01-06T19:23:09Z",
      "updatedAt": "2020-03-04T18:22:36Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "02bf13ebad9a8efd675f6c30c3261dcf6191f179",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "raphaelrobert-typos",
      "headRefOid": "6b535809d07db778e7dfeb6ec8442f056abb3f07",
      "closedAt": "2020-01-07T00:19:50Z",
      "mergedAt": "2020-01-07T00:19:50Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "62bd560673d8e795e8b124e717d122e459e08611"
      },
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "These are resolved in #287.",
          "createdAt": "2020-01-06T19:30:39Z",
          "updatedAt": "2020-01-06T19:30:39Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM4OTcxNDkz",
          "commit": {
            "abbreviatedOid": "6b53580"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-07T00:19:43Z",
          "updatedAt": "2020-01-07T00:19:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 292,
      "id": "MDExOlB1bGxSZXF1ZXN0MzYzMDk3ODQ2",
      "title": "Editorial on top of PR #278",
      "url": "https://github.com/mlswg/mls-protocol/pull/292",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2020-01-15T11:48:12Z",
      "updatedAt": "2020-01-20T18:43:38Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "62bd560673d8e795e8b124e717d122e459e08611",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_278",
      "headRefOid": "543a78105eb1b029315e8342ea73bf5a4434fd26",
      "closedAt": "2020-01-15T11:51:05Z",
      "mergedAt": "2020-01-15T11:51:05Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "26a327ca9c07381c3a8b9d717ff2641749195824"
      },
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Merge+Squash #278 from Brendan and apply editorial fixes",
          "createdAt": "2020-01-15T11:51:10Z",
          "updatedAt": "2020-01-15T11:51:10Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 294,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY5MjQ1MTE1",
      "title": "Re-define direct path to not include the leaf.",
      "url": "https://github.com/mlswg/mls-protocol/pull/294",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "today! (?)"
      ],
      "body": "",
      "createdAt": "2020-01-30T19:27:11Z",
      "updatedAt": "2020-02-06T17:03:16Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "f5f308ddc3cbe8eae68867231e1d79242e6a512f",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2020.1.3",
      "headRefOid": "bd4fec65fd4bbf7d5de164504ab13f7ea9b58421",
      "closedAt": "2020-02-06T17:03:15Z",
      "mergedAt": "2020-02-06T17:03:15Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "57a0a34096a5cd4a0583dbd748a4a462d42b6686"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "You can also strike this sentence further down: \" In particular, for the leaf node, there are no encrypted secrets, since a leaf node has no children.\"",
          "createdAt": "2020-02-05T14:32:15Z",
          "updatedAt": "2020-02-05T14:32:15Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Note that this severs the connection between the HPKE key in the leaf and the parent of the leaf.  Whereas before, the leaf HPKE key was derived from a path secret, and the parent HPKE key was derived from the next path secret.  Now the parent path secret is set directly, and the leaf HPKE key is set completely independently, with no dependency on a path secret.\r\n\r\nSo we're losing a bit of internal structure in the tree.  But this seems OK because that structure was never observable to the group -- only the holder of the leaf knows the leaf path secret, so nobody else could verify that the leaf was related to its parent.",
          "createdAt": "2020-02-05T14:36:51Z",
          "updatedAt": "2020-02-05T14:36:51Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzNzU5NTcy",
          "commit": {
            "abbreviatedOid": "bd5525e"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-05T14:31:50Z",
          "updatedAt": "2020-02-05T14:31:50Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Add root here, so it lines up with the copath",
              "createdAt": "2020-02-05T14:31:50Z",
              "updatedAt": "2020-02-05T16:15:33Z"
            }
          ]
        }
      ]
    },
    {
      "number": 295,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY5OTEwOTc1",
      "title": "Use path secret instead of full DirectPath",
      "url": "https://github.com/mlswg/mls-protocol/pull/295",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "today! (?)"
      ],
      "body": "This PR adapts the Welcome logic so that the new joiners get their path secrets directly, rather than from a DirectPath.  This cleans things up in a few ways.  The new joiners no longer have to have the context for the previous epoch (which was used to encrypt the DirectPath).  And we can get away with one HPKE operation per new joiner instead of two (one for the EncryptedKeyPackage and one for the DirectPath).\r\n\r\nThe major cost is that there's a bit more complexity in the TreeKEM.  Instead of just producing and consuming DirectPaths, you now need to know which path secrets go with which nodes.  You also need tree math to identify the common ancestor of two leaves, but there's a simple closed-form formula for that, expressed in the Python code here.\r\n\r\n[Corresponding PR on the Go implementation.](https://github.com/bifurcation/mls/pull/37)",
      "createdAt": "2020-02-01T15:47:37Z",
      "updatedAt": "2020-02-07T08:40:50Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "57a0a34096a5cd4a0583dbd748a4a462d42b6686",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "path-secret",
      "headRefOid": "e20bcecda309d3ee140644107ff98716fbb76c0e",
      "closedAt": "2020-02-06T17:08:21Z",
      "mergedAt": "2020-02-06T17:08:21Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "db9ab6a206e9b9cca6d1c2e0c3b9c3db0088c644"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@raphaelrobert - Curious if this seems implementable to you.  Clearly it's possible, since I did it in Go :)  But it also needs to make sense to other people.",
          "createdAt": "2020-02-01T15:48:31Z",
          "updatedAt": "2020-02-01T15:48:31Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxODkxMDIz",
          "commit": {
            "abbreviatedOid": "6324601"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-01T16:05:27Z",
          "updatedAt": "2020-02-01T16:07:38Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "I think there might be more math involved here. Unless it's a group of two, the direct path of the new member should be blank until it intersects with the direct path of the adder (who populated their path with the Commit). In other words, the common ancestor node has to be resolved, leading to an array of resolved nodes. The new member should be one of these resolved nodes.\r\nTo me this looks like you end up KEMing to the new member's leaf node directly.",
              "createdAt": "2020-02-01T16:05:27Z",
              "updatedAt": "2020-02-06T17:07:49Z"
            },
            {
              "originalPosition": 145,
              "body": "For simplicity I would just iterate over `parent()` until the value is equal.",
              "createdAt": "2020-02-01T16:07:30Z",
              "updatedAt": "2020-02-06T17:07:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxODkxMzY5",
          "commit": {
            "abbreviatedOid": "6324601"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-01T16:13:03Z",
          "updatedAt": "2020-02-01T16:13:03Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "That actually doesn't work, because the distance to the parent might not be equal.  Consider, for example, the three-member tree:\r\n\r\n```\r\n    ABC\r\n   /   \\\r\n AB     |\r\n / \\    |\r\nA   B   C\r\n```\r\n\r\nThe common ancestor of A and B is `ABC = parent(parent(A)) = parent(C)`.\r\n\r\nYou would have to first compute the direct path of one node, then iterate `parent()` on the other until you end up in the direct path.  The formula here is a little bit of index magic, but I think it can be proven correct, and it's simpler/faster.",
              "createdAt": "2020-02-01T16:13:03Z",
              "updatedAt": "2020-02-06T17:07:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxODkxNTg5",
          "commit": {
            "abbreviatedOid": "6324601"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-01T16:17:43Z",
          "updatedAt": "2020-02-01T16:17:43Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "You're kind of making a point I should have made, namely that sending the path secret of the common ancestor as we are here is equivalent to sending the direct path -- in the direct path encryption, you would encrypt the path secret to the corresponding copath node, which would ultimately resolve to the leaf node (and possibly some others).\r\n\r\nWhat this PR is doing is taking the KEMing to the new member's leaf and taking it out of the context of the DirectPath.  Where before you were doing an HPKE to the new member once for EncryptedKeyPackage and again in the DirectPath, now you just do it for the EncryptedKeyPackage.",
              "createdAt": "2020-02-01T16:17:43Z",
              "updatedAt": "2020-02-06T17:07:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxODkyNTMz",
          "commit": {
            "abbreviatedOid": "6324601"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-01T16:39:19Z",
          "updatedAt": "2020-02-01T16:39:19Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "Sure, I think that makes sense. \r\n\r\nBut there might be another issue: I forgot that we don't blank the direct path of new members anymore and instead use `unmerged_leaves`. This list should now be shorter and only include nodes from leaf to common ancestor. This is however something every member in the group processing the `Add` has to calculate as it is non explicit.",
              "createdAt": "2020-02-01T16:39:19Z",
              "updatedAt": "2020-02-06T17:07:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxODkyNjIx",
          "commit": {
            "abbreviatedOid": "6324601"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-01T16:41:07Z",
          "updatedAt": "2020-02-01T16:41:08Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "True, my idea only works reliably on the left part of the tree. On the right part you'd have to also use `level()` to skip some nodes. If you're confident your math works, it might just be simpler to use that.",
              "createdAt": "2020-02-01T16:41:08Z",
              "updatedAt": "2020-02-06T17:07:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyNDg0NDQz",
          "commit": {
            "abbreviatedOid": "6324601"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-03T18:57:26Z",
          "updatedAt": "2020-02-03T18:57:27Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "The algorithm passes tests on a non-trivial tree, so I have pretty good confidence that it works.  Proof sketch:\r\n\r\n* Each subtree of the tree is identified by a common prefix\r\n    * The root of the subtree is `<prefix>0<1 * level>`\r\n    * The nodes within the subtree are `<prefix>0...0` to <prefix>1...10\r\n* Therefore every common ancestor of A and B will have a prefix that is common to A and B, since a common ancestor is the root of a subtree containing both nodes\r\n* This algorithm finds the longest prefix shared by A and B, then computes the root of the corresponding subtree\r\n\r\nOf course, all of this is just a recommended implementation.  Implementations are free to use a more explicit algorithm like yours if they prefer.",
              "createdAt": "2020-02-03T18:57:26Z",
              "updatedAt": "2020-02-06T17:07:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyOTY2Mjk0",
          "commit": {
            "abbreviatedOid": "6324601"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-04T13:19:03Z",
          "updatedAt": "2020-02-04T13:19:04Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "> This list should now be shorter and only include nodes from leaf to common ancestor\r\n\r\nThis is already true.  Even before this PR, the DirectPath processing would reset the `unnmerged_leaves` arrays to `[]` for nodes in the direct path of the committer.",
              "createdAt": "2020-02-04T13:19:03Z",
              "updatedAt": "2020-02-06T17:07:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyOTY2ODIz",
          "commit": {
            "abbreviatedOid": "6324601"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-04T13:19:56Z",
          "updatedAt": "2020-02-04T13:19:57Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "In any case, we should be clear that you reset `unmerged_leaves` whenever you write to a node.  I don't think that needs to be blocking on this PR.",
              "createdAt": "2020-02-04T13:19:56Z",
              "updatedAt": "2020-02-06T17:07:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzNzc3ODkw",
          "commit": {
            "abbreviatedOid": "6324601"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-02-05T14:53:59Z",
          "updatedAt": "2020-02-05T14:53:59Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1MDAwNDc5",
          "commit": {
            "abbreviatedOid": "e20bcec"
          },
          "author": "ericcornelissen",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-07T08:40:49Z",
          "updatedAt": "2020-02-07T08:40:50Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "This change leaves a reference to a GroupInfo object that is not mentioned before. If I'm not mistaken, I think this can be rewritten as:\r\n\r\n> Create a DirectPath using the new tree (which includes any new members). The GroupContext for this operation uses the `group_id`, `epoch`, and `tree` in the provisional GroupContext and the `confirmed_transcript_hash` for the current state of the group (not the provisional state).\r\n\r\nOn this note, I'm not entirely sure I understand why an entire GroupContext (specifically the `group_id`, `epoch`, and `confirmed_transcript_hash`) is needed to compute a DirectPath...",
              "createdAt": "2020-02-07T08:40:49Z",
              "updatedAt": "2020-02-07T08:40:50Z"
            }
          ]
        }
      ]
    },
    {
      "number": 296,
      "id": "MDExOlB1bGxSZXF1ZXN0MzcxMTQ2Njcx",
      "title": "Flesh out the extensions story",
      "url": "https://github.com/mlswg/mls-protocol/pull/296",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial",
        "functionality",
        "security"
      ],
      "body": "Extensions in the CIK were only half of the story.  To do things like RTreeKEM or fork/merge as extensions, we need the ability to (1) tell new members that the group is doing something different, and (2) confirm that all group members have the same view of the rules of the road.  This PR adds extensions to the GroupInfo object for the first case, and to the Welcome object for the second, and a bunch of explanatory text to make it all work.\r\n\r\nOne thing this PR does *not* do is define a way to change extensions in a running group.  You could in principle do this by sending new extensions in Commit that could overwrite or add to extensions.  But that entails some messy questions (how do you delete an extension in use?), so it is currently left to an extension (heh), or to a group restart.\r\n\r\nDepends on #295 to avoid conflicts in GroupInfo changes.",
      "createdAt": "2020-02-05T01:59:30Z",
      "updatedAt": "2020-03-05T23:05:58Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "10e75b3e9e722f6fda9a48b332407b80e51e87dd",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "more-extensions",
      "headRefOid": "dfd3caba595e855eed63eaa8d565f44fef55093f",
      "closedAt": "2020-03-05T23:05:58Z",
      "mergedAt": "2020-03-05T23:05:58Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "ba7a182cdd541c80087ea21a0d61a5024ab3d105"
      },
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I think this could also be useful for deniability.",
          "createdAt": "2020-02-05T10:22:01Z",
          "updatedAt": "2020-02-05T10:22:01Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "I imagine we also need to define an IANA registry of extensions, designated experts, a private space?",
          "createdAt": "2020-03-03T18:59:35Z",
          "updatedAt": "2020-03-03T18:59:35Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Filed #312 for the IANA stuff",
          "createdAt": "2020-03-04T05:10:30Z",
          "updatedAt": "2020-03-04T05:10:30Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3NTA2NjIx",
          "commit": {
            "abbreviatedOid": "b300624"
          },
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-12T14:43:04Z",
          "updatedAt": "2020-02-12T14:43:05Z",
          "comments": [
            {
              "originalPosition": 119,
              "body": "This means we need some more text in the IANA considerations about setting up the space.",
              "createdAt": "2020-02-12T14:43:04Z",
              "updatedAt": "2020-03-05T23:05:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0OTA5MTEy",
          "commit": {
            "abbreviatedOid": "b300624"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "You've essentially just added extension fields without defining /how/ they'll interact with the protocol. Which tells me they're probably meant to be able to change /anything/ about the protocol. In that case, it needs to be clear that all extensions (outside of CIKs) are effectively mandatory, and that we can't have non-mandatory extensions.",
          "createdAt": "2020-02-26T13:47:27Z",
          "updatedAt": "2020-02-26T13:58:11Z",
          "comments": [
            {
              "originalPosition": 123,
              "body": "expresses",
              "createdAt": "2020-02-26T13:47:27Z",
              "updatedAt": "2020-03-05T23:05:48Z"
            },
            {
              "originalPosition": 122,
              "body": "\"to the one\"\r\n\"one-to-one: the\"",
              "createdAt": "2020-02-26T13:48:00Z",
              "updatedAt": "2020-03-05T23:05:48Z"
            },
            {
              "originalPosition": 129,
              "body": "participation",
              "createdAt": "2020-02-26T13:48:37Z",
              "updatedAt": "2020-03-05T23:05:48Z"
            },
            {
              "originalPosition": 106,
              "body": "corresponds",
              "createdAt": "2020-02-26T13:54:17Z",
              "updatedAt": "2020-03-05T23:05:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5MDA1MzI5",
          "commit": {
            "abbreviatedOid": "5417dae"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-04T18:09:58Z",
          "updatedAt": "2020-03-04T18:09:58Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5MTE3OTM1",
          "commit": {
            "abbreviatedOid": "5417dae"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-03-04T20:59:22Z",
          "updatedAt": "2020-03-04T21:05:43Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "```suggestion\r\n  have an extension of the same type, and the contents of the extension MUST be\r\n```",
              "createdAt": "2020-03-04T20:59:23Z",
              "updatedAt": "2020-03-05T23:05:48Z"
            },
            {
              "originalPosition": 75,
              "body": "I think this would be good. Making sure the CIK format doesn't change is all I think you need for backwards-compatibility.",
              "createdAt": "2020-03-04T21:05:31Z",
              "updatedAt": "2020-03-05T23:05:48Z"
            }
          ]
        }
      ]
    },
    {
      "number": 303,
      "id": "MDExOlB1bGxSZXF1ZXN0MzcyMTU0OTUx",
      "title": "Add some per-message entropy",
      "url": "https://github.com/mlswg/mls-protocol/pull/303",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #216 ",
      "createdAt": "2020-02-06T23:03:01Z",
      "updatedAt": "2020-03-04T18:23:49Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "db9ab6a206e9b9cca6d1c2e0c3b9c3db0088c644",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "per-message-entropy",
      "headRefOid": "a7bd50001dd2a55c92f1e01dfae848ab4874c4b3",
      "closedAt": "2020-02-17T17:57:43Z",
      "mergedAt": "2020-02-17T17:57:43Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "8045e66dbbac361202ac8ab90d3d27d33771ad28"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "cc @Bren2010 ",
          "createdAt": "2020-02-06T23:03:09Z",
          "updatedAt": "2020-02-06T23:03:09Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Quick question without reading much, but why can't we reuse the sender data nonce which is always fresh to do this?",
          "createdAt": "2020-02-07T19:05:37Z",
          "updatedAt": "2020-02-07T19:05:37Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "You could do that; in fact you could just use that nonce for the content encryption as well as the sender data encryption, and forget about the key-schedule derived nonces as well.\r\n\r\nThe reason I didn't go down that path is that I'm generally leery of requiring fresh randomness in the protocol.  In particular, for the sender data, I think we should be moving toward masking instead of GCM (cf #302).  If we do masking, then we won't need to change this, and we'll have basically the minimum amount of fresh entropy needed.",
          "createdAt": "2020-02-07T19:20:46Z",
          "updatedAt": "2020-02-07T19:20:46Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Nope you can't really do that. The xoring of the two is strictly stronger, even if your PRNG is bad, you'll benefit from the entropy of the deterministic nonce because of the current epoch secret to which many people have contributed to.\r\n\r\nUntil we do that move to masking, I think I would prefer to have the xor use the sender data nonce.",
          "createdAt": "2020-02-07T19:25:24Z",
          "updatedAt": "2020-02-07T19:25:24Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm confused about what you're talking about.  In the current proposal:\r\n\r\n```\r\naead_nonce = key_sched_nonce XOR (reuse_guard || 0)\r\n```\r\n\r\nI agree that that's better than just using the `sender_data_nonce` for the reasons you say.  But I thought what you were proposing was :\r\n\r\n```\r\naead_nonce = key_sched_nonce XOR sender_data_nonce\r\n```\r\n\r\nEither way, we're incorporating the key schedule nonce.  \r\n\r\nHow about the following proposal?\r\n* For now: `aead_nonce = key_sched_nonce XOR sender_data_nonce`\r\n* If we do masking later, we do something like what's in this PR",
          "createdAt": "2020-02-07T19:29:42Z",
          "updatedAt": "2020-02-07T19:29:42Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "> How about the following proposal?\r\n> \r\n>     * For now: `aead_nonce = key_sched_nonce XOR sender_data_nonce` \r\n>     * If we do masking later, we do something like what's in this PR\r\n\r\nWorks for me !\r\n",
          "createdAt": "2020-02-07T20:27:10Z",
          "updatedAt": "2020-02-07T20:27:10Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@Bren2010 if the revised scheme looks ok to you, I'll consider this ready to merge",
          "createdAt": "2020-02-07T21:02:33Z",
          "updatedAt": "2020-02-07T21:02:33Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "If I had a concern with the new scheme, it's that it's no longer resistant to nonce misuse. For example, consider somebody setting `sender_data_nonce = key_sched_nonce`.",
          "createdAt": "2020-02-07T21:09:04Z",
          "updatedAt": "2020-02-07T21:09:04Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "That would violate the requirement that the `sender_data_nonce` be fresh.  I've clarified that requirement in the latest commit.",
          "createdAt": "2020-02-07T21:14:57Z",
          "updatedAt": "2020-02-07T21:14:57Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Putting a requirement in the spec is good. But that won't stop a nonce-misusing implementation from running, which was the point of deterministically generating the nonce in the first place.",
          "createdAt": "2020-02-07T21:18:51Z",
          "updatedAt": "2020-02-07T21:18:51Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not sure why you think a freshness requirement is less plausible for the `sender_data_nonce` than for the `reuse_guard`.  Neither is enforceable in the protocol.\r\n\r\n![image](https://user-images.githubusercontent.com/75597/74067871-3209a080-49c8-11ea-991a-69fe1cbbfc9a.png)\r\n",
          "createdAt": "2020-02-07T21:38:46Z",
          "updatedAt": "2020-02-07T21:38:46Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "The value of `reuse_guard` is that it's only 4 bytes, so it doesn't mask the whole thing. Worst case, `reuse_guard` can reliably fix 32 bits, leaving only 64 bits of actual randomness in the nonce. Not good, but better than 0, and better than invoking a hash `H(key_sched_nonce | sender_data_nonce)` to actually mix things.",
          "createdAt": "2020-02-07T21:50:46Z",
          "updatedAt": "2020-02-07T21:50:46Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "The fact that `reuse_guard` is not called a nonce and is a different size also makes me feel better about it not being misused",
          "createdAt": "2020-02-07T21:52:22Z",
          "updatedAt": "2020-02-07T21:52:38Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "@bifurcation @Bren2010 I don't have a strong opinion here, I was just pointing that we already has a fresh value. I can see why Brendan prefers the smaller guard using a fresh distinct value, so I'll support this or any variant for which you both agree ; )",
          "createdAt": "2020-02-16T11:19:19Z",
          "updatedAt": "2020-02-16T11:19:19Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Reverted to the `reuse_guard` approach, which it seems everyone is OK with.",
          "createdAt": "2020-02-17T17:57:36Z",
          "updatedAt": "2020-02-17T17:57:36Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1MzYyOTM5",
          "commit": {
            "abbreviatedOid": "20f59e3"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This is perfect! Thanks!",
          "createdAt": "2020-02-07T18:50:30Z",
          "updatedAt": "2020-02-07T18:50:30Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5MDE0ODI4",
          "commit": {
            "abbreviatedOid": "a7bd500"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Approved.",
          "createdAt": "2020-03-04T18:23:49Z",
          "updatedAt": "2020-03-04T18:23:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 304,
      "id": "MDExOlB1bGxSZXF1ZXN0MzcyMTY3OTY2",
      "title": "Use HKDF to derive key pairs",
      "url": "https://github.com/mlswg/mls-protocol/pull/304",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "ready to merge"
      ],
      "body": "This deals cleanly with groups where the private key size doesn't align neatly with a hash function output size (e.g., X448), and saves a few hash invocations by removing intermediate `node_secret` values.\r\n\r\nA few editorial changes are included here as well.\r\n\r\nDepends on #279.",
      "createdAt": "2020-02-06T23:48:31Z",
      "updatedAt": "2020-03-05T23:01:10Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "74380c5a193277e696d39a0d7554fd9243cd3d9b",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "hkdf-derive-key-pair",
      "headRefOid": "38f1dbf406220f3b484204e229cf5f166ac452a8",
      "closedAt": "2020-03-05T23:01:10Z",
      "mergedAt": "2020-03-05T23:01:10Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "680a2a7858684d6a8d3c7d8fe6b9f273a5d366bf"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "As discussed on call, folks are comfortable with this.  Ready to merge, pending #279 ",
          "createdAt": "2020-02-12T14:35:28Z",
          "updatedAt": "2020-02-12T14:35:28Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwNjk5Mjc1",
          "commit": {
            "abbreviatedOid": "f1b5764"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-18T21:50:49Z",
          "updatedAt": "2020-02-18T21:50:49Z",
          "comments": [
            {
              "originalPosition": 183,
              "body": "66 octets",
              "createdAt": "2020-02-18T21:50:49Z",
              "updatedAt": "2020-03-05T23:00:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3MjgxMjA0",
          "commit": {
            "abbreviatedOid": "f1b5764"
          },
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Please merge when get a chance.",
          "createdAt": "2020-03-02T15:19:58Z",
          "updatedAt": "2020-03-02T15:19:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 305,
      "id": "MDExOlB1bGxSZXF1ZXN0MzczMDU4Mjk3",
      "title": "Update HKDFLabel variable to match naming conventions",
      "url": "https://github.com/mlswg/mls-protocol/pull/305",
      "state": "MERGED",
      "author": "GaPhil",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "? invalid",
        "editorial"
      ],
      "body": "This PR changes the variable name `HkdfLabel` to `HKDFLabel` in order to match the previously used naming conventions.",
      "createdAt": "2020-02-10T10:35:34Z",
      "updatedAt": "2020-02-12T14:10:20Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "9128dc8dc88730467cb42f83643901099f71082c",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "904439875c9aec7342cc722b8e49de88d25c6bb1",
      "closedAt": "2020-02-12T14:01:12Z",
      "mergedAt": "2020-02-12T14:01:12Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "ac53a7dc0984241661d53cf722e0979b18aebda3"
      },
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Hi Philip @GaPhil  !\r\nThis is following the conventions we used in RFC 8446 so I think we should just keep that... I'll let Richard @bifurcation close this if he agrees with me but anyway, thank you for having a look! : )\r\nB.",
          "createdAt": "2020-02-10T10:40:48Z",
          "updatedAt": "2020-02-10T10:40:48Z"
        },
        {
          "author": "GaPhil",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sure, noted.\r\n\r\nHowever, one might consider whether one wishes to maintain the same conventions for acronyms in this document. See `HPKECiphertext` and `MLSPlaintextCommitAuthData` as opposed to `HpkeCiphertext` and `MlsPlaintextCommitAuthData`.",
          "createdAt": "2020-02-10T11:51:05Z",
          "updatedAt": "2020-02-10T11:51:05Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I actually agree with @GaPhil here.  It's also more like Go than Java, so let's go with the more modern language :)",
          "createdAt": "2020-02-12T14:01:07Z",
          "updatedAt": "2020-02-12T14:01:07Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Well Phillip's point was certainly valid. The one about programming language is completely irrelevant.",
          "createdAt": "2020-02-12T14:09:29Z",
          "updatedAt": "2020-02-12T14:09:29Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that it's irrelevant.  Just kidding.",
          "createdAt": "2020-02-12T14:10:20Z",
          "updatedAt": "2020-02-12T14:10:20Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 306,
      "id": "MDExOlB1bGxSZXF1ZXN0MzczMTIwMzQw",
      "title": "Typos",
      "url": "https://github.com/mlswg/mls-protocol/pull/306",
      "state": "MERGED",
      "author": "GaPhil",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "This PR aims to fix some odd formulations, whilst maintaining the intended meaning of the sentences.",
      "createdAt": "2020-02-10T12:58:35Z",
      "updatedAt": "2020-02-10T14:12:58Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "db9ab6a206e9b9cca6d1c2e0c3b9c3db0088c644",
      "headRepository": null,
      "headRefName": "typos",
      "headRefOid": "dec27f1e8dab422bfc9adfbec2472fa22d2dc2a4",
      "closedAt": "2020-02-10T13:00:12Z",
      "mergedAt": "2020-02-10T13:00:12Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "9128dc8dc88730467cb42f83643901099f71082c"
      },
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Thank you!",
          "createdAt": "2020-02-10T13:00:21Z",
          "updatedAt": "2020-02-10T13:00:21Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 307,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc0NjU0MzY1",
      "title": "DE-related text",
      "url": "https://github.com/mlswg/mls-protocol/pull/307",
      "state": "MERGED",
      "author": "seanturner",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Here's to hoping I did this merge properly.",
      "createdAt": "2020-02-13T03:47:01Z",
      "updatedAt": "2020-03-05T22:56:22Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "raphael_ciphersuites",
      "baseRefOid": "6387082ad4c34637940bfc1e1e2b54d4ae17f353",
      "headRepository": "seanturner/mls-protocol",
      "headRefName": "raphael_ciphersuites",
      "headRefOid": "5a5862ab50f2fab54c5af1391da23977e53a3e6a",
      "closedAt": "2020-03-05T22:56:22Z",
      "mergedAt": "2020-03-05T22:56:22Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "0606ce7c64730b54d569aef11c137142942a0927"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5OTAwODIw",
          "commit": {
            "abbreviatedOid": "6161f17"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-02-17T17:58:34Z",
          "updatedAt": "2020-02-17T18:02:10Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "\"Designated\"",
              "createdAt": "2020-02-17T17:58:34Z",
              "updatedAt": "2020-02-19T14:25:17Z"
            },
            {
              "originalPosition": 9,
              "body": "I think this will render as \"MLS Ciphersuites Section X.Y.Z\".  Maybe add parens around `{{ciphersuites}}`",
              "createdAt": "2020-02-17T17:59:15Z",
              "updatedAt": "2020-02-19T14:25:17Z"
            },
            {
              "originalPosition": 5,
              "body": "You don't need to define this, the \"lowercase plus dashes\" tags are auto-generated.",
              "createdAt": "2020-02-17T17:59:46Z",
              "updatedAt": "2020-02-19T14:25:17Z"
            },
            {
              "originalPosition": 9,
              "body": "As above, just use `{{mls-ciphersuites}}` and there's no need for an explicit tag.",
              "createdAt": "2020-02-17T18:00:08Z",
              "updatedAt": "2020-02-19T14:25:17Z"
            },
            {
              "originalPosition": 35,
              "body": "This needs to be guarded with `~~~`",
              "createdAt": "2020-02-17T18:00:38Z",
              "updatedAt": "2020-02-19T14:25:17Z"
            },
            {
              "originalPosition": 69,
              "body": "Suggest `mls-ciphersuites@`",
              "createdAt": "2020-02-17T18:01:11Z",
              "updatedAt": "2020-02-19T14:25:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxMTQ1OTc0",
          "commit": {
            "abbreviatedOid": "6161f17"
          },
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-19T14:19:04Z",
          "updatedAt": "2020-02-19T14:19:05Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "But, we're going to end up with more than one registry (e.g., extensions) so I was going for the more general name.",
              "createdAt": "2020-02-19T14:19:05Z",
              "updatedAt": "2020-02-19T14:25:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4OTgzMzQz",
          "commit": {
            "abbreviatedOid": "5a5862a"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-04T17:37:45Z",
          "updatedAt": "2020-03-04T17:37:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 308,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgxMDkxMDY0",
      "title": "Remove nonce from SenderData AAD.",
      "url": "https://github.com/mlswg/mls-protocol/pull/308",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discussion",
        "performance"
      ],
      "body": "With any AEAD, the nonce is necessarily already authenticated. Also, the name of the struct was changed to be more clear.",
      "createdAt": "2020-02-27T21:50:24Z",
      "updatedAt": "2020-07-13T06:37:37Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "1f9f90578eecd61103cc02f98b8a0d058d265e65",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2020.2.0",
      "headRefOid": "215386655cf85ff6354355848948d05feaf8fd4a",
      "closedAt": "2020-07-12T20:45:15Z",
      "mergedAt": "2020-07-12T20:45:15Z",
      "mergedBy": "Bren2010",
      "mergeCommit": {
        "oid": "7d7b07325f618acd7d254be3bf5ea45615a1445e"
      },
      "comments": [
        {
          "author": "br-hale",
          "authorAssociation": "NONE",
          "body": "Does this force use of an implicit nonce such as in TLS, vice an explicit nonce such as in DTLS?",
          "createdAt": "2020-03-02T21:22:12Z",
          "updatedAt": "2020-03-02T21:22:12Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Sender data has always been encrypted with an explicit nonce, and the explicit nonce is still sent in MLSCiphertext. This just removes the explicit nonce from the AAD.",
          "createdAt": "2020-03-02T21:27:51Z",
          "updatedAt": "2020-03-02T21:28:04Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I think @beurdouche proposed this originally, with the idea that the AAD at each point would include everything above it.  But I agree that it doesn't seem very useful.  I'm OK to merge if other folks are.",
          "createdAt": "2020-03-04T04:47:51Z",
          "updatedAt": "2020-03-04T04:47:51Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "The thing is designed so that the entire prefix of the AEAD ciphertext is authenticated.\r\n<img width=\"718\" alt=\"Screenshot 2020-03-04 at 19 01 50\" src=\"https://user-images.githubusercontent.com/1193431/75908571-af4ef680-5e4a-11ea-8379-4a3e051f25e1.png\">\r\nI would prefer to keep it that way...",
          "createdAt": "2020-03-04T18:02:41Z",
          "updatedAt": "2020-03-04T18:02:41Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@Bren2010 unless you think this is really important, I'm inclined to just close this PR.",
          "createdAt": "2020-03-04T18:04:05Z",
          "updatedAt": "2020-03-04T18:04:05Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "@beurdouche Put \"sender nonce\" under \"Encrypted Sender Data\" because the nonce is part of the ciphertext. Then there's no gap in your picture, and \"Encrypted Sender Data\" will fit within the bounds of the arrow.",
          "createdAt": "2020-03-04T19:38:11Z",
          "updatedAt": "2020-03-04T19:38:11Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "That was not meant to be merged, that was meant for raphael and I to review. So, I\u2019ll revert that until we can do this.\n\n> On Jul 12, 2020, at 10:45 PM, Brendan McMillion <notifications@github.com> wrote:\n> \n> \ufeff\n> Merged #308 into master.\n> \n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub, or unsubscribe.\n",
          "createdAt": "2020-07-13T06:37:36Z",
          "updatedAt": "2020-07-13T06:37:36Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4NTAyMzQ4",
          "commit": {
            "abbreviatedOid": "327590a"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-04T04:47:58Z",
          "updatedAt": "2020-03-04T04:47:58Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2OTA4MzY1",
          "commit": {
            "abbreviatedOid": "2153866"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-12T20:42:04Z",
          "updatedAt": "2020-07-12T20:42:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 309,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgxMTAwMTMw",
      "title": "Update MLSPlaintextTBS struct to match MLSPlaintext.",
      "url": "https://github.com/mlswg/mls-protocol/pull/309",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-02-27T22:13:50Z",
      "updatedAt": "2020-03-04T04:51:02Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "8045e66dbbac361202ac8ab90d3d27d33771ad28",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2020.2.1",
      "headRefOid": "78cdd3be31a53b5f2a7ffe8f5ca9c618f6852d8e",
      "closedAt": "2020-03-04T04:51:02Z",
      "mergedAt": "2020-03-04T04:51:02Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "10e75b3e9e722f6fda9a48b332407b80e51e87dd"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4NTAzMDQ3",
          "commit": {
            "abbreviatedOid": "78cdd3b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks for fixing this bug.",
          "createdAt": "2020-03-04T04:50:55Z",
          "updatedAt": "2020-03-04T04:50:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 310,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgyNjMyNjQ0",
      "title": "Fix identation and remove some vestigial stuff from the key schedule.",
      "url": "https://github.com/mlswg/mls-protocol/pull/310",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2020-03-02T22:05:54Z",
      "updatedAt": "2020-03-03T14:08:51Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "8045e66dbbac361202ac8ab90d3d27d33771ad28",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2020.2.2",
      "headRefOid": "afdfda8ef7eba543097b3af839e357a4ee6e3b49",
      "closedAt": "2020-03-03T14:08:51Z",
      "mergedAt": "2020-03-03T14:08:51Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "b9b68fb1ad3eae9789b14f98216296e1c9415d4a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3NTc2MjQ0",
          "commit": {
            "abbreviatedOid": "15e687e"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Could you please just restore the PSK part of the KeySchedule, I\u2019ll handle that separately.\r\nPs: we wouldn\u2019t have forgot you... :) we intended to go back to the list later, but I\u2019ll merge it now...",
          "createdAt": "2020-03-02T22:27:52Z",
          "updatedAt": "2020-03-02T22:27:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 311,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgzMTM0MTg0",
      "title": "Review of section 7.",
      "url": "https://github.com/mlswg/mls-protocol/pull/311",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2020-03-03T19:32:22Z",
      "updatedAt": "2020-03-05T23:02:25Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "680a2a7858684d6a8d3c7d8fe6b9f273a5d366bf",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2020.2.3",
      "headRefOid": "7ab79af6dded2b255617a531303458b339a58514",
      "closedAt": "2020-03-05T23:02:24Z",
      "mergedAt": "2020-03-05T23:02:24Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "f227d0c5c0f142d7dc421dfe12c22bdff6ce639a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4NTAyNjcw",
          "commit": {
            "abbreviatedOid": "2e6f31c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "One small change, otherwise LGTM.",
          "createdAt": "2020-03-04T04:49:21Z",
          "updatedAt": "2020-03-04T04:50:12Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "This is just an example, so it doesn't cost any generality just to say \"a member\".  And I think it reads more clearly.",
              "createdAt": "2020-03-04T04:49:21Z",
              "updatedAt": "2020-03-05T23:02:16Z"
            }
          ]
        }
      ]
    },
    {
      "number": 313,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg0NTQ5ODA1",
      "title": "Clarify signature algorithm requirements",
      "url": "https://github.com/mlswg/mls-protocol/pull/313",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "#279 required a common signature algorithm, but allowed credentials to deviate.  This PR adds the requirement that credentials be consistent.",
      "createdAt": "2020-03-05T23:22:32Z",
      "updatedAt": "2020-03-06T16:41:23Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "ba7a182cdd541c80087ea21a0d61a5024ab3d105",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "sig-fix",
      "headRefOid": "e663318ca9846cc79e6e4cb629ca496896b980f8",
      "closedAt": "2020-03-06T16:41:23Z",
      "mergedAt": "2020-03-06T16:41:22Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "1d79b5110a3cc31c86bd29e5af059285c1bf9cb0"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 314,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg0ODk3MTEx",
      "title": "Fix build and update changelog",
      "url": "https://github.com/mlswg/mls-protocol/pull/314",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Since draft-08, we have neglected to update the changelog, despite a bunch of significant changes.  Also, because our CI is busted, some build failures crept in.",
      "createdAt": "2020-03-06T15:59:56Z",
      "updatedAt": "2020-03-06T16:43:06Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "1d79b5110a3cc31c86bd29e5af059285c1bf9cb0",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "fix-build",
      "headRefOid": "ae16ebef6b49bae920e196dc43b3ef70fa7875c9",
      "closedAt": "2020-03-06T16:43:06Z",
      "mergedAt": "2020-03-06T16:43:06Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "99745ec6a2babbd12515cd19ae8f4ade7804d452"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 315,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg0ODk5MjAx",
      "title": "ClientInitKey -> KeyPackage",
      "url": "https://github.com/mlswg/mls-protocol/pull/315",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is just a terminology change.  ClientInitKey was feeling increasingly awkward, because (1) ClientInitKey structs are now used in leaves in addition to being used for initialization, and (2) there are some emerging cases where the \"client\" in an MLS sense might be a \"server\" (or some other role) in another application.  \"KeyPackage\" is a more neutral term.\r\n\r\nOther than `s/ClientInitKey/KeyPackage/g`, the most invasive change was in Welcome, where we already had `KeyPackage` and `EncryptedKeyPackage`.  I just changed those to `GroupSecrets` and `EncryptedGroupSecrets`, which seem more descriptive anyway.\r\n\r\nDepends on #314 ",
      "createdAt": "2020-03-06T16:04:31Z",
      "updatedAt": "2020-03-06T17:11:13Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "99745ec6a2babbd12515cd19ae8f4ade7804d452",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "key-package",
      "headRefOid": "1a6b2f1f964e3f64757316607445a9edda421e08",
      "closedAt": "2020-03-06T17:11:12Z",
      "mergedAt": "2020-03-06T17:11:12Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "3e30491de42dbb5443559cca4ece45339cea4721"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 316,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg0OTMxODY2",
      "title": "Update changelog for KeyPackage",
      "url": "https://github.com/mlswg/mls-protocol/pull/316",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-03-06T17:12:46Z",
      "updatedAt": "2020-03-06T17:12:52Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "3e30491de42dbb5443559cca4ece45339cea4721",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "key-package",
      "headRefOid": "b2e52d5229133798f766814db856fe044b0c532e",
      "closedAt": "2020-03-06T17:12:52Z",
      "mergedAt": "2020-03-06T17:12:52Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "35a68735c06c7d6cfa497cb63d6e7fa90e0aa82e"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 317,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg1MDA1MTUz",
      "title": "Change expiration extension to lifetime extension.",
      "url": "https://github.com/mlswg/mls-protocol/pull/317",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-03-06T20:21:39Z",
      "updatedAt": "2020-04-21T19:08:18Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "35a68735c06c7d6cfa497cb63d6e7fa90e0aa82e",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2020.3.0",
      "headRefOid": "cd94ebcf1272456a8e77389c532fef539e5618ff",
      "closedAt": "2020-04-21T19:08:18Z",
      "mergedAt": "2020-04-21T19:08:18Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "50b276b3d6b07c60e69ee54c62e0bede2ee7c527"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNzM0OTU4",
          "commit": {
            "abbreviatedOid": "cd94ebc"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-07T09:51:18Z",
          "updatedAt": "2020-03-07T09:51:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 318,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg1NDQ1MzI1",
      "title": "Fix markdown formatting issue for Ciphersuite section",
      "url": "https://github.com/mlswg/mls-protocol/pull/318",
      "state": "MERGED",
      "author": "arianvp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-03-09T08:25:37Z",
      "updatedAt": "2020-04-21T14:12:26Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "35a68735c06c7d6cfa497cb63d6e7fa90e0aa82e",
      "headRepository": "arianvp/mls-protocol",
      "headRefName": "patch-2",
      "headRefOid": "663ab30b1f09b238d1051853055c926096571f78",
      "closedAt": "2020-04-21T14:12:26Z",
      "mergedAt": "2020-04-21T14:12:26Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "2e9584b5e4e678c9c94baf820b80100b7c96b3fb"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3MzcxMTU1",
          "commit": {
            "abbreviatedOid": "663ab30"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-21T14:12:20Z",
          "updatedAt": "2020-04-21T14:12:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 319,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg2NDA4MTE1",
      "title": "Use correct type for uint32.",
      "url": "https://github.com/mlswg/mls-protocol/pull/319",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-03-10T23:15:18Z",
      "updatedAt": "2020-04-21T14:13:39Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "35a68735c06c7d6cfa497cb63d6e7fa90e0aa82e",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2020.3.1",
      "headRefOid": "7acb2cd43e81915cb67b985a8019c750a03a06fd",
      "closedAt": "2020-04-21T14:13:39Z",
      "mergedAt": "2020-04-21T14:13:38Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "4de0095356658d1486c6d34260e71659e36fa495"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3MzcyMzQw",
          "commit": {
            "abbreviatedOid": "7acb2cd"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-21T14:13:30Z",
          "updatedAt": "2020-04-21T14:13:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 320,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg2NDA4OTE0",
      "title": "Use node type instead of leaf index in tree hashes.",
      "url": "https://github.com/mlswg/mls-protocol/pull/320",
      "state": "CLOSED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "analysis",
        "discussion"
      ],
      "body": "This is more friendly with recursive implementations of Ratchet Trees and is more similar to the construction used in similar places, like RFC 6962.",
      "createdAt": "2020-03-10T23:18:09Z",
      "updatedAt": "2020-05-19T17:51:56Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "35a68735c06c7d6cfa497cb63d6e7fa90e0aa82e",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2020.3.2",
      "headRefOid": "06d579bf8d3957ecfd0b417f64a61f9725bb5f81",
      "closedAt": "2020-05-19T17:51:56Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "We had something like that before, and I think some folks liked having the index better because, for example, blank leaves at different positions have different hashes.",
          "createdAt": "2020-03-31T01:00:15Z",
          "updatedAt": "2020-03-31T01:00:15Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "The change was made in #254 with no apparent discussion. Not sure what you mean wrt to blank nodes -- I don't believe this is any more or less malleable than the current scheme.",
          "createdAt": "2020-03-31T23:57:41Z",
          "updatedAt": "2020-03-31T23:57:41Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "There was discussion. The security proofs rely on being able to disambiguate between different empty leaves or intermediate nodes when you don't balance the levels, and the type is not enough to do that.",
          "createdAt": "2020-04-01T11:45:07Z",
          "updatedAt": "2020-04-01T11:45:07Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry, I still don't see where the ambiguity is? The scheme captures whether or not a node is blank, if it's a leaf or not, where it is in the tree.",
          "createdAt": "2020-04-01T14:54:57Z",
          "updatedAt": "2020-04-01T14:55:40Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@Bren2010  You said in one of the issue discussions that this is to be friendlier to recursive implementations.  But it seems like as long as your recursive function knows (1) how big the tree is and (2) where it is in the tree, then you can include the node index with no problem.  This is in fact [how the Go implementation does it](https://github.com/bifurcation/mls/blob/master/ratchet-tree.go#L844). ",
          "createdAt": "2020-04-21T14:35:44Z",
          "updatedAt": "2020-04-21T14:35:44Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "This implementation doesn't have a recursive structure, it [uses a slice of nodes](https://github.com/bifurcation/mls/blob/master/ratchet-tree.go#L378) and the first thing you do is `len(t.Nodes)`. A recursive implementation would be defined like:\r\n```\r\ntype Node struct {\r\n    left, right *Node\r\n}\r\n```\r\n\r\nIn which case, yeah, a method like `func (n *Node) Hash` wouldn't know how big its subtree is, or whether it's an intermediate or the root.",
          "createdAt": "2020-04-21T16:30:06Z",
          "updatedAt": "2020-04-21T16:30:06Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "To make the protocol work, you need to know which leaf is at which index, and you need to store the total number of leaves somewhere.  So you have the information you need to figure out which non-leaf node has which index.\r\n",
          "createdAt": "2020-04-21T16:50:22Z",
          "updatedAt": "2020-04-21T16:50:22Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't believe you need that information to make anything in the *ratchet tree* work. So you're arguing that we should include unnecessary information in one component of the protocol, because we happen to have that information somewhere else?",
          "createdAt": "2020-04-21T17:38:51Z",
          "updatedAt": "2020-04-21T17:38:51Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 321,
      "id": "MDExOlB1bGxSZXF1ZXN0MzkxODcyNzg5",
      "title": "Extensions -> Extension",
      "url": "https://github.com/mlswg/mls-protocol/pull/321",
      "state": "MERGED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-03-21T15:26:59Z",
      "updatedAt": "2020-03-25T00:07:55Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "35a68735c06c7d6cfa497cb63d6e7fa90e0aa82e",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "raphaelrobert-minor-edits",
      "headRefOid": "a89e27bfade1b787a8f717878f31ce3d4d61747b",
      "closedAt": "2020-03-21T15:55:12Z",
      "mergedAt": "2020-03-21T15:55:12Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "55c292ce69157193da616f2460d0b5de5a6df906"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4OTI4NjA3",
          "commit": {
            "abbreviatedOid": "a89e27b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-21T15:55:06Z",
          "updatedAt": "2020-03-21T15:55:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 322,
      "id": "MDExOlB1bGxSZXF1ZXN0MzkzMzE2NTA0",
      "title": "Minor fix",
      "url": "https://github.com/mlswg/mls-protocol/pull/322",
      "state": "MERGED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-03-25T00:10:09Z",
      "updatedAt": "2020-04-27T11:00:46Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "55c292ce69157193da616f2460d0b5de5a6df906",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "raphaelrobert-minor-fix",
      "headRefOid": "d5e453b7c3899850c8000e36e406636ac9e1ef89",
      "closedAt": "2020-03-25T05:49:14Z",
      "mergedAt": "2020-03-25T05:49:14Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "9b22a1af59a06adf1f18afc2464708f4ae1176e6"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 327,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzk1MTI3ODE1",
      "title": "Fix bugs in tree math and cleanup docs.",
      "url": "https://github.com/mlswg/mls-protocol/pull/327",
      "state": "CLOSED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial",
        "enhancement"
      ],
      "body": "",
      "createdAt": "2020-03-28T17:34:39Z",
      "updatedAt": "2020-07-12T20:04:17Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "c0f69e7f6b96afdffd9f45a7c73d1ef81f9ea99a",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2020.3.3",
      "headRefOid": "5ee9f5d0be4b666d22a318d9ce8695b25cca5e34",
      "closedAt": "2020-07-12T20:04:17Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "yihuang",
          "authorAssociation": "NONE",
          "body": "```\r\nThe basic rule is that the high-order bits of parent and child nodes have the\r\nfollowing relation (where x is an arbitrary bit string):\r\n\r\n    parent=01x => left=00x, right=10x\r\n```\r\n\r\nI think it should change like this: \"where x is an arbitrary bit string\" => \"where x is an sequence of one bits\".",
          "createdAt": "2020-06-07T09:18:47Z",
          "updatedAt": "2020-06-07T09:19:09Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "You can have cases where x isn't all ones, for example when the left and right children are intermediate nodes",
          "createdAt": "2020-06-07T17:54:06Z",
          "updatedAt": "2020-06-07T17:54:06Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3Mzc3MTYw",
          "commit": {
            "abbreviatedOid": "8eaad0f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-21T14:18:17Z",
          "updatedAt": "2020-04-21T14:18:18Z",
          "comments": [
            {
              "originalPosition": 124,
              "body": "```suggestion\r\n# The direct path of a node, ordered from leaf to root,\r\n# including the root but not the leaf.\r\n```",
              "createdAt": "2020-04-21T14:18:17Z",
              "updatedAt": "2020-05-19T17:56:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3Mzc5OTkz",
          "commit": {
            "abbreviatedOid": "8eaad0f"
          },
          "author": "mheinzel",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-21T14:21:06Z",
          "updatedAt": "2020-04-21T14:21:57Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "```suggestion\r\n# left-balanced, there is no dependency on the size of the tree.\r\n```\r\n\r\nTo stay consistent with the code change.",
              "createdAt": "2020-04-21T14:21:06Z",
              "updatedAt": "2020-05-19T17:56:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3Mzg2NjYx",
          "commit": {
            "abbreviatedOid": "8eaad0f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-21T14:27:51Z",
          "updatedAt": "2020-04-21T14:27:52Z",
          "comments": [
            {
              "originalPosition": 165,
              "body": "If you're going to the semantic clarity route, you might as well go all the way.\r\n\r\n```\r\ndef common_ancestor(x, y, n):\r\n    dx = set(direct_path(x, n))\r\n    dy = set(direct_path(y, n))\r\n    dxy = dx & dy\r\n    if len(dxy) == 0:\r\n        raise Exception('failed to find common ancestor')\r\n\r\n    return min(dxy, key=level)\r\n```\r\n\r\nI would prefer we also provide the old, direct version as an alternative implementation.  It is index magic, but it's not really any more magical than the stuff above.\r\n\r\n```\r\n# The same function as common_ancestor, but using the indices \r\n# directly instead of constructing the direct paths\r\ndef common_ancestor_dir(x, y, n):\r\n    ...\r\n```",
              "createdAt": "2020-04-21T14:27:51Z",
              "updatedAt": "2020-05-19T17:56:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3NjAwMDgx",
          "commit": {
            "abbreviatedOid": "8eaad0f"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-21T19:14:30Z",
          "updatedAt": "2020-04-21T19:14:31Z",
          "comments": [
            {
              "originalPosition": 165,
              "body": "I also think we should have both implementations",
              "createdAt": "2020-04-21T19:14:30Z",
              "updatedAt": "2020-05-19T17:56:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3ODExMTk2",
          "commit": {
            "abbreviatedOid": "8eaad0f"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-22T03:06:47Z",
          "updatedAt": "2020-04-22T03:06:47Z",
          "comments": [
            {
              "originalPosition": 124,
              "body": "This is redundant with the definition of direct path",
              "createdAt": "2020-04-22T03:06:47Z",
              "updatedAt": "2020-05-19T17:56:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3ODE0NDAy",
          "commit": {
            "abbreviatedOid": "8eaad0f"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-22T03:17:48Z",
          "updatedAt": "2020-04-22T03:17:48Z",
          "comments": [
            {
              "originalPosition": 165,
              "body": "The code you've given is not correct, `common_ancestor(0, 7, 11) = 15 (should be 7)`.\r\nThe old code is also not correct, `common_ancestor(0, 7, 11) = 3 (should be 7)`, which is why I removed it.",
              "createdAt": "2020-04-22T03:17:48Z",
              "updatedAt": "2020-05-19T17:56:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4MjYyOTI3",
          "commit": {
            "abbreviatedOid": "09d2bd3"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-22T14:41:26Z",
          "updatedAt": "2020-04-22T14:41:27Z",
          "comments": [
            {
              "originalPosition": 165,
              "body": "The semantic code fails when x == y because the leaf is not in the direct path; the direct code fails when one node is in the direct path of the other.  I had not worried about these because MLS only ever needs to call `ancestor(x, y)` with x and y  leaf nodes and x != y.  But both are easy to fix.  See fixed code and validation here:\r\n\r\nhttps://repl.it/@RichardBarnes/ImmediateCrookedScience",
              "createdAt": "2020-04-22T14:41:26Z",
              "updatedAt": "2020-05-19T17:56:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4ODYxMDM0",
          "commit": {
            "abbreviatedOid": "7451a17"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-23T08:12:36Z",
          "updatedAt": "2020-04-23T08:12:36Z",
          "comments": [
            {
              "originalPosition": 170,
              "body": "How can a leaf be the ancestor of another leaf?",
              "createdAt": "2020-04-23T08:12:36Z",
              "updatedAt": "2020-05-19T17:56:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1ODQxNTk0",
          "commit": {
            "abbreviatedOid": "5ee9f5d"
          },
          "author": "yihuang",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-07T18:09:51Z",
          "updatedAt": "2020-06-07T18:09:52Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "If passed in x is larger than `node_width(x)`, the loop might not finish.\r\nso maybe add `assert x < node_width(n)` at the beginning.",
              "createdAt": "2020-06-07T18:09:51Z",
              "updatedAt": "2020-06-07T18:36:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1ODQyNTk0",
          "commit": {
            "abbreviatedOid": "5ee9f5d"
          },
          "author": "yihuang",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-07T18:25:44Z",
          "updatedAt": "2020-06-07T18:25:45Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "```suggestion\r\n    if n == 0:\r\n        return 0\r\n    else:\r\n        return n + n - 1\r\n```",
              "createdAt": "2020-06-07T18:25:44Z",
              "updatedAt": "2020-06-08T04:18:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4MzAzMzQ2",
          "commit": {
            "abbreviatedOid": "5ee9f5d"
          },
          "author": "yihuang",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-10T18:02:12Z",
          "updatedAt": "2020-06-10T18:02:14Z",
          "comments": [
            {
              "originalPosition": 153,
              "body": "Since `direct_path` contains root, and `sibling(root)` raise exception, so it'll raises exception here.",
              "createdAt": "2020-06-10T18:02:13Z",
              "updatedAt": "2020-06-10T18:02:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2OTA2MDQ3",
          "commit": {
            "abbreviatedOid": "5ee9f5d"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-12T20:03:52Z",
          "updatedAt": "2020-07-12T20:03:53Z",
          "comments": [
            {
              "originalPosition": 153,
              "body": "d doesn't contain the root because of the last d.pop()",
              "createdAt": "2020-07-12T20:03:53Z",
              "updatedAt": "2020-07-12T20:03:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2OTA2MDY0",
          "commit": {
            "abbreviatedOid": "5ee9f5d"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-12T20:04:10Z",
          "updatedAt": "2020-07-12T20:04:10Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "We don't assert anywhere else, probably fine",
              "createdAt": "2020-07-12T20:04:10Z",
              "updatedAt": "2020-07-12T20:04:10Z"
            }
          ]
        }
      ]
    },
    {
      "number": 329,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzk3MDk2NTUw",
      "title": "Rename messaging service to service provider",
      "url": "https://github.com/mlswg/mls-protocol/pull/329",
      "state": "MERGED",
      "author": "GaPhil",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR addresses https://github.com/mlswg/mls-architecture/issues/62.",
      "createdAt": "2020-04-01T16:17:48Z",
      "updatedAt": "2020-04-01T16:18:41Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "9b22a1af59a06adf1f18afc2464708f4ae1176e6",
      "headRepository": "GaPhil/mls-protocol",
      "headRefName": "master",
      "headRefOid": "b38bc9e65edd6e68addbf8760e71fa22910f10f8",
      "closedAt": "2020-04-01T16:18:41Z",
      "mergedAt": "2020-04-01T16:18:41Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "16481cecca9420f5928ce4327b55ac5a9911b6f8"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 330,
      "id": "MDExOlB1bGxSZXF1ZXN0NDA5NDM2NDY1",
      "title": "Minor fixes",
      "url": "https://github.com/mlswg/mls-protocol/pull/330",
      "state": "MERGED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-04-27T11:25:32Z",
      "updatedAt": "2021-10-08T22:20:22Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "50b276b3d6b07c60e69ee54c62e0bede2ee7c527",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "raphaelrobert-minor-fix",
      "headRefOid": "4d095697bb742284283e0eb09380094f6bb04225",
      "closedAt": "2020-04-27T13:49:12Z",
      "mergedAt": "2020-04-27T13:49:12Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "5d6a2864054857e18966463d69dde5f8cca71e5a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwOTY5NTE0",
          "commit": {
            "abbreviatedOid": "4d09569"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-27T13:49:05Z",
          "updatedAt": "2020-04-27T13:49:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 331,
      "id": "MDExOlB1bGxSZXF1ZXN0NDA5NTI2MTc4",
      "title": "Make ratcheting optional for Adds",
      "url": "https://github.com/mlswg/mls-protocol/pull/331",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "functionality",
        "performance",
        "security"
      ],
      "body": "When we converted to the Proposal/Commit scheme, one of the consequences was that Adds became O(N) instead of O(1), since they had to Committed and commits encrypt the committer's direct path to the remainder of the tree.  This is ~log(N) in the nice case and ~N in the worst case.  At the time, we noted that one could special-case Add-only Commits in the future and make the update to the direct path optional in that case.\r\n\r\nThis PR implements that suggestion.  The leaf KeyPackage for the Commit is moved into the DirectPath struct, and the whole DirectPath is made optional.  The optional value MUST be provided for:\r\n\r\n* A Commit committing an update or remove\r\n* A \"just update my path\" Commit covering no proposals",
      "createdAt": "2020-04-27T14:08:46Z",
      "updatedAt": "2020-05-21T19:27:44Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "5d6a2864054857e18966463d69dde5f8cca71e5a",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "no-ratchet-on-add",
      "headRefOid": "43e2f5ef4745bcbfabc8316fb9e54e6bfbf61aa8",
      "closedAt": "2020-05-21T19:27:44Z",
      "mergedAt": "2020-05-21T19:27:44Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "8264f452c27354ac043d289a893b4bec80c1d556"
      },
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So we _do_ go forward one epoch, but with an all-zero commit secret. Do I understand that correctly?",
          "createdAt": "2020-04-29T05:42:13Z",
          "updatedAt": "2020-04-29T05:42:13Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@kkohbrok That's correct.  The idea is that you don't need to send the current group any additional entropy, you just need them to hash forward.\r\n\r\nNote that this could change the FS/PCS guarantees available.  But I don't think we ever proposed that Add would cause any FS/PCS changes to the group, so maybe this doesn't matter.",
          "createdAt": "2020-04-29T16:54:37Z",
          "updatedAt": "2020-04-29T16:54:37Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Add should give FS guarantees in so far as that the new member shouldn't be able to decrypt old messages or derive old keys. But I think ratcheting forward should do the trick. We should note, though, that this breaks the (implicit) assumption that a commit always introduces fresh key material to the group. As far as I can see, that's not breaking anything right now, but we should keep it in mind.",
          "createdAt": "2020-04-30T06:06:52Z",
          "updatedAt": "2020-04-30T06:06:52Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Note: The latest commit fixes a gap that was discovered in [implementing this PR in Go](https://github.com/cisco/go-mls/pull/69).",
          "createdAt": "2020-05-20T17:17:40Z",
          "updatedAt": "2020-05-20T17:17:40Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxMDIzOTk0",
          "commit": {
            "abbreviatedOid": "f657621"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-27T14:44:53Z",
          "updatedAt": "2020-04-27T14:44:54Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "Why not set `commit_secret` to zero length vector? Seems easier to me.",
              "createdAt": "2020-04-27T14:44:53Z",
              "updatedAt": "2020-05-21T19:00:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyODU0MDY4",
          "commit": {
            "abbreviatedOid": "f657621"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-29T16:49:52Z",
          "updatedAt": "2020-04-29T16:49:53Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "That would also work for me.  I just copied what TLS does, e.g., for missing PSK inputs.",
              "createdAt": "2020-04-29T16:49:52Z",
              "updatedAt": "2020-05-21T19:00:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0NjIyMTA5",
          "commit": {
            "abbreviatedOid": "f657621"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-19T16:30:08Z",
          "updatedAt": "2020-05-19T16:30:09Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "TODO: Add pseudocode here to express the algorithm.",
              "createdAt": "2020-05-19T16:30:08Z",
              "updatedAt": "2020-05-21T19:00:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1NjYwNjg5",
          "commit": {
            "abbreviatedOid": "a803b8c"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-20T19:45:06Z",
          "updatedAt": "2020-05-20T19:45:07Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "I think we could be more flexible here: Since the path value MAY be omitted if the Commit only contains Adds, it MAY also not be omitted.\r\nThe sender should be able to choose whether they want to use the commit to also do an update and the receivers should simply process it.",
              "createdAt": "2020-05-20T19:45:06Z",
              "updatedAt": "2020-05-21T19:00:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2MzkyMjI1",
          "commit": {
            "abbreviatedOid": "a803b8c"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "See the flexibility question.",
          "createdAt": "2020-05-21T18:33:25Z",
          "updatedAt": "2020-05-21T18:33:25Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2NDEwNTY4",
          "commit": {
            "abbreviatedOid": "a803b8c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-21T19:00:34Z",
          "updatedAt": "2020-05-21T19:00:35Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "I think this is already the case, but I added a bit more text to clarify\r\n",
              "createdAt": "2020-05-21T19:00:35Z",
              "updatedAt": "2020-05-21T19:00:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2NDE1ODEw",
          "commit": {
            "abbreviatedOid": "43e2f5e"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-21T19:08:29Z",
          "updatedAt": "2020-05-21T19:08:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 332,
      "id": "MDExOlB1bGxSZXF1ZXN0NDEzNjkyNTky",
      "title": "adding a table of contents",
      "url": "https://github.com/mlswg/mls-protocol/pull/332",
      "state": "CLOSED",
      "author": "bast",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "We did this together with @chrisbrzuska live on Twitch.",
      "createdAt": "2020-05-05T18:53:29Z",
      "updatedAt": "2020-05-06T11:37:20Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "5d6a2864054857e18966463d69dde5f8cca71e5a",
      "headRepository": null,
      "headRefName": "patch-1",
      "headRefOid": "76e78c54e2bdab46b6f549735db6daeb0adaf969",
      "closedAt": "2020-05-06T11:37:19Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "The table of contents is auto-generated in the text format, there is no need to add it:\r\n\r\nhttps://www.ietf.org/id/draft-ietf-mls-protocol-09.txt",
          "createdAt": "2020-05-05T20:36:56Z",
          "updatedAt": "2020-05-05T20:36:56Z"
        },
        {
          "author": "bast",
          "authorAssociation": "NONE",
          "body": "OK. Thank you for the clarification!",
          "createdAt": "2020-05-06T11:37:19Z",
          "updatedAt": "2020-05-06T11:37:19Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 333,
      "id": "MDExOlB1bGxSZXF1ZXN0NDEzNzMyMTIz",
      "title": "add code highlighting for the python code part",
      "url": "https://github.com/mlswg/mls-protocol/pull/333",
      "state": "CLOSED",
      "author": "bast",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-05-05T20:19:24Z",
      "updatedAt": "2020-05-06T13:56:08Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "5d6a2864054857e18966463d69dde5f8cca71e5a",
      "headRepository": null,
      "headRefName": "radovan/code-highlighting",
      "headRefOid": "e7e1cdb4d34e7bd218b078167f510909e476a572",
      "closedAt": "2020-05-06T13:56:08Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "Code highlighting wouldn't work in the text format.",
          "createdAt": "2020-05-05T20:38:01Z",
          "updatedAt": "2020-05-05T20:38:01Z"
        },
        {
          "author": "bast",
          "authorAssociation": "NONE",
          "body": "OK I considered only the rendered Markdown page on GitHub but forgot that the webpages are generated and possibly does not work there. Where are the generated webpages? Feel free to close it.",
          "createdAt": "2020-05-06T11:36:31Z",
          "updatedAt": "2020-05-06T11:36:31Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 334,
      "id": "MDExOlB1bGxSZXF1ZXN0NDE1MTcxNTE2",
      "title": "Explicitly state the order in which proposals are applied when creating a commit",
      "url": "https://github.com/mlswg/mls-protocol/pull/334",
      "state": "MERGED",
      "author": "ericcornelissen",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #300 by updating the description for creating a commit to explicitly mention that first all update proposals are applied, then remove proposals, and last add proposals.",
      "createdAt": "2020-05-08T10:44:03Z",
      "updatedAt": "2020-05-08T14:20:39Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "5d6a2864054857e18966463d69dde5f8cca71e5a",
      "headRepository": null,
      "headRefName": "proposal-apply-order",
      "headRefOid": "693d3ff1cd4b0ddbf37dbdec2d9e8f6115aeb6a0",
      "closedAt": "2020-05-08T14:20:39Z",
      "mergedAt": "2020-05-08T14:20:39Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "c519e9d8ac723ed19fa114198abb09922d1027f7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4MTg0NTc0",
          "commit": {
            "abbreviatedOid": "693d3ff"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-08T11:50:54Z",
          "updatedAt": "2020-05-08T11:50:54Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4MjczMzc1",
          "commit": {
            "abbreviatedOid": "693d3ff"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-08T14:20:32Z",
          "updatedAt": "2020-05-08T14:20:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 335,
      "id": "MDExOlB1bGxSZXF1ZXN0NDE1ODA5OTQy",
      "title": "Fix HPKE setup function name",
      "url": "https://github.com/mlswg/mls-protocol/pull/335",
      "state": "MERGED",
      "author": "tomtau",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In the latest HPKE draft (draft-irtf-cfrg-hpke-04), \"Initiator (I)\" was renamed to \"Sender (S)\".",
      "createdAt": "2020-05-11T00:47:59Z",
      "updatedAt": "2020-05-17T17:21:12Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "c519e9d8ac723ed19fa114198abb09922d1027f7",
      "headRepository": "tomtau/mls-protocol",
      "headRefName": "patch-1",
      "headRefOid": "4b76ac15dd0ed2c20069d8801f434b6be2488092",
      "closedAt": "2020-05-17T17:21:12Z",
      "mergedAt": "2020-05-17T17:21:12Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "bb3a3de94cc75e91dee62d24f702fb2b1b5d1182"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzMDg1Mzgw",
          "commit": {
            "abbreviatedOid": "4b76ac1"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-16T15:29:17Z",
          "updatedAt": "2020-05-16T15:29:17Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzMTgxOTAw",
          "commit": {
            "abbreviatedOid": "4b76ac1"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-17T17:20:58Z",
          "updatedAt": "2020-05-17T17:20:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 336,
      "id": "MDExOlB1bGxSZXF1ZXN0NDE5MDE0ODc4",
      "title": "PSK Injection, Group recovery, Re-Init, Sub-group Branching",
      "url": "https://github.com/mlswg/mls-protocol/pull/336",
      "state": "MERGED",
      "author": "br-hale",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "key schedule"
      ],
      "body": "Changes to key schedule and corresponding directions on use of PSKs for group recovery, re-initialization, sub-group branching, and external PSK injection.",
      "createdAt": "2020-05-16T19:48:40Z",
      "updatedAt": "2020-10-08T14:40:11Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "5f06f08d001054b74ce40b95bf4b2949eac81dc4",
      "headRepository": "br-hale/mls-protocol",
      "headRefName": "exporters",
      "headRefOid": "3846416b89e800292958566e8aff7081d34bb142",
      "closedAt": "2020-10-08T14:40:11Z",
      "mergedAt": "2020-10-08T14:40:10Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "dca87748bfc9b98b8ed34168e9fbf16fddccad79"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I had some long-form comments on this PR, so I sent them to the mailing list.",
          "createdAt": "2020-06-17T22:54:38Z",
          "updatedAt": "2020-06-17T22:54:38Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0NjAxMzg4",
          "commit": {
            "abbreviatedOid": "0106dff"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-19T16:06:10Z",
          "updatedAt": "2020-05-19T16:06:11Z",
          "comments": [
            {
              "originalPosition": 532,
              "body": "There already is a struct called `KeyPackage`",
              "createdAt": "2020-05-19T16:06:11Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1MDA0MzE5",
          "commit": {
            "abbreviatedOid": "0106dff"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-20T05:34:41Z",
          "updatedAt": "2020-05-20T05:34:41Z",
          "comments": [
            {
              "originalPosition": 532,
              "body": "Hm. Not sure how that got there. I don't think we intended renaming the struct. The change was supposed to be that the `psk`s are included in the Welcome message.",
              "createdAt": "2020-05-20T05:34:41Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2NzYyNTA2",
          "commit": {
            "abbreviatedOid": "20145e4"
          },
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-09T03:22:17Z",
          "updatedAt": "2020-06-09T03:22:18Z",
          "comments": [
            {
              "originalPosition": 158,
              "body": "Over in TLS, we worked on an interface for injecting PSKs:\r\n\r\n   https://tools.ietf.org/html/draft-ietf-tls-external-psk-importer-05\r\n\r\nWe concluded binding the imported PSK to the target protocol and KDF was sufficient. Maybe the same thing should be done here, i.e., to ensure that an injected PSK for MLS v1.0 does not collide with one injected for a different version?",
              "createdAt": "2020-06-09T03:22:17Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2NzYzMDYx",
          "commit": {
            "abbreviatedOid": "20145e4"
          },
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-09T03:24:05Z",
          "updatedAt": "2020-06-09T03:24:05Z",
          "comments": [
            {
              "originalPosition": 265,
              "body": "Are \"external\" PSKs fixed? Would it make sense for them to also include an epoch, to allow applications to roll them forward for some FS?",
              "createdAt": "2020-06-09T03:24:05Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2NzcwNjkx",
          "commit": {
            "abbreviatedOid": "20145e4"
          },
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-09T03:52:22Z",
          "updatedAt": "2020-06-09T03:52:23Z",
          "comments": [
            {
              "originalPosition": 265,
              "body": "External PSKs are required to be of an \"equivalent security level\" (although that terminology was added to the draft a long time ago and not yet defined). As such, any FS guarantees or other requirements must be met before being injected. It does not make sense to ratchet external PSK forward per MLS spec, as then we would be trying to correlate the time of existence of the PSK to MLS (i.e. parallel ratcheting); in that case the PSK is no longer external to the protocol but somehow correlated to it. The nonce prevents reuse, but any additional guarantees should be met by the application, not the protocol (going back to meeting requirements before being injected). ",
              "createdAt": "2020-06-09T03:52:23Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2NzcxMTU1",
          "commit": {
            "abbreviatedOid": "20145e4"
          },
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-09T03:54:07Z",
          "updatedAt": "2020-06-09T03:54:07Z",
          "comments": [
            {
              "originalPosition": 158,
              "body": "Adding the MLS version number to the PSK type sounds like a solid addition.",
              "createdAt": "2020-06-09T03:54:07Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2NzcxNjM4",
          "commit": {
            "abbreviatedOid": "20145e4"
          },
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-09T03:55:58Z",
          "updatedAt": "2020-06-09T03:55:58Z",
          "comments": [
            {
              "originalPosition": 265,
              "body": "I\u2019m not sure I agree. You can certainly do the ratcheting outside of the protocol, but you can also do it inside. For example, send an epoch and psk_id, and hash forward the external PSK corresponding to the ID based on the epoch. Some applications might not be able to augment their external PSK provision machinery to ratchet, so handling it in the protocol can be appealing. Food for thought.",
              "createdAt": "2020-06-09T03:55:58Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2ODE2ODc5",
          "commit": {
            "abbreviatedOid": "20145e4"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-09T06:15:37Z",
          "updatedAt": "2020-06-09T06:15:37Z",
          "comments": [
            {
              "originalPosition": 265,
              "body": "So the proposal would be to extend MLS to allow ratcheting of \"external\" PSKs that continuously get injected into the protocol?\r\n\r\nIt's interesting, but it seems to me like we'd be creating a degree of redundancy here. MLS doesn't have very good FS capabilities (although they can be improved by something like RTreeKEM), so it's tempting to create a secondary mechanism, i.e. ratcheting a PSK along the epoch-chain. However, then the FS guarantees hinge on the FS properties of whatever means was used to distribute the PSK. So what is a scenario where the means of PSK distribution gives you better FS than MLS? If you have this really good out-of-band distribution channel for PSKs, do you really still need MLS?\r\n\r\nI don't think it's a bad idea, but I'm not sure how often it will be used and if it warrants the added complexity in the protocol. But that's maybe an issue we should discuss on the list or in the next virtual interim? \r\n\r\nIn any case, I think it's a good idea that's worth thinking about and that might match the use case of a number of people, but it's relatively orthogonal enough to our PR. Maybe it would be worth a new github issue?",
              "createdAt": "2020-06-09T06:15:37Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4Mjc4NDIy",
          "commit": {
            "abbreviatedOid": "20145e4"
          },
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-10T17:29:12Z",
          "updatedAt": "2020-06-10T17:29:12Z",
          "comments": [
            {
              "originalPosition": 265,
              "body": "This proposal it about taking in an external PSK, and then maintaining it in sync to protocol ratcheting. As FS is the main benefit of this, the working assumption/use case that it addresses is one where:\r\n\r\nA) the application does not have the capability of aligning security level of the PSK to the current epoch but provides it directly to the protocol (which begs the question of whether the application is checking \"equivalent security level\" for the PSK to begin with) and \r\n\r\nB) the external PSK will be used at multiple epochs (FS benefits become relevant when the external PSK has already been used in a past epoch).\r\n\r\nThis is a very specific case. Although it has clear benefits, those benefits derive from poor application choices or machinery.\r\n\r\nMany of the MLS protocol design choices have been made with the explicit goal of separating out necessary protocol actions and peripheral behavior that can be determined by the application, even if it has security implications (e.g. the entire key management of the AS is out of scope). In the same way, this proposal seems to be more suited to the architecture than the core protocol. Perhaps you can draft a PR on the architecture document for this? \r\n\r\nI will add a new github issue so people get a chance to comment as a relevant, separate issue.\r\n",
              "createdAt": "2020-06-10T17:29:12Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4MzE4Nzgy",
          "commit": {
            "abbreviatedOid": "20145e4"
          },
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-10T18:23:48Z",
          "updatedAt": "2020-06-10T18:23:49Z",
          "comments": [
            {
              "originalPosition": 265,
              "body": "Yeah, it's certainly orthogonal. We can address it elsewhere (if at all)!",
              "createdAt": "2020-06-10T18:23:49Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0MDYzNzQ0",
          "commit": {
            "abbreviatedOid": "1646e19"
          },
          "author": "ericcornelissen",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-10T09:05:35Z",
          "updatedAt": "2020-08-10T09:05:35Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "Seems like the `confirmation_key` got duplicated accidentally\r\n\r\n```suggestion\r\n| `confirmation_key`      | \"confirm\"     |\r\n```",
              "createdAt": "2020-08-10T09:05:35Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0MDY1MjIy",
          "commit": {
            "abbreviatedOid": "1646e19"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-10T09:07:59Z",
          "updatedAt": "2020-08-10T09:07:59Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "Whoops you're right. For some reason I can't commit your suggestion, but I'll change the PR accordingly.",
              "createdAt": "2020-08-10T09:07:59Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0MzAyNjM4",
          "commit": {
            "abbreviatedOid": "1646e19"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-10T14:53:18Z",
          "updatedAt": "2020-08-10T16:03:58Z",
          "comments": [
            {
              "originalPosition": 183,
              "body": "```suggestion\r\n```",
              "createdAt": "2020-08-10T14:53:18Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            },
            {
              "originalPosition": 110,
              "body": "Nit: Please format OPEN ISSUEs with the `<!-- -->` bracketing as below.",
              "createdAt": "2020-08-10T14:54:16Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            },
            {
              "originalPosition": 134,
              "body": "It's not \"either/or\" -- when you signal to the existing members in Commit, you MUST include the same instructions in the Welcome.  So I would rephrase this more declaratively:\r\n\r\n> The injection of one or more PSKs into the key schedule is signalied by including a PreSharedKeys value in two places: (1) As an extension in the Commit that initiates a new epoch, and (2) in the GroupSecrets object carried in the Welcome message sent to members added in that epoch.",
              "createdAt": "2020-08-10T14:57:22Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            },
            {
              "originalPosition": 165,
              "body": "\"... or a GroupSecrets object with the `psks` field set\"",
              "createdAt": "2020-08-10T14:58:25Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            },
            {
              "originalPosition": 118,
              "body": "This seems like a good spot to indicate that PSKs are typed.\r\n\r\n> Each PSK in MLS has a type that designates how it was provisioned.  External PSKs are provided by the application logic.  Resumption PSKs are derived from the MLS key schedule, and used in cases where it is necessary to authenticate a member's participation in a prior group state:",
              "createdAt": "2020-08-10T15:01:37Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            },
            {
              "originalPosition": 123,
              "body": "Instead of \"reboot\", suggest \"carry entropy from the old group forward into a new group with the desired parameters\"",
              "createdAt": "2020-08-10T15:02:56Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            },
            {
              "originalPosition": 126,
              "body": "Just to confirm, \"securely\" here means, \"continuing members can verify that the newly added member was a prior participant.\r\n\r\nNote that this will have some complexity in practice, since the continuing members *also* have to have been in the group at that time.  So you couldn't have the following sequence:\r\n\r\n```\r\nEpoch 1: Group = {A, B, C}\r\n=== B loses sync with group ===\r\nEpoch 2: D added, Group = {A, B, C, D}\r\nEpoch 3: B is re-added with PSK to prove that they were in epoch 1\r\n```\r\n\r\n... because D won't have the PSK.",
              "createdAt": "2020-08-10T15:05:46Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            },
            {
              "originalPosition": 162,
              "body": "```suggestion\r\n```",
              "createdAt": "2020-08-10T15:18:01Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            },
            {
              "originalPosition": 139,
              "body": "Nit: I'm not sure if the `-` is allowed in the TLS syntax, but folks tend to reuse notation in programming, and it's definitely not allowed in variable/const names in typical programming languages.  Suggest `reinit`.",
              "createdAt": "2020-08-10T15:20:14Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            },
            {
              "originalPosition": 139,
              "body": "I wonder whether all of these specializations are necessary, or whether a single `resumption` case would suffice.  If you include the *destination* group ID / epoch in the label as well, then you would have even better separation/context than you do here.",
              "createdAt": "2020-08-10T15:21:34Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            },
            {
              "originalPosition": 152,
              "body": "Explicitly enumerating the cases here will be better for future extensibility.",
              "createdAt": "2020-08-10T15:21:58Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            },
            {
              "originalPosition": 157,
              "body": "```suggestion\r\n} PreSharedKeyID;\r\n```",
              "createdAt": "2020-08-10T15:22:25Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            },
            {
              "originalPosition": 175,
              "body": "`PreSharedKey(type);` doesn't make sense syntactically.  I think you can just replace these top two fields with `PreSharedKey psk_id`, since that specifies both the type and the value.",
              "createdAt": "2020-08-10T15:23:48Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0Mzg4MzQy",
          "commit": {
            "abbreviatedOid": "79ac9b9"
          },
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-10T16:28:58Z",
          "updatedAt": "2020-08-10T16:28:58Z",
          "comments": [
            {
              "originalPosition": 139,
              "body": "Dash removed to address first comment.\r\n\r\nFor second comment: a single resumption case does not cover key differences between the three options here, and mixing them into one (which was considered at length) causes issues down the line. In reinit, the original group must be fully terminated as a requirement, which is not the case in branching and recovery. Branching \"copies\" a subset of the current group into a new one, and it is essential that members know that this is not done with recovery (where a member is added back in, but there is no divergence in history). If the PSKtype does not signal distinctions sufficiently well, then there will likely be group authentication attacks over the history of group evolution (i.e. disagreement on what has occurred).",
              "createdAt": "2020-08-10T16:28:58Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NDE0Nzky",
          "commit": {
            "abbreviatedOid": "2fa7ad4"
          },
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-10T17:04:56Z",
          "updatedAt": "2020-08-10T17:04:57Z",
          "comments": [
            {
              "originalPosition": 126,
              "body": "Good observation. Clarification added.",
              "createdAt": "2020-08-10T17:04:56Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NTAyMDAw",
          "commit": {
            "abbreviatedOid": "6689044"
          },
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-10T19:13:20Z",
          "updatedAt": "2020-08-10T19:13:21Z",
          "comments": [
            {
              "originalPosition": 118,
              "body": "Addressed.",
              "createdAt": "2020-08-10T19:13:21Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NTA2NDY0",
          "commit": {
            "abbreviatedOid": "7bd759d"
          },
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-10T19:20:36Z",
          "updatedAt": "2020-08-10T19:20:37Z",
          "comments": [
            {
              "originalPosition": 152,
              "body": "Addressed, according to what you seem to be requesting.",
              "createdAt": "2020-08-10T19:20:37Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1NDAwMTM1",
          "commit": {
            "abbreviatedOid": "3bbd706"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-26T11:34:09Z",
          "updatedAt": "2020-08-26T11:34:09Z",
          "comments": [
            {
              "originalPosition": 175,
              "body": "Good point. Should be fixed now.",
              "createdAt": "2020-08-26T11:34:09Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1NzU5MjU2",
          "commit": {
            "abbreviatedOid": "3bbd706"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-26T18:42:45Z",
          "updatedAt": "2020-08-26T20:48:09Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "I think this Open Issue can be removed -- it is closed by this PR!\r\n",
              "createdAt": "2020-08-26T18:42:45Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            },
            {
              "originalPosition": 122,
              "body": "Is it really necessary to distinguish all of these cases at this level?\r\n\r\nIf so, then the above text needs to change from \"how it was provisioned\", because these types relate to *use*, not provisioning.",
              "createdAt": "2020-08-26T18:48:21Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            },
            {
              "originalPosition": 246,
              "body": "Please revert these changes.",
              "createdAt": "2020-08-26T18:55:52Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            },
            {
              "originalPosition": 269,
              "body": "Maybe \"Associating a New Group to a Previous Group\"",
              "createdAt": "2020-08-26T18:56:39Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            },
            {
              "originalPosition": 281,
              "body": "Need to specify how big the nonce is.  `KDF.Nh`?\r\n\r\nBut I'm not clear on what the nonce reuse criterion here is.  TLS session resumption PSKs can be used for an arbitrary number of sessions, since the sessions into which the PSKs are injected are distinct for other reasons.  The same seems like it is true here: In both the branching and reinit cases, you have a fresh init secret that will cause the resulting secrets to diverge.",
              "createdAt": "2020-08-26T19:01:37Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            },
            {
              "originalPosition": 281,
              "body": "It would be helpful to say here that in both of these cases, the association is signaled by including the PreSharedKeyID in the Welcome initiating the new group.",
              "createdAt": "2020-08-26T19:02:16Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            },
            {
              "originalPosition": 349,
              "body": "Honestly, I'm not sure how much value this adds.  The new group already has a pointer to the old group (by way of the PSK ID).  The best that this can do is cause folks not to use the old group any more, and it seems like doing that at the application layer is sufficient.  The only thing doing it in MLS adds is that it gets into the transcript -- and by definition, the transcript doesn't matter after this!\r\n\r\nIf we're going to have a message here, I would propose we do it a bit differently:\r\n\r\n* Use a different message type, parallel to Proposal or Commit.  Commit advances the group to a new epoch; this operation does not.\r\n* ... and explain that this needs the same sequencing as Commit.\r\n* Have the semantic be just \"close\", with an optional forward pointer.\r\n* For the forward pointer, just use a hash of the Welcome message.\r\n\r\n```\r\nopaque WelcomeID<0..255>; \r\n\r\nstruct {\r\n    optional<WelcomeID> welcome_hash;\r\n} Close;\r\n```",
              "createdAt": "2020-08-26T20:40:37Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            },
            {
              "originalPosition": 549,
              "body": "Please revert these unrelated changes.",
              "createdAt": "2020-08-26T20:45:45Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1OTA4NTQ5",
          "commit": {
            "abbreviatedOid": "3bbd706"
          },
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-26T22:08:22Z",
          "updatedAt": "2020-08-26T22:08:22Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "Actually not -- the \"security level\" is mentioned at different points in the document and still requires clarification as it is never defined. \r\n\r\nFor example, what does it mean for a PSK to be of the same security level as the intended group? In reality, we need to match intended PCS and FS levels, and that is determined by how often keys are ratcheted (including signature keys). If there is a mis-match with incoming external PSKs, then the value of use of a PSK may be minor. If the external PSK was a TLS exporter key for example, then its PCS/FS guarantees are partially dependent on its freshness. \r\n\r\nIf deniable signature keys are ever considered, then PSKs should also not undermine that \"security level\".\r\n\r\nSecurity level explanation is something probably belongs in the architecture doc.",
              "createdAt": "2020-08-26T22:08:22Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2NDM4NjE1",
          "commit": {
            "abbreviatedOid": "3bbd706"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-27T07:03:24Z",
          "updatedAt": "2020-08-27T07:03:25Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "Good point in that the types relate their use rather than their provisioning. What do you mean by \"at this level\"? We do agree that we need strong key separation between the different PSK types, right? That was one of the lessons of various TLS Key Schedule analysis. It's not quite clear to me what you are suggesting we change.",
              "createdAt": "2020-08-27T07:03:24Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2NDM4OTk4",
          "commit": {
            "abbreviatedOid": "3bbd706"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-27T07:04:02Z",
          "updatedAt": "2020-08-27T07:04:03Z",
          "comments": [
            {
              "originalPosition": 246,
              "body": "Sorry about that. There must have been a mixup when merging. I'll fix it.",
              "createdAt": "2020-08-27T07:04:02Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2NDM5MTkw",
          "commit": {
            "abbreviatedOid": "3bbd706"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-27T07:04:21Z",
          "updatedAt": "2020-08-27T07:04:21Z",
          "comments": [
            {
              "originalPosition": 269,
              "body": "Works for me.",
              "createdAt": "2020-08-27T07:04:21Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2NDY0MDI3",
          "commit": {
            "abbreviatedOid": "3bbd706"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-27T07:41:45Z",
          "updatedAt": "2020-08-27T07:41:46Z",
          "comments": [
            {
              "originalPosition": 349,
              "body": "I understand that you're reluctant to bloat the proposal space like this. However, I think a ReInit proposal serves two purposes. 1) It allows an external party (e.g. the DS) to indicate to the group that they should change/upgrade the group. A ReInit proposal authenticates the DS' intent and even the upgrade/change it wants to do.\r\n2) It makes sure that the group agrees on the ReInit. The PSK in the Welcome message is derived from the epoch _after_ the commit, so everyone must have processed it and registered that the group should be closed.\r\n\r\nI think both authentication and agreement are valuable properties for an action that has the power to change ciphersuite, version and extensions.\r\n\r\nOther than potentially bloating the number of proposals we have: Why not have a ReInit proposal?",
              "createdAt": "2020-08-27T07:41:46Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2NDg3ODAx",
          "commit": {
            "abbreviatedOid": "b8e1283"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-27T08:15:16Z",
          "updatedAt": "2020-08-27T08:15:17Z",
          "comments": [
            {
              "originalPosition": 246,
              "body": "Never mind. It was actually emacs, which \"cleared up\" all markdown tables upon saving the file -.-",
              "createdAt": "2020-08-27T08:15:16Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2OTMwNzA0",
          "commit": {
            "abbreviatedOid": "b8e1283"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-27T17:22:53Z",
          "updatedAt": "2020-08-28T14:00:07Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "Sorry, I meant the \"external coordination via proposal\" open issue.",
              "createdAt": "2020-08-27T17:22:53Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 122,
              "body": "Concretely, do we need different `PSKType` values for these different cases, or would a single `recovery` value be sufficient?",
              "createdAt": "2020-08-27T17:23:43Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 349,
              "body": "As to \"why not\" -- typically we try not to put things in the protocol that don't do anything ;)\r\n\r\nBut your two points are a convincing argument that this does do something, namely (1) provides an authenticated \"nudge\" to re-init, and more importantly (2) advances the group to a final \"tail epoch\" that is used only for initializing the next group.\r\n\r\nI think I still prefer that it be a Handshake message rather than a Proposal. That way you don't have to worry about what it means to have other Proposals or a `path` in the Commit.  And you can specify that a `Close` message is processed by \"closing off\" the key schedule:\r\n\r\n```\r\n                  init_secret_[n]\r\n                         |\r\n                         V\r\n          0 ------> KDF.Extract = final_secret\r\n```\r\n\r\nThe only additional complexity would be that now the rule is \"you can only have one Commit **or Close** message per epoch\", where the bold bit is the addition.  Doesn't seem too bad.  I kind of like that it rounds out the key schedule, complementing the \"initial fresh init secret\" discussion we had recently:\r\n\r\n```\r\n                   init_secret_[0]\r\n                         |\r\n                         V\r\n          [normal key schedule diagram as above]\r\n                         |\r\n                         V\r\n                   init_secret_[1]\r\n                         |\r\n                         V\r\n                        ...\r\n                         |\r\n                         V\r\n                   init_secret_[n]\r\n                         |\r\n                         V\r\n               0 -> KDF.Extract \r\n                         |\r\n                         V\r\n                    final_secret\r\n```\r\n",
              "createdAt": "2020-08-27T18:00:03Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3Nzk5Mjc5",
          "commit": {
            "abbreviatedOid": "b8e1283"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-28T14:57:41Z",
          "updatedAt": "2020-08-28T14:57:42Z",
          "comments": [
            {
              "originalPosition": 349,
              "body": "> As to \"why not\" -- typically we try not to put things in the protocol that don't do anything ;)\r\n\r\nPoint taken  :smile: \r\n\r\nRegarding the handshake message: I wasn't aware that they're also pretty extensible, so sure, that would work as well. Just to make sure I understand correctly: The server would be able to send the message themselves (if they're \"preconfigured\") and the message would be authenticated, right? Also, we would have to add the data fields to the handshake message instead like so:\r\n```\r\nstruct {\r\n    opaque group_id<0..255>;\r\n    uint64 epoch;\r\n    Sender sender;\r\n    opaque authenticated_data<0..2^32-1>;\r\n\r\n    ContentType content_type;\r\n    select (MLSPlaintext.content_type) {\r\n        case application:\r\n          opaque application_data<0..2^32-1>;\r\n\r\n        case proposal:\r\n          Proposal proposal;\r\n\r\n        case commit:\r\n          Commit commit;\r\n          opaque confirmation_tag<0..255>;\r\n\r\n        case close:\r\n          ProtocolVersion version;\r\n          CipherSuite cipher_suite;\r\n          Extension extensions<0..2^32-1>;\r\n    }\r\n\r\n    opaque signature<0..2^16-1>;\r\n} MLSPlaintext;\r\n```\r\nFor maximum security guarantees, we could also add a `confirmation_tag` just like for the commit.",
              "createdAt": "2020-08-28T14:57:41Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3ODAxNTk1",
          "commit": {
            "abbreviatedOid": "b8e1283"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-28T15:00:32Z",
          "updatedAt": "2020-08-28T15:00:33Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "I think we do to properly separate the keys depending on their use. This is comparable to TLS, where improper separation between application- and resumption PSKs led to problems down the road. However, we sill only need to derive a single value off of the Key Schedule, as the type is used later when the PSK gets injected into the Key Schedule.",
              "createdAt": "2020-08-28T15:00:33Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMTYyOTUy",
          "commit": {
            "abbreviatedOid": "b8e1283"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-02T18:36:38Z",
          "updatedAt": "2020-09-02T18:36:39Z",
          "comments": [
            {
              "originalPosition": 269,
              "body": "Tweaked the title a little. It's now \"Linking a New Group to an Existing Group\".",
              "createdAt": "2020-09-02T18:36:39Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMTYzNzA0",
          "commit": {
            "abbreviatedOid": "b8e1283"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-02T18:37:40Z",
          "updatedAt": "2020-09-02T18:37:40Z",
          "comments": [
            {
              "originalPosition": 281,
              "body": "I've specified the nonce length to be `KDF.Nh` and added an open issue regarding the possibility to avoid the nonce altogether using the GroupId of the new group.",
              "createdAt": "2020-09-02T18:37:40Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMTcwNDUy",
          "commit": {
            "abbreviatedOid": "b8e1283"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-02T18:47:28Z",
          "updatedAt": "2020-09-02T19:11:02Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "OK, I can live with this.",
              "createdAt": "2020-09-02T18:47:28Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 281,
              "body": "^^^ still outstanding",
              "createdAt": "2020-09-02T18:48:31Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 115,
              "body": "^^^ still outstanding",
              "createdAt": "2020-09-02T18:48:38Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 349,
              "body": "> The server would be able to send the message themselves (if they're \"preconfigured\") and the message would be authenticated, right?\r\n\r\nYep, it would be sent as an MLSPlaintext, so the normal authentication stuff applies.  \r\n\r\nSyntactically, I think it would be even simpler than what you lay out.  We would just define a Close object parallel to commit that has the forward-pointer to the new group (NB: see below).  So where you have the version/cipher_suite fields, we would just have Close object.\r\n\r\nCouple of other points:\r\n\r\n* Is this message useful when closing the group *without a successor*?\r\n    * If so, then the forward pointer needs to be optional\r\n    * If not (so there's always a successor), suggest renaming Close -> Replace\r\n* `version+cipher_suite` seems like an odd way to refer to a new group.  Propose we just send the Welcome or H(Welcome) here, since that will implicitly bind to these fields as well as the group ID, membership, etc.  \r\n\r\n```\r\nstruct {\r\n    opaque welcome_hash<0..255>; // or \r\n    Welcome welcome;\r\n} Replace;\r\n```\r\n\r\n* Just to confirm, the receiver processing of this message is:\r\n    * Ratchet the key schedule forward with commit_secret = 0 to get the last epoch\r\n    * Verify the confirmation tag in the new/last epoch\r\n    * Produce a PSK of type `reinit` (or maybe `replace`), which can be referenced in the new Welcome\r\n* ... which means the sender processing would be:\r\n    * Create a Welcome for the new group referencing the reinit PSK (as groupID + last_epoch)\r\n    * Ratchet to the last epoch => reinit PSK\r\n    * Create MLSPlaintext(Replace(H(Welcome)))\r\n\r\nA little convoluted, but not an unexpected amount of interlock.\r\n\r\n",
              "createdAt": "2020-09-02T18:54:04Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyMzkzMDAy",
          "commit": {
            "abbreviatedOid": "05d1f8a"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-04T06:35:00Z",
          "updatedAt": "2020-09-04T06:35:00Z",
          "comments": [
            {
              "originalPosition": 349,
              "body": "Very good points. Using the Welcome message seems like an elegant way to link the groups.\r\nRegarding ReInit vs. Replace, I have no strong opinion on that. Replace seems a little more direct, so I'll go with that for now. I'll make the changes either today or over the weekend so hopefully we can get the green light for a merge on Tuesday :-)",
              "createdAt": "2020-09-04T06:35:00Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzMTE3NTI2",
          "commit": {
            "abbreviatedOid": "05d1f8a"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-06T07:05:35Z",
          "updatedAt": "2020-09-06T07:05:35Z",
          "comments": [
            {
              "originalPosition": 349,
              "body": "I just noticed that if we use a Welcome message (or its hash) in the Replace message, then the Server won't be able to send it, because it lacks the necessary information to craft it. So until we find a better way of doing it, I'm going with the way I originally sketched. Let me know if you have another idea.\r\n\r\n(The `Capabilities` struct is pretty close to what we need, but the name is a little misleading in that context.)",
              "createdAt": "2020-09-06T07:05:35Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzMTIwODc0",
          "commit": {
            "abbreviatedOid": "05d1f8a"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-06T07:55:03Z",
          "updatedAt": "2020-09-06T07:55:03Z",
          "comments": [
            {
              "originalPosition": 349,
              "body": "If we go for a Handshake Message as opposed to a Proposal, it's also not clear, which group member sends the Welcome message for the new group, as the Close message can come from the Server itself. The Server could nominate a member, but it doesn't know if that member is online and so there is a risk that other members would then have to wait for that member to come online. The other possibility is to just have any member do it, which would create a race condition and possibly multiple follow-up groups.\r\n\r\n Do you have an idea on how to deal with that? Since there is otherwise not that much of a difference between Handshake Message and Proposal, I'm inclined to stick with a Proposal, but rename it to \"Close\" and make the content optional.",
              "createdAt": "2020-09-06T07:55:03Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTE2NDgw",
          "commit": {
            "abbreviatedOid": "5fb03bd"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "This is getting real close.  Just a few things to tighten up.",
          "createdAt": "2020-09-22T14:23:41Z",
          "updatedAt": "2020-09-22T14:42:10Z",
          "comments": [
            {
              "originalPosition": 139,
              "body": "Not an extension, a new Proposal.  Seems like the content of the Proposal and the extension can be the same object?  Or since we're doing multiplicities here, the Welcome extension would have the union of the Proposals.",
              "createdAt": "2020-09-22T14:23:41Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 318,
              "body": "Nit: I would prefer to spell out PreSharedKey.\r\n\r\nDo we need a separate structure here, or could we re-use the PreSharedKeys struct defined above?",
              "createdAt": "2020-09-22T14:25:10Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 343,
              "body": "Do we want to specify a PSK that carries over from the old group to the new group?  So you would define here something like: The new Welcome MUST have a PreSharedKey extension with a `reinit` entry pointing to the epoch initiated by the Commit that covers the ReInit proposal.",
              "createdAt": "2020-09-22T14:30:22Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 354,
              "body": "I would strike this.  It's up to the committer to decide what they commit.  For example, if someone proposes adding a nonsense PSK, that shouldn't get committed.",
              "createdAt": "2020-09-22T14:32:13Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 364,
              "body": "```suggestion\r\nIf there are multiple ReInit proposals during an epoch, the committer MUST choose exactly one to include in the Commit message.  The `version` field in the ReInit proposal MUST be no less than the version for the current group.  A client processing a Commit that covers multiple ReInit proposals or a ReInit proposal with a lower version MUST reject it as malformed.  The committer SHOULD choose a ReInit proposal with a unique `group_id` and parameters that are supported by all clients in the group.\r\n```",
              "createdAt": "2020-09-22T14:37:17Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 378,
              "body": "```suggestion\r\n  * A ReInit proposal is applied by marking the group as \"closed\".  Further proposals and commits for this group MUST be rejected.  The group's only further purpose is to provide a PSK used by the successor group.\r\n```",
              "createdAt": "2020-09-22T14:39:10Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 378,
              "body": "Actually, this probably goes in the receiver processing below...",
              "createdAt": "2020-09-22T14:40:09Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 430,
              "body": "```suggestion\r\n* Verify that at most one ReInit proposal is present and that the `mls_version`\r\n```",
              "createdAt": "2020-09-22T14:40:26Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTkwMDMx",
          "commit": {
            "abbreviatedOid": "5fb03bd"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-09-22T15:30:37Z",
          "updatedAt": "2020-09-22T15:40:06Z",
          "comments": [
            {
              "originalPosition": 191,
              "body": "Maybe for the sake of efficiency, concat all the `psk_[i]` before they're put into Extract?",
              "createdAt": "2020-09-22T15:30:37Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 211,
              "body": "```suggestion\r\nThere are three ways in which a `recovery_secret` can be used: to re-initialize\r\n```",
              "createdAt": "2020-09-22T15:33:23Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 229,
              "body": "I think you definitely need to elaborate on what this means / how it would be done?",
              "createdAt": "2020-09-22T15:34:41Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 154,
              "body": "- empty line",
              "createdAt": "2020-09-22T15:38:13Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 132,
              "body": "Please elaborate on how recovery happens. From skimming, it's not clear how I would do this",
              "createdAt": "2020-09-22T15:39:54Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0NDE4ODE5",
          "commit": {
            "abbreviatedOid": "ea04350"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-23T08:25:34Z",
          "updatedAt": "2020-09-23T08:25:34Z",
          "comments": [
            {
              "originalPosition": 139,
              "body": "Right, it's a Proposal (again). Hm. Right now, the Proposal contains a single `PreSharedKeyID`, while the `Welcome` contains an array of `PreSharedKeyID`s. So the `Welcome` needs to contain the PSKs referenced by the Proposals in the order in which the individual Proposals are contained in the Commit. Is that what you meant?",
              "createdAt": "2020-09-23T08:25:34Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0NDIwODU5",
          "commit": {
            "abbreviatedOid": "ea04350"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-23T08:27:56Z",
          "updatedAt": "2020-09-23T08:27:57Z",
          "comments": [
            {
              "originalPosition": 318,
              "body": "I'll change it such that it spells it out. As I mentioned in my comment above, the Proposal only contains a single `PreSharedKeyID`, while `PreSharedKeys` contains an array. We could change that, though. I don't have a strong opinion on this, so I'll leave it as it is for now.",
              "createdAt": "2020-09-23T08:27:56Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0NDIxNjgz",
          "commit": {
            "abbreviatedOid": "ea04350"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-23T08:28:52Z",
          "updatedAt": "2020-09-23T08:28:52Z",
          "comments": [
            {
              "originalPosition": 343,
              "body": "That's exactly what we want to do, so you're right indeed.",
              "createdAt": "2020-09-23T08:28:52Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0NDMxODUz",
          "commit": {
            "abbreviatedOid": "10c3316"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-23T08:41:22Z",
          "updatedAt": "2020-09-23T08:41:23Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "Good point. That's a relic from a past design that actually supported recovery. I'll remove it, as it is not relevant anymore.",
              "createdAt": "2020-09-23T08:41:22Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0NDM4NzY1",
          "commit": {
            "abbreviatedOid": "10c3316"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-23T08:49:49Z",
          "updatedAt": "2020-09-23T08:49:49Z",
          "comments": [
            {
              "originalPosition": 139,
              "body": "Note, that it's not an extension in the `Welcome` anymore, but instead an optional `PreSharedKeys` field in the `GroupSecrets` object.",
              "createdAt": "2020-09-23T08:49:49Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0NDgwNzI2",
          "commit": {
            "abbreviatedOid": "10c3316"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-23T09:40:39Z",
          "updatedAt": "2020-09-23T09:40:40Z",
          "comments": [
            {
              "originalPosition": 318,
              "body": "Terminology is a bit tricky. We have \"PSK\"s (i.e. the concrete keys), but now we also have \"PreSharedKey\" which is the name of the Proposal. However, the Proposal in turn only contains `PreSharedKeyID`s, i.e. pointers to how the PSK can be derived.",
              "createdAt": "2020-09-23T09:40:39Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3NTAyMTQ4",
          "commit": {
            "abbreviatedOid": "850704b"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-28T13:18:51Z",
          "updatedAt": "2020-09-28T13:18:51Z",
          "comments": [
            {
              "originalPosition": 229,
              "body": "I've added another sentence or two on what this is supposed to achieve and how.",
              "createdAt": "2020-09-28T13:18:51Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3NTExNzM0",
          "commit": {
            "abbreviatedOid": "850704b"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-28T13:29:03Z",
          "updatedAt": "2020-09-28T13:29:04Z",
          "comments": [
            {
              "originalPosition": 191,
              "body": "I'm not sure what the assumptions would be under which we could prove that secure. Other than a random oracle that is. Since I don't think it's likely that people will inject more than one PSK at once very often, I'd rather leave this as it is.",
              "createdAt": "2020-09-28T13:29:04Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3ODE5Mjc2",
          "commit": {
            "abbreviatedOid": "850704b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-28T19:09:25Z",
          "updatedAt": "2020-09-28T19:09:25Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3ODI5MjAz",
          "commit": {
            "abbreviatedOid": "850704b"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-09-28T19:24:30Z",
          "updatedAt": "2020-09-28T21:19:46Z",
          "comments": [
            {
              "originalPosition": 109,
              "body": "```suggestion\r\n<!-- OPEN ISSUE: Clarify lifetime vs security level mandated above. E.g. if\r\n```",
              "createdAt": "2020-09-28T19:24:30Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 113,
              "body": "```suggestion\r\n<!-- OPEN ISSUE: Define \"security level\", and what it means to match the\r\n```",
              "createdAt": "2020-09-28T19:24:38Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 139,
              "body": "Please make zero `reserved`",
              "createdAt": "2020-09-28T21:00:18Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 147,
              "body": "```suggestion\r\n  select (PreSharedKeyID.psktype) {\r\n```",
              "createdAt": "2020-09-28T21:01:03Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 159,
              "body": "Never used",
              "createdAt": "2020-09-28T21:04:19Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 489,
              "body": "```suggestion\r\n  optional<PreSharedKeys> psks;\r\n```",
              "createdAt": "2020-09-28T21:05:13Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 173,
              "body": "References Commit extensions",
              "createdAt": "2020-09-28T21:06:39Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 182,
              "body": "```suggestion\r\npsk_input_[i] = KDF.Extract(psk_[i], \"\")\r\n```",
              "createdAt": "2020-09-28T21:10:38Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 212,
              "body": "Probably can get rid of the last sentence in this paragraph, it comes off as hostile",
              "createdAt": "2020-09-28T21:15:38Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 225,
              "body": "Try to compress this section into one paragraph",
              "createdAt": "2020-09-28T21:18:56Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4MTA5NTM2",
          "commit": {
            "abbreviatedOid": "a1833cf"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-29T05:39:07Z",
          "updatedAt": "2020-09-29T05:39:08Z",
          "comments": [
            {
              "originalPosition": 159,
              "body": "It's used in the derivation of `psk_secret`. `PSKLabel` contains the `PreSharedKeyID`, which in turn contains the nonce.",
              "createdAt": "2020-09-29T05:39:07Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4MTEwNTcz",
          "commit": {
            "abbreviatedOid": "6c7a4d8"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-29T05:41:55Z",
          "updatedAt": "2020-09-29T05:41:56Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "Good catch. I thought I'd gotten rid of all of that stuff.",
              "createdAt": "2020-09-29T05:41:55Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4MTExMTM0",
          "commit": {
            "abbreviatedOid": "6c7a4d8"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-29T05:43:27Z",
          "updatedAt": "2020-09-29T05:43:27Z",
          "comments": [
            {
              "originalPosition": 182,
              "body": "What's wrong with calling `Extract` like this?",
              "createdAt": "2020-09-29T05:43:27Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4MTE0Nzgz",
          "commit": {
            "abbreviatedOid": "6c7a4d8"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-29T05:53:21Z",
          "updatedAt": "2020-09-29T05:53:21Z",
          "comments": [
            {
              "originalPosition": 225,
              "body": "I've shortened it a little bit and left it with two paragraphs. It should be in keeping with the style of the rest of the spec now.",
              "createdAt": "2020-09-29T05:53:21Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0NjgxMDUx",
          "commit": {
            "abbreviatedOid": "8d6d8a8"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-08T11:23:31Z",
          "updatedAt": "2020-10-08T11:23:32Z",
          "comments": [
            {
              "originalPosition": 182,
              "body": "I think Extract specifies the left input to be the keying material and the right one the salt. Since I  would consider `psk_[i]` as the keying material, I'll leave it on the right for now. I'm pretty sure we rely on Extract to provide a \"good\" result independent of the \"good\" input being on the left or the right side anyway, so we should be safe either way.",
              "createdAt": "2020-10-08T11:23:31Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0ODUwNTEz",
          "commit": {
            "abbreviatedOid": "3846416"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-08T14:34:37Z",
          "updatedAt": "2020-10-08T14:34:47Z",
          "comments": [
            {
              "originalPosition": 182,
              "body": "Nope, the IKM is on the right: `Extract(salt, ikm)`.  I agree this is unlikely to be an issue, but it seems more conservative to use the IKM slot.\r\n\r\nhttps://github.com/cfrg/draft-irtf-cfrg-hpke/blob/master/draft-irtf-cfrg-hpke.md#cryptographic-dependencies",
              "createdAt": "2020-10-08T14:34:37Z",
              "updatedAt": "2020-10-08T14:34:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0ODUzODYy",
          "commit": {
            "abbreviatedOid": "3846416"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-08T14:37:38Z",
          "updatedAt": "2020-10-08T14:37:38Z",
          "comments": [
            {
              "originalPosition": 182,
              "body": "Right, sorry. That's what I meant to say, just got the directions confused. Anyway, we're calling with the psk on the right right now, so we should be good.",
              "createdAt": "2020-10-08T14:37:38Z",
              "updatedAt": "2020-10-08T14:37:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0ODU1OTQ3",
          "commit": {
            "abbreviatedOid": "3846416"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-08T14:39:38Z",
          "updatedAt": "2020-10-08T14:39:55Z",
          "comments": [
            {
              "originalPosition": 182,
              "body": "Ah right.  I got mixed up on which was the thing in the PR and which was Brendan's edit.  I agree that the PR has the PSK in the IKM slot.",
              "createdAt": "2020-10-08T14:39:38Z",
              "updatedAt": "2020-10-08T14:39:55Z"
            }
          ]
        }
      ]
    },
    {
      "number": 337,
      "id": "MDExOlB1bGxSZXF1ZXN0NDE5MTA5NjA4",
      "title": "Replace DKDF by n-PRF in key schedule; minor fix",
      "url": "https://github.com/mlswg/mls-protocol/pull/337",
      "state": "CLOSED",
      "author": "chrisbrzuska",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "discussion",
        "key schedule",
        "security",
        "work in progress"
      ],
      "body": "We propose to replace the two-stage Extract-Expand-\r\nExtract-Expand method to derive a single key from\r\nmultiple input keys by an Expand-XOR-Expand method.\r\n\r\nAs a small fix we added the Context argument to the\r\nDerive-Secret function and pass it on to the\r\nHKDF-Extract-Label function. In the key schedule\r\ngraph the function was called with the Context\r\nargument, but it wasn't present in the function\r\ndefinition of Derive-Secret.\r\n\r\nMotivation for the Expand-XOR-Expand method:\r\n- Extract was not used before, KDF was used as DPRF only.\r\n- Previous construction relied on ad hoc assumption on DPRF/DKDF\r\n- Previous construction required uniqueness of secrets to obtain distinct and independent keys (can be fragile when keys are under adversarial control)\r\n- n-PRF reduces reliance on uniqueness of secrets and instead relies on the uniqueness of a public value under the protocol designer's control\r\n\r\nTodo: Find/Design a unique public value.\r\n\r\nThis commit was co-authored by @keks and @chrisbrzuska.",
      "createdAt": "2020-05-17T12:57:24Z",
      "updatedAt": "2020-10-19T15:22:34Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "c519e9d8ac723ed19fa114198abb09922d1027f7",
      "headRepository": "keks/mls-protocol",
      "headRefName": "cb_jw/nprf",
      "headRefOid": "1785e973b99fa395bd0cfce982f7241c5785a59b",
      "closedAt": "2020-10-19T15:22:34Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "@chrisbrzuska are you certain this general construction gives us an n-PRF with the desired properties? To what extent does it rely on HMAC/HKDF? What if we wanted to replace HMAC with a different PRF?",
          "createdAt": "2020-06-09T03:17:35Z",
          "updatedAt": "2020-06-09T03:17:56Z"
        },
        {
          "author": "jhoyla",
          "authorAssociation": "NONE",
          "body": "> I don't like that before, we had Extract calls which theoretically turn non-uniform randomness into uniform randomness, and now that's all replaced with HKDF-Expand calls that theoretically always assume the randomness is uniform.\r\n\r\nI agree with @Bren2010, what's the theory justification for changing to an Expand-XOR-Expand?\r\nGiven that Expand and Extract are both calls to an underlying HMAC this is potentially OK, but it's definitely not obvious. \r\n\r\nThe unique value in the `Derive-Secrets` acts as a salt, and the key material acts as the IKM, so the first call to `Derive-Secrets` can act as `HKDF-Extract`, and the subsequent calls to `Derive-Secret` can act as `HKDF-Expand`s, but I think there should be an explicit requirement / mentioning that the two functions must always have different types when used as `Extract`s vs `Expand`s. \r\n\r\nAs far as I can tell this mostly seems to be a labelling change, renaming `Extract` to overload `Expand`. A security section expanding on why this is secure, preferably with some references to computational proofs would be really good here. \r\n\r\nIt might be better to just define a new `HKDF-Extract`-type function as `(Expand-XOR)`, and enforce a different label in the inner `Extract` step. That would hopefully prevent any collisions of subkeys. \r\n\r\nIt also seems like you could define \r\n```\r\nDerive-Secret(Secret, Label, Context) =\r\n        Derive-Secrets([Secret], 1, Label, Context)\r\n```\r\nso we need to be aware of type collisions there as well. \r\n\r\n",
          "createdAt": "2020-06-17T14:25:35Z",
          "updatedAt": "2020-06-17T14:25:35Z"
        },
        {
          "author": "chrisbrzuska",
          "authorAssociation": "NONE",
          "body": "> > I don't like that before, we had Extract calls which theoretically turn non-uniform randomness into uniform randomness, and now that's all replaced with HKDF-Expand calls that theoretically always assume the randomness is uniform.\r\n> \r\n> I agree with @Bren2010, what's the theory justification for changing to an Expand-XOR-Expand?\r\n> Given that Expand and Extract are both calls to an underlying HMAC this is potentially OK, but it's definitely not obvious.\r\n> \r\n> The unique value in the `Derive-Secrets` acts as a salt, and the key material acts as the IKM, so the first call to `Derive-Secrets` can act as `HKDF-Extract`, and the subsequent calls to `Derive-Secret` can act A security section expanding on why this is secure, preferably with some references to computational proofs would be really good here.\r\n\r\nHere is the accompanying paper with a full discussion of advantages/disadvantages and computational proofs:\r\nhttp://chrisbrzuska.de/2020-NPRF.html\r\n\r\nWhat would be a suitable location for the security section?",
          "createdAt": "2020-06-17T14:42:14Z",
          "updatedAt": "2020-06-17T14:42:14Z"
        },
        {
          "author": "jhoyla",
          "authorAssociation": "NONE",
          "body": "@chrisbrzuska Have you submitted your paper somewhere for publication / peer review?\r\nI had a read of it, and I tried to follow some of your proofs, but despite the excellent diagrams I really struggled. \r\n\r\nThere are many very similarly named things that it's unclear what the difference is. For example I couldn't figure out the difference between CORE_{GNPRF}^0 and CORE^0_{NPRF}. \r\nThe text says:\r\n> CORE_{GNPRF}^0 is defined in Figure 20a\r\n\r\nBut 20a is labelled `CORE^0_{NPRF},R^0_{NPRF}`\r\n\r\nI also was a bit confused by the overloading of `Eval`.\r\n\r\nAnother issue I had was finding all the parts of the proof. To follow the NPRF proof, for example, requires huge amounts of paging back and forth through the document, which large gaps between sections (for the other proofs). Could you possibly share the TeX file, or provide a re-ordered document with all the pieces of each proof next to each other. It would really help people to evaluate the proof. \r\n(A glossary which explains what each thing is and provides a link to the definition would be awesome too.)\r\n\r\nEven though I couldn't completely follow the proofs it does look like all the pieces are there, so maybe add a section to the Security Considerations with a link to the paper. I think if people find this proof satisfactory then this change seems reasonable.\r\n\r\nI know this is getting a bit off topic, but I found a couple of nits in your paper. Things like on page 12 you have `skX_i = skY = \u22a5`, which seems like it should be `skX_i = skY_i = \u22a5`. Let me know if a list would be helpful to you. \r\n",
          "createdAt": "2020-06-19T17:35:13Z",
          "updatedAt": "2020-06-19T17:35:13Z"
        },
        {
          "author": "chrisbrzuska",
          "authorAssociation": "NONE",
          "body": ">>> Let me know if a list would be helpful to you.\r\n\r\n@jhoyla Thank you for the close read, very appreciated. Yes, a list of nits as well as any other feedback would be very useful to us. Especially, also: How did you proceed to read the proof? What distracted, confused or annoyed you? Which were the bits which required page-scrolling? What came first to my mind is the Key package, but I guess there are more parts of the proof which require scrolling? The idea of a glossary is nice.\r\n\r\nPeer review: We submitted the article to Asiacrypt.",
          "createdAt": "2020-06-19T20:03:19Z",
          "updatedAt": "2020-06-19T21:38:20Z"
        },
        {
          "author": "jhoyla",
          "authorAssociation": "NONE",
          "body": "Hi @chrisbrzuska\r\n\r\nI tried to read the proof by following just the proof for the NPRF. I wanted to see all the stages in their simplest form.\r\nI read the paper from start to finish, just skimming the proofs, just to get a sense of what was going on, and then I started to work backwards from Claim 1.\r\nThe first step of the proof is to compare Figure 20a, Figure 17a, and Figure 15a, or pages 35, 26, and 21. \r\nThen one must refer to Fig. 14, Fig. 13a, and Fig. 10 or pages 18, 16, and 12.\r\n\r\nFigure 19 brings them all together, but I like to compare the details. The big jumps from 35 to 26 and 21 are particularly frustrating.\r\nI ended up screenshotting all the definitions and putting them side by side in powerpoint. \r\n\r\nI was able to convince myself that claim 1 is true, but I didn't really follow the proof in Section 6.2. \r\n\r\nI struggled with both the logic of the steps, i.e. that each step followed from the previous step, and with understanding the conclusion.\r\nIn very informal terms, my understanding of the reduction in Fig 20a-d is:\r\nReplace the PRF with the collision resistant PRF.\r\nThe XOR can now be replaced with the collision resistant XOR.\r\nThe PRF can then be replaced with the non-collision resistant PRF.\r\nFig. 20d thus describes the collision resistant NPRF.\r\nIs that approximately right?\r\n\r\nWith respect to the result, the probability equation has terms that I can't evaluate.\r\nWhat does e_{PRF}(B\u2192R^1_{NPRF}) actually evaluate to? \r\nIs it obvious that it is \u2264 e_{PRF}(A)?\r\n\r\nNits / Clarification questions:\r\n1. In the Key package, is there a requirement that the public name be _cryptographically_ bound to the key? \r\n2. Figure 7. could use a more permanent reference, i.e. \"current\" will change eventually.\r\n3. On pg. 12 should `skXi = skY = \u22a5` read `skXi = skYi = \u22a5`?\r\n4. Is there a significance to `sort` being unstable?\r\n5. On pg. 14 you write \"Finally in Section 3.2\", when 3.2 is not the last subsection of section 3.\r\n6. Some of your references have gone a bit weird, specifically [1,3,4,5,8,10,11,12,16]. \"in [name], editor\" seems wrong.\r\n7. Please add a reference to [Kra10] by the min-entropy def. \r\n8. The pseudo-code in Fig. 12 is out of order. `Set(h, k, ctr)` should read `Set(ctr, k, h)` I think.\r\n9. In Fig. 13b. should the lower `Key^{00}` read `Key^{b0}`?\r\n10. Ditto with Fig. 13c.\r\n11. In Fig. 13c. `k <- xtr(S, pkX^Y)` should read `k <- xtr(S, pkX^y)` (i.e. the `Y` should be in lower case.)\r\n12. In Fig. 14 `S: {0, 1}^{l}` should probably read `S: {0,1}^{sl}`. \r\n13. \"thus duped\" should probably read \"thus dubbed\".\r\n14. The package CRPRF is never defined as such. The definition appears in Fig. 14 with the label GcrPRF^b. Without a glossary it's hard to know whether GcrPRF \u225f NPRF \u225f CRPRF.\r\n15. The final column of Fig. 19 replaces code with f_{cfNPRF}, but the code does not exactly match. `f_{PRF}(k_i, (ctx1, i), ol)`  is replaced with `f_{PRF}(k_i, (ctx1, i))`, i.e. the final parameter disappears.\r\n\r\nI didn't try and go through the other 2 code comparisons exactly, but if I have time I will.  ",
          "createdAt": "2020-06-22T15:13:53Z",
          "updatedAt": "2020-06-22T15:13:53Z"
        },
        {
          "author": "chrisbrzuska",
          "authorAssociation": "NONE",
          "body": "Hi @jhoyla \r\n\r\nThanks a lot for the thorough read and the reading feedback! It took me a while to get around integrating your suggested changes into the document. I started with the nits and clarifications (comments below). Will post the new document within the next days.\r\n\r\n> Nits / Clarification questions:\r\n> \r\n> 1. In the Key package, is there a requirement that the public name be _cryptographically_ bound to the key?\r\n\r\nNo, it can be a purely administrative value. However, in the NamePRF and the DHNPRF construction, we explore the use of cryptographic public names (handles).\r\n\r\n> 2. Figure 7. could use a more permanent reference, i.e. \"current\" will change eventually.\r\n\r\nGood point. Done.\r\n\r\n> 3. On pg. 12 should `skXi = skY = \u22a5` read `skXi = skYi = \u22a5`?\r\n\r\nThank you for catching this. Fixed.\r\n\r\n> 4. Is there a significance to `sort` being unstable?\r\n\r\nWhat does 'unstable' mean in this context?\r\n\r\n> 5. On pg. 14 you write \"Finally in Section 3.2\", when 3.2 is not the last subsection of section 3.\r\n\r\nFixed.\r\n\r\n> 6. Some of your references have gone a bit weird, specifically [1,3,4,5,8,10,11,12,16]. \"in [name], editor\" seems wrong.\r\n\r\nThank you, not yet fixed.\r\n\r\n> 7. Please add a reference to [Kra10] by the min-entropy def.\r\n\r\nFixed.\r\n\r\n> 8. The pseudo-code in Fig. 12 is out of order. `Set(h, k, ctr)` should read `Set(ctr, k, h)` I think.\r\n\r\nThat's correct. Thanks! Fixed.\r\n\r\n> 9. In Fig. 13b. should the lower `Key^{00}` read `Key^{b0}`?\r\n> 10. Ditto with Fig. 13c.\r\n\r\nIndeed. Fixed.\r\n\r\n> 11. In Fig. 13c. `k <- xtr(S, pkX^Y)` should read `k <- xtr(S, pkX^y)` (i.e. the `Y` should be in lower case.)\r\n> 12. In Fig. 14 `S: {0, 1}^{l}` should probably read `S: {0,1}^{sl}`.\r\n\r\nFixed.\r\n\r\n> 13. \"thus duped\" should probably read \"thus dubbed\".\r\n\r\nFixed :-D\r\n\r\n> 14. The package CRPRF is never defined as such. The definition appears in Fig. 14 with the label GcrPRF^b. Without a glossary it's hard to know whether GcrPRF \u225f NPRF \u225f CRPRF.\r\n\r\nClarified Fig. 14 to describe the packages crPRF and PRF. There should be no \"CRPRF\", this is a typo. Removed throughout the paper. NPRF is not equal to CPRF, too bad there was a confusion.\r\n\r\n> 15. The final column of Fig. 19 replaces code with f_{cfNPRF}, but the code does not exactly match. `f_{PRF}(k_i, (ctx1, i), ol)`  is replaced with `f_{PRF}(k_i, (ctx1, i))`, i.e. the final parameter disappears.\r\n\r\nRight. We are still wondering whether different output lengths are needed or not and are inconsistent w.r.t. this currently in the paper. Will make it uniform once we determined whether this is needed.",
          "createdAt": "2020-07-14T16:17:36Z",
          "updatedAt": "2020-07-14T16:17:36Z"
        },
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@chrisbrzuska Here's a link to the [CFRG](https://irtf.org/cfrg) (Crypto Forum Research Group).  It's in IRTF (Internet Research Task Force) the sister organization of the IETF. As noted during the interim, there a lot of cryptographers there and IETF WGs often go to get a review of crypto-related items. You can subscribe [here](https://www.irtf.org/mailman/listinfo/cfrg).",
          "createdAt": "2020-07-14T17:03:56Z",
          "updatedAt": "2020-07-14T17:03:56Z"
        },
        {
          "author": "chrisbrzuska",
          "authorAssociation": "NONE",
          "body": "> @chrisbrzuska Here's a link to the [CFRG](https://irtf.org/cfrg) (Crypto Forum Research Group). It's in IRTF (Internet Research Task Force) the sister organization of the IETF. As noted during the interim, there a lot of cryptographers there and IETF WGs often go to get a review of crypto-related items. You can subscribe [here](https://www.irtf.org/mailman/listinfo/cfrg).\r\n\r\n@seanturner: Excellent, thank you! I subscribed and will be there tomorrow in case I get an opportunity to present the design.",
          "createdAt": "2020-07-14T22:19:40Z",
          "updatedAt": "2020-07-14T22:19:40Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "This PR has fallen a bit behind, and the key schedule has been updated so that it's less relevant.  Still open to the idea of n-PRF, but it will need a new PR.",
          "createdAt": "2020-10-19T15:22:34Z",
          "updatedAt": "2020-10-19T15:22:34Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0NjI3MTEx",
          "commit": {
            "abbreviatedOid": "8fec56a"
          },
          "author": "wbl",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-19T16:35:44Z",
          "updatedAt": "2020-05-19T16:35:44Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Are you sure you don't mean Secretn here?",
              "createdAt": "2020-05-19T16:35:44Z",
              "updatedAt": "2020-05-19T19:13:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0ODQ4NjY1",
          "commit": {
            "abbreviatedOid": "1785e97"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "In general, this seems like a nice simplification.  Couple of minor questions.",
          "createdAt": "2020-05-19T21:49:25Z",
          "updatedAt": "2020-05-19T21:54:32Z",
          "comments": [
            {
              "originalPosition": 95,
              "body": "Is there a reason that `unique_value` needs to be folded in  both at the `epoch_secret` level and for the secrets derived from it?  Seems like it would be simpler to fold it into the `epoch_secret`.",
              "createdAt": "2020-05-19T21:49:26Z",
              "updatedAt": "2020-05-19T21:54:32Z"
            },
            {
              "originalPosition": 71,
              "body": "The `(x, y)` syntax is not defined.  And in any case, I think `GroupContext_[n]` is the unique value you're looking for.",
              "createdAt": "2020-05-19T21:49:54Z",
              "updatedAt": "2020-05-19T21:54:32Z"
            },
            {
              "originalPosition": 95,
              "body": "Also, \"unique\" in what sense?",
              "createdAt": "2020-05-19T21:53:04Z",
              "updatedAt": "2020-05-19T21:54:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0ODU5NDgz",
          "commit": {
            "abbreviatedOid": "1785e97"
          },
          "author": "chrisbrzuska",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-19T22:10:17Z",
          "updatedAt": "2020-05-19T22:10:17Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Thanks! Fixed that.",
              "createdAt": "2020-05-19T22:10:17Z",
              "updatedAt": "2020-05-19T22:10:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0ODY4OTIx",
          "commit": {
            "abbreviatedOid": "1785e97"
          },
          "author": "chrisbrzuska",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-19T22:31:11Z",
          "updatedAt": "2020-05-19T22:31:11Z",
          "comments": [
            {
              "originalPosition": 95,
              "body": "Excellent questions! Thanks :-)\r\n\r\n**Double use of unique value:**\r\nDerive-Secrets derives a keys from each input keys and xors them and the result is assigned to epoch_secret. It is important that the inputs to the xor have not been used before and the unique value ensures that. tl;dr: 1st use of unique_value is needed for pseudorandomness.\r\n\r\nThe second use of the unique value ensures that different sessions derive different key values. For honest sessions, this is the case anyway (since pseudorandom key values are unlikely to collide), but for dishonest sessions, the unique value is needed since the xor does not maintain collision-resistance.\r\n\r\n**Definition of unique:**\r\nIn a call to a Derive-Secrets function with fixed label, e.g.,\r\n\r\nDerive-Secrets([., ., .], \"combine\", unique_value),\r\n\r\nthe unique-value should not repeat (across protocol runs), even with different input keys. In Derive-Secret with fixed label, e.g., \r\n\r\nDerive-Secret(., \"sender data\", (unique_value,.)),\r\n\r\nthe unique-value should not repeat (across protocol runs), even with different input keys. However, it is allowed that unique_values are re-used when the labels are different.",
              "createdAt": "2020-05-19T22:31:11Z",
              "updatedAt": "2020-05-19T22:31:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0ODcxODU2",
          "commit": {
            "abbreviatedOid": "1785e97"
          },
          "author": "chrisbrzuska",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-19T22:37:47Z",
          "updatedAt": "2020-05-19T22:37:47Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "(x,y) should refer to an injective encoding of pairs. If GroupContext_[n] is already unique, this simplifies the construction and would be very nice. We were hoping that GroupContext_[n] is already unique, but we don't have the full MLS context to make this judgement. Is GroupContext_[n] also already available at the point when we compute the epoch_secret?",
              "createdAt": "2020-05-19T22:37:47Z",
              "updatedAt": "2020-05-19T22:37:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyOTcxNjAx",
          "commit": {
            "abbreviatedOid": "1785e97"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I don't like that before, we had Extract calls which theoretically turn non-uniform randomness into uniform randomness, and now that's all replaced with HKDF-Expand calls that theoretically always assume the randomness is uniform.",
          "createdAt": "2020-06-02T18:58:55Z",
          "updatedAt": "2020-06-02T19:23:00Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Please update all the calls to HKDF-Expand-Label with the new arguments",
              "createdAt": "2020-06-02T18:58:55Z",
              "updatedAt": "2020-06-02T19:23:00Z"
            },
            {
              "originalPosition": 23,
              "body": "I think the correct syntax here would be `Secrets[0]`, `Secrets[1]` ...",
              "createdAt": "2020-06-02T19:01:17Z",
              "updatedAt": "2020-06-02T19:23:00Z"
            },
            {
              "originalPosition": 23,
              "body": "Also, you've added extra spaces before \"n, \" but they don't seem to align with the last call",
              "createdAt": "2020-06-02T19:02:22Z",
              "updatedAt": "2020-06-02T19:23:00Z"
            },
            {
              "originalPosition": 1,
              "body": "The line just above here references HKDF-Extract, which is no longer used anywhere. Please remove",
              "createdAt": "2020-06-02T19:04:39Z",
              "updatedAt": "2020-06-02T19:23:00Z"
            },
            {
              "originalPosition": 14,
              "body": "Just \"uint8\" no \"_t\"",
              "createdAt": "2020-06-02T19:05:24Z",
              "updatedAt": "2020-06-02T19:23:00Z"
            },
            {
              "originalPosition": 28,
              "body": "```suggestion\r\nwhere n is the length of Secrets.\r\n```",
              "createdAt": "2020-06-02T19:06:45Z",
              "updatedAt": "2020-06-02T19:23:00Z"
            },
            {
              "originalPosition": 65,
              "body": "Not enough arguments to Derive-Secrets",
              "createdAt": "2020-06-02T19:10:09Z",
              "updatedAt": "2020-06-02T19:23:00Z"
            },
            {
              "originalPosition": 71,
              "body": "Yes GroupContext_[n] is what you're looking for, and I also don't like the tuples.",
              "createdAt": "2020-06-02T19:12:18Z",
              "updatedAt": "2020-06-02T19:23:00Z"
            },
            {
              "originalPosition": 65,
              "body": "The label \"combine\" is weird, maybe \"epoch\" instead",
              "createdAt": "2020-06-02T19:22:56Z",
              "updatedAt": "2020-06-02T19:23:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwMTYxMjc1",
          "commit": {
            "abbreviatedOid": "1785e97"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-13T19:36:47Z",
          "updatedAt": "2020-06-13T19:36:47Z",
          "comments": [
            {
              "originalPosition": 95,
              "body": "Thanks for the clarification on the double input.\r\n\r\nI think the GroupContext value does meet the requirement for uniqueness here.  It contains the following values:\r\n\r\n* Group ID\r\n* Epoch\r\n* Tree hash\r\n* Transcript hash\r\n\r\nObviously, GroupID and Epoch provide a first level of protection, and the tree hash diverges if there are any different choices of keys. Even if the participants make the same choices in two protocol runs, HPKE uses random keys which are fed into the transcript hash, so will be different.",
              "createdAt": "2020-06-13T19:36:47Z",
              "updatedAt": "2020-06-13T19:36:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwMTYxMzg0",
          "commit": {
            "abbreviatedOid": "1785e97"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-13T19:38:44Z",
          "updatedAt": "2020-06-13T19:38:44Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "Thanks for the clarification.  We would want a defined injective encoding here.  But if we agree that GroupContext is unique enough, maybe we can just use that?",
              "createdAt": "2020-06-13T19:38:44Z",
              "updatedAt": "2020-06-13T19:38:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ4MTY1MDM3",
          "commit": {
            "abbreviatedOid": "1785e97"
          },
          "author": "chrisbrzuska",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-14T14:32:44Z",
          "updatedAt": "2020-07-14T14:32:45Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Sorry for the delay in my response. Is the length of Secrets equal to the number of secrets?",
              "createdAt": "2020-07-14T14:32:44Z",
              "updatedAt": "2020-07-14T14:32:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ4MzY2NTcw",
          "commit": {
            "abbreviatedOid": "1785e97"
          },
          "author": "chrisbrzuska",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-14T18:38:09Z",
          "updatedAt": "2020-07-14T18:38:09Z",
          "comments": [
            {
              "originalPosition": 95,
              "body": "Okay, this sounds very good, thank you!",
              "createdAt": "2020-07-14T18:38:09Z",
              "updatedAt": "2020-07-14T18:38:09Z"
            }
          ]
        }
      ]
    },
    {
      "number": 338,
      "id": "MDExOlB1bGxSZXF1ZXN0NDE5ODc1MzUx",
      "title": "Rely More on HPKE",
      "url": "https://github.com/mlswg/mls-protocol/pull/338",
      "state": "MERGED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The first commit is editorial. I removed all the DH terminology I could find and replaced it with KEM terminology.\r\n\r\nThe second commit is related to https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/79. It would massively reduce complexity of implementations if people were able to rely on HPKE to do all private key parsing, key validation, public key computation, etc. Currently, all the information in the deleted CFRG and NIST sections is either redundant (performed by HPKE) or outdated and performed correctly by HPKE (e.g., old P-256 DH secret representation). Instead of having all this duplicated, it would be easier to keep it in one place.\r\n\r\nAn issue with the new definition of `Derive-Key-Pair`: Repeatedly calling `HKDF-Expand-Label` can be computationally expensive. Each call requires computing the group hash (which, okay, it could be cached) and serializing a struct. It would be nice to do something that's cheaper but still ties context into the secret key generation.",
      "createdAt": "2020-05-19T04:50:08Z",
      "updatedAt": "2020-06-13T19:29:38Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "bb3a3de94cc75e91dee62d24f702fb2b1b5d1182",
      "headRepository": "rozbb/mls-protocol",
      "headRefName": "hpke_updates",
      "headRefOid": "1a39053ade8469decba8a3c682a887927edb2f83",
      "closedAt": "2020-06-13T19:29:38Z",
      "mergedAt": "2020-06-13T19:29:37Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "8bb36cb9cbede8e383d8a1a59e5e8473f7f25302"
      },
      "comments": [
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Update: This now uses HPKE's `DeriveKeyPair` function to do all the heavy lifting",
          "createdAt": "2020-05-19T19:48:32Z",
          "updatedAt": "2020-05-19T19:48:32Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0NjgxMTI3",
          "commit": {
            "abbreviatedOid": "ef319c5"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-19T17:44:16Z",
          "updatedAt": "2020-05-19T17:44:16Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "I think it would make more sense for the ciphersuite / HPKE to define how it generates a private key, given a seed, than to specify an Unmarshal function and do rejection sampling. Rejection sampling isn't guaranteed to work for many schemes -- RSA being the one that comes to mind, but possibly some PQ schemes also.",
              "createdAt": "2020-05-19T17:44:16Z",
              "updatedAt": "2020-06-10T03:56:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0Njk2OTQw",
          "commit": {
            "abbreviatedOid": "ef319c5"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-19T18:04:17Z",
          "updatedAt": "2020-05-19T18:04:17Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "This is a great point. In this case, `Derive-Key-Pair` should just be HPKE's version of `Derive-Key-Pair`, possibly after some HKDF step. This also lets us avoid doing an `Expand-Label` for every iteration.",
              "createdAt": "2020-05-19T18:04:17Z",
              "updatedAt": "2020-06-10T03:56:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyOTY3MjAy",
          "commit": {
            "abbreviatedOid": "59080fc"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-02T18:52:46Z",
          "updatedAt": "2020-06-02T18:52:46Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2MjYyNTIz",
          "commit": {
            "abbreviatedOid": "59080fc"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-08T13:50:03Z",
          "updatedAt": "2020-06-08T13:51:53Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Might be clearer to write something like `KEM.Nsk`.",
              "createdAt": "2020-06-08T13:50:03Z",
              "updatedAt": "2020-06-10T03:56:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2NzU3MzY5",
          "commit": {
            "abbreviatedOid": "59080fc"
          },
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-09T03:03:45Z",
          "updatedAt": "2020-06-09T03:03:45Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwMTYwODU4",
          "commit": {
            "abbreviatedOid": "1a39053"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-13T19:29:30Z",
          "updatedAt": "2020-06-13T19:29:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 339,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIwMDU2ODc5",
      "title": "Upper bound on group size in early phase too low",
      "url": "https://github.com/mlswg/mls-protocol/pull/339",
      "state": "MERGED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The co-path might contain a high number of resolved nodes when the tree is still empty. The worst case is ~N which is why the limit should be the same as for sender ID.",
      "createdAt": "2020-05-19T11:28:27Z",
      "updatedAt": "2020-05-20T08:03:54Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "bb3a3de94cc75e91dee62d24f702fb2b1b5d1182",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "raphaelrobert-upper-bound",
      "headRefOid": "24356b922bd0039ba9b83e9071b5a69c9cf1b196",
      "closedAt": "2020-05-19T17:32:33Z",
      "mergedAt": "2020-05-19T17:32:33Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "c0f69e7f6b96afdffd9f45a7c73d1ef81f9ea99a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0NDIyNDA3",
          "commit": {
            "abbreviatedOid": "24356b9"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-19T13:04:17Z",
          "updatedAt": "2020-05-19T13:04:17Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0NjcyMTEx",
          "commit": {
            "abbreviatedOid": "24356b9"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thank you for changing this to what my code has been doing all along :)",
          "createdAt": "2020-05-19T17:32:25Z",
          "updatedAt": "2020-05-19T17:32:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 341,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIxMjc2MzA3",
      "title": "Fix in lifetime extension",
      "url": "https://github.com/mlswg/mls-protocol/pull/341",
      "state": "MERGED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-05-21T10:30:26Z",
      "updatedAt": "2020-10-05T15:44:26Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "c0f69e7f6b96afdffd9f45a7c73d1ef81f9ea99a",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "raphaelrobert-lifetime",
      "headRefOid": "31f69d9c823045e7eb5734898c27459fa2f1955d",
      "closedAt": "2020-05-22T19:16:53Z",
      "mergedAt": "2020-05-22T19:16:53Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "48442a2491bfd8e044ddfb044d8db9f029204384"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2MDQ5MTIy",
          "commit": {
            "abbreviatedOid": "31f69d9"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-21T10:45:43Z",
          "updatedAt": "2020-05-21T10:45:43Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3MTE1MjQ2",
          "commit": {
            "abbreviatedOid": "31f69d9"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-22T18:40:27Z",
          "updatedAt": "2020-05-22T18:40:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 342,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI1NDA5MjQx",
      "title": "Allow external proposals to be signed.",
      "url": "https://github.com/mlswg/mls-protocol/pull/342",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #323 by special-casing external senders. Removing the GroupContext would allow me to take messages that user A sent in one instance of a group, and make it look like they're speaking in another group by re-encrypting the ciphertext.",
      "createdAt": "2020-05-30T03:52:30Z",
      "updatedAt": "2020-06-16T19:07:44Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "48442a2491bfd8e044ddfb044d8db9f029204384",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2020.5.0",
      "headRefOid": "1cafde832e0e21da7a0ffba0a36994dae86655ab",
      "closedAt": "2020-06-16T19:07:44Z",
      "mergedAt": "2020-06-16T19:07:43Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "85b5cdad9aa59408e6fc1f1390dbba60351413e5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyODczMzg2",
          "commit": {
            "abbreviatedOid": "d15f1cc"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-02T16:52:47Z",
          "updatedAt": "2020-06-02T17:06:17Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "I might prefer something like the following, in order to preserve the property that the signed data is `prefix || MLSPlaintext`:\r\n\r\n```\r\nstruct {\r\n  select (MLSPlaintextTBS.sender.sender_type) {\r\n    case member:\r\n      opaque tree_hash<0..255>;\r\n      opaque confirmed_transcript_hash<0..255>;\r\n\r\n    case preconfigured, new_member:\r\n      struct{};\r\n  }\r\n\r\n  opaque group_id<0..255>;\r\n  uint64 epoch;\r\n   ...\r\n}\r\n```",
              "createdAt": "2020-06-02T16:52:48Z",
              "updatedAt": "2020-06-03T03:26:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMTkyNzY5",
          "commit": {
            "abbreviatedOid": "1b021d8"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-03T03:23:42Z",
          "updatedAt": "2020-06-03T03:23:42Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "- Also included extensions\r\n- I think this struct is technically un-parse-able because the select is before the field that the select is on, but implementations can probably cheat to get it to work",
              "createdAt": "2020-06-03T03:23:42Z",
              "updatedAt": "2020-06-03T03:26:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxODEyMDYw",
          "commit": {
            "abbreviatedOid": "1cafde8"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-16T19:07:35Z",
          "updatedAt": "2020-06-16T19:07:35Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "It doesn't actually need to be parseable, just serializable.  If you wanted to make it parseable, you could change the `select` to an `optional<GroupContext>` and mandate is presence when `sender_type == member`.",
              "createdAt": "2020-06-16T19:07:35Z",
              "updatedAt": "2020-06-16T19:07:35Z"
            }
          ]
        }
      ]
    },
    {
      "number": 343,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI1NDYxMzMy",
      "title": "Upper bound for Commit",
      "url": "https://github.com/mlswg/mls-protocol/pull/343",
      "state": "MERGED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The upper bound for the number of Proposals of each type in a Commit is currently 2^16.\r\n\r\nThis makes it impossible to create groups with more than 2^16 members in one go and it also limits the number of UpdateProposals and RemoveProposals that can happen between two Commits to 2^16.",
      "createdAt": "2020-05-30T12:44:18Z",
      "updatedAt": "2020-10-05T15:44:28Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "48442a2491bfd8e044ddfb044d8db9f029204384",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "raphaelrobert-large-groups",
      "headRefOid": "3471ad65d73f02400d87dc59303c5f66d8d91026",
      "closedAt": "2020-06-13T19:42:56Z",
      "mergedAt": "2020-06-13T19:42:56Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "e38aac72400f157bff29f96810234e39230753d1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwMTYxNTk4",
          "commit": {
            "abbreviatedOid": "3471ad6"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-13T19:42:49Z",
          "updatedAt": "2020-06-13T19:42:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 345,
      "id": "MDExOlB1bGxSZXF1ZXN0NDMyNDM0ODM1",
      "title": "no need extra layer of optional in GroupInfo.tree",
      "url": "https://github.com/mlswg/mls-protocol/pull/345",
      "state": "CLOSED",
      "author": "yihuang",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "since the Node is optional inside.",
      "createdAt": "2020-06-10T12:53:35Z",
      "updatedAt": "2020-06-16T19:05:39Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "48442a2491bfd8e044ddfb044d8db9f029204384",
      "headRepository": "yihuang/mls-protocol",
      "headRefName": "remove-optional",
      "headRefOid": "d8557b07b54ae5f03bd1cae7cfaacfd7cf7b0006",
      "closedAt": "2020-06-16T19:05:39Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "yihuang",
          "authorAssociation": "NONE",
          "body": "> You do need the `optional<...>` because some of the nodes may be blank\r\n\r\nBut there is already optional inside `Node` type:\r\n```\r\nstruct {\r\n    NodeType node_type;\r\n    select (Node.node_type) {\r\n        case leaf:   optional<KeyPackage> key_package;\r\n        case parent: optional<ParentNode> node;\r\n    };\r\n} Node;\r\n```\r\n\r\nSo we already can express blank nodes like this:\r\n```\r\n[ Node(Leaf, none)\r\n, Node(Parent, none)\r\n, ...\r\n]\r\n```\r\n\r\nNo need for extra optional, there should be no difference between: `None` and `Node(Leaf, none)`, right?",
          "createdAt": "2020-06-10T16:25:36Z",
          "updatedAt": "2020-06-10T16:27:02Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "This should really be replaced by a commit hash so that the tree can be transmitted out-of-band (cf. #344). The TLS encoding doesn't scale very well here for large groups and we also want to allow server assist to work.",
          "createdAt": "2020-06-10T16:26:56Z",
          "updatedAt": "2020-06-10T16:26:56Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@yihuang I think your analysis is correct here, but I would eliminate the other `optional<>`.  That is, something like:\r\n\r\n```\r\nstruct {\r\n    NodeType node_type;\r\n    select (Node.node_type) {\r\n        case leaf:   KeyPackage key_package;\r\n        case parent: ParentNode node;\r\n    };\r\n} Node;\r\n\r\noptional<Node> tree<1..2^32-1>;\r\n```\r\n\r\nIf we agree on the approach here, I can implement it in #348, which makes the tree optional as @raphaelrobert suggests.",
          "createdAt": "2020-06-13T18:46:53Z",
          "updatedAt": "2020-06-13T18:46:53Z"
        },
        {
          "author": "yihuang",
          "authorAssociation": "NONE",
          "body": "> @yihuang I think your analysis is correct here, but I would eliminate the other `optional<>`. That is, something like:\r\n> \r\n> ```\r\n> struct {\r\n>     NodeType node_type;\r\n>     select (Node.node_type) {\r\n>         case leaf:   KeyPackage key_package;\r\n>         case parent: ParentNode node;\r\n>     };\r\n> } Node;\r\n> \r\n> optional<Node> tree<1..2^32-1>;\r\n> ```\r\n> \r\n> If we agree on the approach here, I can implement it in #348, which makes the tree optional as @raphaelrobert suggests.\r\n\r\nYour approach is even better.",
          "createdAt": "2020-06-14T02:32:35Z",
          "updatedAt": "2020-06-14T02:32:35Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @yihuang.  This has been folded into #348 ",
          "createdAt": "2020-06-16T19:05:33Z",
          "updatedAt": "2020-06-16T19:05:33Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4MjIzMzY2",
          "commit": {
            "abbreviatedOid": "d8557b0"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "You do need the `optional<...>` because some of the nodes may be blank",
          "createdAt": "2020-06-10T16:19:07Z",
          "updatedAt": "2020-06-10T16:19:07Z",
          "comments": []
        }
      ]
    },
    {
      "number": 347,
      "id": "MDExOlB1bGxSZXF1ZXN0NDMzOTAyMzMw",
      "title": "Explicitly specify which nodes are targeted",
      "url": "https://github.com/mlswg/mls-protocol/pull/347",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, processing a DirectPath requires that the recipient have a full view of the ratchet tree, so that it can compute the resolutions of copath nodes.  This PR changes the DirectPath structure to explicitly state which tree node a given encryption of a path secret is targeted to.  This is a prerequisit for making full knowledge of the tree optional, as in #344.",
      "createdAt": "2020-06-12T22:03:24Z",
      "updatedAt": "2020-06-16T19:06:05Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "48442a2491bfd8e044ddfb044d8db9f029204384",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "irresolute",
      "headRefOid": "bea46080ee807f3c7f082f58e4c130983b5b1050",
      "closedAt": "2020-06-16T19:06:05Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Plan is to close this PR.",
          "createdAt": "2020-06-16T16:27:06Z",
          "updatedAt": "2020-06-16T16:27:06Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 348,
      "id": "MDExOlB1bGxSZXF1ZXN0NDMzOTA5NTYx",
      "title": "Make the tree in the Welcome optional",
      "url": "https://github.com/mlswg/mls-protocol/pull/348",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #344 ",
      "createdAt": "2020-06-12T22:31:09Z",
      "updatedAt": "2020-07-24T21:14:45Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "60572e71e0e46c1f202352266e1762595f40beb9",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "deforest",
      "headRefOid": "07c1e98e201dfda11f3b3946d3c3c13c1b6c90ec",
      "closedAt": "2020-07-24T21:14:45Z",
      "mergedAt": "2020-07-24T21:14:45Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "e1c56540b40d0ce59b0905f8dc195026805d1e27"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "A couple of shortcomings to note on this PR:\r\n\r\n* The joiner can't compute their private keys because they're not told where they are in the tree or how big the tree is.  The former should be added to `GroupSecrets` and the latter to `GroupInfo`.\r\n\r\n* This approach assumes that the joiner gets the tree OOB before processing the Welcome, otherwise they can't verify the signature on the Welcome.  (Since Welcome presumes they get the credential for the signer from the tree.)\r\n\r\nWe could avoid the latter problem by including a credential for the signer and a \"membership proof\" comprising the hashes needed to tie that leaf to the tree hash in the Welcome.  That could allow participants to remain \"passive\" (without a full tree, just their private keys) for longer, especially if such a proof could be provided on Commit as well.  This might be a good candidate for an extension, though.",
          "createdAt": "2020-07-07T15:05:38Z",
          "updatedAt": "2020-07-07T15:05:38Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussion at the 2020-07-14 interim indicated that we should go ahead with this strategy, and just note the requirement that you have to get the tree before you process the Welcome.",
          "createdAt": "2020-07-24T21:13:26Z",
          "updatedAt": "2020-07-24T21:13:26Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 349,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM1Mzk1MDE3",
      "title": "Use opaque epoch IDs and encrypt content type",
      "url": "https://github.com/mlswg/mls-protocol/pull/349",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #269 \r\nFixes #142 ",
      "createdAt": "2020-06-16T18:27:12Z",
      "updatedAt": "2020-10-06T15:23:10Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "e38aac72400f157bff29f96810234e39230753d1",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "opaque-epoch",
      "headRefOid": "23f64356a8fc949daab60d2a83e69a4de6e3c697",
      "closedAt": "2020-10-06T15:23:10Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@raphaelrobert - You asked today if I had implemented this.  I tried to today and failed!  The problem is that we use different keys for the content encryption depending on the content type.  So the content_type can't go in the encrypted content, it has to go in the sender data.  With that modification, the remainder of the PR worked as expected.  Pushing an update to this PR shortly.\r\n\r\nPR on the Go implementation here: https://github.com/cisco/go-mls/pull/77",
          "createdAt": "2020-07-07T20:33:50Z",
          "updatedAt": "2020-07-07T20:33:50Z"
        },
        {
          "author": "uhoreg",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FWIW, making the epoch opaque rather than an increasing number will help with the decentralized case where users' views of the ratchet tree may branch and merge.  There are of course still other things that will need to change for this case, but this will be one fewer difference.",
          "createdAt": "2020-07-13T20:22:33Z",
          "updatedAt": "2020-07-13T20:22:33Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "@bifurcation Re-iterating my points from the mailing list discussion:\r\n- Implementations that can branch will still have to handle branching on their own, consistent with the way in which they branch.\r\n- The privacy properties of the opaque epoch id are very weak and privacy-preserving applications will still have to invent their own way to hide this metadata.\r\n\r\nPlease decline this PR!",
          "createdAt": "2020-09-08T20:36:20Z",
          "updatedAt": "2020-09-08T20:36:20Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing because:\r\n* This behavior can be emulated by applications, e.g., by exporting an ID and keeping state locally\r\n* There's some operational simplicity to having things the way they are.",
          "createdAt": "2020-10-06T15:23:10Z",
          "updatedAt": "2020-10-06T15:23:10Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzOTkwNTA4",
          "commit": {
            "abbreviatedOid": "b6c3b26"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-07T15:12:21Z",
          "updatedAt": "2020-07-07T19:33:18Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "Note: This should use Derive-Secret, since it doesn't need to be free of context like `welcome_secret` does.",
              "createdAt": "2020-07-07T15:12:22Z",
              "updatedAt": "2020-07-07T20:35:17Z"
            }
          ]
        }
      ]
    },
    {
      "number": 350,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM1NDUwMjM0",
      "title": "IANA updates and their consequences",
      "url": "https://github.com/mlswg/mls-protocol/pull/350",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This started off just fixing #312, then grew a bit.\r\n\r\n* Defines an IANA registry for ExtensionType values\r\n* Defines an IANA registry for CredentialType values\r\n* Updates the Ciphersuites registry to share formatting with the other two, and to be more explicit about its ties to HPKE algorithms\r\n* Removes the unnecessary `signature_scheme` field from `BasicCredential`\r\n* ... and as a result removes the definition of `SignatureScheme` (which is used nowhere else)\r\n\r\nFixes #312 ",
      "createdAt": "2020-06-16T20:29:29Z",
      "updatedAt": "2020-07-14T17:25:16Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "7d7b07325f618acd7d254be3bf5ea45615a1445e",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "iana-extensions",
      "headRefOid": "31bb22aab47bdb6d84f21a3deff1627e02072dba",
      "closedAt": "2020-07-14T17:25:16Z",
      "mergedAt": "2020-07-14T17:25:16Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "5970817438e45c3bdb6f3c92d338a983dcbe45b1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3NzIyODQ5",
          "commit": {
            "abbreviatedOid": "46db202"
          },
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-14T01:30:58Z",
          "updatedAt": "2020-07-14T01:30:58Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Okay I see that we are referring to the uncompressed key format in SECG. I know there's a reference for that somewhere else, but I can't think of it right now. Go ahead and don't block on me and I can submit reference updates later.",
              "createdAt": "2020-07-14T01:30:58Z",
              "updatedAt": "2020-07-14T17:23:29Z"
            }
          ]
        }
      ]
    },
    {
      "number": 352,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM1NDU0Njg3",
      "title": "Use node_index for both hashes",
      "url": "https://github.com/mlswg/mls-protocol/pull/352",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #328 ",
      "createdAt": "2020-06-16T20:39:17Z",
      "updatedAt": "2020-07-07T19:04:55Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "85b5cdad9aa59408e6fc1f1390dbba60351413e5",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "same-index",
      "headRefOid": "f43a7ae18ff51c2e13118c3ce0b63f6244ab7eca",
      "closedAt": "2020-07-07T19:04:55Z",
      "mergedAt": "2020-07-07T19:04:55Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "50fdd379ef6f56855d1c1bf135cb5cb843c99c34"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@Bren2010 - I seem to recall you had some opinions on node hashing?",
          "createdAt": "2020-06-16T20:39:37Z",
          "updatedAt": "2020-06-16T20:39:37Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxOTQ3Nzg3",
          "commit": {
            "abbreviatedOid": "f43a7ae"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-16T22:57:44Z",
          "updatedAt": "2020-06-16T22:57:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 353,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM1NDYwOTU0",
      "title": "Explain the meaning of a Commit with no proposals",
      "url": "https://github.com/mlswg/mls-protocol/pull/353",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #340 ",
      "createdAt": "2020-06-16T20:53:33Z",
      "updatedAt": "2020-07-24T21:11:12Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "60572e71e0e46c1f202352266e1762595f40beb9",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "commit-no-proposals",
      "headRefOid": "ea8ed606b857a4b64b79365742d0df9deb4ca9de",
      "closedAt": "2020-07-24T21:11:12Z",
      "mergedAt": "2020-07-24T21:11:11Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "1130b97a05489f428e3d07a1a05c098489d64c85"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we need to clearly define \"FS / PCS with regard to\", but once we do that, it seems like a fine phrase.  That seems like a good topic for a review / update of the Security Considerations once we have the protocol mostly in shape, for which I have filed #365.",
          "createdAt": "2020-07-24T21:11:06Z",
          "updatedAt": "2020-07-24T21:11:06Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxOTQ4NDcx",
          "commit": {
            "abbreviatedOid": "4d98cec"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-16T22:59:29Z",
          "updatedAt": "2020-06-16T22:59:29Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I don't believe such a commit would change the leaf. Makes more sense to me to not allow empty commits",
              "createdAt": "2020-06-16T22:59:29Z",
              "updatedAt": "2020-07-24T20:19:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxOTYxMTMx",
          "commit": {
            "abbreviatedOid": "4d98cec"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-16T23:33:46Z",
          "updatedAt": "2020-06-16T23:33:46Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "It would reset the leaf, via `Commit.path.leaf_key_package`.\r\n\r\nISTM there is a very concrete use case for this feature, namely keeping the tree full.  If you want to maintain a full tree, then you would want to have each new joiner should send an empty commit immediately on joining, have the neighbor of a removed node send an empty commit after a remove, etc.",
              "createdAt": "2020-06-16T23:33:46Z",
              "updatedAt": "2020-07-24T20:19:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzMzczMTAy",
          "commit": {
            "abbreviatedOid": "4d98cec"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T14:59:57Z",
          "updatedAt": "2020-06-18T14:59:57Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "So an empty commit is essentially what used to be an Update, i.e. fresh key material for the committers leaf, which is then KDFed up the tree. Functionally, I am ok with this, but it seems a little counter-intuitive to me. Wouldn't it be clearer if we disallowed empty commits and a party that would like to keep the tree full simply committed an Update proposal targeting their own leaf? That would yield the same result, wouldn't it?\r\n\r\nAlso: Advancing an epoch doesn't always give PCS guarantees. If an Add proposal is committed without an Update and `path` is empty, the epoch changes, but we don't get PCS (this is why I was critical of allowing Adds without Updates. It breaks the assumption that epoch change implies PCS).",
              "createdAt": "2020-06-18T14:59:57Z",
              "updatedAt": "2020-07-24T20:19:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxODYzOTkw",
          "commit": {
            "abbreviatedOid": "b9bd601"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-20T18:40:42Z",
          "updatedAt": "2020-07-20T18:40:43Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Advancing the epoch gives you PCS with respect to the committer and and any nodes that were updated/removed in the epoch.  That doesn't change here.",
              "createdAt": "2020-07-20T18:40:42Z",
              "updatedAt": "2020-07-24T20:19:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUzODUzMDQ5",
          "commit": {
            "abbreviatedOid": "b9bd601"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-23T06:02:04Z",
          "updatedAt": "2020-07-23T06:02:05Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "I'm pretty sure it doesn't if there is no `path` value. If I understand correctly, an `Add` only commit doesn't update the committers secrets (and thus doesn't get you PCS), but _does_ advance the epoch. I was only pointing out that advancing the epoch doesn't imply PCS if we allow empty `path` fields.",
              "createdAt": "2020-07-23T06:02:04Z",
              "updatedAt": "2020-07-24T20:19:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1MTY1NjYx",
          "commit": {
            "abbreviatedOid": "ea8ed60"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "That works fine. I am a bit bothered by the phrasing regarding properties \u00ab\u00a0with regard to\u00a0...\u00bb. If you can find an alternate phrasing that would be \ud83d\udc4d",
          "createdAt": "2020-07-24T20:26:40Z",
          "updatedAt": "2020-07-24T20:26:40Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1MTg2NDA4",
          "commit": {
            "abbreviatedOid": "ea8ed60"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-24T21:08:01Z",
          "updatedAt": "2020-07-24T21:08:02Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "You are correct that a Commit with no `path` doesn't cause any PCS.  But we're talking about empty Commits here, which are required to have a `path`.  I've edited to be more precise.",
              "createdAt": "2020-07-24T21:08:01Z",
              "updatedAt": "2020-07-24T21:08:02Z"
            }
          ]
        }
      ]
    },
    {
      "number": 354,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM4ODU4MjQ4",
      "title": "misc little fixes",
      "url": "https://github.com/mlswg/mls-protocol/pull/354",
      "state": "MERGED",
      "author": "uhoreg",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I've put a bunch of little fixes in here.  If you disagree with any of these changes, I can back them out or change them.\r\n\r\n- maximal is defined but never used\r\n- k-th leaf/leaf index is defined in two places; merge definitions\r\n- change KeyPackage struct definition to reflect that ~2~ 3 extensions are required\r\n- `lifetime` is also a required extension\r\n- grammar fix\r\n- add missing semicolon",
      "createdAt": "2020-06-23T22:32:31Z",
      "updatedAt": "2020-07-07T19:05:51Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "85b5cdad9aa59408e6fc1f1390dbba60351413e5",
      "headRepository": "uhoreg/mls-protocol",
      "headRefName": "misc_fixes",
      "headRefOid": "023a2e7711b382b4cf466eca223afe574bf2802a",
      "closedAt": "2020-07-07T19:05:51Z",
      "mergedAt": "2020-07-07T19:05:51Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "ee969f006752b34ff94da67908b184f95a5c7870"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzOTc3NzM2",
          "commit": {
            "abbreviatedOid": "4069eca"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "One minor thing, otherwise LGTM",
          "createdAt": "2020-07-07T14:59:15Z",
          "updatedAt": "2020-07-07T14:59:49Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Each extension is at least 4 bytes long (2 for type, 2 for length), so if you want the real minimum here, it should be 12.  I'm generally not sanguine about using the TLS struct definition to enforce this sort of thing, though.",
              "createdAt": "2020-07-07T14:59:15Z",
              "updatedAt": "2020-07-07T16:21:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0MDc1Nzkx",
          "commit": {
            "abbreviatedOid": "023a2e7"
          },
          "author": "uhoreg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-07T16:50:13Z",
          "updatedAt": "2020-07-07T16:50:13Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Fixed",
              "createdAt": "2020-07-07T16:50:13Z",
              "updatedAt": "2020-07-07T16:50:13Z"
            }
          ]
        }
      ]
    },
    {
      "number": 355,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ3NDQ1MTY3",
      "title": "Validate external proposals from preconfigured senders",
      "url": "https://github.com/mlswg/mls-protocol/pull/355",
      "state": "MERGED",
      "author": "d1vyank",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-07-10T13:36:32Z",
      "updatedAt": "2020-07-11T14:52:01Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "ee969f006752b34ff94da67908b184f95a5c7870",
      "headRepository": "d1vyank/mls-protocol",
      "headRefName": "external-proposal",
      "headRefOid": "41c508d2170860fea7542a4b4b650bbaf280ec8d",
      "closedAt": "2020-07-11T14:52:01Z",
      "mergedAt": "2020-07-11T14:52:01Z",
      "mergedBy": "Bren2010",
      "mergeCommit": {
        "oid": "1f9f90578eecd61103cc02f98b8a0d058d265e65"
      },
      "comments": [
        {
          "author": "d1vyank",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This stuck out to me while reading because verification is explicitly specified for the 'new_member' sender type in the paragraph above this and not for the 'preconfigured' sender type.\r\n\r\nI think it would be better to specify this as the verification flow is different for these external proposals i.e. the KeyPackage in the proposal is used for new_member sender types, and the key corresponding to an authorized sender is used for preconfigured senders.",
          "createdAt": "2020-07-11T03:13:56Z",
          "updatedAt": "2020-07-11T03:13:56Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2NjI4Mjcz",
          "commit": {
            "abbreviatedOid": "41c508d"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Was there reasonable confusion that these proposals wouldn't be verified? I see we have this line in the spec:\r\n\r\n```\r\nOn receiving an MLSPlaintext containing a Proposal, a client MUST verify the\r\nsignature on the enclosing MLSPlaintext.\r\n```",
          "createdAt": "2020-07-10T18:46:46Z",
          "updatedAt": "2020-07-10T18:46:46Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2ODA3MzQz",
          "commit": {
            "abbreviatedOid": "41c508d"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-11T14:48:24Z",
          "updatedAt": "2020-07-11T14:48:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 356,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ3NDQ1MzA2",
      "title": "Minor editorial changes",
      "url": "https://github.com/mlswg/mls-protocol/pull/356",
      "state": "MERGED",
      "author": "d1vyank",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-07-10T13:36:47Z",
      "updatedAt": "2020-07-10T18:35:31Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "ee969f006752b34ff94da67908b184f95a5c7870",
      "headRepository": "d1vyank/mls-protocol",
      "headRefName": "nits",
      "headRefOid": "b135de93f1fcb978f051c6fd35b756562c96b689",
      "closedAt": "2020-07-10T18:35:31Z",
      "mergedAt": "2020-07-10T18:35:31Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "fd9222cea4454e6b1714886896b8449ad82300f1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2NjE4NTYw",
          "commit": {
            "abbreviatedOid": "b135de9"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-10T18:34:14Z",
          "updatedAt": "2020-07-10T18:34:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 357,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ3NTkwMzIy",
      "title": "Fix all compiler warnings.",
      "url": "https://github.com/mlswg/mls-protocol/pull/357",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Previously we used [[ ... ]] for comments, and the body of the comment was only getting elided because the compiler didn't know what that syntax meant.",
      "createdAt": "2020-07-10T18:43:26Z",
      "updatedAt": "2020-07-20T21:01:48Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "90a85c4144d5904ce31f36d5cdc07e49c219d721",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2020.7.0",
      "headRefOid": "4047ddc883a73a50d7d2ac201bf8ec368b7fea68",
      "closedAt": "2020-07-20T21:01:47Z",
      "mergedAt": "2020-07-20T21:01:47Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "d68b832e69abcee6150eb69d5d82500f161175db"
      },
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Please don't remove the .editorconfig file again! It's a [normal thing](https://github.com/quicwg/base-drafts/blob/master/.editorconfig) for projects to have!!",
          "createdAt": "2020-07-10T22:57:06Z",
          "updatedAt": "2020-07-10T22:57:06Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2OTA4NTI1",
          "commit": {
            "abbreviatedOid": "05f9d4c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-12T20:44:42Z",
          "updatedAt": "2020-07-12T20:45:36Z",
          "comments": [
            {
              "originalPosition": 342,
              "body": "I don't think this quite matches the intent -- we want these OPEN ISSUES to be visible in the rendered HTML",
              "createdAt": "2020-07-12T20:44:42Z",
              "updatedAt": "2020-07-20T21:01:27Z"
            },
            {
              "originalPosition": 317,
              "body": "I think we can delete this TODO.",
              "createdAt": "2020-07-12T20:45:15Z",
              "updatedAt": "2020-07-20T21:01:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2OTA5MjU4",
          "commit": {
            "abbreviatedOid": "05f9d4c"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-12T20:57:32Z",
          "updatedAt": "2020-07-12T20:57:32Z",
          "comments": [
            {
              "originalPosition": 342,
              "body": "I noticed this is how QUIC WG does it: https://github.com/quicwg/base-drafts/commit/09338d0e237e67c648aa172c32b872e10bf737ff",
              "createdAt": "2020-07-12T20:57:32Z",
              "updatedAt": "2020-07-20T21:01:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxOTU1ODAy",
          "commit": {
            "abbreviatedOid": "024fa7d"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-20T21:00:27Z",
          "updatedAt": "2020-07-20T21:00:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 358,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ3NjczMTgy",
      "title": "Fix build by switching to GitHub actions",
      "url": "https://github.com/mlswg/mls-protocol/pull/358",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-07-10T22:47:11Z",
      "updatedAt": "2020-07-11T13:39:12Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "fd9222cea4454e6b1714886896b8449ad82300f1",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "master",
      "headRefOid": "83bf0237a4dd58acbd60f41697b657d14742d42e",
      "closedAt": "2020-07-11T13:39:12Z",
      "mergedAt": "2020-07-11T13:39:12Z",
      "mergedBy": "katrielalex",
      "mergeCommit": {
        "oid": "3a6ac80ff98946991dc02ce71873069230834aa0"
      },
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "@katrielalex Once this is merged, we should have an automatically maintained gh-pages branch. You can cname mls.rocks to mlswg.github.io",
          "createdAt": "2020-07-10T22:48:10Z",
          "updatedAt": "2020-07-10T22:48:10Z"
        },
        {
          "author": "katrielalex",
          "authorAssociation": "MEMBER",
          "body": "Should work! Let\u2019s try it and see",
          "createdAt": "2020-07-11T13:30:34Z",
          "updatedAt": "2020-07-11T13:30:34Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 359,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ3OTQ4NDc3",
      "title": "Fix bugs in tree math and cleanup docs.",
      "url": "https://github.com/mlswg/mls-protocol/pull/359",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-07-12T20:09:04Z",
      "updatedAt": "2020-07-14T18:17:01Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "1f9f90578eecd61103cc02f98b8a0d058d265e65",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "brendan/fix-tree-math",
      "headRefOid": "46854f86605d01dd597992a12aab12c9fcee675b",
      "closedAt": "2020-07-14T18:17:01Z",
      "mergedAt": "2020-07-14T18:17:01Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "5433610fbdde8989df929cd44bd97c9656fcbb91"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ4MzUxNDAz",
          "commit": {
            "abbreviatedOid": "46854f8"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-14T18:16:56Z",
          "updatedAt": "2020-07-14T18:16:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 360,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ4NjA1ODMx",
      "title": "#302: Reduce encryption overhead to just auth tag",
      "url": "https://github.com/mlswg/mls-protocol/pull/360",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-07-14T02:34:30Z",
      "updatedAt": "2020-09-10T15:00:27Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "1d5e14d79435834bc5cab6c7aa9e2fcdd6afeabc",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "brendan/masking",
      "headRefOid": "1b57be612b2f58ca248f78e6373ffad3463be36c",
      "closedAt": "2020-09-10T15:00:27Z",
      "mergedAt": "2020-09-10T15:00:27Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "bb303085f3748a7ba171f9f12fdbeef22d063283"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Just to recap the options as I understand them:\r\n\r\na) Today:\r\n   encrypted_sender_data = AEAD(sender_data_key, sender_data_nonce, (groupID, epoch), sender_data)\r\n   encrypted_content = AEAD(app_key[i][j], app_key[i][j], (groupID, epoch, encrypted_sender_data), content)\r\n\r\nb) Sample sender data nonce from ciphertext (saves explicit nonce)\r\n   encrypted_content = AEAD(app_key[i][j], app_nonce[i][j], (groupID, epoch), content)\r\n   encrypted_sender_data = AEAD(sender_data_key, sample(encrypted_content), (groupID, epoch, encrypted_content), sender_data)\r\n\r\nc) Drop auth tag from content encryption (saves explicit nonce and content auth tag)\r\n   encrypted_content = Enc(app_key[i][j], app_nonce[i][j], content)\r\n   encrypted_sender_data = AEAD(sender_data_key, sample(encrypted_content), (groupID, epoch, encrypted_content), sender_data)",
          "createdAt": "2020-08-11T16:41:40Z",
          "updatedAt": "2020-08-11T16:41:40Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxODg5NDAx",
          "commit": {
            "abbreviatedOid": "8de7bda"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-20T19:17:54Z",
          "updatedAt": "2020-07-20T19:58:05Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "I think the overview steps are important to have here, especially since the ciphertext sampling makes the order of things a bit complex (you have to encrypt the content, then loop back to the sender data).  But I think we streamline a little bit:\r\n\r\n```\r\n* Set group_id, epoch, content_type and authenticated_data fields from the\r\n  MLSPlaintext object directly\r\n\r\n* Identify the key and key generation depending on the content type\r\n\r\n* Encrypt an MLSCiphertextContent for the ciphertext field using the key\r\n  identified and MLSPlaintext object\r\n\r\n* Encrypt the sender data using the sender data key for the epoch and a\r\n   nonce sampled from  encrypted MLSCiphertextContent.\r\n```",
              "createdAt": "2020-07-20T19:17:55Z",
              "updatedAt": "2020-09-04T22:43:53Z"
            },
            {
              "originalPosition": 241,
              "body": "You've removed the AAD from the main content encryption, which seems wrong.  it seems like we should have the unencrypted sender data feed in the ciphertext AAD, and the ciphertext (or the derived nonce) in the sender data AAD.  Something like:\r\n\r\n```\r\n      /  group_id            \\\r\n      |  epoch               |--+\r\n   +--|  content_type        /  |\r\n   |  |  sender_data         <--+\r\n   |  \\  authenticated_data  \\__|\r\n   +-->  content             /\r\n\r\nstruct {\r\n    opaque group_id<0..255>;\r\n    uint64 epoch;\r\n    ContentType content_type;\r\n    opaque authenticated_data<0..2^32-1>; // <---\r\n    opaque ciphertext<0..2^32-1>;\r\n} SenderDataAAD;\r\n\r\nstruct {\r\n    opaque group_id<0..255>;\r\n    uint64 epoch;\r\n    ContentType content_type;\r\n    SenderData sender_data;\r\n    opaque authenticated_data<0..2^32-1>; // <--- \r\n} ContentAAD;\r\n```",
              "createdAt": "2020-07-20T19:24:04Z",
              "updatedAt": "2020-09-04T22:43:53Z"
            },
            {
              "originalPosition": 281,
              "body": "Can't we just use the existing KDF we have on hand?",
              "createdAt": "2020-07-20T19:25:16Z",
              "updatedAt": "2020-09-04T22:43:53Z"
            },
            {
              "originalPosition": 181,
              "body": "Since we're going to have an auth tag anyway, it seems like we could simplify this a fair bit by just using the ciphersuite's AEAD to encrypt the SenderData (as we do now), and just sampling the *nonce* from the ciphertext.\r\n\r\nThat obviously removes the need to do XOR in addition to normal AEAD, and may allow us to simplify the sampling as well.  Since the nonce only needs to be random and not secret, we might be able to get away with just using the first `nonce_size` bytes of the ciphertext (or HKDF-Extract thereof).  So it gets rid of the AES-ECB dependency as well.\r\n\r\nAnd since this changes from (AEAD + XOR + AEAD) to (AEAD + AEAD), we no longer need the `authentication_key`.\r\n\r\n```\r\nciphertext = AEAD.Seal(key=generation.key,\r\n                       nonce=generation.nonce,\r\n                       pt=content,\r\n                       aad=header_with_plaintext_sender_data)\r\nsender_data_nonce = ciphertext[:nonce_size]\r\nencrypted_sender_data = AEAD.Seal(key=sender_data_key,\r\n                                  nonce=sender_data_nonce,\r\n                                  pt=sender_data,\r\n                                  aad=header_without_sender_data_and_with_ciphertext)\r\n```",
              "createdAt": "2020-07-20T19:57:47Z",
              "updatedAt": "2020-09-04T22:43:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyOTE2OTc2",
          "commit": {
            "abbreviatedOid": "8de7bda"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-22T00:28:58Z",
          "updatedAt": "2020-07-22T00:28:58Z",
          "comments": [
            {
              "originalPosition": 241,
              "body": "The ciphertext's auth tag is truncated so there's no point in having AAD on the content. All AAD is against the sender data.",
              "createdAt": "2020-07-22T00:28:58Z",
              "updatedAt": "2020-09-04T22:43:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyMDU2MjQy",
          "commit": {
            "abbreviatedOid": "1e84b5c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks, @Bren2010, this looks pretty close.  Couple things that need adjusting before we can merge.",
          "createdAt": "2020-09-03T17:29:45Z",
          "updatedAt": "2020-09-04T15:00:47Z",
          "comments": [
            {
              "originalPosition": 147,
              "body": "Having this in the ciphertext AAD creates a circular dependency, since the nonce for the sender data encryption is derived from the ciphertext.  Need to either have the plaintext sender data or nothing.",
              "createdAt": "2020-09-03T17:29:45Z",
              "updatedAt": "2020-09-04T22:43:53Z"
            },
            {
              "originalPosition": 183,
              "body": "This doesn't seem right.  First, this should be `KDF.Expand` for generatlity.  Second, IIRC, HKDF-Expand expects a PRK of the output size of hash function, so your PRK here is to short.\r\n\r\nHowever, I wonder if we can refactor here to also solve a problem I noted above, namely that deriving the key with Derive-Secret doesn't give you the right size key.  What about something like:\r\n\r\n```\r\nsender_data_secret = Derive-Secret(epoch_secret, \"sender data\")\r\nsender_data_key = ExpandWithLabel(sender_data_secret, \"key\", \"\", AEAD.Nk)\r\n\r\nciphertext_sample = ciphertext[0..AEAD.Nn-1]\r\nsender_data_nonce = ExpandWithLabel(sender_data_secret, \"nonce\", ciphertext_sample, AEAD.Nn)\r\n```\r\n\r\nAlternatively, is there a need for the `Expand` call here at all?  The output of the AEAD function should already be indistinguishable from random, so maybe we could use `sender_data_nonce == ciphertext_sample`?\r\n",
              "createdAt": "2020-09-04T14:59:09Z",
              "updatedAt": "2020-09-04T22:43:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2MDI4NDM0",
          "commit": {
            "abbreviatedOid": "1b57be6"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-10T15:00:16Z",
          "updatedAt": "2020-09-10T15:00:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 361,
      "id": "MDExOlB1bGxSZXF1ZXN0NDUzNjg5MzY0",
      "title": "Use correct arguments to Derive-Secret",
      "url": "https://github.com/mlswg/mls-protocol/pull/361",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #324 ",
      "createdAt": "2020-07-20T17:56:46Z",
      "updatedAt": "2020-07-20T18:21:51Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "5433610fbdde8989df929cd44bd97c9656fcbb91",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "derive-secret",
      "headRefOid": "0bae585e6f48de1721aee383f37412c15ac78eb2",
      "closedAt": "2020-07-20T18:21:51Z",
      "mergedAt": "2020-07-20T18:21:51Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "90a85c4144d5904ce31f36d5cdc07e49c219d721"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxODUwMjU3",
          "commit": {
            "abbreviatedOid": "0bae585"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-20T18:20:49Z",
          "updatedAt": "2020-07-20T18:20:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 362,
      "id": "MDExOlB1bGxSZXF1ZXN0NDUzNzE1OTg5",
      "title": "Reorder key schedule inputs",
      "url": "https://github.com/mlswg/mls-protocol/pull/362",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR rearranges the key schedule so that the following values are all fed into the init secret to form epoch secret:\r\n\r\n1. The commit secret\r\n2. The PSK (if any)\r\n3. The group context\r\n\r\nThis assures that new joiners know the PSK for the epoch, since they now need to know it to compute the epoch secret.  It also moves the group context from the `Derive-Secret` calls under the epoch secret to the derivation of the epoch secret itself, ensuring that everything derived in the epoch has the same context folded in.\r\n\r\nFixes #325 \r\nFixes #326 ",
      "createdAt": "2020-07-20T18:29:58Z",
      "updatedAt": "2020-07-28T17:29:27Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "b8b1951b0f315e57377f5ca493c4325d04ab8106",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "key-schedule",
      "headRefOid": "3b330f3110fd4dd60fa57cc423353ced1711d8fd",
      "closedAt": "2020-07-28T17:29:27Z",
      "mergedAt": "2020-07-28T17:29:26Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "593cc3b1af05111436d934a73442518d92303444"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU2Nzc2MDky",
          "commit": {
            "abbreviatedOid": "147b9a3"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Lgtm",
          "createdAt": "2020-07-28T15:53:23Z",
          "updatedAt": "2020-07-28T15:53:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 363,
      "id": "MDExOlB1bGxSZXF1ZXN0NDU0ODIzNzM3",
      "title": "Fix compile errors again.",
      "url": "https://github.com/mlswg/mls-protocol/pull/363",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-07-22T01:16:10Z",
      "updatedAt": "2020-07-24T18:36:07Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "d68b832e69abcee6150eb69d5d82500f161175db",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2020.7.3",
      "headRefOid": "45ca0afd974c554d4b668c80a1e00b6aabe5f1de",
      "closedAt": "2020-07-24T18:36:07Z",
      "mergedAt": "2020-07-24T18:36:07Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "930a1b388d81956761655592d1e26ab701455939"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1MTA0NDY0",
          "commit": {
            "abbreviatedOid": "45ca0af"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-24T18:35:59Z",
          "updatedAt": "2020-07-24T18:35:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 364,
      "id": "MDExOlB1bGxSZXF1ZXN0NDU2NDI4NDQ0",
      "title": "Use the KDF from HPKE",
      "url": "https://github.com/mlswg/mls-protocol/pull/364",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #351 ",
      "createdAt": "2020-07-24T18:28:40Z",
      "updatedAt": "2020-07-24T19:49:13Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "930a1b388d81956761655592d1e26ab701455939",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "hpke-kdf",
      "headRefOid": "10d19660772a6d91da3fa64a3c7ef2ae9b875e4a",
      "closedAt": "2020-07-24T19:49:13Z",
      "mergedAt": "2020-07-24T19:49:13Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "60572e71e0e46c1f202352266e1762595f40beb9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1MTAzMDk3",
          "commit": {
            "abbreviatedOid": "02b57f8"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-24T18:33:43Z",
          "updatedAt": "2020-07-24T18:33:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 369,
      "id": "MDExOlB1bGxSZXF1ZXN0NDU2NjYzNDEz",
      "title": "Add Commit extensions and clarify the extensibility story",
      "url": "https://github.com/mlswg/mls-protocol/pull/369",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #366 ",
      "createdAt": "2020-07-25T20:06:41Z",
      "updatedAt": "2020-08-25T18:44:13Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "593cc3b1af05111436d934a73442518d92303444",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "commit-ext",
      "headRefOid": "f3599f673a1a5720187c54205061ba9d5c89aef8",
      "closedAt": "2020-08-25T18:44:13Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 370,
      "id": "MDExOlB1bGxSZXF1ZXN0NDU2NjY0MTgz",
      "title": "Minor extension fixes",
      "url": "https://github.com/mlswg/mls-protocol/pull/370",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR makes a few minor fixes to extensions:\r\n\r\n* Coalesces `supported_versions` and `supported_ciphersuites` into a single extension\r\n* Adds a list of supported extensions in parallel with the versions and ciphersuites\r\n* Adds a missing value to the IANA table for the `ratchet_tree` extension",
      "createdAt": "2020-07-25T20:14:35Z",
      "updatedAt": "2020-07-27T13:29:41Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "e1c56540b40d0ce59b0905f8dc195026805d1e27",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "client-capabilities",
      "headRefOid": "ff79548f1854ed64d4f3ce2c305c067f149af0c6",
      "closedAt": "2020-07-27T13:29:40Z",
      "mergedAt": "2020-07-27T13:29:40Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "9b52e6a735cc926d3a3b5488b5c3e5e6de2f1dab"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1Mzg4NDQw",
          "commit": {
            "abbreviatedOid": "ff79548"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-26T19:14:22Z",
          "updatedAt": "2020-07-26T19:14:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 371,
      "id": "MDExOlB1bGxSZXF1ZXN0NDU2ODA0Mzc3",
      "title": "Define HPKE on first use",
      "url": "https://github.com/mlswg/mls-protocol/pull/371",
      "state": "MERGED",
      "author": "chelseakomlo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR defines and links to the HPKE draft when first introducing this term in the draft.",
      "createdAt": "2020-07-26T20:55:14Z",
      "updatedAt": "2020-07-27T13:30:44Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "e1c56540b40d0ce59b0905f8dc195026805d1e27",
      "headRepository": "chelseakomlo/mls-protocol",
      "headRefName": "define-hpke-on-first-use",
      "headRefOid": "2f84cd477dc9dd9197150296b42f72b79fef90c8",
      "closedAt": "2020-07-27T13:30:44Z",
      "mergedAt": "2020-07-27T13:30:44Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "da6d4ebf3abdd459ff57b9ec954600475067c29a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1NzgyMDQ1",
          "commit": {
            "abbreviatedOid": "2f84cd4"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-27T13:30:38Z",
          "updatedAt": "2020-07-27T13:30:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 372,
      "id": "MDExOlB1bGxSZXF1ZXN0NDU2ODU0MDQ3",
      "title": "Commit Generation Clarifications",
      "url": "https://github.com/mlswg/mls-protocol/pull/372",
      "state": "MERGED",
      "author": "chelseakomlo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR tries to clarify these paragraphs by the following: \r\n\r\n- Differentiating between HPKE public/private keys when describing how these keys are rotated for a commit\r\n- Clarifying who does the actions associated with a commit\r\n- Adding consistency fixes between the two paragraphs\r\n\r\nLet me know if these fixes are not quite right, as this PR tries to clarify where I had questions when reading. ",
      "createdAt": "2020-07-27T02:07:58Z",
      "updatedAt": "2020-07-27T21:07:28Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "e1c56540b40d0ce59b0905f8dc195026805d1e27",
      "headRepository": "chelseakomlo/mls-protocol",
      "headRefName": "hpke-pub-key-update",
      "headRefOid": "d136e979ebb89c5f371a1b6aa2d58a98f5766919",
      "closedAt": "2020-07-27T21:07:28Z",
      "mergedAt": "2020-07-27T21:07:27Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "b8b1951b0f315e57377f5ca493c4325d04ab8106"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1Nzg2NTIw",
          "commit": {
            "abbreviatedOid": "bd391f4"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-27T13:35:33Z",
          "updatedAt": "2020-07-27T13:37:26Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "This isn't quite right.  `leaf_hpke_secret` is a symmetric secret value, from which an HPKE secret key is derived, as illustrated below:\r\n\r\n```\r\n    path_secret[0] --> node_priv[0], node_pub[0]\r\n         ^\r\n         |\r\n   leaf_hpke_secret\r\n```\r\n\r\nMaybe it would be helpful to annotate that diagram to reinforce that the `[0]` is the leaf?\r\n\r\n```\r\n    path_secret[0] --> node_priv[0], node_pub[0]\r\n         ^             = leaf_priv, leaf_pub\r\n         |             ~> leaf_key_package\r\n         |\r\n   leaf_hpke_secret\r\n```",
              "createdAt": "2020-07-27T13:35:33Z",
              "updatedAt": "2020-07-27T21:01:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU2MTA2OTA3",
          "commit": {
            "abbreviatedOid": "bd391f4"
          },
          "author": "chelseakomlo",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-27T20:22:47Z",
          "updatedAt": "2020-07-27T20:22:47Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "This annotation would be helpful. ",
              "createdAt": "2020-07-27T20:22:47Z",
              "updatedAt": "2020-07-27T21:01:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU2MTE5NTg1",
          "commit": {
            "abbreviatedOid": "bd391f4"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-27T20:42:15Z",
          "updatedAt": "2020-07-27T20:42:15Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Actually, as you pointed out to me offline, this is inconsistent with the diagram below.  I think what it should be instead is:\r\n\r\n```\r\n       path_secret[1] --> node_priv[1], node_pub[1]\r\n            ^\r\n            |\r\n       path_secret[0] --> node_priv[0], node_pub[0]\r\n            ^\r\n            |\r\n       leaf_secret    --> leaf_priv, leaf_pub\r\n                          ~> leaf_key_package\r\n```",
              "createdAt": "2020-07-27T20:42:15Z",
              "updatedAt": "2020-07-27T21:01:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU2MTM1ODQ4",
          "commit": {
            "abbreviatedOid": "d136e97"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-27T21:07:20Z",
          "updatedAt": "2020-07-27T21:07:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 375,
      "id": "MDExOlB1bGxSZXF1ZXN0NDU3NTE2Mjg1",
      "title": "Fix grammar and add some initials",
      "url": "https://github.com/mlswg/mls-protocol/pull/375",
      "state": "CLOSED",
      "author": "claucece",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "After reviewing for a second time the document, I decided to do some grammar fixes as well. Hope it is helpful.\r\ncc./ @beurdouche ",
      "createdAt": "2020-07-28T03:25:33Z",
      "updatedAt": "2020-07-29T07:40:11Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "b8b1951b0f315e57377f5ca493c4325d04ab8106",
      "headRepository": "claucece/mls-protocol",
      "headRefName": "master",
      "headRefOid": "8b152c16c255f68c33cb4e2f61cdbb29ad71dac8",
      "closedAt": "2020-07-29T07:40:11Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "claucece",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Mmm.. as the PR has too many line fixes, I'm going to open a new one with only the grammar changes. ",
          "createdAt": "2020-07-29T07:40:11Z",
          "updatedAt": "2020-07-29T07:40:11Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU2NzgwODIz",
          "commit": {
            "abbreviatedOid": "8b152c1"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-28T15:58:39Z",
          "updatedAt": "2020-07-28T16:10:41Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "needs is correct, the subject is \"group\" which is singular",
              "createdAt": "2020-07-28T15:58:39Z",
              "updatedAt": "2020-07-28T16:10:41Z"
            },
            {
              "originalPosition": 46,
              "body": "-as",
              "createdAt": "2020-07-28T16:00:03Z",
              "updatedAt": "2020-07-28T16:10:41Z"
            },
            {
              "originalPosition": 43,
              "body": "Wrapping text pollutes \"git blame\" unnecessarily. We don't have any real line length",
              "createdAt": "2020-07-28T16:01:50Z",
              "updatedAt": "2020-07-28T16:10:41Z"
            },
            {
              "originalPosition": 15,
              "body": "I think the punctuation was fine before",
              "createdAt": "2020-07-28T16:02:25Z",
              "updatedAt": "2020-07-28T16:10:41Z"
            },
            {
              "originalPosition": 409,
              "body": "FC -> FS",
              "createdAt": "2020-07-28T16:04:38Z",
              "updatedAt": "2020-07-28T16:10:41Z"
            },
            {
              "originalPosition": 455,
              "body": "Two options:\r\n- sends itself an Add and commits, then (how it was)\r\n- sends itself an Add, commits, and then",
              "createdAt": "2020-07-28T16:06:41Z",
              "updatedAt": "2020-07-28T16:10:41Z"
            },
            {
              "originalPosition": 501,
              "body": "\"by which\" or \"where\"",
              "createdAt": "2020-07-28T16:07:51Z",
              "updatedAt": "2020-07-28T16:10:41Z"
            },
            {
              "originalPosition": 843,
              "body": "-to",
              "createdAt": "2020-07-28T16:10:02Z",
              "updatedAt": "2020-07-28T16:10:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3MjY4Mjcy",
          "commit": {
            "abbreviatedOid": "8b152c1"
          },
          "author": "claucece",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-29T07:38:36Z",
          "updatedAt": "2020-07-29T07:38:37Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Oh, yes! Thanks! I got confused by this: https://english.stackexchange.com/questions/39838/is-group-singular-or-plural ",
              "createdAt": "2020-07-29T07:38:36Z",
              "updatedAt": "2020-07-29T07:38:37Z"
            }
          ]
        }
      ]
    },
    {
      "number": 376,
      "id": "MDExOlB1bGxSZXF1ZXN0NDU3OTk2NjM0",
      "title": "Negotiate PSKs",
      "url": "https://github.com/mlswg/mls-protocol/pull/376",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #367 ",
      "createdAt": "2020-07-28T19:09:47Z",
      "updatedAt": "2020-08-03T22:22:09Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "593cc3b1af05111436d934a73442518d92303444",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "negotiate-psk",
      "headRefOid": "ddbca946933352357ea323111aa311d9d5c38b13",
      "closedAt": "2020-08-03T22:22:09Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this one for now.  After discussion with @kkohbrok, he's going to refactor the relevant bits out of #336 once we have the required tools from fixing #366.",
          "createdAt": "2020-08-03T22:22:08Z",
          "updatedAt": "2020-08-03T22:22:08Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4OTY3MzY0",
          "commit": {
            "abbreviatedOid": "ddbca94"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-31T07:24:09Z",
          "updatedAt": "2020-07-31T07:24:09Z",
          "comments": [
            {
              "originalPosition": 160,
              "body": "As I noted on the mailinglist, the issue with the PSKId being (part of) an extension and those extensions in turn being part of the `GroupInfo` object, means that the PSK can't be required for decrypting that `GroupInfo` object in the first place. In #336 , we suggested that the PSKId be part of the `GroupSecrets` object along with the other secrets. This would also ensure compatibility with the pending nPRF key schedule proposal.",
              "createdAt": "2020-07-31T07:24:09Z",
              "updatedAt": "2020-07-31T07:24:09Z"
            }
          ]
        }
      ]
    },
    {
      "number": 377,
      "id": "MDExOlB1bGxSZXF1ZXN0NDU4MjU5MDg2",
      "title": "Fix grammar",
      "url": "https://github.com/mlswg/mls-protocol/pull/377",
      "state": "MERGED",
      "author": "claucece",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "cc./ @Bren2010, it should be better now.",
      "createdAt": "2020-07-29T07:49:07Z",
      "updatedAt": "2020-07-29T16:37:49Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "593cc3b1af05111436d934a73442518d92303444",
      "headRepository": "claucece/mls-protocol",
      "headRefName": "master",
      "headRefOid": "74f90f89cbef122616cc459df68b9b82adc6e4b0",
      "closedAt": "2020-07-29T16:37:33Z",
      "mergedAt": "2020-07-29T16:37:33Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "e09ea022f428273d0b7ca2b5c01cce11e5e00aca"
      },
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Thanks both ! :)",
          "createdAt": "2020-07-29T16:37:49Z",
          "updatedAt": "2020-07-29T16:37:49Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3NjI1NTAw",
          "commit": {
            "abbreviatedOid": "74f90f8"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-29T15:15:00Z",
          "updatedAt": "2020-07-29T15:15:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 378,
      "id": "MDExOlB1bGxSZXF1ZXN0NDU4ODMzNzc4",
      "title": "Readability edits for section 'Synchronizing Views of the Tree'",
      "url": "https://github.com/mlswg/mls-protocol/pull/378",
      "state": "MERGED",
      "author": "chelseakomlo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR does the following: \r\n\r\n- Adds a lead-in sentence describing how this section builds on the prior. \r\n- Differentiates between public keys for nodes and public keys for leaves (users)\r\n- Clarifies when secret key material needs to be deleted. \r\n\r\nI also wanted to make a couple other changes, but wanted feedback first. \r\n\r\n1. This section describes the private value corresponding to a node's public key as 'ns[0]' (or node secret), whereas the prior section referred to it as 'np[0]' (or node_priv). It would be better to have these terms be consistent.\r\n2.  On line 773, it says that the client \"...transmits a handshake message containing a set of **public** values\" and on line 776 it says that \"other members of the group can use these **public** values to update\". However, this values seems to be contradictory with the value listed on line 785. \r\n3. The current terminology is unclear regarding 1) a Commit to the tree, 2) an update to the tree, and and 3) a handshake message. I think these are very similar but using the same language consistently would be better (such as defining a Commit as what updates the tree, and then describing how the handshake message is different from a Commit message, which is described earlier in the spec). ",
      "createdAt": "2020-07-30T02:53:00Z",
      "updatedAt": "2020-07-31T20:55:23Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "e09ea022f428273d0b7ca2b5c01cce11e5e00aca",
      "headRepository": "chelseakomlo/mls-protocol",
      "headRefName": "read-sync",
      "headRefOid": "c2b0bd607d596ab10dd1dc9831a5ce1fbbfd36c0",
      "closedAt": "2020-07-31T20:55:23Z",
      "mergedAt": "2020-07-31T20:55:23Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "c3db39266505e9d202158d642d65918d35870e77"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for looking through this, @chelseakomlo.  There's a lot of historical baggage here, so it's good to get it cleaned up.  I'll review the diff in a moment, but to respond to your points:\r\n\r\n1. Just to confirm terminology here, there are three values in play, (1) a symmetric secret, (2) a KEM private key derived from the secret, and (3) the corresponding public key.  It _should_ be the case that you only need to store the latter two in the tree (priv+pub), since the secrets are used transiently: For deriving the tree key pairs, for deriving the commit secret, and for initializing new members added in an epoch.  [My implementation](https://github.com/cisco/mlspp/blob/master/include/treekem.h#L42) stores the node secrets to simplify these operations, but it feels like it should be possible to arrange things so that this isn't necessary.  So I think the right answer here is to just refer to node private keys.\r\n\r\n2. Line 785 is correct, the Commit contains a public key and encrypted copies of the path secret for each node.  So the text should refer to public **and encrypted private** values as necessary.\r\n\r\n3. The right taxonomy here is: \"Handshake message\" encompasses `Proposal` and `Commit`.  Processing the Commit is the thing that causes an update to the tree; more specifically, applying a DirectPath.  So we should only talk about handshake messages when we want to cover both Proposals and Commits, and most instances of \"update\" should probably refer to either Commit or DirectPath.",
          "createdAt": "2020-07-31T17:33:36Z",
          "updatedAt": "2020-07-31T17:33:36Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5MzQ2MTI0",
          "commit": {
            "abbreviatedOid": "043cb5c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-31T17:37:01Z",
          "updatedAt": "2020-07-31T18:00:05Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "`s/will need to//`",
              "createdAt": "2020-07-31T17:37:26Z",
              "updatedAt": "2020-07-31T20:54:10Z"
            },
            {
              "originalPosition": 7,
              "body": "Might rephrase as \"apply it to their local views of the tree to keep them in sync with the sender's.\"",
              "createdAt": "2020-07-31T17:37:58Z",
              "updatedAt": "2020-07-31T20:54:10Z"
            },
            {
              "originalPosition": 5,
              "body": "This stuff might be better phrased in terms of a `DirectPath` (which maybe we should rename to `UpdatePath`?), since a Commit no longer has to have an update of this character.",
              "createdAt": "2020-07-31T17:57:17Z",
              "updatedAt": "2020-07-31T20:54:10Z"
            },
            {
              "originalPosition": 23,
              "body": "Unclear whether \"outdated\" here means \"from before the Commit\" or \"transmitted in the Commit, but now obsolete because the keys have been generated from them\".  Like I said above, I think we can focus on the latter (so that you'll never even have the former stored), we just need to make sure that the wording of the requirement doesn't interfere with the secondary uses of the path secrets.",
              "createdAt": "2020-07-31T17:59:58Z",
              "updatedAt": "2020-07-31T20:54:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NDA0NjYw",
          "commit": {
            "abbreviatedOid": "043cb5c"
          },
          "author": "chelseakomlo",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-31T19:18:29Z",
          "updatedAt": "2020-07-31T19:18:30Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "`UpdatePath` sounds like a better name. I'll do this renaming in a separate PR, but will rephrase this section to refer to a `DirectPath` as opposed to a `Commit` in the meantime.  ",
              "createdAt": "2020-07-31T19:18:29Z",
              "updatedAt": "2020-07-31T20:54:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NDA4MTg4",
          "commit": {
            "abbreviatedOid": "043cb5c"
          },
          "author": "chelseakomlo",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-31T19:24:56Z",
          "updatedAt": "2020-07-31T19:24:56Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Actually, you know, I think it would be better to do this change in a separate commit as well, as it will involve re-writing the \"Ratchet Tree Evolution\" section to refer to `DirectPath` as well, no? ",
              "createdAt": "2020-07-31T19:24:56Z",
              "updatedAt": "2020-07-31T20:54:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NDE1MDMw",
          "commit": {
            "abbreviatedOid": "4344030"
          },
          "author": "chelseakomlo",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-31T19:30:53Z",
          "updatedAt": "2020-07-31T19:30:54Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Do you mind suggesting phrasing here? This doesn't match my mental model of \"when replacing key material in the tree after receiving a `DirectPath`, the outdated key material (that was replaced by key material in the `DirectPath` message) should be deleted, but there could be something I'm profoundly missing. ",
              "createdAt": "2020-07-31T19:30:53Z",
              "updatedAt": "2020-07-31T20:54:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NDE5NjY2",
          "commit": {
            "abbreviatedOid": "4344030"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-31T19:39:23Z",
          "updatedAt": "2020-07-31T19:43:35Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "The question is: if your nodes have `(secret, sk, pk)`, and you move from `(secret0, sk0, pk0) -> (secret1, sk1, pk1)`, do you need to delete secret0, secret1, or both?  (If you delete `secret1`, then you never have a `secret0` to delete)",
              "createdAt": "2020-07-31T19:39:23Z",
              "updatedAt": "2020-07-31T20:54:10Z"
            },
            {
              "originalPosition": 5,
              "body": "Given this and the discussion below, do you want to close this and come back after the other refactors are done?",
              "createdAt": "2020-07-31T19:41:24Z",
              "updatedAt": "2020-07-31T20:54:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NDcyNzI2",
          "commit": {
            "abbreviatedOid": "c2b0bd6"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-31T20:55:17Z",
          "updatedAt": "2020-07-31T20:55:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 379,
      "id": "MDExOlB1bGxSZXF1ZXN0NDU5OTc4MTcx",
      "title": "Fix typo at minimal number of extensions",
      "url": "https://github.com/mlswg/mls-protocol/pull/379",
      "state": "MERGED",
      "author": "yihuang",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-07-31T09:47:54Z",
      "updatedAt": "2020-08-03T22:22:59Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "c3db39266505e9d202158d642d65918d35870e77",
      "headRepository": "yihuang/mls-protocol",
      "headRefName": "patch-1",
      "headRefOid": "bbbd812b9c6638a5840c02f2fe7f14aa94f08e98",
      "closedAt": "2020-08-03T22:22:59Z",
      "mergedAt": "2020-08-03T22:22:59Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "fa567ad1fba2a24f09d4cdd7d5a9a2138aeffa56"
      },
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "This is not the number of extensions, it's the size of the payload.",
          "createdAt": "2020-07-31T11:03:00Z",
          "updatedAt": "2020-07-31T11:03:00Z"
        },
        {
          "author": "yihuang",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> This is not the number of extensions, it's the size of the payload.\r\n\r\nok",
          "createdAt": "2020-07-31T11:10:41Z",
          "updatedAt": "2020-07-31T11:10:41Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Actually, there's still a change here, since we bumped from 3 required extensions down to 2 (`lifetime` and `capabilities`).  So the minimum should be `8`.  @yihuang you want to make that tweak?",
          "createdAt": "2020-07-31T17:20:29Z",
          "updatedAt": "2020-07-31T17:20:29Z"
        },
        {
          "author": "yihuang",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Actually, there's still a change here, since we bumped from 3 required extensions down to 2 (`lifetime` and `capabilities`). So the minimum should be `8`. @yihuang you want to make that tweak?\r\n\r\nWhy it's 8? I think lifetime extension have two u64 which is 16 bytes already?",
          "createdAt": "2020-08-01T02:05:19Z",
          "updatedAt": "2020-08-01T02:05:19Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "2x (2-byte type + 2-byte length)\n\nThat\u2019s why it was 12 when we had 3 required extensions :)\n\nOn Fri, Jul 31, 2020 at 22:05 yihuang <notifications@github.com> wrote:\n\n> Actually, there's still a change here, since we bumped from 3 required\n> extensions down to 2 (lifetime and capabilities). So the minimum should\n> be 8. @yihuang <https://github.com/yihuang> you want to make that tweak?\n>\n> Why it's 8? I think lifetime extension have two u64 which is 16 bytes\n> already?\n>\n> \u2014\n> You are receiving this because you modified the open/close state.\n>\n>\n> Reply to this email directly, view it on GitHub\n> <https://github.com/mlswg/mls-protocol/pull/379#issuecomment-667451819>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAASOTJWNSHHII2ZVCXSFQ3R6NZ63ANCNFSM4PP443EA>\n> .\n>\n",
          "createdAt": "2020-08-01T02:10:06Z",
          "updatedAt": "2020-08-01T02:10:06Z"
        },
        {
          "author": "yihuang",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> 2x (2-byte type + 2-byte length) That\u2019s why it was 12 when we had 3 required extensions :)\r\n> [\u2026](#)\r\n> On Fri, Jul 31, 2020 at 22:05 yihuang ***@***.***> wrote: Actually, there's still a change here, since we bumped from 3 required extensions down to 2 (lifetime and capabilities). So the minimum should be 8. @yihuang <https://github.com/yihuang> you want to make that tweak? Why it's 8? I think lifetime extension have two u64 which is 16 bytes already? \u2014 You are receiving this because you modified the open/close state. Reply to this email directly, view it on GitHub <[#379 (comment)](https://github.com/mlswg/mls-protocol/pull/379#issuecomment-667451819)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAASOTJWNSHHII2ZVCXSFQ3R6NZ63ANCNFSM4PP443EA> .\r\n\r\nok, changed.",
          "createdAt": "2020-08-01T02:21:57Z",
          "updatedAt": "2020-08-01T02:21:57Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 380,
      "id": "MDExOlB1bGxSZXF1ZXN0NDYwMDY4NTA2",
      "title": "Fix inconsistency in deriving welcome_secret",
      "url": "https://github.com/mlswg/mls-protocol/pull/380",
      "state": "MERGED",
      "author": "yihuang",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Keep it consistent with #key-schedule",
      "createdAt": "2020-07-31T11:45:08Z",
      "updatedAt": "2020-07-31T17:21:29Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "e09ea022f428273d0b7ca2b5c01cce11e5e00aca",
      "headRepository": "yihuang/mls-protocol",
      "headRefName": "patch-2",
      "headRefOid": "d5f4bc91861f37c2f947c9a4674e546367a08c8f",
      "closedAt": "2020-07-31T17:21:29Z",
      "mergedAt": "2020-07-31T17:21:29Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "37d42127bf0a1951841a6e156dc96ca8e264169f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5MzAwNTY2",
          "commit": {
            "abbreviatedOid": "d5f4bc9"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-31T16:22:07Z",
          "updatedAt": "2020-07-31T16:22:07Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5MzM2Njgx",
          "commit": {
            "abbreviatedOid": "d5f4bc9"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-31T17:21:23Z",
          "updatedAt": "2020-07-31T17:21:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 381,
      "id": "MDExOlB1bGxSZXF1ZXN0NDYwNjE0Mzg0",
      "title": "Consistency fix for description of key material sent in an update message",
      "url": "https://github.com/mlswg/mls-protocol/pull/381",
      "state": "MERGED",
      "author": "chelseakomlo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR adds a fix mentioned in #378 but was not included in the PR that was eventually merged. Specifically, both **public and encrypted private** values are sent in a message containing key material to ratchet the tree forward. ",
      "createdAt": "2020-07-31T23:36:44Z",
      "updatedAt": "2020-08-03T22:23:29Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "c3db39266505e9d202158d642d65918d35870e77",
      "headRepository": "chelseakomlo/mls-protocol",
      "headRefName": "sync-consist",
      "headRefOid": "73b023cd7d0997610ed9d39587b7465b28c836a8",
      "closedAt": "2020-08-03T22:23:29Z",
      "mergedAt": "2020-08-03T22:23:29Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "39455d2ea5e8fb42e8f0f0624bddd8c56675da0e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwMzc4MzU2",
          "commit": {
            "abbreviatedOid": "73b023c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-03T22:23:24Z",
          "updatedAt": "2020-08-03T22:23:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 382,
      "id": "MDExOlB1bGxSZXF1ZXN0NDYyMTgwOTI5",
      "title": "Add Konrad and Britta to contribtors",
      "url": "https://github.com/mlswg/mls-protocol/pull/382",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-08-03T13:34:11Z",
      "updatedAt": "2020-08-03T13:35:03Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "c3db39266505e9d202158d642d65918d35870e77",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "kb",
      "headRefOid": "6bcc578508cbf214dc5b46047f4167bbd8d91c64",
      "closedAt": "2020-08-03T13:35:03Z",
      "mergedAt": "2020-08-03T13:35:03Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "a775172284bc6ca7a5196e7c7be7b1bcf01ca183"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 384,
      "id": "MDExOlB1bGxSZXF1ZXN0NDYyNTcyMTE5",
      "title": "4 editorial edits to the draft",
      "url": "https://github.com/mlswg/mls-protocol/pull/384",
      "state": "MERGED",
      "author": "ericcornelissen",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "A couple of minor editorial changes to the current draft, namely:\r\n\r\n<details>\r\n<summary>There was a missing grave accent in one of the paragraphs of <a href=\"https://github.com/mlswg/mls-protocol/blob/c3db39266505e9d202158d642d65918d35870e77/draft-ietf-mls-protocol.md#commit\">the Commit section</a> causing some formatting issues</summary>\r\n\r\n**Before**:\r\n\r\n![paragraph before](https://user-images.githubusercontent.com/3742559/89263277-9fc21c80-d639-11ea-9bd1-19e377fa3628.png)\r\n\r\n**After**:\r\n\r\n![paragraph after](https://user-images.githubusercontent.com/3742559/89263328-b9fbfa80-d639-11ea-8d5d-3b1c27c7d884.png)\r\n\r\n</details>\r\n\r\n<details>\r\n<summary>Fix typo Pre-Shared Keys section</summary>\r\n\r\n\r\n[...], it does not necessarily provide the same [...] guarantees ~than~ as a Commit message.\r\n\r\n</details>\r\n\r\n\r\n<details>\r\n<summary>Resolve remaining reference to <code>prior_epoch</code></summary>\r\n\r\nIn the Sequencing section there was a reference to a `prior_epoch` field that was introduced in 2fa6ed3c6afc7d308905255b4cabe154a48d1e4b. However, in 69e12cd61378aae4a81199c28a16e2802666b6e3, it was removed from the struct where it was added. That entire struct was then removed in 27c9c28f9634a06a9b7921ea9c15e276f8c9ff6f, after which the trail runs cold. So I wasn't able to figure out exactly what it must be based on what on what it originally was. Hence, I replaced it with something that makes sense in context.\r\n\r\nI based the new text on the following line found in the <a href=\"https://github.com/mlswg/mls-protocol/blob/39455d2ea5e8fb42e8f0f0624bddd8c56675da0e/draft-ietf-mls-protocol.md#commit\">(current) Commit section</a>:\r\n\r\n> Verify that the `epoch` field of the enclosing MLSPlaintext message is\r\n> equal to the `epoch` field of the current GroupContext object\r\n\r\n</details>\r\n\r\n\r\n<details>\r\n<summary>Rewrite paragraph on the <code>new_member</code> SenderType</summary>\r\n\r\nI found the phrase \" In such cases\" after the sentence \"Proposals with types other than Add MUST NOT be sent with this sender type\" slightly confusing and awkward. To improve this I rewrote the paragraph.\r\n\r\n</details>",
      "createdAt": "2020-08-04T07:04:58Z",
      "updatedAt": "2020-08-07T08:36:54Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "39455d2ea5e8fb42e8f0f0624bddd8c56675da0e",
      "headRepository": "ericcornelissen/mls-protocol",
      "headRefName": "formatting/issue-in-commit",
      "headRefOid": "db7028e06b776de0cf514d351e4f9f169d9d18fb",
      "closedAt": "2020-08-06T18:01:27Z",
      "mergedAt": "2020-08-06T18:01:27Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "d1d5f56a5d83781042d19c830497ab5aa104907f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyNDc4MjI3",
          "commit": {
            "abbreviatedOid": "6ea4861"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Couple of nits on your nits",
          "createdAt": "2020-08-06T12:40:01Z",
          "updatedAt": "2020-08-06T12:41:32Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "```suggestion\r\nMUST be Add. The MLSPlaintext MUST be signed with the private key corresponding\r\n```",
              "createdAt": "2020-08-06T12:40:01Z",
              "updatedAt": "2020-08-06T17:55:48Z"
            },
            {
              "originalPosition": 44,
              "body": "```suggestion\r\n```",
              "createdAt": "2020-08-06T12:40:42Z",
              "updatedAt": "2020-08-06T17:55:48Z"
            }
          ]
        }
      ]
    },
    {
      "number": 385,
      "id": "MDExOlB1bGxSZXF1ZXN0NDYzOTU3NTQ2",
      "title": "Require the initial init_secret to be a random value",
      "url": "https://github.com/mlswg/mls-protocol/pull/385",
      "state": "MERGED",
      "author": "ericcornelissen",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This suggestion is based on a discussion in the MLS mailing list [[1]](https://mailarchive.ietf.org/arch/msg/mls/qrpAoK7aNSzKxX4O60pOLvM3cp8). It prevents issues that currently arrise when the very first commit of a group is an \"add-only\" commit because both the `commit_secret` and `init_secret` would be **0**.\r\n\r\nLet me know if the wording or anything else should be changed.\r\n\r\n/cc @bifurcation\r\n\r\n---\r\n\r\n1. https://mailarchive.ietf.org/arch/msg/mls/qrpAoK7aNSzKxX4O60pOLvM3cp8",
      "createdAt": "2020-08-06T11:09:18Z",
      "updatedAt": "2020-08-12T06:12:52Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "39455d2ea5e8fb42e8f0f0624bddd8c56675da0e",
      "headRepository": null,
      "headRefName": "random-first-init-secret",
      "headRefOid": "5a34af6b36509dd1eff4ca4abbedd31288fe904f",
      "closedAt": "2020-08-06T13:35:34Z",
      "mergedAt": "2020-08-06T13:35:34Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "4829451c5a21cd7b85d59407bd46fcd2a194283d"
      },
      "comments": [
        {
          "author": "ericcornelissen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I believe this change invalidates the last paragraph of the [Group Creation section](https://github.com/mlswg/mls-protocol/blob/d1d5f56a5d83781042d19c830497ab5aa104907f/draft-ietf-mls-protocol.md#group-creation), as it is impossible to verify the group creation process for the joiner without knowing the random `init_secret` that the group creator used.\r\n\r\n\r\n> A new member receiving a Welcome message can recognize group creation if the number of entries in the members array is equal to the number of leaves in the tree minus one. A client receiving a Welcome message SHOULD verify whether it is a newly created group, and if so, **SHOULD verify that the above process was followed by reconstructing the Add and Commit messages and verifying that the resulting transcript hashes and epoch secret match those found in the Welcome message.**",
          "createdAt": "2020-08-11T13:32:49Z",
          "updatedAt": "2020-08-11T13:32:49Z"
        },
        {
          "author": "tomtau",
          "authorAssociation": "CONTRIBUTOR",
          "body": "maybe one alternative is to keep the zero `init_secret`, but make it compulsory to populate the path for this group creation welcome/commit (so that `commit_secret` isn't zero)?",
          "createdAt": "2020-08-12T05:24:36Z",
          "updatedAt": "2020-08-12T05:28:14Z"
        },
        {
          "author": "ericcornelissen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That would also work @tomtau (I also suggested that as an alternative in my original report in the mailing list), to me it is a little bit less elegant though. Personally, I also wonder why it is necessary to verify that group creation just happened. (Moreover, this way of recognizing group creation would prevent any group from which all but one person left from continuing, which my be confusing to end-users)",
          "createdAt": "2020-08-12T06:12:51Z",
          "updatedAt": "2020-08-12T06:12:51Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyNDc2ODQ3",
          "commit": {
            "abbreviatedOid": "d66463a"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm with one minor thing fixed",
          "createdAt": "2020-08-06T12:38:04Z",
          "updatedAt": "2020-08-06T12:38:47Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "```suggestion\r\n  * Init secret: a fresh random value of size `KDF.Nh`\r\n```\r\n\r\n... just to ensure you have enough entropy here.",
              "createdAt": "2020-08-06T12:38:04Z",
              "updatedAt": "2020-08-06T12:59:35Z"
            }
          ]
        }
      ]
    },
    {
      "number": 387,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY1NjI1MDI2",
      "title": "Make composite types 2^32 and make 0 invalid for enums",
      "url": "https://github.com/mlswg/mls-protocol/pull/387",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- 0 is invalid for all enums except a few, and I wasn't sure if it mattered? So I made them consistent\r\n- `DirectPath.nodes` needs to be 2^32 to fit the largest DirectPathNode\r\n- Make the `extensions` array 2^32 as well to fit the largest Extension, and also 2^16 for *all* extensions seems small",
      "createdAt": "2020-08-10T17:09:38Z",
      "updatedAt": "2020-08-11T19:48:58Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "d1d5f56a5d83781042d19c830497ab5aa104907f",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2020.8.0",
      "headRefOid": "83471ad6a95c7f1bb0c8ccb42f2eed2bdcc1f958",
      "closedAt": "2020-08-11T19:48:58Z",
      "mergedAt": "2020-08-11T19:48:58Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "4fc8afa1f7548ebf56bde9e2d45d0352c66fcf5b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1MjMzODA5",
          "commit": {
            "abbreviatedOid": "63e14af"
          },
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-11T16:28:44Z",
          "updatedAt": "2020-08-11T16:28:44Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Change to reserved.",
              "createdAt": "2020-08-11T16:28:44Z",
              "updatedAt": "2020-08-11T18:45:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1MjMzOTU4",
          "commit": {
            "abbreviatedOid": "63e14af"
          },
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-11T16:28:53Z",
          "updatedAt": "2020-08-11T16:28:54Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "Change to reserved.",
              "createdAt": "2020-08-11T16:28:54Z",
              "updatedAt": "2020-08-11T18:45:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1Mzc3OTc0",
          "commit": {
            "abbreviatedOid": "83471ad"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-11T19:48:51Z",
          "updatedAt": "2020-08-11T19:48:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 388,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY2MTc0NzI2",
      "title": "Clarify the transcript hash computation",
      "url": "https://github.com/mlswg/mls-protocol/pull/388",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses ambiguity pointed out on the mailing list by @ericcornelissen.\r\n\r\nFixes #386 ",
      "createdAt": "2020-08-11T15:20:44Z",
      "updatedAt": "2020-08-11T19:18:12Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "d1d5f56a5d83781042d19c830497ab5aa104907f",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "interim",
      "headRefOid": "2c570160ae48c198a31ff3e9dedb27d1c0ed110a",
      "closedAt": "2020-08-11T19:18:11Z",
      "mergedAt": "2020-08-11T19:18:11Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "385c19416355b5f2900e3b499bdeb4e718b08348"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1MjI4NDMz",
          "commit": {
            "abbreviatedOid": "870674d"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-11T16:22:24Z",
          "updatedAt": "2020-08-11T16:22:25Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Still not clear to me what `0` means here. ",
              "createdAt": "2020-08-11T16:22:24Z",
              "updatedAt": "2020-08-11T16:23:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1MzU1ODM4",
          "commit": {
            "abbreviatedOid": "2c57016"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-11T19:14:20Z",
          "updatedAt": "2020-08-11T19:14:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 389,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY2MzI5NzQw",
      "title": "#383: Enable Commit to cover new proposal types",
      "url": "https://github.com/mlswg/mls-protocol/pull/389",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-08-11T20:10:13Z",
      "updatedAt": "2020-08-25T18:33:18Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "e477ea4279f680446d2cc6f2011b2b8961d77033",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2020.8.2",
      "headRefOid": "dd70f10f2701ef46e4f0cd6b19488b1574b9ce2f",
      "closedAt": "2020-08-25T18:33:17Z",
      "mergedAt": "2020-08-25T18:33:17Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "28c6099e92f2b4767e247cd2016abd760a6620d0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1Mzk5Mjk2",
          "commit": {
            "abbreviatedOid": "1a2ee8a"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-11T20:21:50Z",
          "updatedAt": "2020-08-11T21:04:35Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "This algorithm doesn't validate that the `proposals` vector is in the proper order, which is the complexity I'm most worried about.  Do you have a proposed algorithm for that?",
              "createdAt": "2020-08-11T20:21:50Z",
              "updatedAt": "2020-08-25T18:28:18Z"
            },
            {
              "originalPosition": 103,
              "body": "It might be good to (1) break these out into bullets, and (2) state explicitly where other proposal types fit (presumably after Adds, in any order defined by the proposals?).",
              "createdAt": "2020-08-11T21:03:07Z",
              "updatedAt": "2020-08-25T18:28:18Z"
            },
            {
              "originalPosition": 103,
              "body": "As I mentioned on the call today, we need a way for clients to state their support for proposals, e.g., a `supported_proposals` field in the `capabilities` extension.",
              "createdAt": "2020-08-11T21:04:32Z",
              "updatedAt": "2020-08-25T18:28:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1NDI5NTYz",
          "commit": {
            "abbreviatedOid": "1a2ee8a"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-11T21:07:16Z",
          "updatedAt": "2020-08-11T21:07:16Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "Yes it does, line 1962 does that check",
              "createdAt": "2020-08-11T21:07:16Z",
              "updatedAt": "2020-08-25T18:28:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1NDMyMTEw",
          "commit": {
            "abbreviatedOid": "1a2ee8a"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-11T21:11:35Z",
          "updatedAt": "2020-08-11T21:11:35Z",
          "comments": [
            {
              "originalPosition": 103,
              "body": "I didn't state where other proposals go, because I thought extensions would want to decide for themselves.\r\n\r\nI think support for given proposals should be assumed if the client supports a given group extension",
              "createdAt": "2020-08-11T21:11:35Z",
              "updatedAt": "2020-08-25T18:28:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MDkyMjUx",
          "commit": {
            "abbreviatedOid": "f76ad2e"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-12T16:43:25Z",
          "updatedAt": "2020-08-12T16:43:26Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "line 1967 now",
              "createdAt": "2020-08-12T16:43:26Z",
              "updatedAt": "2020-08-25T18:28:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3ODI1MDYx",
          "commit": {
            "abbreviatedOid": "3b27aa3"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-14T19:26:29Z",
          "updatedAt": "2020-08-14T20:56:44Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "I see what you mean.  That also explains why you reordered the proposal definitions, which I found a bit puzzling :)  You've still got them in the wrong order, (Add, Update, Remove) instead of (Update, Remove, Add).\r\n\r\nI would prefer not to rely interpreting ProposalType values as integers / the order of the enum here.  Instead, how about something more explicit, like:\r\n\r\n```\r\ndef proposal_order(proposal_type):\r\n    if proposal_type == update:\r\n        return 1\r\n    elif proposal_type == remove:\r\n        return 2\r\n    elif proposal_type == add:\r\n        return 3\r\n    else:\r\n        return 4\r\n```",
              "createdAt": "2020-08-14T19:26:29Z",
              "updatedAt": "2020-08-25T18:28:18Z"
            },
            {
              "originalPosition": 113,
              "body": "At this point, though, I wonder what the utility is of requiring the proposals to be ordered.  We already require that the recipient MUST first apply the Updates, then Removes, then Adds.  It will remove the need for validation logic, and not make the processing logic much worse.\r\n\r\n```\r\napplied = set()\r\napplied = state.apply_updates(proposals, applied)\r\napplied = state.apply_removes(proposals, applied)\r\napplied = state.apply_adds(proposals, applied)\r\nif len(applied) != len(proposals):\r\n    raise Exception(\"Unsupported proposals\")\r\n```\r\n\r\nThis would get you to a point where new proposal types wouldn't require a *syntax* change, but would require different processing.  That doesn't seem awful, since new proposal types will have to be negotiated, and thus we can assume that if one is used, then everyone will have the right processing logic.",
              "createdAt": "2020-08-14T19:40:07Z",
              "updatedAt": "2020-08-25T18:28:18Z"
            },
            {
              "originalPosition": 113,
              "body": "In a related vein, this PR should:\r\n1. Extend the `capabilities` extension to have `supported_proposals`\r\n2. Add a note to the proposal processing step below that future proposal handling is defined by the future proposals.",
              "createdAt": "2020-08-14T20:56:40Z",
              "updatedAt": "2020-08-25T18:28:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5NjA0OTk1",
          "commit": {
            "abbreviatedOid": "d6dd20e"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T16:04:37Z",
          "updatedAt": "2020-08-18T16:04:38Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "Added a note that the processing should be updated by extensions that add new proposals.\r\n\r\nI don't want to add a `supported_proposals` vector, because proposals can't be supported piecemeal. If you support an extension and that extension adds several proposals, you'd need to support them all",
              "createdAt": "2020-08-18T16:04:38Z",
              "updatedAt": "2020-08-25T18:28:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0NzM4NDMw",
          "commit": {
            "abbreviatedOid": "632c901"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Two small things, otherwise lgtm.",
          "createdAt": "2020-08-25T18:18:41Z",
          "updatedAt": "2020-08-25T18:23:02Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "\r\n```suggestion\r\nif the Commit covers no proposals at all (i.e., if the proposal vector\r\n```",
              "createdAt": "2020-08-25T18:18:41Z",
              "updatedAt": "2020-08-25T18:28:18Z"
            }
          ]
        }
      ]
    },
    {
      "number": 391,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY3Njk5NDEx",
      "title": "Rename DirectPath to UpdatePath",
      "url": "https://github.com/mlswg/mls-protocol/pull/391",
      "state": "MERGED",
      "author": "chelseakomlo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This is a simple rename of `DirectPath` to `UpdatePath` to be more descriptive of the action being performed by the message.\r\n\r\nI'll open a separate PR after this PIR is merged with updates to the spec where it uses `Commit` when instead it should say `UpdatePath` (since not every `Commit` actually ratchets forward key material, as I understand). Some examples of where these clarifications should happen are: \r\n\r\n- Line 1203 should instead say \"each MLS UpdatePath message\" \r\n- The sections \"Ratchet Tree Evolution\" and \"Sychronizing Views of the Tree\" should describe the process of generating the key material for an `UpdatePath` message\r\n\r\ncc @bifurcation ",
      "createdAt": "2020-08-14T00:11:44Z",
      "updatedAt": "2020-08-20T16:03:46Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "4fc8afa1f7548ebf56bde9e2d45d0352c66fcf5b",
      "headRepository": "chelseakomlo/mls-protocol",
      "headRefName": "direct-path-to-update-path",
      "headRefOid": "09fcebc4d20fcb49e7ae3e4a9989b41b70af3fef",
      "closedAt": "2020-08-20T16:03:46Z",
      "mergedAt": "2020-08-20T16:03:46Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "9f52307a138e303b967eca3df9df966ee581e9ef"
      },
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "DirectPath corresponds to the graph theory term \"direct path\" of a leaf with the root",
          "createdAt": "2020-08-14T00:20:13Z",
          "updatedAt": "2020-08-14T00:20:13Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "\"Direct path\" is still a thing, and the object in question here operates along a direct path, but I think \"UpdatePath\" indicates more clearly what it's doing.",
          "createdAt": "2020-08-20T16:03:42Z",
          "updatedAt": "2020-08-20T16:03:42Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 393,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY3OTgwNDIw",
      "title": "Application messages MUST be encrypted",
      "url": "https://github.com/mlswg/mls-protocol/pull/393",
      "state": "MERGED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-08-14T13:20:20Z",
      "updatedAt": "2020-10-05T15:44:30Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "4fc8afa1f7548ebf56bde9e2d45d0352c66fcf5b",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "raphaelrobert-message-encryption",
      "headRefOid": "6855c706ed7b9a7e87a9da11b6c2c971c8c6cc88",
      "closedAt": "2020-08-25T16:17:54Z",
      "mergedAt": "2020-08-25T16:17:54Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "e477ea4279f680446d2cc6f2011b2b8961d77033"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3ODIwMzc0",
          "commit": {
            "abbreviatedOid": "6855c70"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-14T19:17:27Z",
          "updatedAt": "2020-08-14T19:17:37Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "I don't think this MUST makes sense -- for example, there may be cases where you want to take an MLS key exchange and protect application data with an exported key.\r\n\r\nInstead, can we just delete \"both application and\" here?  I think the intent of the sentence was to encourage encryption of handshake messages, not to say anything about application messages.",
              "createdAt": "2020-08-14T19:17:28Z",
              "updatedAt": "2020-08-14T19:17:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3OTY2Nzky",
          "commit": {
            "abbreviatedOid": "6855c70"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-15T11:56:20Z",
          "updatedAt": "2020-08-15T11:56:20Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "> I don't think this MUST makes sense -- for example, there may be cases where you want to take an MLS key exchange and protect application data with an exported key.\r\n\r\nIf you just want to use MLS for key exchange and then use key material from the exporter that's fine, but that's orthogonal to using Application Messages.\r\n\r\nI really want to make sure that client never send unencrypted Application Messages. If you don't care about confidentiality you can always use the AAD for that.",
              "createdAt": "2020-08-15T11:56:20Z",
              "updatedAt": "2020-08-15T11:56:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0NjQyNjMz",
          "commit": {
            "abbreviatedOid": "6855c70"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-25T16:17:29Z",
          "updatedAt": "2020-08-25T16:17:38Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Actually, on re-read, seems clear from context.",
              "createdAt": "2020-08-25T16:17:29Z",
              "updatedAt": "2020-08-25T16:17:38Z"
            }
          ]
        }
      ]
    },
    {
      "number": 394,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY3OTg3Mjk4",
      "title": "Confirmation fix",
      "url": "https://github.com/mlswg/mls-protocol/pull/394",
      "state": "MERGED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": " This PR gets rid of the explicit HMAC reference and uses KDF.Extract instead (which internally uses HMAC). Also `confirmation` is renamed to `confirmation_tag`.",
      "createdAt": "2020-08-14T13:33:50Z",
      "updatedAt": "2020-10-05T15:44:31Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "4fc8afa1f7548ebf56bde9e2d45d0352c66fcf5b",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "raphaelrobert-hmac",
      "headRefOid": "71e5cb48115be760667704af12837119b706dff2",
      "closedAt": "2020-08-14T19:14:25Z",
      "mergedAt": "2020-08-14T19:14:25Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "1982f307a772d17c0470ee492fcedf4cfafac62d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3ODE4NzAx",
          "commit": {
            "abbreviatedOid": "71e5cb4"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I don't love the extra `_tag`, but I can live with it.",
          "createdAt": "2020-08-14T19:14:18Z",
          "updatedAt": "2020-08-14T19:14:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 395,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY5NTQ3NDgy",
      "title": "Remove requirement to verify the group creation process",
      "url": "https://github.com/mlswg/mls-protocol/pull/395",
      "state": "MERGED",
      "author": "ericcornelissen",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #390\r\n\r\nAs discussed on [the mailing list](https://mailarchive.ietf.org/arch/msg/mls/CbBEhH5A7OyoP6Mf5FFXgSU0r30/) this removes the paragraph in the Group Creation section specifying that joiners SHOULD verify group creation if it is detected. A recent change to group creation - namely a random initial `init_secret` - makes it impossible to verify group creation.\r\n",
      "createdAt": "2020-08-18T14:46:24Z",
      "updatedAt": "2020-08-18T15:18:35Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "1982f307a772d17c0470ee492fcedf4cfafac62d",
      "headRepository": "ericcornelissen/mls-protocol",
      "headRefName": "update-group-creation",
      "headRefOid": "76d115f8f3f4eee55feff5f09ee177820bf1d32f",
      "closedAt": "2020-08-18T14:50:20Z",
      "mergedAt": "2020-08-18T14:50:19Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "bb6b3fa6ae3869275a16be24250e9ac26ddfe02a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5NTMzNzc5",
          "commit": {
            "abbreviatedOid": "76d115f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-18T14:50:14Z",
          "updatedAt": "2020-08-18T14:50:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 396,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY5Njc4NjM2",
      "title": "Authenticate group membership in MLSPlaintext",
      "url": "https://github.com/mlswg/mls-protocol/pull/396",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "[Jo\u00ebl pointed out on the list](https://mailarchive.ietf.org/arch/msg/mls/LFz5nC4BnNTf7-OGIac5_QdlCRs/) that MLSPlaintext does not currently authenticate the sender's membership on the group, and as a result, some important attacks arise.  Discussion on the list indicated that adding a MAC with a key derived from the key schedule would provide this authentication.  This PR implements that suggestion.",
      "createdAt": "2020-08-18T18:57:31Z",
      "updatedAt": "2020-10-07T15:19:33Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "62c2b24f4c406eddd80e528ca07fb1dfca8b5505",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "member-pt",
      "headRefOid": "ac35b2336d1cc8e668d552c7fcd19073416fb051",
      "closedAt": "2020-10-07T15:18:36Z",
      "mergedAt": "2020-10-07T15:18:36Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "81c3949040724725d76568887851dba7930238f9"
      },
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Lgtm. Rebase and I'll properly approve.",
          "createdAt": "2020-09-10T17:12:14Z",
          "updatedAt": "2020-09-10T17:12:14Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Generally not a fan of rebasing, but here you go.",
          "createdAt": "2020-09-10T17:23:10Z",
          "updatedAt": "2020-09-10T17:23:10Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczODU2NTM0",
          "commit": {
            "abbreviatedOid": "02cb4f5"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-24T21:05:59Z",
          "updatedAt": "2020-08-24T21:15:10Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "You didn't fix this issue?",
              "createdAt": "2020-08-24T21:05:59Z",
              "updatedAt": "2020-10-07T15:16:32Z"
            },
            {
              "originalPosition": 30,
              "body": "\"contains the content\"",
              "createdAt": "2020-08-24T21:11:12Z",
              "updatedAt": "2020-10-07T15:16:32Z"
            },
            {
              "originalPosition": 32,
              "body": "\"the AEAD authenticates\"",
              "createdAt": "2020-08-24T21:12:04Z",
              "updatedAt": "2020-10-07T15:16:32Z"
            },
            {
              "originalPosition": 25,
              "body": "Using a KDF output for authentication feels wrong",
              "createdAt": "2020-08-24T21:15:05Z",
              "updatedAt": "2020-10-07T15:16:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0NTM5OTMw",
          "commit": {
            "abbreviatedOid": "02cb4f5"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-25T14:29:33Z",
          "updatedAt": "2020-08-25T14:29:33Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "I thought about it, and decided not to worry about it.  If you feel strongly, we can keep it.",
              "createdAt": "2020-08-25T14:29:33Z",
              "updatedAt": "2020-10-07T15:16:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0NTQxNzY3",
          "commit": {
            "abbreviatedOid": "02cb4f5"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-25T14:31:28Z",
          "updatedAt": "2020-08-25T14:31:28Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "We already do this elsewhere:\r\n```\r\nMLSPlaintext.confirmation_tag =\r\n    KDF.Extract(confirmation_key, GroupContext.confirmed_transcript_hash)\r\n```\r\n\r\nThis seems OK with HKDF, since Extract is just HMAC.  But I agree that we should confirm that this generalizes properly.",
              "createdAt": "2020-08-25T14:31:28Z",
              "updatedAt": "2020-10-07T15:16:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0NjYyOTQ1",
          "commit": {
            "abbreviatedOid": "02cb4f5"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-25T16:41:53Z",
          "updatedAt": "2020-08-25T16:41:54Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Agreements on the 2020-08-25 call:\r\n* Use an explicit MAC here instead of KDF.Extract\r\n* Use a separate key from the key schedule, different from the confirmation_key\r\n\r\n```\r\nepoch\r\n  |\r\n  +-- confirmation_key\r\n  |\r\n  +-- membership_key\r\n  |\r\n  +-- authentication_secret (todo)\r\n```",
              "createdAt": "2020-08-25T16:41:54Z",
              "updatedAt": "2020-10-07T15:16:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2MzUxOTQw",
          "commit": {
            "abbreviatedOid": "0275142"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-10T22:23:07Z",
          "updatedAt": "2020-09-10T22:23:07Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3MTg3Mjgw",
          "commit": {
            "abbreviatedOid": "0275142"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-12T00:49:09Z",
          "updatedAt": "2020-09-12T00:49:09Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "Actually this isn't quite right because the signature doesn't cover the membership token",
              "createdAt": "2020-09-12T00:49:09Z",
              "updatedAt": "2020-10-07T15:16:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3MTg4MDg1",
          "commit": {
            "abbreviatedOid": "0275142"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-12T00:56:14Z",
          "updatedAt": "2020-09-12T00:56:14Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Please make this its own sub-section titled \"Plaintext Authentication\" or similar, and add an explainer that `membership_tag` is only necessary when sending MLSPlaintext over-the-wire",
              "createdAt": "2020-09-12T00:56:14Z",
              "updatedAt": "2020-10-07T15:16:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzMzMwNDU5",
          "commit": {
            "abbreviatedOid": "0275142"
          },
          "author": "psyoptix",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-09-22T10:41:27Z",
          "updatedAt": "2020-09-22T11:34:31Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I think membership_tag field can be moved to the \"case proposal\"  section (line 1500). We only need it if the content type = proposal so including it in all MLSPlaintexts would waste bandwidth. Here's my reasoning:\r\n\r\n- content type = application should never be sent as MLSPlaintext and an MLSCiphertext already has a mechanism for authenticating that a sender knows the current key schedule\r\n\r\n- content type = commit already includes the confirmation_tag. That in turn is derived (in part) from the MLSPlaintext content of this packet and secrets in the application key schedule. So if I were to change any of that content then I'd have to derive a fresh confirmation_tag. That in turn means I need to know secrets from the key schedule which is what we wanted.",
              "createdAt": "2020-09-22T10:41:28Z",
              "updatedAt": "2020-10-07T15:16:32Z"
            }
          ]
        }
      ]
    },
    {
      "number": 397,
      "id": "MDExOlB1bGxSZXF1ZXN0NDcxMjQwODg2",
      "title": "Always use path secrets with KDF.Expand",
      "url": "https://github.com/mlswg/mls-protocol/pull/397",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@ericcornelissen pointed out on the mailing list that path secrets are currently used with both KDF.Expand and KEM.DeriveKeyPair.  This PR introduces an extra KDF.Expand call so that each key is used with exactly one algorithm.",
      "createdAt": "2020-08-20T21:04:23Z",
      "updatedAt": "2020-08-25T16:11:15Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "9f52307a138e303b967eca3df9df966ee581e9ef",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "re-expand",
      "headRefOid": "0e926c2b72209d71a12f7463a3620c5d8e967576",
      "closedAt": "2020-08-25T16:11:15Z",
      "mergedAt": "2020-08-25T16:11:15Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "7b9065d4cba1e8f1636a9e99354b761920ca5d99"
      },
      "comments": [
        {
          "author": "ericcornelissen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I believe it was @chrisbrzuska who that [pointed this out](https://mailarchive.ietf.org/arch/msg/mls/EQLdrkuVBeB5ExDcFx4EMbJcpOg/), not me. Also, shouldn't the `node_priv[n]` and `node_pub[n]` derivation be updated as well?\r\n\r\n```diff\r\n- node_priv[n], node_pub[n] = KEM.DeriveKeyPair(path_secret[n])\r\n+ node_priv[n], node_pub[n] = KEM.DeriveKeyPair(node_secret[n])\r\n```",
          "createdAt": "2020-08-21T06:11:41Z",
          "updatedAt": "2020-08-21T06:11:41Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, sorry!  I'll make that change.",
          "createdAt": "2020-08-25T14:27:56Z",
          "updatedAt": "2020-08-25T14:27:56Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Approved at the interim 2020-08-25.",
          "createdAt": "2020-08-25T16:11:10Z",
          "updatedAt": "2020-08-25T16:11:10Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 398,
      "id": "MDExOlB1bGxSZXF1ZXN0NDczNDIwODAw",
      "title": "Use full-size path secrets",
      "url": "https://github.com/mlswg/mls-protocol/pull/398",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #392 \r\n\r\n(Also, when I made the change from `KEM.Nsk` to `KDF.Nh`, I realized that the calls to `ExpandWithLabel` all had the same structure as `DeriveSecret`, so I changed to just call DeriveSecret directly.)",
      "createdAt": "2020-08-25T19:45:43Z",
      "updatedAt": "2020-09-03T00:30:22Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "28c6099e92f2b4767e247cd2016abd760a6620d0",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "full-size-secrets",
      "headRefOid": "5fbcb392b853ba30754c2dc6e1b57136b49f056f",
      "closedAt": "2020-09-03T00:30:22Z",
      "mergedAt": "2020-09-03T00:30:22Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "1d5e14d79435834bc5cab6c7aa9e2fcdd6afeabc"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0OTI1NTYy",
          "commit": {
            "abbreviatedOid": "5fbcb39"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-25T21:27:22Z",
          "updatedAt": "2020-08-25T21:27:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 399,
      "id": "MDExOlB1bGxSZXF1ZXN0NDc0MTE2MzYy",
      "title": "Use UpdatePath instead of Commit when describing tree updates",
      "url": "https://github.com/mlswg/mls-protocol/pull/399",
      "state": "MERGED",
      "author": "chelseakomlo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR updates two sections to reference generating and sending an `UpdatePath` message, as not all Commits transmit fresh key material (as discussed in #391). \r\n\r\nThis PR also includes light editorial edits for clarity and adds detail around the steps to perform an update.\r\n\r\nSection 7.7 `Update Paths` currently says that \"each MLS Commit message needs to transmit a KeyPackage leaf and node values along its direct path\", but section 10.2 `Commit` says that an UpdatePath is optional. I can update 7.7 as well, if 10.2 is correct.",
      "createdAt": "2020-08-26T19:44:57Z",
      "updatedAt": "2020-09-03T00:30:01Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "28c6099e92f2b4767e247cd2016abd760a6620d0",
      "headRepository": "chelseakomlo/mls-protocol",
      "headRefName": "commit-to-update-path-specification",
      "headRefOid": "8b3dd5d33fa2d689534035b6cbbde4799527f407",
      "closedAt": "2020-09-03T00:30:01Z",
      "mergedAt": "2020-09-03T00:30:01Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "d50188c7549d640d557b2b6524d412915eed48ae"
      },
      "comments": [
        {
          "author": "chelseakomlo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I went ahead and changed Section 7.7 to specify that MLS commits may optionally transmit updates for consistency with Section 10.2",
          "createdAt": "2020-09-01T03:09:31Z",
          "updatedAt": "2020-09-01T03:09:31Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc5NzM5MzQx",
          "commit": {
            "abbreviatedOid": "0882711"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-01T13:27:20Z",
          "updatedAt": "2020-09-01T13:29:15Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nA member of an MLS group advances the key schedule to provide forward secrecy\r\nand post-compromise security by providing the group with fresh key material to\r\nbe added into the group's shared secret. To do so, the member generates fresh key\r\n```\r\n\r\n... and change to present tense in the rest of the sentence",
              "createdAt": "2020-09-01T13:27:20Z",
              "updatedAt": "2020-09-03T00:27:48Z"
            },
            {
              "originalPosition": 54,
              "body": "```suggestion\r\nthis update to other members of the group in a Commit message, who\r\n```\r\n\r\n... or \"by including an UpdatePath in a Commit message\"",
              "createdAt": "2020-09-01T13:28:48Z",
              "updatedAt": "2020-09-03T00:27:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMzk5ODc0",
          "commit": {
            "abbreviatedOid": "94bc2ec"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-03T00:27:41Z",
          "updatedAt": "2020-09-03T00:27:41Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nA member of an MLS group advances the key schedule to provide forward secrecy\r\n```",
              "createdAt": "2020-09-03T00:27:41Z",
              "updatedAt": "2020-09-03T00:27:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxNDAwMDUy",
          "commit": {
            "abbreviatedOid": "8b3dd5d"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-03T00:28:20Z",
          "updatedAt": "2020-09-03T00:28:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 400,
      "id": "MDExOlB1bGxSZXF1ZXN0NDg1NTg1MjY3",
      "title": "Update security considerations.",
      "url": "https://github.com/mlswg/mls-protocol/pull/400",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bifurcation",
        "beurdouche"
      ],
      "labels": [],
      "body": "Security considerations has gotten a little outdated. Updated with new info",
      "createdAt": "2020-09-12T00:10:01Z",
      "updatedAt": "2020-10-07T15:21:25Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "eec3985d34dbb5a38fa45ec7edd3a0a1f2bd1fdc",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2020.9.0",
      "headRefOid": "53b3a5ec05e7402febfc5626deb27800db555183",
      "closedAt": "2020-10-07T15:21:25Z",
      "mergedAt": "2020-10-07T15:21:25Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "5f06f08d001054b74ce40b95bf4b2949eac81dc4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3NDkyNjAz",
          "commit": {
            "abbreviatedOid": "51850fb"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Some very necessary updates, but I think we should be precise with regard to FS/PCS and/or leave it to the architecture document to go into detail. Especially FS (or PCFS) is very tricky in MLS.",
          "createdAt": "2020-09-14T07:38:44Z",
          "updatedAt": "2020-09-14T08:00:20Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "Do you mean public here? Private keys are usually not used for encryption. \r\n\r\nA small nitpick: Also, in theory, the old key _can_ still be used. The update just signals that other members shouldn't use it.",
              "createdAt": "2020-09-14T07:38:44Z",
              "updatedAt": "2020-10-05T17:55:44Z"
            },
            {
              "originalPosition": 96,
              "body": "`message_tag` -> `confirmation_tag`?",
              "createdAt": "2020-09-14T07:40:07Z",
              "updatedAt": "2020-10-05T17:55:44Z"
            },
            {
              "originalPosition": 110,
              "body": "I think FS is a bit more nuanced, as you only get full FS if you update your own leaf key and delete the old private key afterwards. That means you only get proper FS between epochs where you update your own leaf.\r\n\r\nYou might get some weaker version of FS, because you still need the init secret of the past epoch, but, for example, a member that was just removed might still have that. I think FS for a given epoch should not depend on other epochs having been compromised in the past.\r\n\r\nYou also get some partial FS if someone else updates a key in your path, I think, but I'm not sure we should advertise this here.",
              "createdAt": "2020-09-14T07:46:44Z",
              "updatedAt": "2020-10-05T17:55:44Z"
            },
            {
              "originalPosition": 112,
              "body": "In line with my comment above, I don't think you can get full FS \"within\" an epoch, as the key material used to derive the application secrets/keys in the first place might still be around. The AS Tree and the sender ratchets allow you to still provide optimal FS while keeping old keys around to decrypt out-of-order messages, but only _after_ you've deleted the other key material.",
              "createdAt": "2020-09-14T07:55:46Z",
              "updatedAt": "2020-10-05T17:55:44Z"
            },
            {
              "originalPosition": 105,
              "body": "Maybe qualify that only the updating parties get PCS as opposed to the whole group? This is not explicit here, but just to be precise.",
              "createdAt": "2020-09-14T07:57:08Z",
              "updatedAt": "2020-10-05T17:55:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3OTY3NzEy",
          "commit": {
            "abbreviatedOid": "51850fb"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-14T16:54:26Z",
          "updatedAt": "2020-09-14T16:54:27Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "`membership_tag` actually, https://github.com/mlswg/mls-protocol/pull/396",
              "createdAt": "2020-09-14T16:54:26Z",
              "updatedAt": "2020-10-05T17:55:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3OTcyNjY5",
          "commit": {
            "abbreviatedOid": "51850fb"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-14T17:00:53Z",
          "updatedAt": "2020-09-14T17:00:53Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "I think it's fine to only discuss PCS wrt to an individual member. FS is talked about the same way, and it makes sense to me",
              "createdAt": "2020-09-14T17:00:53Z",
              "updatedAt": "2020-10-05T17:55:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3OTc5Nzgx",
          "commit": {
            "abbreviatedOid": "51850fb"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-14T17:10:42Z",
          "updatedAt": "2020-09-14T17:10:42Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "That key material must be deleted per the protocol, so I don't feel the need to re-specify that in its entirety here",
              "createdAt": "2020-09-14T17:10:42Z",
              "updatedAt": "2020-10-05T17:55:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3OTgxMjkz",
          "commit": {
            "abbreviatedOid": "51850fb"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-14T17:12:47Z",
          "updatedAt": "2020-09-14T17:12:47Z",
          "comments": [
            {
              "originalPosition": 110,
              "body": "I think what I said is correct in principle, I'm just cutting corners. There's a disclaimer at the top of this section saying that this is just meant to give a high-level understanding of why MLS is secure but a full discussion is out of scope",
              "createdAt": "2020-09-14T17:12:47Z",
              "updatedAt": "2020-10-05T17:55:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4MjQ1MzM3",
          "commit": {
            "abbreviatedOid": "a0f96a5"
          },
          "author": "tomtau",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-15T00:39:33Z",
          "updatedAt": "2020-09-15T00:39:34Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "```suggestion\r\nsubtree. This is called the *ratchet tree invariant* and it makes it possible to\r\n```",
              "createdAt": "2020-09-15T00:39:33Z",
              "updatedAt": "2020-10-05T17:55:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4Mzc5Mzg3",
          "commit": {
            "abbreviatedOid": "a0f96a5"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-15T06:59:42Z",
          "updatedAt": "2020-09-15T06:59:43Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "It's true that it must be deleted. It's just that deleting it doesn't give you FS within an epoch.",
              "createdAt": "2020-09-15T06:59:42Z",
              "updatedAt": "2020-10-05T17:55:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzOTk3NTkw",
          "commit": {
            "abbreviatedOid": "53b3a5e"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-07T15:21:18Z",
          "updatedAt": "2020-10-07T15:21:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 401,
      "id": "MDExOlB1bGxSZXF1ZXN0NDg2ODYyNDEz",
      "title": "Derive handshake keys from a secret tree as well.",
      "url": "https://github.com/mlswg/mls-protocol/pull/401",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-09-14T20:24:24Z",
      "updatedAt": "2020-10-06T13:55:10Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "bb303085f3748a7ba171f9f12fdbeef22d063283",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "brendan/2020.9.2",
      "headRefOid": "5a4bfcff4b5377438d02e2e4488c44ee5fc1c156",
      "closedAt": "2020-10-06T13:55:10Z",
      "mergedAt": "2020-10-06T13:55:10Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "62c2b24f4c406eddd80e528ca07fb1dfca8b5505"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3NDc4Mjc2",
          "commit": {
            "abbreviatedOid": "7483556"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-28T12:52:16Z",
          "updatedAt": "2020-09-28T12:52:37Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "I think that on the last interim call, we agreed to split off at the leaves of the tree, instead of at the root.  So you would have one secret tree per epoch, and the leaves would split into application and handshake hash chains.\r\n\r\n@Bren2010 if you could make that update, I think this is good to go.",
              "createdAt": "2020-09-28T12:52:16Z",
              "updatedAt": "2020-09-29T02:35:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4MDIzNDM2",
          "commit": {
            "abbreviatedOid": "5a4bfcf"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-29T02:35:46Z",
          "updatedAt": "2020-09-29T02:35:47Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Updated, thank you!",
              "createdAt": "2020-09-29T02:35:47Z",
              "updatedAt": "2020-09-29T02:35:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4NTA0MzEx",
          "commit": {
            "abbreviatedOid": "5a4bfcf"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-29T14:02:33Z",
          "updatedAt": "2020-09-29T14:02:33Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyOTg5NDAx",
          "commit": {
            "abbreviatedOid": "5a4bfcf"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-06T13:55:03Z",
          "updatedAt": "2020-10-06T13:55:03Z",
          "comments": []
        }
      ]
    },
    {
      "number": 402,
      "id": "MDExOlB1bGxSZXF1ZXN0NDg4MTE5OTAz",
      "title": "Allow for credentials supporting multiple signature schemes",
      "url": "https://github.com/mlswg/mls-protocol/pull/402",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The credentials we have defined at the moment only contain a single public key and no information regarding what signature scheme that keypair works with (even though the Spec actually says it should include the signature scheme as well).\r\n\r\nIt would be nice, however, to support potential CredentialTypes that, similar to KeyPackages, include multiple supported signature schemes, each accompanied by a corresponding public key.\r\n\r\nThe Key that should be used in any given group is then determined by the CipherSuite of the group (which includes a Signature Scheme). When choosing a KeyPackage of a new member, it has to be one that contains a Credential which supports that Signature Scheme.\r\n\r\nNote, that I'm not suggesting that this be the case in all Credentials, or even that we change the BasicCredential.\r\n\r\nI understand that it's possible to have multiple credentials per identity, but in some authentication settings it can be beneficial to have a 1-to-1 mapping between Credential and identity.",
      "createdAt": "2020-09-16T16:53:31Z",
      "updatedAt": "2020-10-08T14:55:17Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "ca187c70d7a5a5ac38f027526e78a72fa043bdf5",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "multiple_signature_schemes",
      "headRefOid": "d3cde81650ae10568b658d16acb91c1233b2825b",
      "closedAt": "2020-10-08T14:55:17Z",
      "mergedAt": "2020-10-08T14:55:17Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "04ac5c00c6586acf60fa02354f5f2e17dc844812"
      },
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "> It would be nice, however, to support potential CredentialTypes that, similar to KeyPackages, include multiple supported signature schemes, each accompanied by a corresponding public key.\r\n\r\nKeyPackages don't support multiple signature schemes?\r\n\r\n> I understand that it's possible to have multiple credentials per identity, but in some authentication settings it can be beneficial to have a 1-to-1 mapping between Credential and identity.\r\n\r\nIn what scenario is it beneficial?",
          "createdAt": "2020-09-17T20:43:41Z",
          "updatedAt": "2020-09-17T20:43:41Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> KeyPackages don't support multiple signature schemes?\r\n\r\nAh, right. I think that was the case in the past, but you're right, they don't.\r\n\r\n> In what scenario is it beneficial?\r\n\r\nOf course it's always possible to just bundle a bunch of certificates, each supporting a different signature scheme and then treat that as your \"Multi-Scheme Credential\" in the grand scheme of things. \r\n\r\nHowever, if you end up rotating them a lot, where you have to sign them and potentially store the whole chain for a longer period of time, being able to support multiple signature schemes in only one credential means less overhead.",
          "createdAt": "2020-09-18T06:09:32Z",
          "updatedAt": "2020-09-18T06:09:32Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "> However, if you end up rotating them a lot, where you have to sign them and potentially store the whole chain for a longer period of time, being able to support multiple signature schemes in only one credential means less overhead.\r\n\r\nCredentials are stored in each group's ratchet tree though, so you're keeping a bunch of unnecessary key material in the group's tree which everyone has to store",
          "createdAt": "2020-09-18T15:17:01Z",
          "updatedAt": "2020-09-18T15:17:01Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's fair. And it's not something you have to do if you don't want to. I'm just proposing for MLS to support that type of Credential in general.",
          "createdAt": "2020-09-18T15:21:11Z",
          "updatedAt": "2020-09-18T15:21:35Z"
        },
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "To support hybrid PQ/standard schemes at any point in the future, allowing for multiple schemes is reasonable (in addition to the above arguments for it). Most applications probably will not use the feature, especially to start with, but providing support for just the option is not going to cause any of the problems noted. ",
          "createdAt": "2020-09-21T15:48:15Z",
          "updatedAt": "2020-09-21T15:48:15Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "> To support hybrid PQ/standard schemes at any point in the future, allowing for multiple schemes is reasonable\r\n\r\nPQ schemes can be used by switching the entire group to a new ciphersuite using those schemes. Requiring everybody in the group to store a bunch of unused key material isn't reasonable",
          "createdAt": "2020-09-21T16:26:02Z",
          "updatedAt": "2020-09-21T16:26:02Z"
        },
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The statement was not about PQ, but hybrid PQ/standard schemes. Those require use to two signature schemes, for which both types of keying material are used.",
          "createdAt": "2020-09-21T16:27:57Z",
          "updatedAt": "2020-09-21T16:27:57Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Then you need a ciphersuite that specifies a hybrid scheme.",
          "createdAt": "2020-09-21T16:30:20Z",
          "updatedAt": "2020-09-21T16:30:20Z"
        },
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It would be ideal to have a ciphersuite specifying a single hybrid scheme, but even that does not imply use of a single credential, unfortunately. In fact, hybrid schemes may rely on two separate credentials, with the ciphersuite specifying the hybrid algorithm for combining them. Since the \"main\" method of building a solo hybrid credential is under patent, there is also additional motivation for applications to use two.",
          "createdAt": "2020-09-21T16:39:38Z",
          "updatedAt": "2020-09-21T16:39:38Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I concur with Brendan here.  To be consistent with our earlier decisions to (a) keep KeyPackages to one ciphersuite and (b) include the signature algorithm in the ciphersuite, we should keep credentials to one signature algorithm as well.\r\n\r\nPropose closing this PR without merging.",
          "createdAt": "2020-10-06T13:57:30Z",
          "updatedAt": "2020-10-06T13:57:30Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed at 2020-10-06 interim, TODO:\r\n* Re-add SignatureScheme enum, re-using the TLS signature schemes\r\n* Clarify that the main job of a Credential is to provide a public key for verifying messages\r\n    * How it provides the credential might be different per credential type\r\n    * e.g., in BasicCredential, it's provided directly, X509Credential, have to parse the leaf certificate",
          "createdAt": "2020-10-06T15:48:49Z",
          "updatedAt": "2020-10-06T15:48:49Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0ODU3NDMz",
          "commit": {
            "abbreviatedOid": "2b9a84e"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM with a couple nits.",
          "createdAt": "2020-10-08T14:41:07Z",
          "updatedAt": "2020-10-08T14:48:59Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "```suggestion\r\n```",
              "createdAt": "2020-10-08T14:41:07Z",
              "updatedAt": "2020-10-08T14:50:44Z"
            },
            {
              "originalPosition": 37,
              "body": "```suggestion\r\n    SignatureScheme signature_scheme;\r\n    opaque signature_key<0..2^16-1>;\r\n```",
              "createdAt": "2020-10-08T14:41:27Z",
              "updatedAt": "2020-10-08T14:50:44Z"
            }
          ]
        }
      ]
    },
    {
      "number": 403,
      "id": "MDExOlB1bGxSZXF1ZXN0NDg4MTIxMTg5",
      "title": "Rename identity key to signature key",
      "url": "https://github.com/mlswg/mls-protocol/pull/403",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The public key in a credential is introduced without a special name and the field in the BasicCredential is currently called public_key, which is not very expressive. A few paragraphs below, it is referenced as \"Identity Key\" or simply \"Identity\", which is a bit misleading, as Credentials are supposed to contain an additional \"identity\" which is not the key.\r\n\r\nI propose we clear up the terminology a bit here and refer to the public key contained in a Credential as \"Signature Key\". ",
      "createdAt": "2020-09-16T16:56:03Z",
      "updatedAt": "2020-09-22T16:21:17Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "bb303085f3748a7ba171f9f12fdbeef22d063283",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "identity_key_rename",
      "headRefOid": "ffa13ae56d54fff10d51c9829e14dbd7a1d7ca05",
      "closedAt": "2020-09-22T16:21:17Z",
      "mergedAt": "2020-09-22T16:21:17Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "ca187c70d7a5a5ac38f027526e78a72fa043bdf5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwOTcyMTU2",
          "commit": {
            "abbreviatedOid": "ffa13ae"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-17T20:39:46Z",
          "updatedAt": "2020-09-17T20:39:46Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNjM3MTQx",
          "commit": {
            "abbreviatedOid": "ffa13ae"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-22T16:21:08Z",
          "updatedAt": "2020-09-22T16:21:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 404,
      "id": "MDExOlB1bGxSZXF1ZXN0NDg4MTIyNjU5",
      "title": "Remove long term and explicitly prevent changing of identity",
      "url": "https://github.com/mlswg/mls-protocol/pull/404",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Rotating keys is important and in some cases, Signature Keys are not going to be very \"long-term\". Instead they're going to be rotated periodically.\r\n\r\nI thus propose we simply remove the assumption that Signature Keys are of a \"long-term\" nature (or otherwise \"long-lived\"). \r\n\r\nThe second change in this PR is that I added a few words indicating explicitly that the identity must not change when updating a KeyPackage.",
      "createdAt": "2020-09-16T16:58:59Z",
      "updatedAt": "2020-09-28T12:49:11Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "ca187c70d7a5a5ac38f027526e78a72fa043bdf5",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "remove_long_term",
      "headRefOid": "25a2cdc6c477efdfeec8180d7a966354b7456991",
      "closedAt": "2020-09-28T12:49:11Z",
      "mergedAt": "2020-09-28T12:49:10Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "43a514125cfbd4fa00710babc6270b39139f1ef4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwOTY4MzEw",
          "commit": {
            "abbreviatedOid": "96cd22d"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-17T20:34:40Z",
          "updatedAt": "2020-09-17T20:38:39Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "```suggestion\r\n* An identity key provider which allows clients to authenticate\r\n```",
              "createdAt": "2020-09-17T20:34:40Z",
              "updatedAt": "2020-09-23T06:11:59Z"
            },
            {
              "originalPosition": 34,
              "body": "This doesn't necessarily make sense because not all credentials have an `identity`",
              "createdAt": "2020-09-17T20:38:25Z",
              "updatedAt": "2020-09-23T06:11:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxNTU4NTM4",
          "commit": {
            "abbreviatedOid": "c6aae6f"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-18T15:15:28Z",
          "updatedAt": "2020-09-18T15:15:28Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNjYxNjAx",
          "commit": {
            "abbreviatedOid": "c6aae6f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-22T16:50:39Z",
          "updatedAt": "2020-09-22T16:50:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 406,
      "id": "MDExOlB1bGxSZXF1ZXN0NDkwNDczOTI0",
      "title": "External Commits",
      "url": "https://github.com/mlswg/mls-protocol/pull/406",
      "state": "MERGED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-09-21T18:13:54Z",
      "updatedAt": "2021-10-08T22:20:24Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "6c89e9fb40b15f225d0349b88426ac7ee2124212",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "external_commit",
      "headRefOid": "bc8445ceecb96c4742ca5dba0b792f9d974ab3cd",
      "closedAt": "2020-10-26T21:35:05Z",
      "mergedAt": "2020-10-26T21:35:05Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "5ea742c9770cd5f8b2964badba4e6e7b756fa13f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyMjkzMDAy",
          "commit": {
            "abbreviatedOid": "56c847f"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "- Please wrap lines at 80 characters\r\n- Please update to use an asymmetrically encrypted init secret (for *all* Commits, ideally)",
          "createdAt": "2020-10-05T17:59:54Z",
          "updatedAt": "2020-10-05T18:01:43Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n2. A member of the group or a new member broadcasts a Commit message that causes one or more\r\n```",
              "createdAt": "2020-10-05T17:59:54Z",
              "updatedAt": "2020-10-26T21:10:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMDIwOTUw",
          "commit": {
            "abbreviatedOid": "a31fdee"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-19T17:56:10Z",
          "updatedAt": "2020-10-19T17:56:11Z",
          "comments": [
            {
              "originalPosition": 180,
              "body": "```suggestion\r\n* An external commit MUST reference exactly one ExternalInit proposal, and the\r\n  sender of the proposal MUST be the same as the sender of the Commit. When\r\n  processing a Commit, both existing and new members MUST use the external init\r\n  secret as described in {{external-initialization}}.\r\n```",
              "createdAt": "2020-10-19T17:56:10Z",
              "updatedAt": "2020-10-26T21:10:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMDIzNzUy",
          "commit": {
            "abbreviatedOid": "7edb721"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-19T17:59:51Z",
          "updatedAt": "2020-10-19T17:59:51Z",
          "comments": [
            {
              "originalPosition": 181,
              "body": "```suggestion\r\n* An external commit MUST reference no more than one ExternalInit proposal, and the\r\n  ExternalInit proposal MUST be supplied by value, not by reference. When\r\n  processing a Commit, both existing and new members MUST use the external init\r\n  secret as described in {{external-initialization}}.\r\n```",
              "createdAt": "2020-10-19T17:59:51Z",
              "updatedAt": "2020-10-26T21:10:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMDU5OTg0",
          "commit": {
            "abbreviatedOid": "7edb721"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-19T18:45:30Z",
          "updatedAt": "2020-10-19T18:45:31Z",
          "comments": [
            {
              "originalPosition": 181,
              "body": "I think we said that `ExternalInit` can only be an inline proposal, but we didn't specify it. So I'd rather specify that requirement in the ExternalInit section.",
              "createdAt": "2020-10-19T18:45:30Z",
              "updatedAt": "2020-10-26T21:10:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMDY2NTI5",
          "commit": {
            "abbreviatedOid": "7edb721"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-19T18:54:16Z",
          "updatedAt": "2020-10-19T18:54:16Z",
          "comments": [
            {
              "originalPosition": 181,
              "body": "(I updated your suggestion)",
              "createdAt": "2020-10-19T18:54:16Z",
              "updatedAt": "2020-10-26T21:10:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMjA5MjQy",
          "commit": {
            "abbreviatedOid": "7edb721"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-19T22:38:45Z",
          "updatedAt": "2020-10-19T22:38:45Z",
          "comments": [
            {
              "originalPosition": 181,
              "body": "I was about to argue that I don't think it technically needs to be an inline proposal, but it does -- there's no way to send ExternalInit if you're not in the group.  (You can use `new-member` for Add, but not ExternalInit.)  So your tweak works for me.\r\n",
              "createdAt": "2020-10-19T22:38:45Z",
              "updatedAt": "2020-10-26T21:10:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMjEyMzM0",
          "commit": {
            "abbreviatedOid": "7edb721"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-19T22:46:11Z",
          "updatedAt": "2020-10-20T02:08:45Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Table is messed up again",
              "createdAt": "2020-10-19T22:46:11Z",
              "updatedAt": "2020-10-26T21:10:46Z"
            },
            {
              "originalPosition": 159,
              "body": "The ratchet tree is also needed for external joiners, so let's remove `tree_hash` and replace with `ratchet_tree`, and rename to something more descriptive like `GroupPublicState`",
              "createdAt": "2020-10-19T23:56:42Z",
              "updatedAt": "2020-10-26T21:10:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyNzY3NTYy",
          "commit": {
            "abbreviatedOid": "9cabc69"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-20T14:16:35Z",
          "updatedAt": "2020-10-20T14:16:36Z",
          "comments": [
            {
              "originalPosition": 159,
              "body": "We should keep the same flexibility here. It makes no sense that clients upload a large tree for every epoch, if the tree is maintained by the server.",
              "createdAt": "2020-10-20T14:16:36Z",
              "updatedAt": "2020-10-26T21:10:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyODE1Mzg0",
          "commit": {
            "abbreviatedOid": "0f24a78"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-20T14:58:40Z",
          "updatedAt": "2020-10-20T14:58:40Z",
          "comments": [
            {
              "originalPosition": 159,
              "body": "This structure is already maintained by the server. Users don't have to re-upload the whole thing, they can just tell the DS the new external_pub",
              "createdAt": "2020-10-20T14:58:40Z",
              "updatedAt": "2020-10-26T21:10:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyODQyMzI4",
          "commit": {
            "abbreviatedOid": "0f24a78"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-20T15:15:33Z",
          "updatedAt": "2020-10-20T15:15:33Z",
          "comments": [
            {
              "originalPosition": 159,
              "body": "In that scenario, in addition to the pub key they also send the hash, so that the server can make sure it has the right public tree.",
              "createdAt": "2020-10-20T15:15:33Z",
              "updatedAt": "2020-10-26T21:10:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMDM3NzM5",
          "commit": {
            "abbreviatedOid": "0f24a78"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-10-20T18:51:40Z",
          "updatedAt": "2020-10-20T18:53:18Z",
          "comments": [
            {
              "originalPosition": 144,
              "body": "```suggestion\r\n* interim transcript hash\r\n```",
              "createdAt": "2020-10-20T18:51:40Z",
              "updatedAt": "2020-10-26T21:10:46Z"
            },
            {
              "originalPosition": 156,
              "body": "```suggestion\r\n    opaque interim_transcript_hash<0..255>;\r\n```",
              "createdAt": "2020-10-20T18:52:58Z",
              "updatedAt": "2020-10-26T21:10:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzODIwNDMw",
          "commit": {
            "abbreviatedOid": "8773fc3"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-21T15:32:21Z",
          "updatedAt": "2020-10-21T15:32:21Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3MDYzMTI4",
          "commit": {
            "abbreviatedOid": "8773fc3"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-26T18:27:27Z",
          "updatedAt": "2020-10-26T18:29:13Z",
          "comments": [
            {
              "originalPosition": 159,
              "body": "```suggestion\r\n} PublicGroupState;\r\n```",
              "createdAt": "2020-10-26T18:27:27Z",
              "updatedAt": "2020-10-26T21:10:46Z"
            },
            {
              "originalPosition": 31,
              "body": "```suggestion\r\nThe public key `external_pub` can be published as part of the `PublicGroupState`\r\n```",
              "createdAt": "2020-10-26T18:27:55Z",
              "updatedAt": "2020-10-26T21:10:46Z"
            },
            {
              "originalPosition": 43,
              "body": "```suggestion\r\ninformation provided in the PublicGroupState and an external Commit to initialize\r\n```",
              "createdAt": "2020-10-26T18:28:09Z",
              "updatedAt": "2020-10-26T21:10:46Z"
            },
            {
              "originalPosition": 47,
              "body": "```suggestion\r\nkem_output, context = SetupBaseS(external_pub, PublicGroupState)\r\n```",
              "createdAt": "2020-10-26T18:28:16Z",
              "updatedAt": "2020-10-26T21:10:46Z"
            },
            {
              "originalPosition": 55,
              "body": "```suggestion\r\ncontext = SetupBaseR(kem_output, external_priv, PublicGroupState)\r\n```",
              "createdAt": "2020-10-26T18:28:30Z",
              "updatedAt": "2020-10-26T21:10:46Z"
            },
            {
              "originalPosition": 59,
              "body": "```suggestion\r\nIn both cases, the `info` input to HPKE is set to the PublicGroupState for the\r\n```",
              "createdAt": "2020-10-26T18:28:38Z",
              "updatedAt": "2020-10-26T21:10:46Z"
            },
            {
              "originalPosition": 148,
              "body": "```suggestion\r\nThis information is aggregated in a `PublicGroupState` object as follows:\r\n```",
              "createdAt": "2020-10-26T18:29:00Z",
              "updatedAt": "2020-10-26T21:10:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3MjI5NzA0",
          "commit": {
            "abbreviatedOid": "bc8445c"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-26T22:45:42Z",
          "updatedAt": "2020-10-26T22:50:52Z",
          "comments": [
            {
              "originalPosition": 109,
              "body": "proposal",
              "createdAt": "2020-10-26T22:45:42Z",
              "updatedAt": "2020-10-26T22:50:52Z"
            },
            {
              "originalPosition": 179,
              "body": "Shouldn't the signature come from the credential in the Add proposal? Not the Commit. That's how it is for everyone else",
              "createdAt": "2020-10-26T22:49:31Z",
              "updatedAt": "2020-10-26T22:50:52Z"
            },
            {
              "originalPosition": 180,
              "body": "exactly one ExternalInit",
              "createdAt": "2020-10-26T22:49:56Z",
              "updatedAt": "2020-10-26T22:50:52Z"
            }
          ]
        }
      ]
    },
    {
      "number": 407,
      "id": "MDExOlB1bGxSZXF1ZXN0NDkwOTMxMTcx",
      "title": "Fix typo",
      "url": "https://github.com/mlswg/mls-protocol/pull/407",
      "state": "MERGED",
      "author": "rex4539",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-09-22T13:13:15Z",
      "updatedAt": "2020-09-22T14:42:46Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "bb303085f3748a7ba171f9f12fdbeef22d063283",
      "headRepository": null,
      "headRefName": "typos",
      "headRefOid": "2dd0edf0cf8285bcdb8cdf5ad36d006893cca62b",
      "closedAt": "2020-09-22T14:42:46Z",
      "mergedAt": "2020-09-22T14:42:46Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "395ffd56d330ae32239f22e981209deae2937448"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTM3Njcw",
          "commit": {
            "abbreviatedOid": "2dd0edf"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-22T14:42:41Z",
          "updatedAt": "2020-09-22T14:42:41Z",
          "comments": []
        }
      ]
    },
    {
      "number": 408,
      "id": "MDExOlB1bGxSZXF1ZXN0NDkyMDQ4MDI0",
      "title": "Clarify X509Credential structure",
      "url": "https://github.com/mlswg/mls-protocol/pull/408",
      "state": "MERGED",
      "author": "suhasHere",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR adds clarification around X509 cert structure, the chain and its encoding X509.",
      "createdAt": "2020-09-23T21:22:59Z",
      "updatedAt": "2020-10-05T14:59:56Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "ca187c70d7a5a5ac38f027526e78a72fa043bdf5",
      "headRepository": "suhasHere/mls-protocol",
      "headRefName": "master",
      "headRefOid": "8dec7125dfce6dd14f6d9494ca3c911b6b3eb876",
      "closedAt": "2020-10-05T14:59:56Z",
      "mergedAt": "2020-10-05T14:59:56Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "eec3985d34dbb5a38fa45ec7edd3a0a1f2bd1fdc"
      },
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@Bren2010  thanks for the suggestions. updated PR to reflect the changes . pls let me know .. ",
          "createdAt": "2020-09-24T23:14:06Z",
          "updatedAt": "2020-09-24T23:14:06Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@Bren2010 i have pushed another commit .. can you please check. thanks",
          "createdAt": "2020-09-29T19:54:38Z",
          "updatedAt": "2020-09-29T19:54:38Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1NjMwMDkz",
          "commit": {
            "abbreviatedOid": "7df46d7"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks, @suhasHere.  I agree that separating out the certificates is a good idea.  While it's different from how TLS does things, I'm ready to declare TLS wrong here, since this saves mixing TLS-syntax and X.509 parsing logic.\r\n\r\nAs for the chain ordering, I really thought we had this in here already, so I'm glad to have it back.",
          "createdAt": "2020-09-24T14:25:01Z",
          "updatedAt": "2020-09-24T14:25:01Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1NzM0NTI2",
          "commit": {
            "abbreviatedOid": "7df46d7"
          },
          "author": "DemiMarie",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "Looks good.  In particular, requiring that certificates be ordered from leaf to root allows for arbitrarily long certificate chains to be verified in O(1) memory.",
          "createdAt": "2020-09-24T16:11:36Z",
          "updatedAt": "2020-09-24T16:11:36Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1ODQ0NjIy",
          "commit": {
            "abbreviatedOid": "7df46d7"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-09-24T18:26:30Z",
          "updatedAt": "2020-09-24T18:32:30Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "remove newline",
              "createdAt": "2020-09-24T18:26:30Z",
              "updatedAt": "2020-09-29T19:52:14Z"
            },
            {
              "originalPosition": 25,
              "body": "```suggestion\r\nFor X509Credential, each entry in the chain represents a single DER-encoded\r\n```",
              "createdAt": "2020-09-24T18:27:35Z",
              "updatedAt": "2020-09-29T19:52:14Z"
            },
            {
              "originalPosition": 26,
              "body": "```suggestion\r\nX509 certificate. The chain is ordered such that the first entry (chain[0])\r\n```",
              "createdAt": "2020-09-24T18:27:55Z",
              "updatedAt": "2020-09-29T19:52:14Z"
            },
            {
              "originalPosition": 27,
              "body": "```suggestion\r\nis the end-entity certificate and each subsequent certificate in the chain MUST be\r\n```",
              "createdAt": "2020-09-24T18:28:15Z",
              "updatedAt": "2020-09-29T19:52:14Z"
            },
            {
              "originalPosition": 28,
              "body": "```suggestion\r\nthe issuer of the previous certificate. The algorithm for the `public_key` in the\r\n```",
              "createdAt": "2020-09-24T18:28:43Z",
              "updatedAt": "2020-09-29T19:52:14Z"
            },
            {
              "originalPosition": 29,
              "body": "```suggestion\r\nend-entity certificate MUST match the relevant ciphersuite.\r\n```",
              "createdAt": "2020-09-24T18:31:09Z",
              "updatedAt": "2020-09-29T19:52:14Z"
            },
            {
              "originalPosition": 30,
              "body": "```suggestion\r\n\r\n```",
              "createdAt": "2020-09-24T18:31:49Z",
              "updatedAt": "2020-09-29T19:52:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2MDMwNjA0",
          "commit": {
            "abbreviatedOid": "9e6d452"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Many lines still have trailing spaces, please fix",
          "createdAt": "2020-09-25T00:16:07Z",
          "updatedAt": "2020-09-25T00:16:23Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "```suggestion\r\nciphersuite.\r\n```",
              "createdAt": "2020-09-25T00:16:07Z",
              "updatedAt": "2020-09-29T19:52:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2MTkwMzc3",
          "commit": {
            "abbreviatedOid": "9e6d452"
          },
          "author": "franziskuskiefer",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-25T07:54:34Z",
          "updatedAt": "2020-09-25T07:54:35Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "This wasn't clearly defined before so I appreciate making it clear.\r\nHowever, this `MUST` makes the mandatory ciphersuite pretty hard to use with x509 certificates. Public CAs don't issue ed25519 certificates.",
              "createdAt": "2020-09-25T07:54:34Z",
              "updatedAt": "2020-09-29T19:52:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2NDk1NjAw",
          "commit": {
            "abbreviatedOid": "9e6d452"
          },
          "author": "DemiMarie",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-25T14:51:41Z",
          "updatedAt": "2020-09-25T14:51:41Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Most uses for MLS don\u2019t involve public CAs.",
              "createdAt": "2020-09-25T14:51:41Z",
              "updatedAt": "2020-09-29T19:52:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2NjAwNzkw",
          "commit": {
            "abbreviatedOid": "9e6d452"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-25T17:09:40Z",
          "updatedAt": "2020-09-25T17:09:41Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "It seems a bit early to talk about \"most uses for MLS\", since AFAIK there aren't any yet :) \r\n\r\nBut I think the overall point still stands -- precedent in the Web PKI doesn't really matter here, because (again in most of the envisioned use cases), these certificates will be for user identifiers that aren't even allowed in Web PKI certificates.  I suppose it's possible to have a bunch of entities with domain names and Web PKI certificates doing MLS, but (a) that doesn't seem like a core use cases and (b) they can just use a ciphersuite that is lines up with those certs.",
              "createdAt": "2020-09-25T17:09:40Z",
              "updatedAt": "2020-09-29T19:52:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNTY5NjI5",
          "commit": {
            "abbreviatedOid": "8dec712"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-03T19:40:18Z",
          "updatedAt": "2020-10-03T19:40:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 412,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk5NjA2ODkx",
      "title": "Editorial changes to Content Auth section.",
      "url": "https://github.com/mlswg/mls-protocol/pull/412",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-10-08T01:52:41Z",
      "updatedAt": "2020-10-08T15:28:05Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "5f06f08d001054b74ce40b95bf4b2949eac81dc4",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2020.10.0",
      "headRefOid": "5e6a958d910c5353ae6b54bd28726092467b5c5d",
      "closedAt": "2020-10-08T15:28:05Z",
      "mergedAt": "2020-10-08T15:28:05Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "831ee5e61644246b3be5b4ef7d2c7d0eb93d6886"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0OTA1NjA1",
          "commit": {
            "abbreviatedOid": "5e6a958"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-08T15:27:59Z",
          "updatedAt": "2020-10-08T15:27:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 413,
      "id": "MDExOlB1bGxSZXF1ZXN0NTAwMDExMjEw",
      "title": "Remove references to undefined SignatureScheme enum.",
      "url": "https://github.com/mlswg/mls-protocol/pull/413",
      "state": "CLOSED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-10-08T15:31:58Z",
      "updatedAt": "2020-10-09T23:31:19Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "831ee5e61644246b3be5b4ef7d2c7d0eb93d6886",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2020.10.1",
      "headRefOid": "ea44b9e5b46990cea96e9bb64a72bf8a590cf581",
      "closedAt": "2020-10-09T23:31:19Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 414,
      "id": "MDExOlB1bGxSZXF1ZXN0NTAwMDE4OTg1",
      "title": "Allow proposals by value in Commit",
      "url": "https://github.com/mlswg/mls-protocol/pull/414",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This avoids extra signatures and message overhead in the case where the committer is originating proposals.",
      "createdAt": "2020-10-08T15:44:09Z",
      "updatedAt": "2020-10-20T20:53:19Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "831ee5e61644246b3be5b4ef7d2c7d0eb93d6886",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "inline-proposal",
      "headRefOid": "cbffafdd3552d172a1d86fb863fa312bad8a180e",
      "closedAt": "2020-10-20T20:53:19Z",
      "mergedAt": "2020-10-20T20:53:19Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "d17b8ac7fb7b7c7d228398700fec11f9aee9d5b2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0OTM3MDgz",
          "commit": {
            "abbreviatedOid": "e2b99f5"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-08T16:01:21Z",
          "updatedAt": "2020-10-08T16:03:01Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "```suggestion\r\n  select (ProposalID.type) {\r\n```",
              "createdAt": "2020-10-08T16:01:21Z",
              "updatedAt": "2020-10-20T19:12:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1MzI3OTY0",
          "commit": {
            "abbreviatedOid": "27775a2"
          },
          "author": "suhasHere",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-09T02:57:35Z",
          "updatedAt": "2020-10-09T02:57:35Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1MzM5Mjgy",
          "commit": {
            "abbreviatedOid": "27775a2"
          },
          "author": "suhasHere",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-09T03:39:35Z",
          "updatedAt": "2020-10-09T03:39:35Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "i wonder an informal note on when one variant is used vs another might be helpful for the implementors ..",
              "createdAt": "2020-10-09T03:39:35Z",
              "updatedAt": "2020-10-20T19:12:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1MzY4NDk5",
          "commit": {
            "abbreviatedOid": "27775a2"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-09T05:16:43Z",
          "updatedAt": "2020-10-09T05:16:43Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "It's strange that something called `ProposalID` contains an actual Proposal.",
              "createdAt": "2020-10-09T05:16:43Z",
              "updatedAt": "2020-10-20T19:12:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExODg5MjQz",
          "commit": {
            "abbreviatedOid": "1e357aa"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-19T15:29:11Z",
          "updatedAt": "2020-10-19T15:29:11Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": " > For proposals whose application depends on who sent them\r\n\r\nI think this is true for all proposals, because they might get rejected depending on the application's policy.",
              "createdAt": "2020-10-19T15:29:11Z",
              "updatedAt": "2020-10-20T19:12:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMTQyOTAw",
          "commit": {
            "abbreviatedOid": "1d13e25"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-10-19T20:41:56Z",
          "updatedAt": "2020-10-19T20:42:34Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "Need to update a few references of ProposalID to ProposalOrRefType;",
              "createdAt": "2020-10-19T20:41:56Z",
              "updatedAt": "2020-10-20T19:12:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMTc4MTgy",
          "commit": {
            "abbreviatedOid": "d8baecc"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-19T21:37:35Z",
          "updatedAt": "2020-10-19T21:37:35Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "Good point, thanks.",
              "createdAt": "2020-10-19T21:37:35Z",
              "updatedAt": "2020-10-20T19:12:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMjA2MjEy",
          "commit": {
            "abbreviatedOid": "d8baecc"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-10-19T22:32:02Z",
          "updatedAt": "2020-10-19T22:34:01Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nretrieved by hash (as a ProposalOrRef object) in a later Commit message.\r\n```",
              "createdAt": "2020-10-19T22:32:02Z",
              "updatedAt": "2020-10-20T19:12:58Z"
            },
            {
              "originalPosition": 37,
              "body": "```suggestion\r\n    case 1: Proposal proposal;\r\n```",
              "createdAt": "2020-10-19T22:33:26Z",
              "updatedAt": "2020-10-20T19:12:58Z"
            },
            {
              "originalPosition": 38,
              "body": "```suggestion\r\n    case 2: opaque hash<0..255>;\r\n```",
              "createdAt": "2020-10-19T22:33:35Z",
              "updatedAt": "2020-10-20T19:12:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMTIwMDky",
          "commit": {
            "abbreviatedOid": "cbffafd"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-20T20:47:16Z",
          "updatedAt": "2020-10-20T20:47:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 415,
      "id": "MDExOlB1bGxSZXF1ZXN0NTAwMTgxOTQz",
      "title": "make IANA reference for Signature Schemes more precise",
      "url": "https://github.com/mlswg/mls-protocol/pull/415",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Thanks @Bren2010 pointing out the imprecision. Is this what you were looking for?\r\n\r\nThanks @bifurcation for the pointer to the correct registry.\r\n\r\n",
      "createdAt": "2020-10-08T20:52:45Z",
      "updatedAt": "2020-10-19T14:11:43Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "831ee5e61644246b3be5b4ef7d2c7d0eb93d6886",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "signature_scheme_reference",
      "headRefOid": "2b4d5d4e846225cde0ee473c4ed4258d0ccc7e79",
      "closedAt": "2020-10-19T14:11:43Z",
      "mergedAt": "2020-10-19T14:11:43Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "b7baca2cc44a55f05be4823c6df78743b25607bb"
      },
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "This doesn't make sense because we don't actually use this registry. The signature scheme is defined by the ciphersuite, and the ciphersuite registry doesn't map to this unrelated registry",
          "createdAt": "2020-10-09T14:34:31Z",
          "updatedAt": "2020-10-09T14:34:31Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The `SignatureScheme` is not authoritative in the group context and will always correspond with the one in the group (as is required by the generic description of the functionalities that Credentials have to provide). The SignatureScheme is there for when the Credential is handled in a context where there is no surrounding group. For example, when it's handled by the AS.\r\n\r\nThere is a mapping from ciphersuit to SignatureScheme in Table 5, the entries of which correspond to the entries in the referenced registry. Is that what you meant?",
          "createdAt": "2020-10-09T14:53:45Z",
          "updatedAt": "2020-10-09T14:53:45Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2MDE2OTk2",
          "commit": {
            "abbreviatedOid": "41c36d3"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-10-09T22:24:49Z",
          "updatedAt": "2020-10-09T22:25:39Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n// See RFC 8446 and the IANA TLS SignatureScheme registry\r\n```",
              "createdAt": "2020-10-09T22:24:49Z",
              "updatedAt": "2020-10-12T07:06:02Z"
            },
            {
              "originalPosition": 5,
              "body": "Please also update a few lines above here, \"private keys\" -> \"private key\"",
              "createdAt": "2020-10-09T22:25:19Z",
              "updatedAt": "2020-10-12T07:06:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2NTc0NTIx",
          "commit": {
            "abbreviatedOid": "2b4d5d4"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-12T12:29:38Z",
          "updatedAt": "2020-10-12T12:29:38Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2NzI5OTMy",
          "commit": {
            "abbreviatedOid": "2b4d5d4"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-12T15:41:46Z",
          "updatedAt": "2020-10-12T15:41:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 416,
      "id": "MDExOlB1bGxSZXF1ZXN0NTAwODczOTYz",
      "title": "Inlclude the signature in the confirmation tag",
      "url": "https://github.com/mlswg/mls-protocol/pull/416",
      "state": "MERGED",
      "author": "dajost",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "As discussed in the mailing list, not having the signature contribute to the new epoch's key schedule leads to a one-off effect where parties stay in sync (with respect to keys) for one more epoch, before inevitably go out of sync. This pull request addresses this issue by including the signature in the confirmed transcript hash rather than the interim transcript hash. See the mailing list for a security consideration of this change.\r\n\r\nCredit: This pull request was primarily authored by Marta Mularczk; I'm just posting it here for administrative reasons. ",
      "createdAt": "2020-10-10T00:15:42Z",
      "updatedAt": "2020-10-14T14:21:22Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "831ee5e61644246b3be5b4ef7d2c7d0eb93d6886",
      "headRepository": "dajost/mls-protocol",
      "headRefName": "signature-in-conf-tag",
      "headRefOid": "fe3658eb8d8848ca0b7df4f8015934e41bc1238c",
      "closedAt": "2020-10-14T14:21:22Z",
      "mergedAt": "2020-10-14T14:21:22Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "fba989d1d17d9e4a543b0e30d53757f9fdb33b8b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2MDQ1MzU2",
          "commit": {
            "abbreviatedOid": "fe3658e"
          },
          "author": "dajost",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-10T00:22:33Z",
          "updatedAt": "2020-10-10T00:22:33Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "An alternative would be to use:\r\nselect (MLSPlaintext.content_type) {\r\n        case commit:\r\n          MAC confirmation_tag;\r\n}\r\nsparing the need for the definition below that the confirmation tag must be present iff it is a commit.",
              "createdAt": "2020-10-10T00:22:33Z",
              "updatedAt": "2020-10-10T00:22:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2NTgwODQw",
          "commit": {
            "abbreviatedOid": "fe3658e"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-12T12:38:23Z",
          "updatedAt": "2020-10-12T12:39:04Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "Not a bad idea; it would save an octet and give you \"syntactic\" enforcement.  I'm still inclined to go with the `optional<>` approach for two reasons:\r\n\r\n1. I'm not aware of TLS syntax implementatiosn that implement `select()` in any sort of automated fashion, so there would be manual logic here in any case.  It's just slightly easier to omit with `optional<>`.\r\n\r\n2. If we do `select` for `confirmation_tag`, we should probably also do it with `membership_tag` (selecting based on `sender_type`), which gets to be ugly.",
              "createdAt": "2020-10-12T12:38:23Z",
              "updatedAt": "2020-10-12T12:39:04Z"
            }
          ]
        }
      ]
    },
    {
      "number": 417,
      "id": "MDExOlB1bGxSZXF1ZXN0NTAxNDIyODgx",
      "title": "use `KDF.Nh` instead of `Hash.length`",
      "url": "https://github.com/mlswg/mls-protocol/pull/417",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-10-12T08:45:51Z",
      "updatedAt": "2020-10-12T13:40:47Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "831ee5e61644246b3be5b4ef7d2c7d0eb93d6886",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "hash_length",
      "headRefOid": "40f7c4bf6e32aabdbe29f202ec5ba2922603ea0f",
      "closedAt": "2020-10-12T12:28:40Z",
      "mergedAt": "2020-10-12T12:28:40Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "9d9804017016325d26460aff96b548670daf173d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2NTczNzYy",
          "commit": {
            "abbreviatedOid": "40f7c4b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "For the record: I asked @kkohbrok whether we could just update DeriveTreeSecret so that it always produces `KDF.Nh` octets.  But he pointed out that DeriveTreeSecret is also used to produce keys and nonces.  Might be something to clean up later.",
          "createdAt": "2020-10-12T12:28:33Z",
          "updatedAt": "2020-10-12T12:28:33Z",
          "comments": []
        }
      ]
    },
    {
      "number": 419,
      "id": "MDExOlB1bGxSZXF1ZXN0NTAxODgxMjA2",
      "title": "Authentication Secret",
      "url": "https://github.com/mlswg/mls-protocol/pull/419",
      "state": "MERGED",
      "author": "br-hale",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The authentication_secret was previously in a PR and agreed, but seems to have been removed from the key schedule (possibly during a merge). The discussion on its use is still present. This PR is just to add it back in to the key schedule.",
      "createdAt": "2020-10-12T23:43:21Z",
      "updatedAt": "2020-10-19T14:05:16Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "9d9804017016325d26460aff96b548670daf173d",
      "headRepository": "br-hale/mls-protocol",
      "headRefName": "exporters",
      "headRefOid": "6b94f4a6ae7c20524ed201322197a4dba784f76f",
      "closedAt": "2020-10-19T14:05:07Z",
      "mergedAt": "2020-10-19T14:05:07Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "4e515a7cbb68720ab8b2bb591c71abc4946c923f"
      },
      "comments": [
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "True! Haha. I was working on getting on the dashes to line up nicely as a box for presentation, and the repo view does not show spaces in the same way as a text file.\r\n\r\nCheers,\r\n\r\n. . .\r\nProf. Britta Hale, PhD\r\nCryptography\r\nNaval Postgraduate School  | Computer Science\r\nhttp://faculty.nps.edu/haleb/\r\n\r\n\r\nFrom: Brendan McMillion <notifications@github.com>\r\nReply-To: mlswg/mls-protocol <reply@reply.github.com>\r\nDate: Tuesday, October 13, 2020 at 12:34 PM\r\nTo: mlswg/mls-protocol <mls-protocol@noreply.github.com>\r\nCc: \"Hale, Britta (CIV)\" <britta.hale@nps.edu>, Author <author@noreply.github.com>\r\nSubject: Re: [mlswg/mls-protocol] Authentication Secret (#419)\r\n\r\n\r\n\r\n@Bren2010 approved this pull request.\r\n\r\nWhoever merges this better squash, no way Britta is getting credit for 16 commits on a 2 line change\r\n\r\n\u2014\r\nYou are receiving this because you authored the thread.\r\nReply to this email directly, view it on GitHub<https://github.com/mlswg/mls-protocol/pull/419#pullrequestreview-507764956>, or unsubscribe<https://github.com/notifications/unsubscribe-auth/ALEYMX6AHBN2BF3VKOAYBQDSKSTUNANCNFSM4SNVIIHA>.\r\n",
          "createdAt": "2020-10-13T19:37:56Z",
          "updatedAt": "2020-10-13T19:37:56Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@Bren2010 your wish is my command",
          "createdAt": "2020-10-19T14:05:16Z",
          "updatedAt": "2020-10-19T14:05:16Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3NzY0OTU2",
          "commit": {
            "abbreviatedOid": "6b94f4a"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Whoever merges this better squash, no way Britta is getting credit for 16 commits on a 2 line change",
          "createdAt": "2020-10-13T19:34:15Z",
          "updatedAt": "2020-10-13T19:34:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 420,
      "id": "MDExOlB1bGxSZXF1ZXN0NTAzMzMzODAx",
      "title": "make confirmation_tag a MAC just like membership_tag",
      "url": "https://github.com/mlswg/mls-protocol/pull/420",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-10-14T12:22:13Z",
      "updatedAt": "2020-10-14T15:19:55Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "9d9804017016325d26460aff96b548670daf173d",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "confirmation_tag",
      "headRefOid": "f6a5447b1342502dc37d5b40f086d9acd222598a",
      "closedAt": "2020-10-14T15:19:55Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah, I missed that this is apparently already underway in #416.",
          "createdAt": "2020-10-14T15:19:55Z",
          "updatedAt": "2020-10-14T15:19:55Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 421,
      "id": "MDExOlB1bGxSZXF1ZXN0NTAzNTAxMDU1",
      "title": "Review PSK PR.",
      "url": "https://github.com/mlswg/mls-protocol/pull/421",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-10-14T16:37:27Z",
      "updatedAt": "2020-10-21T18:58:55Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "68d2ea0e5fbf3fc914c03d44d0249f873064378c",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2020.10.3",
      "headRefOid": "deae9c08e1ad848ebc8635bac0f709d7e45d4863",
      "closedAt": "2020-10-21T18:58:55Z",
      "mergedAt": "2020-10-21T18:58:55Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "54519449b09423bd2a44702f5be9388ebdf8bc48"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5MzI5MzQ0",
          "commit": {
            "abbreviatedOid": "1ed7471"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T12:35:57Z",
          "updatedAt": "2020-10-19T06:29:54Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "A re-initialization could also be proposed by a non-member.",
              "createdAt": "2020-10-15T12:35:57Z",
              "updatedAt": "2020-10-21T18:23:51Z"
            },
            {
              "originalPosition": 66,
              "body": "We don't really have \"resumption\" psks. Also, I think that \"internal\" fits quite well here. Although to be fair, neither branching nor re-initialization PKSs are communicated via `PreSharedKey` proposals. However, it might still be useful to use with internal PSKs (e.g. to re-add member so the group that have lost group state for some reason).",
              "createdAt": "2020-10-15T12:38:54Z",
              "updatedAt": "2020-10-21T18:23:51Z"
            },
            {
              "originalPosition": 94,
              "body": "Why remove this section? If I understand correctly, it fits well into the subsections explaining the use of the various keys derived from the key schedule.",
              "createdAt": "2020-10-19T06:23:09Z",
              "updatedAt": "2020-10-21T18:23:51Z"
            },
            {
              "originalPosition": 147,
              "body": "Why remove this, but not the subsection below on Sub-group branching? I think both section serve the purpose of giving an overview over the respective process and should be left in.",
              "createdAt": "2020-10-19T06:25:18Z",
              "updatedAt": "2020-10-21T18:23:51Z"
            },
            {
              "originalPosition": 167,
              "body": "@bifurcation wanted to have this spelled out. I'm happy with the abbreviation.",
              "createdAt": "2020-10-19T06:26:12Z",
              "updatedAt": "2020-10-21T18:23:51Z"
            },
            {
              "originalPosition": 232,
              "body": "Why remove this? I think we should at least specify that only one re-init proposal can be included in a commit.",
              "createdAt": "2020-10-19T06:27:49Z",
              "updatedAt": "2020-10-21T18:23:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExODEzMDIy",
          "commit": {
            "abbreviatedOid": "1ed7471"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-19T14:18:16Z",
          "updatedAt": "2020-10-19T14:18:16Z",
          "comments": [
            {
              "originalPosition": 167,
              "body": "I can live with this.  ",
              "createdAt": "2020-10-19T14:18:16Z",
              "updatedAt": "2020-10-21T18:23:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExODMyOTM0",
          "commit": {
            "abbreviatedOid": "1ed7471"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-19T14:34:12Z",
          "updatedAt": "2020-10-19T14:34:12Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "```suggestion\r\nExternal PSKs are provided by the application, while recovery and re-init PSKs\r\n```",
              "createdAt": "2020-10-19T14:34:12Z",
              "updatedAt": "2020-10-21T18:23:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExODM0NTUy",
          "commit": {
            "abbreviatedOid": "1ed7471"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-19T14:35:40Z",
          "updatedAt": "2020-10-19T14:52:06Z",
          "comments": [
            {
              "originalPosition": 167,
              "body": "Or `pre_shared_key(4)`",
              "createdAt": "2020-10-19T14:35:40Z",
              "updatedAt": "2020-10-21T18:23:51Z"
            },
            {
              "originalPosition": 199,
              "body": "\"MUST be `external`\" is too strong here; this proposal is also how \"recovery\" PSKs are injected, right?  I think all you want to say is \"MUST NOT be `reinit`\"",
              "createdAt": "2020-10-19T14:38:59Z",
              "updatedAt": "2020-10-21T18:23:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExOTk2MjIz",
          "commit": {
            "abbreviatedOid": "1ed7471"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-10-19T17:31:27Z",
          "updatedAt": "2020-10-19T17:43:05Z",
          "comments": [
            {
              "originalPosition": 119,
              "body": "I think detecting attacks is a valid goal of the authentication keys, we shouldn't remove it.",
              "createdAt": "2020-10-19T17:31:27Z",
              "updatedAt": "2020-10-21T18:23:51Z"
            },
            {
              "originalPosition": 223,
              "body": "This sounds like existing proposals should be dropped, which should not be the case. I think it better to mandate an extra Commit that is issued when there are no more pending proposals.",
              "createdAt": "2020-10-19T17:35:51Z",
              "updatedAt": "2020-10-21T18:23:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMTI1MjEy",
          "commit": {
            "abbreviatedOid": "1ed7471"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-19T20:15:54Z",
          "updatedAt": "2020-10-19T20:39:15Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "I don't see a provision for that in the External Proposals section. I think there's more to think through in that case, which we can do in another PR",
              "createdAt": "2020-10-19T20:15:54Z",
              "updatedAt": "2020-10-21T18:23:51Z"
            },
            {
              "originalPosition": 94,
              "body": "You did not define how to do recovery. Define how to do recovery in another PR and you can add it back",
              "createdAt": "2020-10-19T20:26:59Z",
              "updatedAt": "2020-10-21T18:23:51Z"
            },
            {
              "originalPosition": 119,
              "body": "It's redundant. The second clause of the sentence just says \"detect attacks\" again in a different way.",
              "createdAt": "2020-10-19T20:28:20Z",
              "updatedAt": "2020-10-21T18:23:51Z"
            },
            {
              "originalPosition": 147,
              "body": "This is all (correctly) discussed in the section on ReInit proposals. Sub-group branching isn't discussed anywhere else",
              "createdAt": "2020-10-19T20:32:11Z",
              "updatedAt": "2020-10-21T18:23:51Z"
            },
            {
              "originalPosition": 199,
              "body": "There are no recovery PSKs, `external` is currently the only valid PSK type to put here",
              "createdAt": "2020-10-19T20:33:36Z",
              "updatedAt": "2020-10-21T18:23:51Z"
            },
            {
              "originalPosition": 223,
              "body": "Yes, the ReInit must be dropped or the rest of the proposals must be dropped. Applications can do what you say automatically: Commit outstanding proposals -> send new ReInit -> Commit ReInit. There's no reason to mandate it",
              "createdAt": "2020-10-19T20:36:44Z",
              "updatedAt": "2020-10-21T18:23:51Z"
            },
            {
              "originalPosition": 232,
              "body": "This discussion was moved to the ReInit proposal section\r\n\r\n> If a ReInit proposal is included in a Commit, it MUST be the only proposal\r\nreferenced by the Commit.",
              "createdAt": "2020-10-19T20:37:43Z",
              "updatedAt": "2020-10-21T18:23:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMzYyMTIw",
          "commit": {
            "abbreviatedOid": "2212df5"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-20T06:18:38Z",
          "updatedAt": "2020-10-20T06:18:38Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "In my mind, that was one of the main features of having a ReInit proposal. But you are right, we should have mentioned it in the External Proposals section. I'll make a PR.",
              "createdAt": "2020-10-20T06:18:38Z",
              "updatedAt": "2020-10-21T18:23:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMzYzMzk0",
          "commit": {
            "abbreviatedOid": "2212df5"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-20T06:21:19Z",
          "updatedAt": "2020-10-20T06:21:19Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "This Section is not about keys for recovery specifically, but about the `recovery_secret`, which is the basis for internal PSK derivation. I agree that the name is not ideal, though.",
              "createdAt": "2020-10-20T06:21:19Z",
              "updatedAt": "2020-10-21T18:23:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMzY1NzY3",
          "commit": {
            "abbreviatedOid": "2212df5"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-20T06:26:00Z",
          "updatedAt": "2020-10-20T06:26:00Z",
          "comments": [
            {
              "originalPosition": 199,
              "body": "You are right, that the of the currently specified PSK types, only `external` can be used in a psk proposal. However, implementors could define proprietary PSK types (e.g. for recovery) that they would want to use with a psk proposal as well. Not sure how we should write the spec so that option remains open.",
              "createdAt": "2020-10-20T06:26:00Z",
              "updatedAt": "2020-10-21T18:23:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMzY2NTU5",
          "commit": {
            "abbreviatedOid": "2212df5"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-20T06:27:32Z",
          "updatedAt": "2020-10-20T06:27:33Z",
          "comments": [
            {
              "originalPosition": 223,
              "body": "Why does it have to be the only proposal in the commit? I mean, updates are going to be useless, but Adds and Removes can still be processed.",
              "createdAt": "2020-10-20T06:27:33Z",
              "updatedAt": "2020-10-21T18:23:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyOTA0MTU1",
          "commit": {
            "abbreviatedOid": "2212df5"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-20T16:09:58Z",
          "updatedAt": "2020-10-20T16:09:58Z",
          "comments": [
            {
              "originalPosition": 223,
              "body": "Discussed at virtual interim 2020-10-20:\r\n* ReInit MUST be only proposal\r\n* If non-ReInit and ReInit received in same epoch, SHOULD prefer non-ReInit\r\n* Options for recovering from contention: committer re-originates or original proposer retries",
              "createdAt": "2020-10-20T16:09:58Z",
              "updatedAt": "2020-10-21T18:23:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0MDY4MjM4",
          "commit": {
            "abbreviatedOid": "deae9c0"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-21T18:37:12Z",
          "updatedAt": "2020-10-21T18:37:12Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0MDg2OTk2",
          "commit": {
            "abbreviatedOid": "deae9c0"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good! Thanks for cleaning up some of the bits we missed in the original PSK PR!",
          "createdAt": "2020-10-21T18:57:32Z",
          "updatedAt": "2020-10-21T18:57:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 422,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA0MTk3Nzk5",
      "title": "No redundant ciphertexts",
      "url": "https://github.com/mlswg/mls-protocol/pull/422",
      "state": "MERGED",
      "author": "dajost",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As briefly explained in the mailing list, commit messages currently contain encryptions for newly added group members that never even receive this commit message. This PR explicitely exlcudes them during the preparation of the UpdatePath.",
      "createdAt": "2020-10-15T15:38:35Z",
      "updatedAt": "2020-10-20T15:40:12Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "fba989d1d17d9e4a543b0e30d53757f9fdb33b8b",
      "headRepository": "dajost/mls-protocol",
      "headRefName": "no-redundant-ciphertexts",
      "headRefOid": "705fd58705612c1171d0a98681ca6f95faccd417",
      "closedAt": "2020-10-20T15:40:12Z",
      "mergedAt": "2020-10-20T15:40:12Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "5acf3e402023eb3cab5675d188844a22f1a78563"
      },
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I think this is a good point that wasn't really specified so far. The wording sounds a bit convoluted, maybe there is an easier way to describe it, like saying that the final resolution list should be filtered and all new leaf nodes should be removed from it.",
          "createdAt": "2020-10-19T16:25:02Z",
          "updatedAt": "2020-10-19T16:25:02Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyODE1MTQy",
          "commit": {
            "abbreviatedOid": "705fd58"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-20T14:58:27Z",
          "updatedAt": "2020-10-20T14:58:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 423,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA0OTM3NjUx",
      "title": "Remove encrypted sender data from ciphertext AAD.",
      "url": "https://github.com/mlswg/mls-protocol/pull/423",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-10-16T15:44:25Z",
      "updatedAt": "2020-10-20T15:37:54Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "fba989d1d17d9e4a543b0e30d53757f9fdb33b8b",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2020.10.4",
      "headRefOid": "c1b4bdef3e139d25428e1fe0e561b77802674400",
      "closedAt": "2020-10-20T15:37:54Z",
      "mergedAt": "2020-10-20T15:37:54Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "d32287e85298b3c26c054f08c00f50e2462bd3cf"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@psyoptix - We had talked about this circular dependency offline.  Does this resolution make sense to you?",
          "createdAt": "2020-10-19T18:00:47Z",
          "updatedAt": "2020-10-19T18:00:47Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@Bren2010 It seems like at this point, we can provide the same AAD to the content and sender data encryption.  Should we consolidate into something like this?\r\n\r\n```\r\nstruct {\r\n    opaque group_id<0..255>;\r\n    uint64 epoch;\r\n    ContentType content_type;\r\n    opaque authenticated_data<0..2^32-1>;\r\n} MLSCiphertextAAD;\r\n```\r\n\r\nOr is there some reason not to provide the `authenticated_data` to the sender data encryption.",
          "createdAt": "2020-10-19T18:04:09Z",
          "updatedAt": "2020-10-19T18:04:39Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Well, we don't know how large `authenticated_data` will be. If it's large, doing multiple passes over it when they aren't necessary would be undesirable",
          "createdAt": "2020-10-19T20:10:54Z",
          "updatedAt": "2020-10-19T20:10:54Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed on virtual interim 2020-10-20:\r\n* Sender data AAD is almost not necessary, since the key/nonce are derived from the ciphertext, which includes the whole header as AAD\r\n* But sampling introduces some ambiguity here, and this argument could be difficult for composability\r\n* So the original path of having minimal AAD in sender data encryption is the right compromise",
          "createdAt": "2020-10-20T15:37:23Z",
          "updatedAt": "2020-10-20T15:37:23Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 424,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA1MDAxMTM0",
      "title": "Update paragraph about handshake key schedule.",
      "url": "https://github.com/mlswg/mls-protocol/pull/424",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-10-16T17:36:57Z",
      "updatedAt": "2020-10-19T14:13:59Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "fba989d1d17d9e4a543b0e30d53757f9fdb33b8b",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2020.10.5",
      "headRefOid": "556d4b76a5f729834c2f3635adeac288da01a4cc",
      "closedAt": "2020-10-19T14:13:59Z",
      "mergedAt": "2020-10-19T14:13:59Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "f6ff3e41c702dabcaa0721878fec337669dd459d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExODA4NDQ5",
          "commit": {
            "abbreviatedOid": "556d4b7"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-19T14:13:54Z",
          "updatedAt": "2020-10-19T14:13:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 425,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA1NTE4MTI5",
      "title": "RLB edit",
      "url": "https://github.com/mlswg/mls-protocol/pull/425",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Some editorial rearrangement of the external commit PR",
      "createdAt": "2020-10-18T18:30:52Z",
      "updatedAt": "2020-10-19T14:23:10Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "external_commit",
      "baseRefOid": "65e1a24300e676ccec9b22f03cc4b2150826286b",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "external_commit_edit",
      "headRefOid": "b8b4cbf008ab42664c29ae9af70345cf25570a22",
      "closedAt": "2020-10-19T14:23:10Z",
      "mergedAt": "2020-10-19T14:23:10Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "db3b4ab23497c6091bb64bf855ac106764126b2f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExODE1NjI0",
          "commit": {
            "abbreviatedOid": "0b1ea1f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-19T14:20:40Z",
          "updatedAt": "2020-10-19T14:20:41Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "```suggestion\r\ncontext = SetupBaseR(kem_output, external_priv, GroupKeyPackage)\r\n```",
              "createdAt": "2020-10-19T14:20:40Z",
              "updatedAt": "2020-10-19T14:22:59Z"
            }
          ]
        }
      ]
    },
    {
      "number": 427,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA2ODk4NzAx",
      "title": "Groupcontext as context",
      "url": "https://github.com/mlswg/mls-protocol/pull/427",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This fixes issue #426 . This is originally the work of @chrisbrzuska . I'm only submitting it for administrative purposes.",
      "createdAt": "2020-10-20T15:22:03Z",
      "updatedAt": "2020-10-20T15:30:51Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "f6ff3e41c702dabcaa0721878fec337669dd459d",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "groupcontext_as_context",
      "headRefOid": "9f2f9a7981e0c9d32a57fd6081ed30574d678e8d",
      "closedAt": "2020-10-20T15:30:51Z",
      "mergedAt": "2020-10-20T15:30:51Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "0a932a191070d1e534bbcc351dbadaf9a075ae25"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyODY0Mzcx",
          "commit": {
            "abbreviatedOid": "9f2f9a7"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-20T15:30:25Z",
          "updatedAt": "2020-10-20T15:30:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 428,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA3MDI0Njc2",
      "title": "Remove interim transcript hash from GroupInfo",
      "url": "https://github.com/mlswg/mls-protocol/pull/428",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed on 2020-10-20, this field is not needed now that #416 moved the signature under the confirmation tag.",
      "createdAt": "2020-10-20T18:50:32Z",
      "updatedAt": "2020-10-21T18:06:42Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "5acf3e402023eb3cab5675d188844a22f1a78563",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "transcript-min",
      "headRefOid": "b61a44874c7b713eebad6e1a83d15e9efbcdcf98",
      "closedAt": "2020-10-21T18:06:42Z",
      "mergedAt": "2020-10-21T18:06:42Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "68d2ea0e5fbf3fc914c03d44d0249f873064378c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMTI3NzIx",
          "commit": {
            "abbreviatedOid": "b61a448"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-20T20:57:48Z",
          "updatedAt": "2020-10-20T20:57:48Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzODE1NDI2",
          "commit": {
            "abbreviatedOid": "b61a448"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-21T15:27:36Z",
          "updatedAt": "2020-10-21T15:27:36Z",
          "comments": []
        }
      ]
    },
    {
      "number": 429,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA3MDg3OTY0",
      "title": "Update changelog for draft-10",
      "url": "https://github.com/mlswg/mls-protocol/pull/429",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We have a changelog for the document by I-D release, but haven't been updating it as we go.  This PR updates the changelog based on merged PRs and the few we expect to close before releasing draft-10.\r\n\r\nMarking this as draft right now, until the other PRs have merged.",
      "createdAt": "2020-10-20T20:49:50Z",
      "updatedAt": "2020-10-23T18:32:36Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "5acf3e402023eb3cab5675d188844a22f1a78563",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "change-log-10",
      "headRefOid": "47f6c09bf7696849f27206aa9794e3261ce43d5f",
      "closedAt": "2020-10-23T18:32:36Z",
      "mergedAt": "2020-10-23T18:32:36Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "6c89e9fb40b15f225d0349b88426ac7ee2124212"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1OTA3NTk5",
          "commit": {
            "abbreviatedOid": "47f6c09"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-23T18:27:39Z",
          "updatedAt": "2020-10-23T18:27:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 430,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA3MzEzOTI2",
      "title": "Allow ReInit proposals from preconfigured senders",
      "url": "https://github.com/mlswg/mls-protocol/pull/430",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-10-21T07:16:33Z",
      "updatedAt": "2020-10-21T14:40:52Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "d17b8ac7fb7b7c7d228398700fec11f9aee9d5b2",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "external_proposals",
      "headRefOid": "49d8872a23dc525ec6880b187db977a7e5a6f95b",
      "closedAt": "2020-10-21T14:40:52Z",
      "mergedAt": "2020-10-21T14:40:52Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "10d58381d7a5d8a431c3d38fc1d917b74a8b3eb5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzNzY0Nzgx",
          "commit": {
            "abbreviatedOid": "49d8872"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-21T14:40:47Z",
          "updatedAt": "2020-10-21T14:40:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 431,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA4MDg0ODg4",
      "title": "Secret Tree: clarifications and typos",
      "url": "https://github.com/mlswg/mls-protocol/pull/431",
      "state": "MERGED",
      "author": "fxguenther",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Some clarifications and typos from my attempt to understand secret trees and the deletion schedule. Please verify that I'm correct in that `joiner_secret` and `member_secret` also need to be consumed.",
      "createdAt": "2020-10-22T07:37:44Z",
      "updatedAt": "2020-10-23T17:38:24Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "54519449b09423bd2a44702f5be9388ebdf8bc48",
      "headRepository": "fxguenther/mls-protocol",
      "headRefName": "secret-tree-clarifications",
      "headRefOid": "0a9562f5b9fdc9096984b31bf61a5b949390b760",
      "closedAt": "2020-10-23T17:38:24Z",
      "mergedAt": "2020-10-23T17:38:24Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "600d1d13ed7ddf7e13e21acfad76c31fdc933153"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I'll hold off on merging until we resolve the discussion above, though.",
          "createdAt": "2020-10-22T14:21:26Z",
          "updatedAt": "2020-10-22T14:21:26Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0NTEwMzA3",
          "commit": {
            "abbreviatedOid": "b466ab0"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-22T09:02:57Z",
          "updatedAt": "2020-10-22T10:12:09Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Wouldn't this be the leaf index instead? It shouldn't make an actual difference, but it seems more appropriate here since the sender ratchets are based on leaf indexes, not node indexes.",
              "createdAt": "2020-10-22T09:02:57Z",
              "updatedAt": "2020-10-22T14:31:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0NjA3MjU1",
          "commit": {
            "abbreviatedOid": "b466ab0"
          },
          "author": "fxguenther",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-22T11:03:54Z",
          "updatedAt": "2020-10-22T11:03:55Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "This might be me being confused, however I understood the \"index\" in this sentence (and the subsequent key derivation) referring to N, and N being the node index:\r\n\r\n> Nodes are also assigned an index according to their position in the array representation of the tree (described in Appendix A).\r\n\r\nGiven that we derive, e.g., `handshake_ratchet_secret_[N]_[0]` from `tree_node_[N]_secret`, and the latter being defined on these node indices, I assumed that, throughout, N should be a node index.\r\n\r\nIf you say the symmetric ratchets `..._ratchet_secret_...` are identified via _leaf indices_, then I'd agree this should all better refer to those leaf indices.",
              "createdAt": "2020-10-22T11:03:54Z",
              "updatedAt": "2020-10-22T14:31:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0NjM3NTM1",
          "commit": {
            "abbreviatedOid": "b466ab0"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-22T11:47:28Z",
          "updatedAt": "2020-10-22T11:47:29Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "This seems to be quite under-specified indeed. I was working under the assumption that members are always referenced by leaf indexes, because node indexes are only relevant for operation within the tree, not at the leaf level.\r\n@Bren2010 @bifurcation any opinion on which it is?",
              "createdAt": "2020-10-22T11:47:29Z",
              "updatedAt": "2020-10-22T14:31:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0Nzc0MzUz",
          "commit": {
            "abbreviatedOid": "b466ab0"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "With the formatting nits noted, this LGTM.  Thanks @fxguenther !",
          "createdAt": "2020-10-22T14:14:02Z",
          "updatedAt": "2020-10-22T14:18:05Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "The `N` in the indices in subscripts and context values is a **node** index, not a **leaf** index.  You need that to be the case so that you don't have collisions from switching between them.  If you want, we could clarify that the member at leaf `n` uses `ratchet_secret_[2*n]_[*]` (recall that the node index of the `n`-th leaf is `2*n`).",
              "createdAt": "2020-10-22T14:14:02Z",
              "updatedAt": "2020-10-22T14:31:51Z"
            },
            {
              "originalPosition": 55,
              "body": "```suggestion\r\n* the `commit_secret`, `joiner_secret`, `member_secret`, `epoch_secret`,\r\n  `encryption_secret` of that epoch n as well as the `init_secret` of the\r\n  previous epoch n-1,\r\n```",
              "createdAt": "2020-10-22T14:16:27Z",
              "updatedAt": "2020-10-22T14:31:51Z"
            },
            {
              "originalPosition": 60,
              "body": "```suggestion\r\n  node index N,\r\n```",
              "createdAt": "2020-10-22T14:16:56Z",
              "updatedAt": "2020-10-22T14:31:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0Nzg3Njk2",
          "commit": {
            "abbreviatedOid": "b466ab0"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-22T14:26:22Z",
          "updatedAt": "2020-10-22T14:26:22Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Is there a reason for keeping both node and leaf index around conceptually? Aren't we only ever indexing the tree array? If that is the case, why not just use node indices everywhere?",
              "createdAt": "2020-10-22T14:26:22Z",
              "updatedAt": "2020-10-22T14:31:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0NzkzMDE3",
          "commit": {
            "abbreviatedOid": "b466ab0"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-22T14:30:34Z",
          "updatedAt": "2020-10-22T14:30:34Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "The case that comes immediately to mind: In Remove, it's nice if the syntax constrains you so that you can only remove leaf nodes, not arbitrary nodes.",
              "createdAt": "2020-10-22T14:30:34Z",
              "updatedAt": "2020-10-22T14:31:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0Nzk0NTQ0",
          "commit": {
            "abbreviatedOid": "0a9562f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-22T14:31:53Z",
          "updatedAt": "2020-10-22T14:31:53Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "FWIW, in the implementation work I've done, it has been pretty simple to avoid confusion by having LeafIndex and NodeIndex types and using type conversion to implement the relevant math.",
              "createdAt": "2020-10-22T14:31:53Z",
              "updatedAt": "2020-10-22T14:31:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0ODA1MTMy",
          "commit": {
            "abbreviatedOid": "0a9562f"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-22T14:41:39Z",
          "updatedAt": "2020-10-22T14:41:40Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "It would be more robust if we exclusively used node indices. You still have to be mindful about where you have to convert and where you don't. We can add a simple check to Remove to make sure that only leaf nodes get removed. We have to check that the leaf is within the tree size anyway.\r\n\r\nYou told me before that we don't add stuff to the standard without good reason, so why now keep it in? :wink: \r\nBeside saving us the check at Remove: Is there really a reason to keep leaf indices around?",
              "createdAt": "2020-10-22T14:41:40Z",
              "updatedAt": "2020-10-22T14:41:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0ODgxODgy",
          "commit": {
            "abbreviatedOid": "0a9562f"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-22T15:55:47Z",
          "updatedAt": "2020-10-22T15:55:48Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "To second what Konrad said: We need to do checks for Removes anyway, since you can't remove an empty leaf node and the index has to be <= than the number of members, so this would just be one more test.\r\nI like the idea to have only one type of index for all operations that are covered by the spec. Naturally applications can then choose to reference members with a different scheme if they so wish (especially since empty leaf nodes are already an issue today if the member list uses leaf indexes).",
              "createdAt": "2020-10-22T15:55:47Z",
              "updatedAt": "2020-10-22T15:55:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0OTIzODM1",
          "commit": {
            "abbreviatedOid": "0a9562f"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-22T16:42:49Z",
          "updatedAt": "2020-10-22T16:42:49Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0OTMxNDQ1",
          "commit": {
            "abbreviatedOid": "0a9562f"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-22T16:52:04Z",
          "updatedAt": "2020-10-22T16:52:05Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "- Leaf index is used in Remove and in `unmerged_leaves`, and also in internal APIs that refer to specific members\r\n- Like Richard, I haven't had trouble keeping leaf and node ids separate in my implementation\r\n- I personally like keeping the two separate because it's more semantic",
              "createdAt": "2020-10-22T16:52:05Z",
              "updatedAt": "2020-10-22T16:52:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1NDAyNDI3",
          "commit": {
            "abbreviatedOid": "0a9562f"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-23T07:17:37Z",
          "updatedAt": "2020-10-23T07:17:37Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "I've created a separate issue (#432) for this, so this PR can go ahead. \r\n\r\nI'm aware that leaf indices are used, I just don't think they are necessary. As far as I can see, in every place they are used you can simply use a node index instead, with the exception of the Remove, where you have to add a simple check. Just because you _can_ implement it (and have already done so) doesn't mean it should be in the spec.",
              "createdAt": "2020-10-23T07:17:37Z",
              "updatedAt": "2020-10-23T07:35:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1ODc0MTk4",
          "commit": {
            "abbreviatedOid": "0a9562f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-23T17:38:16Z",
          "updatedAt": "2020-10-23T17:38:16Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Thanks for following that issue, @kkohbrok.  If that issue is off the table, I think this is clear to merge.",
              "createdAt": "2020-10-23T17:38:16Z",
              "updatedAt": "2020-10-23T17:38:16Z"
            }
          ]
        }
      ]
    },
    {
      "number": 433,
      "id": "MDExOlB1bGxSZXF1ZXN0NTEwMzI4MzAx",
      "title": "Sign the PublicGroupState",
      "url": "https://github.com/mlswg/mls-protocol/pull/433",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The unsigned PublicGroupState created by #406 leads to an attack on the new joiner.  The sender of a GroupPublicState can associate any HPKE it wants with the group, and thus learn the `init_secret` without being a member of the group.  (The UpdatePath and the resulting `commit_secret` partly defend against this attack, though they are subverted if the attacker has compromised any single key used in the Update Path.)\r\n\r\nTo guard against this attack, this PR adds a signature over the HPKE public key in the PublicGroupState.",
      "createdAt": "2020-10-26T21:49:57Z",
      "updatedAt": "2020-11-20T17:41:50Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "5ea742c9770cd5f8b2964badba4e6e7b756fa13f",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "sign-group-key",
      "headRefOid": "9b4a3c66b90ec3f889a6ef336695f625a1d0ad8d",
      "closedAt": "2020-11-20T17:41:50Z",
      "mergedAt": "2020-11-20T17:41:50Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "529a5ce7f4a08840593c6d5b23aab684d498ebb3"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "In light of the feedback on the mailing list from @claucece re: deniability, I have upgraded this PR to sign the whole PublicGroupState.",
          "createdAt": "2020-11-16T17:11:22Z",
          "updatedAt": "2020-11-16T17:11:22Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "Outstanding issue: One detail that is not fully covered by #436 is the strategy new joiners should apply to determine who the latest committer is and make sure that both the `PublicGroupState` and the last Commit are signed by the same member.",
          "createdAt": "2020-11-18T16:52:12Z",
          "updatedAt": "2020-11-18T16:52:12Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "The last node to send an UpdatePath is the last one to set the root.  So you can follow parent_hash to find which leaf it is.  But like I said on the IETF meeting call, I don't think we should actually require that PublicGroupState be signed by the last updater.  There are possible operational/sync issues if the PublicGroupState isn't fate-shared with the Commit, but that's a practical issue, not a security issue.\r\n\r\nAnd in any case, it's not a breaking change, so we can fix it post-draft-11 if we decide we need to.",
          "createdAt": "2020-11-20T17:41:14Z",
          "updatedAt": "2020-11-20T17:41:46Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3MjI3MzY4",
          "commit": {
            "abbreviatedOid": "e18376f"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-26T22:40:30Z",
          "updatedAt": "2020-10-26T22:40:30Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Is there a good reason not to sign everything? Would be simpler and more robust to do so",
              "createdAt": "2020-10-26T22:40:30Z",
              "updatedAt": "2020-11-16T17:10:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3MjU3NDM2",
          "commit": {
            "abbreviatedOid": "e18376f"
          },
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-26T23:56:21Z",
          "updatedAt": "2020-10-26T23:56:21Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "I second this question. Following discussion elsewhere on the mailing list, deniability may be pushed to the application level. If deniability was a factor for not signing everything, then it may not apply anymore.",
              "createdAt": "2020-10-26T23:56:21Z",
              "updatedAt": "2020-11-16T17:10:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4MDkzODgw",
          "commit": {
            "abbreviatedOid": "e18376f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-27T19:59:01Z",
          "updatedAt": "2020-10-27T19:59:01Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Personally, I agree with you both.  @raphaelrobert raised some concerns about deniability due to signing the tree, I think because he doesn't totally buy the \"punt\" argument I presented on the mailing list.  This was the minimum solution to address the obvious problem.",
              "createdAt": "2020-10-27T19:59:01Z",
              "updatedAt": "2020-11-16T17:10:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4MTQ5Mzc2",
          "commit": {
            "abbreviatedOid": "e18376f"
          },
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-27T21:04:07Z",
          "updatedAt": "2020-10-27T21:04:07Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "That makes sense. Even if we are still aiming for some form of deniability here, I think that we can sign a little more. For example, the cipher_suite, extensions, should be fine. The opaque_signature should be the main issue with respect to deniability. @raphaelrobert : do you have a strong opinion about not signing the transcript hash?",
              "createdAt": "2020-10-27T21:04:07Z",
              "updatedAt": "2020-11-16T17:10:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4NDExOTUw",
          "commit": {
            "abbreviatedOid": "e18376f"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-28T08:18:15Z",
          "updatedAt": "2020-10-28T08:18:16Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "The difference between signing the transcript hash and signing just the public key is that you need knowledge of the key schedule (and how it was derived) to tie the public key to the rest of the group state, while (if you don't encrypt handshake messages), the transcript hash can be computed by any party observing the traffic. At least as far as I understand the transcript hash computation. So in terms of deniability it certainly gets easier for the adversary.",
              "createdAt": "2020-10-28T08:18:15Z",
              "updatedAt": "2020-11-16T17:10:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxMTU4OTg1",
          "commit": {
            "abbreviatedOid": "e18376f"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-31T18:18:29Z",
          "updatedAt": "2020-10-31T18:18:29Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Sorry for the late reply. I think the PR really just covers the bare minimum of what needs to be signed. My initial proposal was to cover the whole PublicGroupState struct by the signature, except for the tree_hash field.\r\nJust like @br-hale I think including the transcript hash would make this more robust. That being said, @kkohbrok has a very valid point here: the transcript hash can be computed by a passive network observer without any knowledge of group secrets (this is where we are missing the derived epoch IDs we discarded). My intuition is that if we include the transcript hash we might as well include everything.\r\nAs @br-hale pointed out, if we go for the beefier version of the parent hash anyway, seeking any deniability guarantees at this level makes little sense.",
              "createdAt": "2020-10-31T18:18:29Z",
              "updatedAt": "2020-11-16T17:10:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMxNTU1NDA5",
          "commit": {
            "abbreviatedOid": "9b4a3c6"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-16T17:39:47Z",
          "updatedAt": "2020-11-16T17:39:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 434,
      "id": "MDExOlB1bGxSZXF1ZXN0NTEyNTY5NDA5",
      "title": "move definition of ParentNode earlier",
      "url": "https://github.com/mlswg/mls-protocol/pull/434",
      "state": "MERGED",
      "author": "uhoreg",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I think that this change will reduce the chance for [confusion](https://mailarchive.ietf.org/arch/msg/mls/UIWuwPC3ukryFUOANyH4cX4et3o/), as now the Parent Hash section will be self-contained, rather than needing to also look into the Tree Hashes section.  Also, it should hopefully be clearer that the `parent_hash` field in the `ParentNode` struct is calculated as the hash of another `ParentNode` struct, rather than the hash of a `ParentNodeHashInput`.\r\n\r\n(Though I don't see anywhere that says what to use as `parent_hash` when the `ParentNode` refers to the root.)",
      "createdAt": "2020-10-29T21:06:08Z",
      "updatedAt": "2020-11-16T16:36:53Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "5ea742c9770cd5f8b2964badba4e6e7b756fa13f",
      "headRepository": "uhoreg/mls-protocol",
      "headRefName": "hash_clarification",
      "headRefOid": "4d2367e672bd4f0119a70fac348198cd50cc03f8",
      "closedAt": "2020-11-16T16:36:53Z",
      "mergedAt": "2020-11-16T16:36:52Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "57bb2954265c57896249dcb2bbb04788205fb466"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxMDA1Mjcx",
          "commit": {
            "abbreviatedOid": "4d2367e"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-30T20:16:38Z",
          "updatedAt": "2020-10-30T20:16:38Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMxNDk2NzUy",
          "commit": {
            "abbreviatedOid": "4d2367e"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-16T16:36:42Z",
          "updatedAt": "2020-11-16T16:36:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 435,
      "id": "MDExOlB1bGxSZXF1ZXN0NTE0ODgxMzcy",
      "title": "Fix parent hash verification",
      "url": "https://github.com/mlswg/mls-protocol/pull/435",
      "state": "CLOSED",
      "author": "dajost",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This is a spin-off from the work on tree-signing by Jo\u00ebl, Marta, and me. Note that this obsoletes #434 as I couldn't figure out how to do dependent PRs in Github.\r\n\r\nConsider the following ratchet tree and assume that (1) the left subtree is fully occupied and (2) E last committed in the right subtree, i.e., the key at node [A..F] has been sampled by E. \r\n```\r\n       [root]   \r\n           \\\r\n            \\\r\n             \\\r\n            [A..F]\r\n            /    \\\r\n           /      \\\r\n          /        \\\r\n         /          \\\r\n     [A..D]        [EF]\r\n      /  \\          /\\\r\n     /    \\        /  \\\r\n    /      \\      /    \\\r\n  [AB]    [CD]   [E]   [F]\r\n   /\\      /\\\r\n  /  \\    /  \\\r\n[A] [B] [C] [D]\r\n```\r\nNow say party Z from the left subtree committs a proposal that adds party G. According to my understanding the tree will look as follows, where I use the syntax [A..F,G] to denote that parties A to F know the secret key and G is tracked as an unmerged leaf. \r\n```\r\n       [root]   \r\n           \\\r\n            \\\r\n             \\\r\n           [A..F,G]\r\n            /    \\\r\n           /      \\\r\n          /        \\\r\n         /          \\\r\n     [A..D]        [X]\r\n      /  \\          /\\\r\n     /    \\        /  \\\r\n    /      \\      /    \\\r\n  [AB]    [CD]   [EF]  [G]\r\n   /\\      /\\     /\\\r\n  /  \\    /  \\   /  \\\r\n[A] [B] [C] [D] [E] [F]\r\n```\r\n\r\nNow observe the following two issues:\r\n* According to the draft, G now has to verify that either of [A..F,G]'s children store a correct parent hash. However, its parent-hash is no longer stored in its direct child [X], an additional blank node inserted for the add, but still in [EF] instead. This needs to be accounted for in the verification.\r\n* Orignally, the ``parent_hash`` includes ``unmerged_leaves``. Hence, for [A..F,G] the value stored in [EF] (and recursively signed by E) will no longer match the recomputed value. Since partent hashes are only updated along the committer's path which at this point has no unmerged leaves, however, there is no point in including unmerged leaves. ",
      "createdAt": "2020-11-03T17:16:15Z",
      "updatedAt": "2020-12-11T21:22:41Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "5ea742c9770cd5f8b2964badba4e6e7b756fa13f",
      "headRepository": "dajost/mls-protocol",
      "headRefName": "parent-hash-verification",
      "headRefOid": "ce81177b49fcfbf555189a3c56eb28990e7c6b40",
      "closedAt": "2020-12-11T21:22:41Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "dajost",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I am not sure I can follow your concern. Just to clarify, this is so far just about fixing the current scheme, preserving the deniability properties. The bigger change of reversing the order of the tree hashes in the parent hashes will be a different PR.",
          "createdAt": "2020-11-03T21:07:36Z",
          "updatedAt": "2020-11-03T21:07:36Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, if this is still about the old scheme, I would say we just wait for the change to the new one.",
          "createdAt": "2020-11-04T16:15:18Z",
          "updatedAt": "2020-11-04T16:15:18Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I think I see where the misunderstanding is here.  The tree you present is only constructed transiently, for use in generating the `UpdatePath` for the commit.  The tree that is actually sent to G has the `UpdatePath` merged:\r\n\r\n```\r\n       [root]   \r\n           \\\r\n            \\\r\n             \\\r\n             [X3]               X3.ph = 0\r\n            /    \\\r\n           /      \\\r\n          /        \\\r\n         /          \\\r\n      [X2]         [__]         X2.ph = H(X3.pk, X3.ph, [EF.pk, G.pk])\r\n      /  \\          /\\\r\n     /    \\        /  \\\r\n    /      \\      /    \\\r\n  [AB]    [X1]   [EF]  [G]      X1.ph = H(X2.pk, X2.ph, [AB.pk])\r\n   /\\      /\\     /\\\r\n  /  \\    /  \\   /  \\\r\n[A] [B] [X] [D] [E] [F]         X.ph  = H(X1.pk, X1.ph, [D.pk])\r\n```\r\n\r\nHere `X` is the sender of the update, and the ParentHashes according to the scheme in #436 are shown.  In this tree, the updated nodes have valid parent hash values, and the new blank node doesn't need one. ",
          "createdAt": "2020-11-20T20:03:18Z",
          "updatedAt": "2020-11-20T20:03:18Z"
        },
        {
          "author": "MartaMularczyk",
          "authorAssociation": "NONE",
          "body": "> I think I see where the misunderstanding is here. The tree you present is only constructed transiently, for use in generating the `UpdatePath` for the commit. The tree that is actually sent to G has the `UpdatePath` merged:\r\n> \r\n> ```\r\n>        [root]   \r\n>            \\\r\n>             \\\r\n>              \\\r\n>              [X3]               X3.ph = 0\r\n>             /    \\\r\n>            /      \\\r\n>           /        \\\r\n>          /          \\\r\n>       [X2]         [__]         X2.ph = H(X3.pk, X3.ph, [EF.pk, G.pk])\r\n>       /  \\          /\\\r\n>      /    \\        /  \\\r\n>     /      \\      /    \\\r\n>   [AB]    [X1]   [EF]  [G]      X1.ph = H(X2.pk, X2.ph, [AB.pk])\r\n>    /\\      /\\     /\\\r\n>   /  \\    /  \\   /  \\\r\n> [A] [B] [X] [D] [E] [F]         X.ph  = H(X1.pk, X1.ph, [D.pk])\r\n> ```\r\n> \r\n> Here `X` is the sender of the update, and the ParentHashes according to the scheme in #436 are shown. In this tree, the updated nodes have valid parent hash values, and the new blank node doesn't need one.\r\n\r\nI think the misunderstanding may be in who's the committer: this picture shows only the right half of the tree and the committer X is in the left part (left child of [root]). So after X commits, [A..F,G].ph doesn't change and it's still computed using [EF]'s values.",
          "createdAt": "2020-11-25T16:53:02Z",
          "updatedAt": "2020-11-25T16:53:02Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, thanks for the clarification, @MartaMularczyk.  So the observation here is that committing Add proposals can result in blank nodes being inserted beneath a parent node, as the tree grows.  That means that you can't just go down one level, you have to recurse to the left until you find a non-blank node (equivalently, take the first node in the resolution of the right child).\r\n\r\nIt seems like the right parent hash validation is then to do the following check for each non-blank `parent_node`:\r\n\r\n```\r\nH = Hash(parent_node)\r\nL = left_child(parent_node)\r\nR = left_child^k(right_child(parent_node) // k >= 0 smallest value such that R != blank\r\nreturn H == L.parent_hash || H == R.parent_hash;\r\n```\r\n\r\nThe theory being that extending the tree always adds nodes to the right, so that when these situations arise, you just need to recurse to the left.  \r\n",
          "createdAt": "2020-12-11T20:56:35Z",
          "updatedAt": "2020-12-11T20:56:35Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Given that this PR will need to be rebased on #436 anyway, I'm closing this one and proposing that we just update #436 to do the right thing.  I have suggested text on that PR.",
          "createdAt": "2020-12-11T21:22:41Z",
          "updatedAt": "2020-12-11T21:22:41Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyODUzNDcx",
          "commit": {
            "abbreviatedOid": "ce81177"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I'm not sure this gets where you want.\r\n\r\nparent_hash = H(subtree headed by my parent, excluding parent_hash related stuff)",
          "createdAt": "2020-11-03T20:32:48Z",
          "updatedAt": "2020-11-03T20:32:48Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1NzMxOTE5",
          "commit": {
            "abbreviatedOid": "ce81177"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Given the issues noted, I am inclined to close this with no action.",
          "createdAt": "2020-11-20T19:50:28Z",
          "updatedAt": "2020-11-20T19:52:27Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "This seems incorrect to me.  The  value of `parent_hash` is set from the direct parent, so it's useless to look at the blank node's children.  You don't have enough information to verify that `parent_hash`; you're missing what was in the blank node.  You also can't reset the `parent_hash` to \"skip over\" the blank node when you set it to blank, because that would invalidate `parent_hash` values below it in the tree and ultimately, the signature on the leaf.",
              "createdAt": "2020-11-20T19:50:29Z",
              "updatedAt": "2020-11-20T19:52:27Z"
            },
            {
              "originalPosition": 23,
              "body": "I prefer not to group things like this, and just assemble the hash input as necessary.  Especially since #436 is going to change `ParentHashInput` to diverge further from `ParentNode`.  Implementations are of course free to store things this way.",
              "createdAt": "2020-11-20T19:51:25Z",
              "updatedAt": "2020-11-20T19:52:27Z"
            }
          ]
        }
      ]
    },
    {
      "number": 436,
      "id": "MDExOlB1bGxSZXF1ZXN0NTIwMTUxNDIx",
      "title": "Strong tree signing",
      "url": "https://github.com/mlswg/mls-protocol/pull/436",
      "state": "MERGED",
      "author": "psyoptix",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This pull request makes editorial changes to the definition of Tree Hash  to hopefully make it easier to understand.\r\n\r\nIt also redefines Parent Hash to include the HPKE public keys to which a nodes secret key was sent. This binds a key package introduced to the ratchet tree in a commit not just to the HPKE keys on the commits direct path but also (indirectly) to the other members that were sent each of the new (secret) keys. \r\n\r\nIn particular, this prevents the attacks from the mailinglist that allowed an attacker to create artificial ratchet trees where the tree invariant was violated (which in turn lead to removes failing). But parent_hash only includes the HPKE pubkeys in the resolution so at least some amount of deniability might be preserved.",
      "createdAt": "2020-11-12T20:52:09Z",
      "updatedAt": "2020-12-21T21:48:25Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "5cedaf1ec905e046b86f057499f01a0259829278",
      "headRepository": "dajost/mls-protocol",
      "headRefName": "strong-tree-signing",
      "headRefOid": "f1dfd594d18db3b7d705800460467e0a11ad8d25",
      "closedAt": "2020-12-21T21:48:25Z",
      "mergedAt": "2020-12-21T21:48:25Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "10df4266e4733134decdcc6cfa80f2d480674261"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMwODU0MzU1",
          "commit": {
            "abbreviatedOid": "8d4e183"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Please also remove trailing spaces from many lines",
          "createdAt": "2020-11-16T00:27:02Z",
          "updatedAt": "2020-11-16T00:46:15Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "```suggestion\r\nconstructing an artificial ratchet tree with a node whose HPKE secret key is\r\n```",
              "createdAt": "2020-11-16T00:27:03Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            },
            {
              "originalPosition": 30,
              "body": "```suggestion\r\ncorresponding subtree. (Indeed, such a ratchet tree would violate the tree\r\n```",
              "createdAt": "2020-11-16T00:27:25Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            },
            {
              "originalPosition": 46,
              "body": "```suggestion\r\na group new members MUST verify that if a leaf contains a `parent_hash` value, then\r\n```",
              "createdAt": "2020-11-16T00:28:04Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            },
            {
              "originalPosition": 57,
              "body": "```suggestion\r\nThe `parent_hash` at the root is a zero-length bit string. To compute the parent hash at a non-root\r\n```",
              "createdAt": "2020-11-16T00:28:30Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            },
            {
              "originalPosition": 58,
              "body": "```suggestion\r\nnode V with parent P and sibling S, the `ParentHashInput` struct is used. It\r\n```",
              "createdAt": "2020-11-16T00:29:11Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            },
            {
              "originalPosition": 59,
              "body": "```suggestion\r\nconsists of three fields: The first contains the HPKE public key of P. The second\r\n```",
              "createdAt": "2020-11-16T00:29:22Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            },
            {
              "originalPosition": 60,
              "body": "```suggestion\r\ncontains the `parent_hash` at P. The third contains the list of HPKE public\r\n```",
              "createdAt": "2020-11-16T00:29:48Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            },
            {
              "originalPosition": 61,
              "body": "```suggestion\r\nkeys to which the HPKE secret key of P was sent to. That is, it consists of\r\n```",
              "createdAt": "2020-11-16T00:31:42Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            },
            {
              "originalPosition": 62,
              "body": "```suggestion\r\nthe array of `HPKEPublicKey` values of the nodes in the resolution of U, with\r\n```",
              "createdAt": "2020-11-16T00:31:56Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            },
            {
              "originalPosition": 63,
              "body": "```suggestion\r\nthe`unmerged_leaves` of P omitted. \r\n```",
              "createdAt": "2020-11-16T00:32:24Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            },
            {
              "originalPosition": 111,
              "body": "This struct got deleted but is still referenced in several places",
              "createdAt": "2020-11-16T00:46:01Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMxNTAyNjIz",
          "commit": {
            "abbreviatedOid": "8d4e183"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-16T16:42:53Z",
          "updatedAt": "2020-11-16T17:05:47Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "I think this can be stronger -- the extension MUST be present **if and only if** the KeyPackage is in the UpdatePath.  Just to be clear that for other KeyPackages (e.g., pre-published ones, ones sent in Update proposals), this extension MUST NOT be included.\r\n\r\n```suggestion\r\nThis extension MUST be present in the `leaf_key_package` field of an\r\n```",
              "createdAt": "2020-11-16T16:42:53Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            },
            {
              "originalPosition": 57,
              "body": "Nit: Octet string, not bit string.\r\n\r\nIs there a reason to use the zero-length octet string instead of the `Nh`-long all-zero `0` string?  We use `0` for missing values elsewhere, e.g., PSK secret.  And it seems like it gives you an explicit \"null termination\" here.",
              "createdAt": "2020-11-16T16:44:48Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            },
            {
              "originalPosition": 78,
              "body": "This scheme seems a little cumbersome, in that the `original_sibling_resolution` vector could get quite large.  I wonder if we should just define another layer of hashing underneath this that summarizes the HPKE public keys in the tree.  So something like the following picture:\r\n\r\n```\r\n/ / / /  TreeHash\r\n\\ \\ \\ \\  ParentHash\r\n/ / / /  ResolutionHash\r\n```\r\n\r\nWhere `/` indicates parents' hashes covering children, and `\\` indicates the reverse.",
              "createdAt": "2020-11-16T16:55:10Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            },
            {
              "originalPosition": 78,
              "body": "It might be worth saying a something here on the validation strategy.  Before, we had the property that tree is valid if for every non-blank parent node, its ParentHashInput matches exactly one of its children's parent_hash fields.  It seems like that probably still applies here, but wanted to check.",
              "createdAt": "2020-11-16T16:58:37Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            },
            {
              "originalPosition": 78,
              "body": "It seems a little odd that we have a pointer \"across\" the tree here, from a node to its sibling.  Would it work to move the resolution to the parent?  So the ParentHashInput would say, \"this public key under this parent, with the private key encrypted to this resolution\".  Together with the above suggestions, you would end up with something like:\r\n\r\n```\r\nstruct {\r\n  HPKEPublicKey public_key;     // from parent\r\n  opaque parent_hash<0..255>;   // from parent\r\n  opaque resolution_hash<0..8>; // from non-updated child\r\n} ParentHashInput;\r\n```\r\n\r\nThen your validity check for a non-blank parent node is that for one of its children:\r\n```\r\none_child.parent_hash = H(ParentHashInput{public_key, parent_hash, other_child.resolution_hash})\r\n```",
              "createdAt": "2020-11-16T17:04:04Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            },
            {
              "originalPosition": 116,
              "body": "```suggestion\r\nThe tree hash of a leaf node is the hash of leaf's `LeafNodeHashInput` object which\r\n```",
              "createdAt": "2020-11-16T17:04:54Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMxNTUxNzEw",
          "commit": {
            "abbreviatedOid": "8d4e183"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-16T17:35:13Z",
          "updatedAt": "2020-11-16T17:35:13Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "I've always been trying to use zero-length octet strings instead of \"0\" because \"0\" is ambiguous to me. For `Nh`-long all-zero string, I don't think we've used that anywhere else. Probably just because it's wordier",
              "createdAt": "2020-11-16T17:35:13Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyNDg4Nzk3",
          "commit": {
            "abbreviatedOid": "8e814ae"
          },
          "author": "psyoptix",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-17T15:27:46Z",
          "updatedAt": "2020-11-17T15:27:46Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "My (weak) preference is to use an Nh long all-zero string. But only because that makes it the right data type for the output of a hash function (in contrast to the empty string).",
              "createdAt": "2020-11-17T15:27:46Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyNDkzNDgy",
          "commit": {
            "abbreviatedOid": "2c199ce"
          },
          "author": "psyoptix",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-17T15:32:09Z",
          "updatedAt": "2020-11-17T15:32:10Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "I'm not a fan of \"corresponding\" subtree because its a bit imprecise since we dont define what the correspondence is. I find \"subtree rooted at v\" clearer. Alternatively we could define \"corresponding subtree\" somewhere but my preference is to not introduce new (e.g. graph theory) terminology whenever standard terms can be used to the same end.",
              "createdAt": "2020-11-17T15:32:09Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyNTAxNDY4",
          "commit": {
            "abbreviatedOid": "2c199ce"
          },
          "author": "psyoptix",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-17T15:39:44Z",
          "updatedAt": "2020-11-17T15:39:44Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "Re: Validation. Yes, i think the same validation algo should work as before. And I agree text describing validation is necessary. Just not sure where to put that. Could put it in the Parent Hash section but maybe its more appropriate when describing how to process commit packets and how to join a group? (Group members should check that the parent_hash in the commitors key package checks out by recomputing it and comparing to whats in the key package. New members should check that the parent hash of each internal node is stored at one of its two children.)",
              "createdAt": "2020-11-17T15:39:44Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyNjExODA4",
          "commit": {
            "abbreviatedOid": "2c199ce"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-17T17:23:39Z",
          "updatedAt": "2020-11-17T17:23:40Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "```suggestion\r\nthe `unmerged_leaves` of P omitted.\r\n```",
              "createdAt": "2020-11-17T17:23:40Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1NzI3MjQw",
          "commit": {
            "abbreviatedOid": "2c199ce"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "@psyoptix I think you mean to change \"ParentNode\" to \"ParentNodeTreeHashData\", but didn't get all the way there.  I prefer it as \"ParentNode\" anyway :)  If you could fix that and the other comments noted, I think this will be ready to merge.",
          "createdAt": "2020-11-20T19:42:53Z",
          "updatedAt": "2020-11-21T00:08:55Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "After think through this a bit more (and getting a partial implementation working).  I think I'm OK with the original formulation here.  Jo\u00ebl reminded me that the sibling resolution will be short in a full tree, so the only case where you'll end up with large values here is in a sparse tree, which seems acceptable to me.  Given that, I think my only comment here is around naming, which I'll put in as a suggestion abvoe. ",
              "createdAt": "2020-11-20T19:42:53Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            },
            {
              "originalPosition": 70,
              "body": "```suggestion\r\n    HPKEPublicKey public_key;\r\n    opaque parent_hash<0..255>;\r\n    HPKEPublicKey original_child_resolution<0..2^32-1>;\r\n```\r\n\r\n1. Convert tabs to spaces\r\n2. Phrase the variable names from the point of view of the parent.",
              "createdAt": "2020-11-20T19:44:32Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            },
            {
              "originalPosition": 111,
              "body": "Yeah, I think we still need this one.  It goes in the syntax for how you send the tree to a new member.",
              "createdAt": "2020-11-21T00:04:17Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            },
            {
              "originalPosition": 139,
              "body": "```suggestion\r\nstruct {\r\n    HPKEPublicKey public_key;\r\n    opaque parent_hash<0..255>;\r\n    uint32 unmerged_leaves<0..2^32-1>;\r\n} ParentNode;\r\n```",
              "createdAt": "2020-11-21T00:06:39Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            },
            {
              "originalPosition": 131,
              "body": "```suggestion\r\nits `ParentNodeTreeHashInput`. This includes an optional `ParentNode`\r\n```\r\n\r\nI prefer \"ParentNode\", since we use this for sending the tree as well as hashing.",
              "createdAt": "2020-11-21T00:07:14Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwNTcyODE4",
          "commit": {
            "abbreviatedOid": "37adf10"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "One more small fix here, then I think this is ready to merge.",
          "createdAt": "2020-12-11T20:57:38Z",
          "updatedAt": "2020-12-11T21:21:09Z",
          "comments": [
            {
              "originalPosition": 111,
              "body": "Resolving this conversation because it got re-added below.",
              "createdAt": "2020-12-11T20:57:39Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            },
            {
              "originalPosition": 104,
              "body": "This section should address the problem noted in #435.  Namely, `V` should either be `left(P)` or `left^k(right(P)`, for the smallest possible `k >= 0`. Suggested text:\r\n\r\n```suggestion\r\nTo this end, when processing a Commit message clients MUST recompute the\r\nexpected value of `parent_hash` for the committer's new leaf and verify that it\r\nmatches the `parent_hash` value in the supplied `leaf_key_package`. Moreover, when\r\njoining a group, new members MUST authenticate each non-blank parent node P. A parent\r\nnode P is authenticated by performing the following check: \r\n\r\n* Let L and R be the left and right children of P, respectively\r\n* If L.parent_hash is equal to the Parent Hash of P with Co-Path Child R, the check passes \r\n* If R is blank, replace R with its left child until R is either non-blank or a leaf node\r\n* If R is a leaf node, the check fails\r\n* If R.parent_hash is equal to the Parent Hash of P with Co-Path Child L, the check passes\r\n* Otherwise, the check fails\r\n\r\nThe left-child recursion under the right child of P is necessary because the expansion of \r\nthe tree to the right due to Add proposals can cause blank nodes to be interposed \r\nbetween a parent node and its right child. \r\n```\r\n\r\ncc @MartaMularczyk @dajost ",
              "createdAt": "2020-12-11T21:14:24Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1NjMxNjQ0",
          "commit": {
            "abbreviatedOid": "37adf10"
          },
          "author": "psyoptix",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-18T16:24:38Z",
          "updatedAt": "2020-12-18T16:24:38Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "Nice! Looks good to me.",
              "createdAt": "2020-12-18T16:24:38Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1NjM5MzAz",
          "commit": {
            "abbreviatedOid": "9957be7"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-18T16:34:35Z",
          "updatedAt": "2020-12-18T16:34:35Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU2MDQzNjEz",
          "commit": {
            "abbreviatedOid": "9957be7"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Looks good, please fix conflicts",
          "createdAt": "2020-12-20T19:18:20Z",
          "updatedAt": "2020-12-20T19:34:46Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "```suggestion\r\nis the root, then `parent_hash` is set to a zero-length octet string.\r\n```",
              "createdAt": "2020-12-20T19:18:20Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            },
            {
              "originalPosition": 81,
              "body": "```suggestion\r\n6 has an array with one element in it: the HPKE public key of 6.\r\n```",
              "createdAt": "2020-12-20T19:20:00Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            },
            {
              "originalPosition": 86,
              "body": "```suggestion\r\nthen P's Parent Hash is stored in the `parent_hash` fields of both V's\r\n```",
              "createdAt": "2020-12-20T19:24:53Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            },
            {
              "originalPosition": 202,
              "body": "```suggestion\r\n    leaf). If either of the node's children are empty, and in particular does not\r\n```",
              "createdAt": "2020-12-20T19:34:18Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU2NTE3NjU4",
          "commit": {
            "abbreviatedOid": "9957be7"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-21T16:47:14Z",
          "updatedAt": "2020-12-21T16:47:14Z",
          "comments": [
            {
              "originalPosition": 202,
              "body": "No, the subject which which the verb must agree is \"either\" (singular), not \"children\" (plural).",
              "createdAt": "2020-12-21T16:47:14Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU2NjA4MTM4",
          "commit": {
            "abbreviatedOid": "f1dfd59"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-21T19:18:56Z",
          "updatedAt": "2020-12-21T19:18:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 437,
      "id": "MDExOlB1bGxSZXF1ZXN0NTIwNjMxOTM5",
      "title": "Leave this phrase open to allow deniability",
      "url": "https://github.com/mlswg/mls-protocol/pull/437",
      "state": "MERGED",
      "author": "claucece",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "cc./ @raphaelrobert @beurdouche ",
      "createdAt": "2020-11-13T15:00:52Z",
      "updatedAt": "2020-11-16T16:36:14Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "5ea742c9770cd5f8b2964badba4e6e7b756fa13f",
      "headRepository": "claucece/mls-protocol",
      "headRefName": "master",
      "headRefOid": "92038a49d63b375bd5cf12992159660ba80cc064",
      "closedAt": "2020-11-16T16:36:14Z",
      "mergedAt": "2020-11-16T16:36:14Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "a1fe025945b7b2b3e2dd8cf102984637061b7655"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMwODU0MDEx",
          "commit": {
            "abbreviatedOid": "92038a4"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-16T00:24:22Z",
          "updatedAt": "2020-11-16T00:24:22Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMxMDA0NzQx",
          "commit": {
            "abbreviatedOid": "92038a4"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-16T07:50:30Z",
          "updatedAt": "2020-11-16T07:50:30Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMxNDk2MjA2",
          "commit": {
            "abbreviatedOid": "92038a4"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-16T16:36:09Z",
          "updatedAt": "2020-11-16T16:36:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 438,
      "id": "MDExOlB1bGxSZXF1ZXN0NTIxODAzNDU5",
      "title": "Remove some stale OPEN ISSUEs",
      "url": "https://github.com/mlswg/mls-protocol/pull/438",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In preparation for feature-freeze / post-first-WGLC living, this PR removes a few issues that have been discussed and pretty much resolved.  It leaves a few OPEN ISSUES that could benefit from analysis during the feature freeze.",
      "createdAt": "2020-11-16T17:08:24Z",
      "updatedAt": "2020-11-21T20:02:15Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "529a5ce7f4a08840593c6d5b23aab684d498ebb3",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "open-issues",
      "headRefOid": "80a9d687e9c44a630b858704dc393369a52bd1e7",
      "closedAt": "2020-11-21T20:02:15Z",
      "mergedAt": "2020-11-21T20:02:15Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "9afdd386ecaf391a948ec3e0de79991a683c89fc"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMxNTUzNzI0",
          "commit": {
            "abbreviatedOid": "969c900"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-16T17:37:41Z",
          "updatedAt": "2020-11-16T17:37:41Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzNjU0OTMx",
          "commit": {
            "abbreviatedOid": "969c900"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "Looks good in general. I flagged one issue I saw.",
          "createdAt": "2020-11-18T16:54:11Z",
          "updatedAt": "2020-11-18T16:55:24Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "I'm inclined to have this documented somewhere, perhaps not as an open issue. Otherwise someone will claim they discovered an \"attack\".",
              "createdAt": "2020-11-18T16:54:11Z",
              "updatedAt": "2020-11-20T19:24:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1OTcxMjUw",
          "commit": {
            "abbreviatedOid": "80a9d68"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-21T14:50:42Z",
          "updatedAt": "2020-11-21T14:50:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 439,
      "id": "MDExOlB1bGxSZXF1ZXN0NTIyMjU3MDQ4",
      "title": "Identities SHOULD be unique per group",
      "url": "https://github.com/mlswg/mls-protocol/pull/439",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR changes the draft such that it mandates identities SHOULD be unique per group.\r\n\r\nIn particular, a committer SHOULD only include one Add per identity if multiple are present and SHOULD NOT include Adds for identities that are already members of the group.\r\n\r\nI also made the requirement more precise, that there shouldn't be multiple Adds for the same \"client\", which I change \"client\" to \"KeyPackage\".\r\n\r\nThe rationale here being that this change allows us to address group members by their identity rather than their leaf index, which would allow us to finally hide the fact that we're using a tree underneath from users of MLS.",
      "createdAt": "2020-11-17T09:13:12Z",
      "updatedAt": "2021-08-19T21:11:06Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "57bb2954265c57896249dcb2bbb04788205fb466",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "unique_identity_per_group",
      "headRefOid": "4d6dde92c86320c6df3b8981e5f8685b6ca67877",
      "closedAt": "2021-08-19T21:11:06Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "This PR seems like all down-side to me.  On the one hand, it's not clear what benefit there is to maintaining distinct identities in the credential.  On the other hand, it seems like there are cases where it is desirable to have multiple appearances of the same identity, for example, multiple devices owned by the same user.  \r\n\r\nIf the application wants to implement \"remove a user\" functionality, then they just need to iterate over all instances of that user in the tree.  If the application needs to individual device identifiers, it can choose to encode these in the credential or use an extension to provide a separate device identifier.\r\n\r\nSo I would be inclined to close this PR with no action.",
          "createdAt": "2020-11-18T12:51:11Z",
          "updatedAt": "2020-11-18T12:51:54Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The benefit would be that group members are not solely identified by their leaf index. I understand if that's not motivation enough.\r\n\r\nHowever, the spec currently says\r\n\r\n> If there are multiple Add proposals for the same client, the committer again chooses one to include and considers the rest invalid.\r\n\r\n\"Client\" is a bit tricky if we don't define it via the identity. It's defined as an entity that is defined by the key material it holds.  But how to detect if a client is added multiple times? We could try checking if it's the same key package, but if that party uses the same identity for all their devices/clients then it might well be the same, because it's down to the key package of last resort. Or are we assuming that clients will always use different key packages? Or is that something where we leave the check to the application layer? That point should be either a bit more specific or removed entirely.\r\n\r\n>  If the application needs to individual device identifiers, it can choose to encode these in the credential or use an extension to provide a separate device identifier.\r\n\r\nWhy wouldn't that then be part of the `identity`? The only place we really do anything with the `identity` is currently the fact that it can't change with an update.",
          "createdAt": "2020-11-18T15:02:45Z",
          "updatedAt": "2020-11-18T15:02:45Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "> The benefit would be that group members are not solely identified by their leaf index. I understand if that's not motivation enough.\r\n\r\nYeah, I don't see why I would care about this.  The leaf index is clear and unambiguous for intra-MLS usage, and applications can use the rest of the KeyPackage to decide which leaves to remove.\r\n\r\nAgree that we should fix that spec text.  IMO the right answer is to make clear that it's up to the application to decide when two KeyPackages represent the same client.\r\n\r\n> Why wouldn't that then be part of the identity?\r\n\r\nThere are circumstances where `credential.identity` might be constrained so that it can't hold all the information you want.  For example, if you were using X509Credentials from a CA that certified email addresses, then all instances of a user with a given email address would have the same `credential.identity` (the email address).  You would need something else to distinguish different instances/devices of the same user, probably a KeyPackage extension.\r\n",
          "createdAt": "2020-11-20T19:37:12Z",
          "updatedAt": "2020-11-20T19:37:12Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I see your point. I'll close this, then.",
          "createdAt": "2020-11-23T06:57:51Z",
          "updatedAt": "2020-11-23T06:57:51Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In light of the discussion on the mailing list regarding the improvement of client authentication, I'm reopening this PR. I've updated this PR to include both identities and signature keys.",
          "createdAt": "2021-01-20T12:31:40Z",
          "updatedAt": "2021-01-20T12:31:40Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "This looks almost good! I think it's missing the rule that Commits MUST be rejected if they contain identities that are not unique.",
          "createdAt": "2021-03-02T14:53:50Z",
          "updatedAt": "2021-03-02T14:53:50Z"
        },
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed at 20210526 Interim. Look to merge.",
          "createdAt": "2021-05-26T15:32:59Z",
          "updatedAt": "2021-05-26T15:32:59Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Replaced by #476 ",
          "createdAt": "2021-08-19T21:11:06Z",
          "updatedAt": "2021-08-19T21:11:06Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyMTcwODQ5",
          "commit": {
            "abbreviatedOid": "eb854af"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-11-17T09:27:53Z",
          "updatedAt": "2020-11-17T09:31:50Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "should -> SHOULD",
              "createdAt": "2020-11-17T09:27:53Z",
              "updatedAt": "2021-03-04T08:22:02Z"
            },
            {
              "originalPosition": 22,
              "body": "\"If there are multiple Add proposals of KeyPackages with the same identity\"",
              "createdAt": "2020-11-17T09:30:07Z",
              "updatedAt": "2021-03-04T08:22:02Z"
            },
            {
              "originalPosition": 24,
              "body": "\"if there are Add proposals of KeyPackages with an identity that is already present\"",
              "createdAt": "2020-11-17T09:31:30Z",
              "updatedAt": "2021-03-04T08:22:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyMTc2NDYw",
          "commit": {
            "abbreviatedOid": "eb854af"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-17T09:34:17Z",
          "updatedAt": "2020-11-17T09:34:17Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I thought those capitalized SHOULDs, MUSTs, etc are only used for actual instructions. I use it later on in cases where I describe what the committer SHOULD do. I'm happy to change it here, as well, though.",
              "createdAt": "2020-11-17T09:34:17Z",
              "updatedAt": "2021-03-04T08:22:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcyMTkxMTMz",
          "commit": {
            "abbreviatedOid": "0d90b8d"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-20T12:55:15Z",
          "updatedAt": "2021-01-20T12:55:15Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI2OTI0OTM1",
          "commit": {
            "abbreviatedOid": "4d6dde9"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-08-10T23:31:33Z",
          "updatedAt": "2021-08-10T23:31:43Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "I still object to this requirement, on the same grounds as before.  Namely, multi-device cases will result in multiple appearances of the same identity with high probability.\r\n\r\nI thought we had agreed to make the prohibition on duplication of signature keys.  If that's the case, then let's make that change and merge.",
              "createdAt": "2021-08-10T23:31:33Z",
              "updatedAt": "2021-08-10T23:31:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI3MDc1Mzk0",
          "commit": {
            "abbreviatedOid": "4d6dde9"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-11T05:51:10Z",
          "updatedAt": "2021-08-11T05:51:11Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Is there a particular reason why you wouldn't want to use different identities for the devices? They will have to be distinguished at some point. Even if you use X509 certificates, you could still use the fingerprint as identity.\r\n\r\nThis change would allow us to address group members by their identity as opposed to their leaf index, which makes for a more intuitive API and allows us to hide the fact that we're using a tree underneath.\r\n\r\n(Updated the PR description to reflect this rationale.)",
              "createdAt": "2021-08-11T05:51:11Z",
              "updatedAt": "2021-08-11T05:53:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI3ODc1MTE2",
          "commit": {
            "abbreviatedOid": "4d6dde9"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-11T19:37:36Z",
          "updatedAt": "2021-08-11T19:37:36Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Well, if you define \"identity\" in the right way, sure :)  \r\n\r\nPart of the challenge here is that we don't really have a well-defined notion of \"identity\" on which to hang requirements such as these.  And I would argue that we should not have such a notion at this level -- it's up to the application to define how the credentials in MLS are used to authenticate application-level identities.  \"Identity\" is also a bad API concept, because you're going to have different cases; think \"remove this specific device\" vs. \"remove all participants with this phone number\".\r\n\r\nYour X.509 example seems like it points back to my suggestion of focusing this on signature keys.  Aside from serial numbers, public keys are the major reason that two certificates would be different.",
              "createdAt": "2021-08-11T19:37:36Z",
              "updatedAt": "2021-08-11T19:37:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI4MjIzMjA3",
          "commit": {
            "abbreviatedOid": "4d6dde9"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-12T06:29:45Z",
          "updatedAt": "2021-08-12T06:29:45Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "I'm less concerned about concrete API schemes, and more about the fact that we can't abstract the tree away.\r\n\r\nI see that signature keys would allow us to hide the tree under an abstraction. However, signature keys of a given client, even if they are unique, (potentially) change over the time of that client's group membership, so if we used that to address individual group members, we would have to have an additional mapping that keeps track of changing signature keys, which is not ideal.\r\n\r\n(I realize now that that means that my fingerprint example wouldn't work, either.)\r\n\r\nYou are right in that we should probably talk a bit about what \"identity\" really means in the context of MLS. As you said, it's the job of the application layer to verify credentials, so what is verified by the AS could be something more than the `identity` field that the spec currently requires. Looking at it from that angle: does the `identity` field currently serve any purpose in the spec other than that it's verified as part of the credential and that it doesn't change through updates?\r\n\r\nIf that is not the case, we could require the identity field to be something unique, while leaving other fields in the credential (that MLS doesn't have to know about) as the \"user-facing\" identity, which (also) gets verified by the AS as part of the credential and which the user can base their for authentication decision on. Thus, for MLS, the `identity` field, would be mostly administrative.",
              "createdAt": "2021-08-12T06:29:45Z",
              "updatedAt": "2021-08-12T06:29:45Z"
            }
          ]
        }
      ]
    },
    {
      "number": 441,
      "id": "MDExOlB1bGxSZXF1ZXN0NTI0MTQwMjQ4",
      "title": "remove references to nonexistent key_package field in Commit message",
      "url": "https://github.com/mlswg/mls-protocol/pull/441",
      "state": "MERGED",
      "author": "uhoreg",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "It looks like `key_package`  in Commit was moved to `leaf_key_package` in UpdatePath, but some docs didn't get updated.",
      "createdAt": "2020-11-19T18:11:29Z",
      "updatedAt": "2020-11-20T17:35:12Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "57bb2954265c57896249dcb2bbb04788205fb466",
      "headRepository": "uhoreg/mls-protocol",
      "headRefName": "no_key_package_in_commit",
      "headRefOid": "92246be0634bac1d1ff37a09bb3bee3fc40e04c4",
      "closedAt": "2020-11-20T17:35:12Z",
      "mergedAt": "2020-11-20T17:35:12Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "a3b424e8ae7440052f0c1fe5f7fbf15fc93230aa"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1NjM4MDU2",
          "commit": {
            "abbreviatedOid": "92246be"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-20T17:35:06Z",
          "updatedAt": "2020-11-20T17:35:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 442,
      "id": "MDExOlB1bGxSZXF1ZXN0NTI1MTg1NTg4",
      "title": "Add an \"AppAck\" proposal",
      "url": "https://github.com/mlswg/mls-protocol/pull/442",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We had longstanding issue #160 to allow the participants in an MLS group to detect when the DS drops messages.  That issue was closed because it had been open for a long time without a concrete proposed solution.  More recently, however, @raphaelrobert and @beurdouche suggested using a Proposal for this, and it made a lot of sense to me when I looked into the details.  So this PR should be considere joint work between, @raphaelrobert, @beurdouche, and me.\r\n\r\nThis PR adds an `AppAck` Proposal that any member of the group can send to advertise the last generation it sent, and acknowledge the receipt of application messages from other members.  As a Proposal, it is included in the transcript via Commits, providing a pretty strong defence against message suppression -- the DS basically has to stop the group progressing at all if it wants to drop applications without the group being aware of it.",
      "createdAt": "2020-11-21T20:26:19Z",
      "updatedAt": "2020-12-14T15:56:40Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "9afdd386ecaf391a948ec3e0de79991a683c89fc",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "appack",
      "headRefOid": "747a96d5a460537c389ce1c7a2b62c6dc2ece328",
      "closedAt": "2020-12-14T15:56:40Z",
      "mergedAt": "2020-12-14T15:56:40Z",
      "mergedBy": "raphaelrobert",
      "mergeCommit": {
        "oid": "12beb366b68d59d6b7e41699915c4f03ce776e70"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "BTW, there are a *bunch* of ways to go about [expressing what a member did and did not receive](https://en.wikipedia.org/wiki/Acknowledgement_(data_networks)).  Most of these schemes are designed for 1:1 connections like TCP or QUIC, but adapt in a straightforward way to groups.  Which one is most efficient depends on what you assume about losses.  Some examples:\r\n\r\n1. List of received messages (the most na\u00efve approach; efficient only if losses dominate)\r\n2. List of received message ranges (implemented here, more efficient for infrequent losses)\r\n3. Highest received generation, plus list of generations not received (more efficient for even more infrequent losses)\r\n\r\nFWIW, scheme (2) is effectively [what QUIC does](https://tools.ietf.org/html/draft-ietf-quic-transport-32#section-19.3).  TCP does something like (3), but because it is synchronous, doesn't include generations not received.  The [\"selective acknowledgement\"](https://tools.ietf.org/html/rfc2018#section-3) option for TCP is basically the same as option (2), reporting ranges of received packets.",
          "createdAt": "2020-11-21T20:39:25Z",
          "updatedAt": "2020-11-21T20:39:25Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Great idea! Two comments:\r\n\r\nTo make sure that the DS doesn't drop any Commit that has an AppAck extension (to cover up their dropping of Application messages), either one has to encrypt Commit messages or AppAcks need to be mandatory for Commits by policy. Otherwise the DS can just drop any Commit that has an AppAck in it (without impeding the sending of messages in the group).\r\n\r\nA cheaper, although functionally less powerful version would be to simply send a hash of the SecretTree. The other group members would then know if they received the same messages as the sender (but not more than that).",
          "createdAt": "2020-11-23T07:05:11Z",
          "updatedAt": "2020-11-23T07:05:11Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@kkohbrok good point about addressing suppression of AppAck itself.  I added a paragraph. \r\n\r\nSending a hash of the SecretTree seems both less powerful and way more complicated, since we would have to define a hashing scheme.  So I'm gonna pass :)",
          "createdAt": "2020-12-12T20:16:12Z",
          "updatedAt": "2020-12-12T20:16:12Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2MDA3NTM4",
          "commit": {
            "abbreviatedOid": "81c99ef"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-21T20:42:18Z",
          "updatedAt": "2020-11-21T20:42:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 444,
      "id": "MDExOlB1bGxSZXF1ZXN0NTI1MzcwNDE5",
      "title": "Fix typo",
      "url": "https://github.com/mlswg/mls-protocol/pull/444",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-11-22T22:46:18Z",
      "updatedAt": "2020-11-23T07:57:24Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "9afdd386ecaf391a948ec3e0de79991a683c89fc",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/asdf1",
      "headRefOid": "01ca54faa9527cd0281937835bbb50a9d5a2f9b8",
      "closedAt": "2020-11-23T07:57:14Z",
      "mergedAt": "2020-11-23T07:57:14Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "b3e4c00084d254ce2c127da8fafe762f6f4ad4ba"
      },
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Thanks !",
          "createdAt": "2020-11-23T07:57:24Z",
          "updatedAt": "2020-11-23T07:57:24Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 445,
      "id": "MDExOlB1bGxSZXF1ZXN0NTI1NzE4NDAw",
      "title": "Fix typo Derive-Secret",
      "url": "https://github.com/mlswg/mls-protocol/pull/445",
      "state": "MERGED",
      "author": "franziskuskiefer",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "There's only `DeriveSecret`.",
      "createdAt": "2020-11-23T13:06:43Z",
      "updatedAt": "2020-11-23T13:54:50Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "b3e4c00084d254ce2c127da8fafe762f6f4ad4ba",
      "headRepository": "franziskuskiefer/mls-protocol",
      "headRefName": "patch-2",
      "headRefOid": "929e4bd120e2e38e298357655530580697aab84b",
      "closedAt": "2020-11-23T13:54:43Z",
      "mergedAt": "2020-11-23T13:54:43Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "6603c78258a5376e8132ceafb1ba8af27a406841"
      },
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Thanks!",
          "createdAt": "2020-11-23T13:54:50Z",
          "updatedAt": "2020-11-23T13:54:50Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 446,
      "id": "MDExOlB1bGxSZXF1ZXN0NTI4OTM5ODc3",
      "title": "Move joiner_secret to the end of the first KDF cycle in the Key Schedule",
      "url": "https://github.com/mlswg/mls-protocol/pull/446",
      "state": "MERGED",
      "author": "ericcornelissen",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This is a small suggestion to move the definition of the `joiner_secret` to the\r\nend of the first Extract-Expand (KDF) cycle of the [key schedule]. This makes\r\nmore sense from a cryptographic perspective as we would not be using anything\r\nfrom the middle of a KDF cycle.\r\n\r\nA related suggestion is to remove the `member_secret` from the document. I\r\nremoved it from the key schedule, removed all the mentions to forget it as soon\r\nas possible and updated the description of deriving the `welcome_key` and\r\n`welcome_nonce` from the [welcoming new members] section.\r\n\r\n[key schedule]: https://github.com/mlswg/mls-protocol/blob/master/draft-ietf-mls-protocol.md#key-schedule\r\n[welcoming new members]: https://github.com/mlswg/mls-protocol/blob/master/draft-ietf-mls-protocol.md#welcoming-new-members\r\n",
      "createdAt": "2020-11-28T12:11:18Z",
      "updatedAt": "2020-12-12T21:02:05Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "6603c78258a5376e8132ceafb1ba8af27a406841",
      "headRepository": null,
      "headRefName": "move-joiner-secret",
      "headRefOid": "f83984b73b5479e6a6f258e2144e24ed4c84a0ca",
      "closedAt": "2020-12-12T20:04:38Z",
      "mergedAt": "2020-12-12T20:04:38Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "11d344041f9933998a1a4506d980872165990e7c"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the quick fix, @ericcornelissen !",
          "createdAt": "2020-12-12T20:04:33Z",
          "updatedAt": "2020-12-12T20:04:33Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwNTkxODY1",
          "commit": {
            "abbreviatedOid": "31bee95"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-11T21:32:58Z",
          "updatedAt": "2020-12-11T21:33:02Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Nit: Either this should be `member` or the label above should be `joiner`",
              "createdAt": "2020-12-11T21:32:58Z",
              "updatedAt": "2020-12-12T11:25:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwNzEyMjU0",
          "commit": {
            "abbreviatedOid": "f83984b"
          },
          "author": "ericcornelissen",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-12T11:26:34Z",
          "updatedAt": "2020-12-12T11:26:34Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Changed it to `joiner` as I think calling this the _\"joiner_secret\"_ makes more sense, but would be happy to do the change the other way as well.",
              "createdAt": "2020-12-12T11:26:34Z",
              "updatedAt": "2020-12-12T11:26:34Z"
            }
          ]
        }
      ]
    },
    {
      "number": 449,
      "id": "MDExOlB1bGxSZXF1ZXN0NTQxMjAzNTY0",
      "title": "Pin HPKE to -07.",
      "url": "https://github.com/mlswg/mls-protocol/pull/449",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "cc @bifurcation ",
      "createdAt": "2020-12-16T14:27:09Z",
      "updatedAt": "2020-12-16T15:30:01Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "12beb366b68d59d6b7e41699915c4f03ce776e70",
      "headRepository": "chris-wood/mls-protocol",
      "headRefName": "caw/pin-hpke",
      "headRefOid": "b5001529319dae841d0d33225641f03698dcdbc8",
      "closedAt": "2020-12-16T14:37:04Z",
      "mergedAt": "2020-12-16T14:37:04Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "5cedaf1ec905e046b86f057499f01a0259829278"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "@beurdouche is the build expected to fail?",
          "createdAt": "2020-12-16T14:34:49Z",
          "updatedAt": "2020-12-16T14:34:49Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "No, but the problem seem unrelated to your change, so we are all good.",
          "createdAt": "2020-12-16T14:36:27Z",
          "updatedAt": "2020-12-16T14:36:27Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks like it was a transient failure.  Re-running resulted in success.",
          "createdAt": "2020-12-16T15:30:01Z",
          "updatedAt": "2020-12-16T15:30:01Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzNzM4Mzc4",
          "commit": {
            "abbreviatedOid": "b500152"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-16T14:28:10Z",
          "updatedAt": "2020-12-16T14:28:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 450,
      "id": "MDExOlB1bGxSZXF1ZXN0NTQyMTc1MzEz",
      "title": "Editorial changes",
      "url": "https://github.com/mlswg/mls-protocol/pull/450",
      "state": "MERGED",
      "author": "uhoreg",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "- use `AEAD.Nh` and `AEAD.Nk` instead of `nonce_length` and `key_length`, for consistency with the rest of the spec\r\n- the key and nonce are now derived from the `joiner_secret` rather than randomly chosen",
      "createdAt": "2020-12-17T22:36:27Z",
      "updatedAt": "2020-12-18T16:48:06Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "5cedaf1ec905e046b86f057499f01a0259829278",
      "headRepository": "uhoreg/mls-protocol",
      "headRefName": "misc_fixes2",
      "headRefOid": "e68eeeeda1068d095683f0cdf930f72077282cd7",
      "closedAt": "2020-12-18T16:48:06Z",
      "mergedAt": "2020-12-18T16:48:06Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "6e4582881c931edb59e31508c8d45467c14bb646"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1NjQ5MjI3",
          "commit": {
            "abbreviatedOid": "e68eeee"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-18T16:47:58Z",
          "updatedAt": "2020-12-18T16:47:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 451,
      "id": "MDExOlB1bGxSZXF1ZXN0NTQzNzQ2OTI3",
      "title": "Remove contradictory initialization of transcript hashes",
      "url": "https://github.com/mlswg/mls-protocol/pull/451",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "While reviewing #436, I noticed that in one place, we define the initial `interim_transcript_hash` to be the all-zero vector, and in another, we define it to be the empty octet string.  In keeping with the idea of starting chained hashes with the empty octet string, this PR normalizes on the empty octet string for the transcript hashes as well.",
      "createdAt": "2020-12-21T21:59:08Z",
      "updatedAt": "2020-12-22T13:42:37Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "10df4266e4733134decdcc6cfa80f2d480674261",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "zero-length",
      "headRefOid": "a353055a246062a969593c9c9af17ba05d7bab41",
      "closedAt": "2020-12-22T13:42:37Z",
      "mergedAt": "2020-12-22T13:42:37Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "1f8c8b17ef8679b444302adb8f605f15f3938557"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU2NzMwNjUz",
          "commit": {
            "abbreviatedOid": "a353055"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-21T23:41:37Z",
          "updatedAt": "2020-12-21T23:41:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 452,
      "id": "MDExOlB1bGxSZXF1ZXN0NTQ0MTk5MDE1",
      "title": "Add changelog for draft-11",
      "url": "https://github.com/mlswg/mls-protocol/pull/452",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Immediately after I published draft-11, @raphaelrobert noticed that I had failed to update the change log.  This PR adds it to the editor's copy, so that it will be included in future versions.",
      "createdAt": "2020-12-22T15:37:57Z",
      "updatedAt": "2020-12-22T15:39:16Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "1f8c8b17ef8679b444302adb8f605f15f3938557",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "changelog-11",
      "headRefOid": "b807592899cc088cc41a44c7e00114b0e0985e74",
      "closedAt": "2020-12-22T15:39:16Z",
      "mergedAt": "2020-12-22T15:39:16Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "96efaf0633b2d0e861f06f4ba489c6193dea6052"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3MTcwMDc2",
          "commit": {
            "abbreviatedOid": "b807592"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-22T15:38:37Z",
          "updatedAt": "2020-12-22T15:38:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 453,
      "id": "MDExOlB1bGxSZXF1ZXN0NTQ3MzUzMDE2",
      "title": "Use the GroupContext to derive the joiner_secret",
      "url": "https://github.com/mlswg/mls-protocol/pull/453",
      "state": "MERGED",
      "author": "ericcornelissen",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This is a proposal to change how the `joiner_secret` is derived. Before, it was derived simply by derivation with a label. This Pull Request updates this step to include the GroupContext, similar to how the `epoch_secret` is derived. Including the GroupContext will give stronger uniqueness guarantees on the `joiner_secret` cryptographically speaking. I think the GroupContext in the derivation of the `epoch_secret` should be kept as it proves that joiners have learned the GroupContext through the Welcome message as well.",
      "createdAt": "2020-12-31T12:59:41Z",
      "updatedAt": "2021-08-19T21:17:59Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "96efaf0633b2d0e861f06f4ba489c6193dea6052",
      "headRepository": null,
      "headRefName": "context-for-joiner_secret",
      "headRefOid": "522a3d7d604a13b6338b4d41b376e4d6370e70a6",
      "closedAt": "2021-08-19T21:08:37Z",
      "mergedAt": "2021-08-19T21:08:37Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "a89ebee622ce3dcd44fe220d3313cf101baaaa01"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I have a couple of problems with this PR:\r\n\r\n> I think the GroupContext in the derivation of the epoch_secret should be kept as it proves that joiners have learned the GroupContext through the Welcome message as well.\r\n\r\nI don't see how this follows -- joiners are told the `joiner_secret` directly in the GroupSecrets message, they don't compute it themselves.  (It's also doesn't prove anything useful about the existing members, since their knowledge of the `init_secret` proves that they knew the GroupContext for the last epoch.)  If you wanted this property, you would have to instead send the output of `KDF.Extract` in GroupSecrets.\r\n\r\nBut there's a bigger problem here: This would create a circular dependency.  The joiner doesn't know the group context until they decrypt the Welcome message, which they do with the `welcome_secret`.  So you can't inject anything about the GroupContext in between the thing you hand to the joiner and the `welcome_secret`.\r\n\r\nIn other words, the injection of GroupContext is already done as early as it can be.  So we should close this PR",
          "createdAt": "2021-03-08T00:36:59Z",
          "updatedAt": "2021-03-08T00:36:59Z"
        },
        {
          "author": "ericcornelissen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I don't see how this follows -- joiners are told the joiner_secret directly in the GroupSecrets message, they don't compute it themselves.\r\n\r\nApologies for the confusion but that is not quite what I intended to say. Yes, joiners are told the `joiner_secret`, so what I meant to say is this: as joiners provided with the `joiner_secret` directly they don't need to use the `GroupContext` in the first `ExpandWithLabel` call, hence the `GroupContext` should be **kept** in the second `ExpandWithLabel` call.\r\n\r\n\r\n> It's also doesn't prove anything useful about the existing members, since their knowledge of the init_secret proves that they knew the GroupContext for the last epoch.\r\n\r\nI (intuitively) agree with that, but as per the Pull Request description: I added the `GroupContext` in the first `ExpandWithLabel` call for stronger uniqueness guarantees on the `joiner_secret` only.\r\n\r\n\r\n\r\n> But there's a bigger problem here: This would create a circular dependency. The joiner doesn't know the group context until they decrypt the Welcome message, which they do with the welcome_secret. So you can't inject anything about the GroupContext in between the thing you hand to the joiner and the welcome_secret.\r\n\r\nI'm not sure if I follow, I'm not proposing we change anything about how joiners are added to the group, they would still receive the `joiner_secret` as they do now. Therefore I'm not injecting anything about the `GroupContext` in between the thing we hand to the joiner (i.e. the `joiner_secret`) and the `welcome_secret`.\r\n\r\nAgain, my apologies if the Pull Request description wasn't clear. The change I'm proposing is primarily for uniqueness guarantees on the `joiner_secret`. I included the last sentence of the Pull Request description only as a motivation for keeping the `GroupContext` in the second `ExpandWithLabel` call.",
          "createdAt": "2021-03-08T11:56:19Z",
          "updatedAt": "2021-03-08T11:56:19Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for clarifying @ericcornelissen.  Good that we agree w.r.t. joiners.  If we're not aiming at that, then this seems pretty innocuous to me.  Would it be correct to say that this ensures that parties that don't agree on the GroupContext diverge as soon as possible?\r\n\r\nI'm not sure I see a ton of value in that, since the `joiner_secret` is only used ephemerally by existing members -- for them, the meaningful transition is `init_secret + commit_secret + psk_secret -> epoch_secret`, and that already includes the GroupContext.\r\n\r\nThat said, as long as we're not trying to address joiners, this seems innocuous, so if others are keen, I can go along with it.",
          "createdAt": "2021-03-08T12:39:51Z",
          "updatedAt": "2021-03-08T12:39:51Z"
        },
        {
          "author": "ericcornelissen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Would it be correct to say that this ensures that parties that don't agree on the GroupContext diverge as soon as possible?\r\n\r\nThat is correct, but not the only way of looking at it as per the below.\r\n\r\n\r\n> I'm not sure I see a ton of value in that, since the `joiner_secret` is only used ephemerally by existing members -- for them, the meaningful transition is `init_secret + commit_secret + psk_secret -> epoch_secret`, and that already includes the GroupContext.\r\n\r\nPractically speaking I would (intuitively) agree. That said, if a collision on the `joiner_secret` where to happen (and no PSK is used) everything up to and including the `welcome_secret` would collide and since the `GroupSecrets` are encrypted with keys derived (deterministically) from the `welcome_secret`, a collision _would_ be a problem.\r\n\r\nNamely, in a cryptographic analysis this would mean that the adversary may know a `welcome_secret` that it is not supposed to know. In a game-based setting, the adversary can first derive a (malicious) `welcome_secret` that they know, and than a colliding one they're not supposed to know. If I recall correctly, this \"problematic scenario\" may result from the fact that the `commit_secret` is not chained between epochs (a feature like https://mailarchive.ietf.org/arch/msg/mls/ZR84smU5xeLrziNTk5W1P1Z1nQI/ would likely give the same level of uniqueness to the `joiner_secret`, but this Pull Request is a far simpler solution for this particular problem).",
          "createdAt": "2021-03-08T14:22:05Z",
          "updatedAt": "2021-03-08T14:22:05Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the explanation, @ericcornelissen.  Makes sense to me.",
          "createdAt": "2021-03-08T14:29:22Z",
          "updatedAt": "2021-03-08T14:29:22Z"
        },
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed at 20210526 Interim. No downsides noted at this point. @kkohbrok agreed to review and provide any additional input.",
          "createdAt": "2021-05-26T15:35:35Z",
          "updatedAt": "2021-05-26T15:35:35Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "All the info was really already provided by @ericcornelissen in the conversation above. I'll summarize:\r\n\r\nUpsides of merging: The `joiner_secret` will enjoy better uniqueness guarantees, because the added context leads to it being _unique per group_. This improved uniqueness is also enjoyed by the derived `welcome_secret`.\r\n\r\nDownsides of merging: None. The `group_context` has to be used in the derivation of the `joiner_secret`, but it's the same amount of `HMAC` operations and the `group_context` has to be serialized anyway for the derivation of the `epoch_secret`.",
          "createdAt": "2021-08-10T12:06:20Z",
          "updatedAt": "2021-08-10T12:06:20Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYwODg4Nzkw",
          "commit": {
            "abbreviatedOid": "522a3d7"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-04T09:36:36Z",
          "updatedAt": "2021-01-04T09:36:36Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxMzMyNjk1",
          "commit": {
            "abbreviatedOid": "522a3d7"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-04T20:46:29Z",
          "updatedAt": "2021-01-04T20:46:29Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI2OTIzMDA3",
          "commit": {
            "abbreviatedOid": "522a3d7"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "One note I'll leave here for posterity: I briefly thought that because we are now injecting the GroupContext into the `joiner_secret`, we could remove the context from the `epoch_secret` derivation.  However, including the context there confirms that the joiner computed the same GroupContext as the Welcome sender, so it's important to keep it.",
          "createdAt": "2021-08-10T23:27:02Z",
          "updatedAt": "2021-08-10T23:27:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 454,
      "id": "MDExOlB1bGxSZXF1ZXN0NTU5NjAyMjMz",
      "title": "more editorial changes",
      "url": "https://github.com/mlswg/mls-protocol/pull/454",
      "state": "MERGED",
      "author": "uhoreg",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "- add the missing `authenticated_data` field to `MLSPlaintextCommitContent`\r\n- the sections for the `Commit` sender and `Commit` receiver seem to have gotten out of sync.  I tried to sync them up (but let me know if I messed something up)\r\n- fix a typo",
      "createdAt": "2021-01-21T23:21:53Z",
      "updatedAt": "2021-10-04T14:29:43Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "05fe1daacd66006f600869f6bc05bc9efb1530ed",
      "headRepository": "uhoreg/mls-protocol",
      "headRefName": "editorial-changes-2021-01-21",
      "headRefOid": "a352fa19217e237df27865a0f604ce29ea62eecf",
      "closedAt": "2021-10-04T14:29:43Z",
      "mergedAt": "2021-10-04T14:29:43Z",
      "mergedBy": "raphaelrobert",
      "mergeCommit": {
        "oid": "cb45ce3654b04596f740f5d74bb4f1cdf0f611fe"
      },
      "comments": [
        {
          "author": "uhoreg",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I've tried to align with the current mlspp code for how to process commits.  If the current mlspp code is incorrect, or if I'm reading it incorrectly, I'm more than happy to fix my changes to reflect the correct behaviour.",
          "createdAt": "2021-03-26T22:37:38Z",
          "updatedAt": "2021-03-26T22:37:38Z"
        },
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@bifurcation @raphaelrobert took action item to review editorial changes.",
          "createdAt": "2021-05-26T15:38:25Z",
          "updatedAt": "2021-05-26T15:38:25Z"
        },
        {
          "author": "uhoreg",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think I've addressed all the comments.  I also realized that the calculation of the new GroupContext was in the wrong spot (it has to be done after the MLSPlaintext is created (sans confirmation_tag), and then the confirmed transcript hash is created, then the new GroupContext, then the secrets, then the confirmation tag -- that's what mlspp does AFAICT), so I've fixed that up as well.",
          "createdAt": "2021-08-12T03:49:16Z",
          "updatedAt": "2021-08-12T03:49:16Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@raphaelrobert I think if you're OK with this, we're clear to merge.",
          "createdAt": "2021-08-19T21:07:36Z",
          "updatedAt": "2021-08-19T21:07:36Z"
        },
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As discussed at interim. @raphaelrobert review. If good, then merge.",
          "createdAt": "2021-10-04T14:18:43Z",
          "updatedAt": "2021-10-04T14:18:43Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc1Njc0OTYz",
          "commit": {
            "abbreviatedOid": "1b4b1c6"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-25T18:12:06Z",
          "updatedAt": "2021-01-25T18:15:09Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "You say use the provisional GroupContext, but the original text says to use the original GroupContext",
              "createdAt": "2021-01-25T18:12:07Z",
              "updatedAt": "2021-03-26T22:30:46Z"
            },
            {
              "originalPosition": 40,
              "body": "Again, mixing epochs seems bad",
              "createdAt": "2021-01-25T18:13:27Z",
              "updatedAt": "2021-03-26T22:30:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc1NjkxNzk5",
          "commit": {
            "abbreviatedOid": "1b4b1c6"
          },
          "author": "uhoreg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-25T18:30:50Z",
          "updatedAt": "2021-01-25T18:30:50Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "The \"A member of the group applies a Commit message by taking the following steps:\" section says\r\n\r\n> * If the `path` value is populated: Process the `path` value using the new ratchet tree and the provisional GroupContext, to update the ratchet tree and generate the `commit_secret`:\r\n\r\nSo this change is to make the two sections consistent",
              "createdAt": "2021-01-25T18:30:50Z",
              "updatedAt": "2021-03-26T22:30:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc1Njk0NzUz",
          "commit": {
            "abbreviatedOid": "1b4b1c6"
          },
          "author": "uhoreg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-25T18:33:34Z",
          "updatedAt": "2021-01-25T18:33:34Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "This is how it works in the \"A member of the group applies a Commit message by taking the following steps:\" section.  It verifies the signature before doing any modifications, and uses the `confirmation_key` from the new epoch.",
              "createdAt": "2021-01-25T18:33:34Z",
              "updatedAt": "2021-03-26T22:30:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAxODY5NjE3",
          "commit": {
            "abbreviatedOid": "1b4b1c6"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-03-02T14:23:24Z",
          "updatedAt": "2021-03-02T14:48:06Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "The authenticated data is not part of the content of an `MLSPlaintext`, it only exists when `MLSCiphertext` is used",
              "createdAt": "2021-03-02T14:23:25Z",
              "updatedAt": "2021-03-26T22:30:46Z"
            },
            {
              "originalPosition": 19,
              "body": "I agree it looks a bit inconsistent here indeed. I think this part is however the correct one and what you quote is confusing and should be changed instead.\r\nThe reason for my thinking is that the provisional group context is not known at this point in time and therefore the existing one should be used.",
              "createdAt": "2021-03-02T14:34:27Z",
              "updatedAt": "2021-03-26T22:30:46Z"
            },
            {
              "originalPosition": 35,
              "body": "This paragraph explains how the key schedule should be computed, but it omits quite a few steps (joiner secret, welcome secret, etc.) and the values are in the wrong chronologic order.",
              "createdAt": "2021-03-02T14:44:04Z",
              "updatedAt": "2021-03-26T22:30:46Z"
            },
            {
              "originalPosition": 51,
              "body": "See comment from above. I think this part is indeed wrong and the broken syntax might be a hint that it's the result of a copy & pasta job gone wrong.",
              "createdAt": "2021-03-02T14:47:53Z",
              "updatedAt": "2021-03-26T22:30:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA2MzI1Nzg5",
          "commit": {
            "abbreviatedOid": "1b4b1c6"
          },
          "author": "uhoreg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-08T14:13:06Z",
          "updatedAt": "2021-03-08T14:13:06Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I don't understand this comment.  `MLSPlaintext` does have an `authenticated_data` field, and the messages that are used here come from a Commit, which is encrypted, it would also use an `MLSCiphertext`.\r\n\r\nAnyways, I had asked @bifurcation about this earlier, and he said that it was accidentally omitted and should be added, which is why I did this.  If it in fact should be omitted, then I can revert the change, but I think that we should either add the field, or else explain why it isn't there because every other field from the beginning of `MLSPlaintext` up to the `signature` field is included.",
              "createdAt": "2021-03-08T14:13:06Z",
              "updatedAt": "2021-03-26T22:30:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA2NDI5MjI3",
          "commit": {
            "abbreviatedOid": "1b4b1c6"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-08T15:46:11Z",
          "updatedAt": "2021-03-08T15:46:11Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "You are absolutely right, apologies for the confusion. The two should be aligned of course.",
              "createdAt": "2021-03-08T15:46:11Z",
              "updatedAt": "2021-03-26T22:30:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIyNTU0MTkw",
          "commit": {
            "abbreviatedOid": "1b4b1c6"
          },
          "author": "uhoreg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-26T21:47:25Z",
          "updatedAt": "2021-03-26T21:47:26Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "If I'm reading the mlspp sources right, it looks like it uses the provisional GroupContext for this: https://github.com/cisco/mlspp/blob/main/src/state.cpp#L347-L359\r\n\r\n> The reason for my thinking is that the provisional group context is not known at this point in time and therefore the existing one should be used.\r\n\r\nThe provisional group context is created two steps before this step.\r\n\r\nI personally don't care which one is used, but they should be consistent.  For now, I'm going to follow what mlspp does, but if the consensus is that the original text here is correct, then I'm happy to change it.",
              "createdAt": "2021-03-26T21:47:26Z",
              "updatedAt": "2021-03-26T22:30:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIyNTYyMDAy",
          "commit": {
            "abbreviatedOid": "1b4b1c6"
          },
          "author": "uhoreg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-26T22:06:12Z",
          "updatedAt": "2021-03-26T22:06:12Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "This was basically a copy-and-paste from the other section.  I can update both sections to be more accurate.",
              "createdAt": "2021-03-26T22:06:12Z",
              "updatedAt": "2021-03-26T22:30:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIyNTcxNTg0",
          "commit": {
            "abbreviatedOid": "93ff197"
          },
          "author": "uhoreg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-26T22:32:28Z",
          "updatedAt": "2021-03-26T22:32:28Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "Alternatively, I can say \"Use the ... and the new GroupContext to advance the key schedule.\"  if we want to be less verbose.",
              "createdAt": "2021-03-26T22:32:28Z",
              "updatedAt": "2021-03-26T22:32:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIyNTcyMzQ5",
          "commit": {
            "abbreviatedOid": "93ff197"
          },
          "author": "uhoreg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-26T22:34:45Z",
          "updatedAt": "2021-03-26T22:34:45Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "It looks like DirectPath was renamed to UpdatePath, and the UpdatePath is already applied in a previous step (as part of the step where it's actually created), so this looks to me like an obsolete leftover.",
              "createdAt": "2021-03-26T22:34:45Z",
              "updatedAt": "2021-03-26T22:34:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIyNTcyNzAz",
          "commit": {
            "abbreviatedOid": "93ff197"
          },
          "author": "uhoreg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-26T22:35:50Z",
          "updatedAt": "2021-03-26T22:35:50Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "I'm not entirely sure why it takes the `confirmation_key` from the new epoch, but the `membership_key` from the old epoch, but that's what the current mlspp code does.",
              "createdAt": "2021-03-26T22:35:50Z",
              "updatedAt": "2021-03-26T22:35:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIyNjAxNjA3",
          "commit": {
            "abbreviatedOid": "93ff197"
          },
          "author": "uhoreg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-27T00:44:00Z",
          "updatedAt": "2021-03-27T00:44:01Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "Oh, actually, I do know, I think.  The `confirmation_tag` allows the other group members to check that they derived the same tree/secrets as the sender.  The `membership_tag` allows other group members to ensure that it was sent by a group member before processing the message.  I think this is mentioned in other parts of the document, but I can reiterate here if necessary.",
              "createdAt": "2021-03-27T00:44:00Z",
              "updatedAt": "2021-03-27T00:44:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY5MTkzMjIx",
          "commit": {
            "abbreviatedOid": "93ff197"
          },
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-26T15:37:40Z",
          "updatedAt": "2021-05-26T15:37:40Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Discussed at 20210526 Interim. Will split out authenticated_data change to another PR so it can be merged. Editorial changes continue to be reviewed.",
              "createdAt": "2021-05-26T15:37:40Z",
              "updatedAt": "2021-05-26T15:37:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI2OTI4NDEy",
          "commit": {
            "abbreviatedOid": "2f4e8a6"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-10T23:39:40Z",
          "updatedAt": "2021-08-10T23:46:44Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\nWhen creating or processing a Commit, three different GroupContexts are used:\r\n```",
              "createdAt": "2021-08-10T23:39:40Z",
              "updatedAt": "2021-08-10T23:46:44Z"
            },
            {
              "originalPosition": 19,
              "body": "I think \"provisional\" is the right answer here.  The idea of the GroupContext used with TreeKEM is to capture the tree to which the secrets are encapsulated.  That tree is the one in the provisional GroupContext, to which the proposals have been applied.",
              "createdAt": "2021-08-10T23:43:32Z",
              "updatedAt": "2021-08-10T23:46:44Z"
            },
            {
              "originalPosition": 51,
              "body": "This should be \"provisional\" in both cases -- the tree after applying proposals but before applying the UpdatePath.",
              "createdAt": "2021-08-10T23:46:31Z",
              "updatedAt": "2021-08-10T23:46:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI3ODMwNjY4",
          "commit": {
            "abbreviatedOid": "03a7617"
          },
          "author": "uhoreg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-11T18:52:58Z",
          "updatedAt": "2021-08-11T18:52:58Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "Uhm, yes.  Obviously it can't be the \"new\" ratchet tree, since this is the step that creates the \"new\" ratchet tree.  Not sure why I put \"new\" there.",
              "createdAt": "2021-08-11T18:52:58Z",
              "updatedAt": "2021-08-11T18:52:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI3ODM0ODE2",
          "commit": {
            "abbreviatedOid": "03a7617"
          },
          "author": "uhoreg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-11T18:57:45Z",
          "updatedAt": "2021-08-11T18:57:46Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "I think I've addressed this comment",
              "createdAt": "2021-08-11T18:57:45Z",
              "updatedAt": "2021-08-11T18:57:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI3ODM3NTkw",
          "commit": {
            "abbreviatedOid": "03a7617"
          },
          "author": "uhoreg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-11T19:00:58Z",
          "updatedAt": "2021-08-11T19:00:58Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "Oh, it's because we've only defined \"old\", \"provisional\", and \"new\" for GroupContext, and not for the ratchet tree.  I'll adjust the wording to fix that up.",
              "createdAt": "2021-08-11T19:00:58Z",
              "updatedAt": "2021-08-11T19:00:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM0NDY5MTk5",
          "commit": {
            "abbreviatedOid": "a352fa1"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-19T21:07:54Z",
          "updatedAt": "2021-08-19T21:07:54Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4t12p6",
          "commit": {
            "abbreviatedOid": "a352fa1"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "One more comment about the 3 ratcheting trees",
          "createdAt": "2021-10-01T15:13:54Z",
          "updatedAt": "2021-10-01T15:19:36Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "I'm still struggling with the fact that there are 3 ratcheting trees. In my mind there are only 2:\r\n - The ratcheting tree *before* applying proposals and the (potential) UpdatePath\r\n - The ratcheting tree *after* applying proposals and the (potential) UpdatePath\r\n\r\nThe ratcheting trees described here as \"provisional\" and \"new\" are in fact identical. It's just that they exist at different times. I think it would be good to make that clear, i.e. a \"provisional\" ratcheting tree becomes a \"new\" ratcheting tree when a Commit is applied.",
              "createdAt": "2021-10-01T15:13:54Z",
              "updatedAt": "2021-10-01T15:19:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4t6k88",
          "commit": {
            "abbreviatedOid": "a352fa1"
          },
          "author": "uhoreg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-04T13:55:25Z",
          "updatedAt": "2021-10-04T13:55:25Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "The \"provisional\" ratchet tree is the tree after applying the proposals, but before applying the UpdatePath.  We could probably do without a \"provisional\" ratchet tree, but I think it helps with clarity to give it a name since applying the proposals and applying the UpdatePath are different steps.",
              "createdAt": "2021-10-04T13:55:25Z",
              "updatedAt": "2021-10-04T13:55:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4t6rlk",
          "commit": {
            "abbreviatedOid": "a352fa1"
          },
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-04T14:16:12Z",
          "updatedAt": "2021-10-04T14:16:13Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Discussed at 20211004 MLS interim.",
              "createdAt": "2021-10-04T14:16:13Z",
              "updatedAt": "2021-10-04T14:16:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4t6s9Y",
          "commit": {
            "abbreviatedOid": "a352fa1"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-04T14:20:24Z",
          "updatedAt": "2021-10-04T14:20:25Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Fine, that makes sense to me!",
              "createdAt": "2021-10-04T14:20:25Z",
              "updatedAt": "2021-10-04T14:20:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4t6tUd",
          "commit": {
            "abbreviatedOid": "a352fa1"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Ready to be merged from my side.",
          "createdAt": "2021-10-04T14:21:32Z",
          "updatedAt": "2021-10-04T14:21:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 455,
      "id": "MDExOlB1bGxSZXF1ZXN0NTcxODM0MDMw",
      "title": "Make PreSharedKeys non optional in GroupSecrets",
      "url": "https://github.com/mlswg/mls-protocol/pull/455",
      "state": "MERGED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Currently the `psks` field in `GroupSecrets` is optional. `PreSharedKeys` only contains an array, which can be empty, even if the option is not empty. To avoid undefined behavior, I removed the option. In case no PSKs are used, the array should simply be empty.",
      "createdAt": "2021-02-11T13:52:59Z",
      "updatedAt": "2021-10-08T22:20:15Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "96efaf0633b2d0e861f06f4ba489c6193dea6052",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "raphaelrobert/optional-group-secrets",
      "headRefOid": "480022ba441d1ee9aacad1f140d402d309839da0",
      "closedAt": "2021-05-26T15:39:57Z",
      "mergedAt": "2021-05-26T15:39:57Z",
      "mergedBy": "raphaelrobert",
      "mergeCommit": {
        "oid": "d1e067f98158342a950f514ea76e13abc357b59c"
      },
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "I don't think the semantics of what you are suggesting is correct with respect to the TLS syntax. If you want to remove the option then the value has to be something, zeros for example.",
          "createdAt": "2021-02-11T18:12:42Z",
          "updatedAt": "2021-02-11T18:12:42Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "This is not a strong objection though...",
          "createdAt": "2021-02-11T18:16:46Z",
          "updatedAt": "2021-02-11T18:16:46Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "@beurdouche Can you point to the TLS syntax for that one? What I'm concerned about is specifically the UB, there has to be a better way to define this.",
          "createdAt": "2021-03-02T14:19:49Z",
          "updatedAt": "2021-03-02T14:19:49Z"
        },
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed at 20210526 Interim: As long as there is some input you can have an empty list. No impact on security.",
          "createdAt": "2021-05-26T15:39:37Z",
          "updatedAt": "2021-05-26T15:39:37Z"
        },
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "merge",
          "createdAt": "2021-05-26T15:40:07Z",
          "updatedAt": "2021-05-26T15:40:07Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTg4ODQ0MDc3",
          "commit": {
            "abbreviatedOid": "480022b"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-11T18:06:44Z",
          "updatedAt": "2021-02-11T18:06:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 456,
      "id": "MDExOlB1bGxSZXF1ZXN0NTczODgwODc0",
      "title": "Update name for this particular key",
      "url": "https://github.com/mlswg/mls-protocol/pull/456",
      "state": "MERGED",
      "author": "claucece",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I think this word was left from previous changes to the name of this particular key..\r\n\r\ncc./ @raphaelrobert @beurdouche ",
      "createdAt": "2021-02-16T02:13:04Z",
      "updatedAt": "2021-02-16T07:04:20Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "96efaf0633b2d0e861f06f4ba489c6193dea6052",
      "headRepository": "claucece/mls-protocol",
      "headRefName": "master",
      "headRefOid": "dc20a145fc7205fcbb119ffda030463c5240f3a4",
      "closedAt": "2021-02-16T07:04:07Z",
      "mergedAt": "2021-02-16T07:04:07Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "487cb3784da1cd5240918a95ba796bcfff67e3d1"
      },
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Thanks Sof\u00eda\r\n!",
          "createdAt": "2021-02-16T07:04:20Z",
          "updatedAt": "2021-02-16T07:04:20Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkwOTI5NTAx",
          "commit": {
            "abbreviatedOid": "dc20a14"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-16T07:03:09Z",
          "updatedAt": "2021-02-16T07:03:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 458,
      "id": "MDExOlB1bGxSZXF1ZXN0NTgzMTAzODI3",
      "title": "Fix the protocol overview section",
      "url": "https://github.com/mlswg/mls-protocol/pull/458",
      "state": "MERGED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #440 (see issue for details).",
      "createdAt": "2021-03-02T15:05:36Z",
      "updatedAt": "2021-10-08T22:20:08Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "487cb3784da1cd5240918a95ba796bcfff67e3d1",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "raphaelrobert/remove-old-welcome-mechanism",
      "headRefOid": "6d4725974ea87e0d9652e813a893a9c0c2a6973b",
      "closedAt": "2021-03-04T21:33:44Z",
      "mergedAt": "2021-03-04T21:33:44Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "a92a2690b630333c493ff111408054ee3161c793"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAyMDQ4MzQ5",
          "commit": {
            "abbreviatedOid": "6d47259"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-02T16:57:38Z",
          "updatedAt": "2021-03-02T16:57:38Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAyMDcxNzg1",
          "commit": {
            "abbreviatedOid": "6d47259"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-02T17:20:08Z",
          "updatedAt": "2021-03-02T17:20:08Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA0NTgwNjE5",
          "commit": {
            "abbreviatedOid": "6d47259"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-04T21:33:36Z",
          "updatedAt": "2021-03-04T21:33:36Z",
          "comments": []
        }
      ]
    },
    {
      "number": 460,
      "id": "MDExOlB1bGxSZXF1ZXN0NTg1NTY0NjIy",
      "title": "Fix typo in Parent Hash verification.",
      "url": "https://github.com/mlswg/mls-protocol/pull/460",
      "state": "MERGED",
      "author": "psyoptix",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Add a missing word. Fail on *blank* leaf.",
      "createdAt": "2021-03-05T12:29:03Z",
      "updatedAt": "2021-03-08T05:59:08Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "a92a2690b630333c493ff111408054ee3161c793",
      "headRepository": "psyoptix/mls-protocol",
      "headRefName": "fix_parent_hash_typo",
      "headRefOid": "7e8a6cfb16b2d3c2841b82a69c9c76c28841e91c",
      "closedAt": "2021-03-08T05:59:08Z",
      "mergedAt": "2021-03-08T05:59:07Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "da9333b8227e969f56b6c20d63b9ff836eb79dd5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA1OTA1ODIx",
          "commit": {
            "abbreviatedOid": "7e8a6cf"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-08T00:42:19Z",
          "updatedAt": "2021-03-08T00:42:19Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA1OTI4ODg4",
          "commit": {
            "abbreviatedOid": "7e8a6cf"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-08T02:34:19Z",
          "updatedAt": "2021-03-08T02:34:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 461,
      "id": "MDExOlB1bGxSZXF1ZXN0NTg2MjEwOTQ2",
      "title": "Truncate tree size on removal",
      "url": "https://github.com/mlswg/mls-protocol/pull/461",
      "state": "MERGED",
      "author": "suhasHere",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR adds text to truncate the tree to perform garbage collection on removal. [ref: https://github.com/mlswg/mls-protocol/pull/84/files]",
      "createdAt": "2021-03-07T08:34:07Z",
      "updatedAt": "2021-03-08T05:56:37Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "a92a2690b630333c493ff111408054ee3161c793",
      "headRepository": "suhasHere/mls-protocol",
      "headRefName": "truncate",
      "headRefOid": "46a06fe8eefae91a326fd68a7682be2da054419b",
      "closedAt": "2021-03-08T05:56:36Z",
      "mergedAt": "2021-03-08T05:56:36Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "2988304c45def53ac338045bcb7b49d5bb002365"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA1OTM0NDE4",
          "commit": {
            "abbreviatedOid": "46a06fe"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-08T02:55:47Z",
          "updatedAt": "2021-03-08T02:55:47Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA1OTgyNjMz",
          "commit": {
            "abbreviatedOid": "46a06fe"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-08T05:56:20Z",
          "updatedAt": "2021-03-08T05:56:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 462,
      "id": "MDExOlB1bGxSZXF1ZXN0NTg2NDc0Mzgz",
      "title": "Make ratchet tree section clearer.",
      "url": "https://github.com/mlswg/mls-protocol/pull/462",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-03-08T06:00:39Z",
      "updatedAt": "2021-10-04T17:32:19Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "da9333b8227e969f56b6c20d63b9ff836eb79dd5",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/asdf2",
      "headRefOid": "278f54d1b38c085a0371c64b6af8066b9d477ab9",
      "closedAt": "2021-10-04T17:32:19Z",
      "mergedAt": "2021-10-04T17:32:18Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "b9b6fa73e3973cf132d04bc125d1db4c5bff6076"
      },
      "comments": [
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "202105 Interim: To be reviewed by editors.",
          "createdAt": "2021-05-26T15:40:48Z",
          "updatedAt": "2021-05-26T15:40:48Z"
        },
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ready to merge modulo one nit.",
          "createdAt": "2021-10-04T14:20:11Z",
          "updatedAt": "2021-10-04T14:20:11Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI2OTI3NTg1",
          "commit": {
            "abbreviatedOid": "be5f887"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "One minor fix, otherwise ready to go.",
          "createdAt": "2021-08-10T23:37:41Z",
          "updatedAt": "2021-08-10T23:38:30Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\ncontaining a set of public keys and encrypted path secrets\r\nfor intermediate nodes in the direct path of its leaf. The\r\n```",
              "createdAt": "2021-08-10T23:37:41Z",
              "updatedAt": "2021-08-10T23:38:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4t14gc",
          "commit": {
            "abbreviatedOid": "be5f887"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-01T15:21:20Z",
          "updatedAt": "2021-10-01T15:21:20Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4t6s2z",
          "commit": {
            "abbreviatedOid": "be5f887"
          },
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-04T14:20:05Z",
          "updatedAt": "2021-10-04T14:20:05Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "minor correctness fix.",
              "createdAt": "2021-10-04T14:20:05Z",
              "updatedAt": "2021-10-04T14:20:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4t7iHF",
          "commit": {
            "abbreviatedOid": "278f54d"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-04T17:31:47Z",
          "updatedAt": "2021-10-04T17:31:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 463,
      "id": "MDExOlB1bGxSZXF1ZXN0NTg2NDc1NzEy",
      "title": "Remove AppAck proposal.",
      "url": "https://github.com/mlswg/mls-protocol/pull/463",
      "state": "CLOSED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-03-08T06:03:01Z",
      "updatedAt": "2021-10-04T14:27:17Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "da9333b8227e969f56b6c20d63b9ff836eb79dd5",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/no-app-ack",
      "headRefOid": "2bc2722d83c4de5ef0c8ad00d24d3bbc05c6917f",
      "closedAt": "2021-10-04T14:27:16Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(briefly) Discussed at 20210526 Interim: Debate about whether this is required at the protocol level. @grittygrease @seanturner to review discussion on list and determine way forward.",
          "createdAt": "2021-05-26T15:43:18Z",
          "updatedAt": "2021-05-26T15:43:18Z"
        },
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As discussed at 20211004 interim, will retain text.",
          "createdAt": "2021-10-04T14:27:16Z",
          "updatedAt": "2021-10-04T14:27:16Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 464,
      "id": "MDExOlB1bGxSZXF1ZXN0NTg3ODU5NTc3",
      "title": "Clarify which extensions should go into the group context",
      "url": "https://github.com/mlswg/mls-protocol/pull/464",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Just a small editorial change to clarify which extensions should be included in the `GroupContext`. There is a paragraph explaining that the `RatchetTreeExtension` should not go in, but I think the section on the `GroupContext` should be precise about what _does_ go in.\r\n\r\nI did notice, though, that we currently don't have a way of actually changing extensions during the lifetime of the group. If someone wanted to change an extensions, they would currently have to re-init the whole group. Of course, this could be solved by an extension, but maybe it would be sensible to have an `Extension` proposal for that purpose?",
      "createdAt": "2021-03-09T11:50:17Z",
      "updatedAt": "2021-08-13T05:18:06Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "da9333b8227e969f56b6c20d63b9ff836eb79dd5",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "extension_clarification",
      "headRefOid": "3f90a68824b686580f25f8807169221e64d78d92",
      "closedAt": "2021-08-13T05:18:06Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We should decide if we want to tackle #473 before discussing this further.",
          "createdAt": "2021-05-26T15:45:51Z",
          "updatedAt": "2021-05-26T15:45:51Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing in favor of the approach decided upon in #473.",
          "createdAt": "2021-08-13T05:18:06Z",
          "updatedAt": "2021-08-13T05:18:06Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 465,
      "id": "MDExOlB1bGxSZXF1ZXN0NTg5MTI3MjQ1",
      "title": "Rename add-only Commit to partial Commit.",
      "url": "https://github.com/mlswg/mls-protocol/pull/465",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-03-10T06:17:11Z",
      "updatedAt": "2021-05-26T15:45:04Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "da9333b8227e969f56b6c20d63b9ff836eb79dd5",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/asdf3",
      "headRefOid": "3a7d2aea12e678c4c5691fcc97b520623cabb0f6",
      "closedAt": "2021-05-26T15:45:04Z",
      "mergedAt": "2021-05-26T15:45:04Z",
      "mergedBy": "raphaelrobert",
      "mergeCommit": {
        "oid": "7a698d46c83b57f5cb2097eec8ffaa58875e7000"
      },
      "comments": [
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed at 20210526 Interim. Merge.",
          "createdAt": "2021-05-26T15:45:02Z",
          "updatedAt": "2021-05-26T15:45:02Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA4NTExNzg0",
          "commit": {
            "abbreviatedOid": "3a7d2ae"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Good point about allowing PSKs in a partial Commit!",
          "createdAt": "2021-03-10T09:43:00Z",
          "updatedAt": "2021-03-10T09:43:00Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA4NTEzMDEw",
          "commit": {
            "abbreviatedOid": "3a7d2ae"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-10T09:44:17Z",
          "updatedAt": "2021-03-10T09:44:17Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA5NDUxNDM0",
          "commit": {
            "abbreviatedOid": "3a7d2ae"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-11T07:17:01Z",
          "updatedAt": "2021-03-11T07:17:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 466,
      "id": "MDExOlB1bGxSZXF1ZXN0NTk2ODg1MzMz",
      "title": "Minor fixes to message formats",
      "url": "https://github.com/mlswg/mls-protocol/pull/466",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR fixes a few small issues I noticed while reviewing mlspp for compliance with the spec:\r\n\r\n* The size of the `Extension.extension_data` vector needs to expand `2^32-1` to support trees for large groups\r\n* The content of the `parent_hash` extension is specified\r\n* `authenticated_data` is included in `MLSPlaintextCommitContent` so that it goes into the transcript\r\n* `MLSPlaintextAuthData` now carries an `optional<MAC>` even though the value is always present, so that the transcript matches the data on the wire",
      "createdAt": "2021-03-19T21:24:37Z",
      "updatedAt": "2021-05-26T15:47:05Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "da9333b8227e969f56b6c20d63b9ff836eb79dd5",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "message-fixes",
      "headRefOid": "b5c460460070b2e8aed9d6620c056c913c4739d0",
      "closedAt": "2021-05-26T15:47:04Z",
      "mergedAt": "2021-05-26T15:47:04Z",
      "mergedBy": "raphaelrobert",
      "mergeCommit": {
        "oid": "ba6614efc4c2bc44cdc11c9914b2a37d4b340b84"
      },
      "comments": [
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed at 20210526 Interim. Merge",
          "createdAt": "2021-05-26T15:46:59Z",
          "updatedAt": "2021-05-26T15:46:59Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE3MDYyMjA5",
          "commit": {
            "abbreviatedOid": "b5c4604"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-21T21:12:35Z",
          "updatedAt": "2021-03-21T21:12:35Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE3MjI2MTIw",
          "commit": {
            "abbreviatedOid": "b5c4604"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-22T07:54:09Z",
          "updatedAt": "2021-03-22T07:54:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 467,
      "id": "MDExOlB1bGxSZXF1ZXN0NjAzNDUwODcw",
      "title": "An entropy pool design for MLS",
      "url": "https://github.com/mlswg/mls-protocol/pull/467",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR mandates the use of an entropy pool for MLS and proposes a design that is modeled after the key schedule such that it\r\n1) allows the extraction of entropy when needed,\r\n2) allows the repeated injection of entropy originating from the system's RNG such that the entropy pool gets refreshed after a full state compromise,\r\n3) gathers entropy over time while maintaining forward-secrecy,\r\n4) allows the safe injection of entropy originating from other parties.\r\n\r\nIn particular, the design is such that we achieve what we believe are the best possible security guarantees from any injection operation:\r\n* if the entropy from the system's RNG is good, the result is good independent of any other input to the pool\r\n* if the entropy from one of the groups is good, the result is good independent of any other input to the pool\r\n\r\nTODO:\r\n* allow the injection of auxiliary randomness, for example a signature using a long term signature key as suggested by https://eprint.iacr.org/2018/1057",
      "createdAt": "2021-03-30T07:24:37Z",
      "updatedAt": "2021-08-13T05:20:10Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "da9333b8227e969f56b6c20d63b9ff836eb79dd5",
      "headRepository": "psyoptix/mls-protocol",
      "headRefName": "improving_entropy",
      "headRefOid": "03563f74e59eb4ac9f100550ad27a9195ec32c4d",
      "closedAt": "2021-08-13T05:20:09Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing this PR as the entropy pool specification is moved to an \"implementation-considerations\" document.",
          "createdAt": "2021-08-13T05:20:09Z",
          "updatedAt": "2021-08-13T05:20:09Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 469,
      "id": "MDExOlB1bGxSZXF1ZXN0NjMwNzI2ODk3",
      "title": "Fix typos in the \"IANA Considerations\" section",
      "url": "https://github.com/mlswg/mls-protocol/pull/469",
      "state": "MERGED",
      "author": "TWal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I noticed a bunch of typos in the \"IANA Considerations\" section: the \"ciphersuites\" and \"credentials\" were probably copy-pasted from the \"extension\" one, and some parts were not changed correctly.\r\n\r\nThis PR fixes these typos.",
      "createdAt": "2021-05-05T16:11:11Z",
      "updatedAt": "2021-06-23T10:22:09Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "da9333b8227e969f56b6c20d63b9ff836eb79dd5",
      "headRepository": "TWal/mls-protocol",
      "headRefName": "twal_iana_typos",
      "headRefOid": "a7e2fec4adc29fc2d7b05b4f6d580ea92b311174",
      "closedAt": "2021-06-23T10:22:02Z",
      "mergedAt": "2021-06-23T10:22:02Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "8216b7904caa54a822202863f38f3a9956e30388"
      },
      "comments": [
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed 20210526 Interim: editorial will be taken up by editors.",
          "createdAt": "2021-05-26T15:48:02Z",
          "updatedAt": "2021-05-26T15:48:02Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Thanks!",
          "createdAt": "2021-06-23T10:22:09Z",
          "updatedAt": "2021-06-23T10:22:09Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 471,
      "id": "MDExOlB1bGxSZXF1ZXN0NjQ2NzMzNjc2",
      "title": "Use HPKE draft-08",
      "url": "https://github.com/mlswg/mls-protocol/pull/471",
      "state": "MERGED",
      "author": "franziskuskiefer",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "draft-08 is the latest HPKE draft, which should be stable. It is also what's being used for interop testing right now.",
      "createdAt": "2021-05-18T13:03:50Z",
      "updatedAt": "2021-05-26T15:48:32Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "da9333b8227e969f56b6c20d63b9ff836eb79dd5",
      "headRepository": "franziskuskiefer/mls-protocol",
      "headRefName": "patch-3",
      "headRefOid": "4e4bd1eb168c1165bbfdec7203ebe29334a70c2f",
      "closedAt": "2021-05-26T15:48:27Z",
      "mergedAt": "2021-05-26T15:48:27Z",
      "mergedBy": "raphaelrobert",
      "mergeCommit": {
        "oid": "05fe1daacd66006f600869f6bc05bc9efb1530ed"
      },
      "comments": [
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed 20210526 Interim: Merge.",
          "createdAt": "2021-05-26T15:48:32Z",
          "updatedAt": "2021-05-26T15:48:32Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY5MjA1Njcx",
          "commit": {
            "abbreviatedOid": "4e4bd1e"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-26T15:48:31Z",
          "updatedAt": "2021-05-26T15:48:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 474,
      "id": "MDExOlB1bGxSZXF1ZXN0NjkyNjk5MTQ4",
      "title": "Explicit blank cases in MLSPlaintextTBS",
      "url": "https://github.com/mlswg/mls-protocol/pull/474",
      "state": "MERGED",
      "author": "eiqo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The  `select` based on `MLSPlaintextTBS.sender.sender_type` seems ambiguous, as it does not state what happens to cases other than `member`. The TLS presentation language does not say anything on the matter.",
      "createdAt": "2021-07-19T15:16:10Z",
      "updatedAt": "2021-07-19T15:46:19Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "5c5663ca170c7a7bee73395cee42468e271479b7",
      "headRepository": "eiqo/mls-protocol",
      "headRefName": "blank",
      "headRefOid": "88de926913e2add40e4ee320925b220752998d29",
      "closedAt": "2021-07-19T15:46:19Z",
      "mergedAt": "2021-07-19T15:46:19Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "3c690fdc85114061b98ec56e3a6c605de0706d4d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA5Njc2MzM0",
          "commit": {
            "abbreviatedOid": "88de926"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-19T15:17:28Z",
          "updatedAt": "2021-07-19T15:17:28Z",
          "comments": []
        }
      ]
    },
    {
      "number": 475,
      "id": "MDExOlB1bGxSZXF1ZXN0NjkzNTMyNzc4",
      "title": "Clarify signature encoding",
      "url": "https://github.com/mlswg/mls-protocol/pull/475",
      "state": "MERGED",
      "author": "franziskuskiefer",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The spec doesn't say anything about the signature encoding yet.\r\nThis PR adds a paragraph clarifying that signature encoding is done like in TLS.",
      "createdAt": "2021-07-20T14:50:03Z",
      "updatedAt": "2021-08-19T21:09:59Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "3c690fdc85114061b98ec56e3a6c605de0706d4d",
      "headRepository": "franziskuskiefer/mls-protocol",
      "headRefName": "patch-4",
      "headRefOid": "e0b3a4ac91756e29d5277bf3654b2308be250177",
      "closedAt": "2021-08-19T21:09:59Z",
      "mergedAt": "2021-08-19T21:09:59Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "e374686f64915720914f3f663c98b47530edc039"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzEwNzY1MDY1",
          "commit": {
            "abbreviatedOid": "e2d4c76"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-20T16:07:51Z",
          "updatedAt": "2021-07-20T16:07:51Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzEwNzY5NTU1",
          "commit": {
            "abbreviatedOid": "e2d4c76"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-20T16:09:49Z",
          "updatedAt": "2021-07-20T16:10:00Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I think the CI error we're getting might require this to be `{{!RFC8446}}` (`? -> !`)\r\n",
              "createdAt": "2021-07-20T16:09:49Z",
              "updatedAt": "2021-07-20T16:10:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzExMzE0Mzc0",
          "commit": {
            "abbreviatedOid": "e0b3a4a"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-21T06:55:45Z",
          "updatedAt": "2021-07-21T06:55:45Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "There is still a '?' here.",
              "createdAt": "2021-07-21T06:55:45Z",
              "updatedAt": "2021-07-21T06:55:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzExMzE0OTY2",
          "commit": {
            "abbreviatedOid": "e0b3a4a"
          },
          "author": "franziskuskiefer",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-21T06:56:35Z",
          "updatedAt": "2021-07-21T06:56:35Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "yeah, that should be fine",
              "createdAt": "2021-07-21T06:56:35Z",
              "updatedAt": "2021-07-21T06:56:35Z"
            }
          ]
        }
      ]
    },
    {
      "number": 476,
      "id": "MDExOlB1bGxSZXF1ZXN0NzEyMzIzMDEw",
      "title": "Revisit the notion of identity in MLS groups",
      "url": "https://github.com/mlswg/mls-protocol/pull/476",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "After a discussion with @bifurcation and @raphaelrobert, this PR is a new spin on and an extension of #439.\r\n\r\nThis PR adds the `endpoint_id` field to KeyPackages. The `endpoint_id` field serves to distinguish KeyPackages with Credentials that share the value of their `identity` field.\r\n\r\nThis PR also introduces a set of restrictions for KeyPackages that introduced to the group via Adds and Updates.\r\n\r\nGenerally, for both Adds and Updates, the committer has to ensure that\r\n- signature keys are unique within a group (this is so that the sender of a message can be determined uniquely within a group),\r\n- `(identity, endpoint_id)` tuples are unique in a group,\r\n- `hpke_init_key`s are unique in a group.\r\n\r\nAdditionally, Updates have to ensure that\r\n- the new and the old key package have the same `identity` (in the Credential), `endpoint_id`, `version` and `cipher_suite` as the key package they replace,\r\n- the new and the old key package do not share the same `hpke_init_key`.\r\n\r\nI didn't extend the section indicating that the processor of a commit has to check all these things in the same way that the committer has to. I think, here we should probably restructure the section, so that we can just reference the part where it is specified how to determine if a given proposal is valid in the context of a given group.",
      "createdAt": "2021-08-13T12:33:51Z",
      "updatedAt": "2021-10-04T17:35:55Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "b9b6fa73e3973cf132d04bc125d1db4c5bff6076",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "konrad/identity_and_endpoint_id",
      "headRefOid": "f16da5a4ead63315881d938a7f8624ac1484524c",
      "closedAt": "2021-10-04T17:35:55Z",
      "mergedAt": "2021-10-04T17:35:55Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "f85e2487888703cc48e177f94878361f61e08480"
      },
      "comments": [
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank for proposing this PR, Konrad. The changes look beneficial.\r\n\r\nI have one question about the requirement for updates that the ciphersuite matches the prior ciphersuite. Currently, all group members are required to use the same ciphersuite so this requirement does not seem necessary in most cases. There is one case worth considering though that this restricts - namely that it limits the option for the entire group to roll the ciphersuite simultaneously. It would be advantageous for us to support changing of the identity key ciphersuite for the entire group, if necessary, without a full tear-down of the state. I do not think we currently specify options for this in the spec, but a ciphersuite matching requirement would inhibit the possibility.\r\n\r\n",
          "createdAt": "2021-08-16T18:49:44Z",
          "updatedAt": "2021-08-16T18:49:44Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the feedback @br-hale!\r\n\r\nI agree that the requirement for all group members to use matching ciphersuites was there before, but I couldn't find it anywhere explicitly, so I added it just to be sure. If it turns out to be redundant, I'm happy to remove it again.\r\n\r\nIf I understand your proposal correctly, rolling the ciphersuite simultaneously would require a few more changes, for a example an additional proposal to coordinate the change. If that is the case, I'd say we leave it in and remove the requirement once we add the capability for the ciphersuite rolling. A problem I see with ciphersuite rolling is that it would require everyone to change their Credential simultaneously. Although maybe we could overcome that by coordinating Update proposals? Do you want to open a new GH issue/PR so you can outline your idea and we can continue the discussion there?",
          "createdAt": "2021-08-17T05:42:33Z",
          "updatedAt": "2021-08-17T05:42:33Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "On the topic of ciphersuite change: we have a mechanism for that in 10.1:\r\n\r\n> Re-initializing an existing group may be used, for example, to restart the group with a different ciphersuite or protocol version.\r\n\r\nI would assume that the binary tree wouldn't be re-usable anyway if different crypto primitives are used so it's only a matter of preserving existing entropy and carry over group secrets to the new group which can be done through the PSK mechanism. Am I missing something here?",
          "createdAt": "2021-08-17T09:42:47Z",
          "updatedAt": "2021-08-17T09:42:47Z"
        },
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What @raphaelrobert mentions is where my comment was vectored towards. The concern would be if locking in the ciphersuite per this PR blocks that option entirely. However, it is correct that the PSK mechanism can be used for creating a new group (with new ciphersuite) that ties to the prior group and therefore bypasses the need need to roll a ciphersuite within a group. It may be a heavier change mechanism than rolling a ciphersuite would be, but it works. \r\n\r\nSince this is specifically about rolling identity keys, the rest of the tree should still be usable following a roll of the ciphersuite (signatures properties active after the next update of leaf node keys of course). But @raphaelrobert you make a good point that any such handling would then need to prevent rolling of other ciphersuite elements aside from the identity. Such changes would need careful consideration - at this point in the process, it is best not to introduce something too nuanced. So, all that said, I think we can close the question on ciphersuite matching.",
          "createdAt": "2021-08-17T18:26:41Z",
          "updatedAt": "2021-08-17T18:26:41Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I just realized that one corollary of this change is that we can now use the `(identity, endpoint_id)` tuple in the message structs and thus further reduce our dependency on any specific binary tree implementation. Something like this:\r\n\r\n```\r\nstruct {\r\n    SenderType sender_type;\r\n    opaque sender_identity;\r\n    opaque sender_endpoint_id;\r\n} Sender;\r\n```\r\nAnd similarly for the case of `MLSSenderData`, the `Remove` proposal, `MessageRange`, `PublicGroupState`, `GroupInfo` and anything else that's not immediately part of the tree primitives, at least for now.",
          "createdAt": "2021-09-15T06:47:22Z",
          "updatedAt": "2021-09-15T06:47:22Z"
        },
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed at 20211004 Interim, merge. @kkohbrok also to submit new Issue he noted.",
          "createdAt": "2021-10-04T14:36:52Z",
          "updatedAt": "2021-10-04T14:36:52Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4tzIqL",
          "commit": {
            "abbreviatedOid": "4033b10"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks, @kkohbrok this is a useful clarification.  It seems fine to handle the receiver processing in a separate PR; consolidating it as you suggest is a good idea.",
          "createdAt": "2021-09-30T21:54:26Z",
          "updatedAt": "2021-09-30T21:56:38Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Rather than say \"share\" here, it would be clearer to say that the values MUST be equal.",
              "createdAt": "2021-09-30T21:54:26Z",
              "updatedAt": "2021-09-30T21:56:38Z"
            },
            {
              "originalPosition": 31,
              "body": "Likewise below, instead of \"MUST NOT share\", \"MUST be different\".",
              "createdAt": "2021-09-30T21:54:50Z",
              "updatedAt": "2021-09-30T21:56:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4t15EU",
          "commit": {
            "abbreviatedOid": "4033b10"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-01T15:23:35Z",
          "updatedAt": "2021-10-01T15:23:36Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Agreed",
              "createdAt": "2021-10-01T15:23:35Z",
              "updatedAt": "2021-10-01T15:23:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4t15eq",
          "commit": {
            "abbreviatedOid": "4033b10"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Looks good, modulo @bifurcation's remarks",
          "createdAt": "2021-10-01T15:25:13Z",
          "updatedAt": "2021-10-01T15:25:13Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4t6v52",
          "commit": {
            "abbreviatedOid": "bdccfab"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-04T14:29:13Z",
          "updatedAt": "2021-10-04T14:29:13Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4t7i62",
          "commit": {
            "abbreviatedOid": "f16da5a"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-04T17:35:10Z",
          "updatedAt": "2021-10-04T17:35:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 477,
      "id": "MDExOlB1bGxSZXF1ZXN0NzEzNjc0OTU0",
      "title": "Signal the intended wire format for MLS messages",
      "url": "https://github.com/mlswg/mls-protocol/pull/477",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": " @kkohbrok pointed out to me that there's currently no way for a DS to distinguish between MLSPlaintext and MLSCiphertext messages.  Obviously, an application could provide a flag on the outside of a message, but there are a few relatively minor benefits to including a flag in MLS:\r\n \r\n * Signing the flag authenticates the sender's intent\r\n * Including the flag in the transcript confirms that all group members got it in the same format\r\n * Including the flag in the struct provides a clear signal as to whether the `membership_tag` needs to be present/verified\r\n\r\nSince these benefits are pretty minor, I could kind of go either way on whether to make this change.  But it seemed worth writing up a PR to see what the change would look like.",
      "createdAt": "2021-08-16T19:04:01Z",
      "updatedAt": "2021-10-04T17:38:06Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "3c690fdc85114061b98ec56e3a6c605de0706d4d",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "wire-format",
      "headRefOid": "09cab5e68e4f61bded85be5a41940fbc8d4e0c74",
      "closedAt": "2021-10-04T17:38:06Z",
      "mergedAt": "2021-10-04T17:38:06Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "b49d1567b2560f8d2ce3b36e29f0db4b59b27d94"
      },
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My original intention was not for the DS to distinguish the message types, but also for a receiving client. Even if there's a group policy that dictates whether to encrypt handshake messages, the client won't know how to parse a message, because the `content_type` fields on plaintext and ciphertext are not aligned in the two structs. So I think fixing that would be the low-hanging fruit.\r\n\r\nThat being said, I agree with @bifurcation that it would be neat to have a flag that signals the encryption status, but also communicates the sender's intent in a cryptographically authenticated manner.",
          "createdAt": "2021-08-17T05:51:07Z",
          "updatedAt": "2021-08-17T05:54:30Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I agree with your reasoning and I think it's worthwhile doing.\r\n\r\nThe only part that is not straight forward for me is this:\r\n\r\n> Including the flag in the struct provides a clear signal as to whether the membership_tag needs to be present/verified\r\n\r\nIf the sender is of type `external` the `membership_tag` also doesn't need to be present for an `MLSPlaintext`. This should either be clarified, or we could have a third wire format for external senders.",
          "createdAt": "2021-08-17T09:34:39Z",
          "updatedAt": "2021-08-17T09:34:39Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Re: `external` -- there isn't an `external` sender type, but there are `new_member` and `preconfigured`.  You're correct that in both of those cases, the `membership_tag` shouldn't be populated.  The signal in this PR helps distinguish the two cases when `sender_type == member`.",
          "createdAt": "2021-08-19T21:04:41Z",
          "updatedAt": "2021-08-19T21:04:41Z"
        },
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed at 20211004 interim, merge.",
          "createdAt": "2021-10-04T14:40:04Z",
          "updatedAt": "2021-10-04T14:40:04Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4tRQpr",
          "commit": {
            "abbreviatedOid": "09cab5e"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-21T09:15:41Z",
          "updatedAt": "2021-09-21T09:15:41Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4t16Ev",
          "commit": {
            "abbreviatedOid": "09cab5e"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-01T15:27:38Z",
          "updatedAt": "2021-10-01T15:27:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 478,
      "id": "MDExOlB1bGxSZXF1ZXN0NzE2MjcxNjUz",
      "title": "Inject GroupContext as HPKE info instead of AAD",
      "url": "https://github.com/mlswg/mls-protocol/pull/478",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #470 ",
      "createdAt": "2021-08-19T21:22:48Z",
      "updatedAt": "2021-10-04T17:38:24Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "e374686f64915720914f3f663c98b47530edc039",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "aad-to-info",
      "headRefOid": "a42cdaaed2aa6dcc8b5a7a77c93074105c197c10",
      "closedAt": "2021-10-04T17:38:24Z",
      "mergedAt": "2021-10-04T17:38:24Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "0262671c433cc468c01f860c42c14d7830d94e35"
      },
      "comments": [
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed at 20211004 interim, merge.",
          "createdAt": "2021-10-04T14:42:06Z",
          "updatedAt": "2021-10-04T14:42:06Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM0NzMwOTgz",
          "commit": {
            "abbreviatedOid": "a42cdaa"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-20T07:04:03Z",
          "updatedAt": "2021-08-20T07:04:03Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4t16Pk",
          "commit": {
            "abbreviatedOid": "a42cdaa"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-01T15:28:17Z",
          "updatedAt": "2021-10-01T15:28:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 479,
      "id": "MDExOlB1bGxSZXF1ZXN0NzE2MjgyODI1",
      "title": "Clarify extension handling and make extension updatable",
      "url": "https://github.com/mlswg/mls-protocol/pull/479",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #473 ",
      "createdAt": "2021-08-19T21:44:15Z",
      "updatedAt": "2021-10-04T19:47:55Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "28195f529017a726f6f3c34700176f6e3f44f9ae",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "separate-extensions",
      "headRefOid": "75707ea95d6d0f6376b347b2c17f3303dec23f29",
      "closedAt": "2021-10-04T19:47:55Z",
      "mergedAt": "2021-10-04T19:47:55Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "2eb85927d4159c59c4b5ca1efc2de9142ddaa282"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@kkohbrok r?",
          "createdAt": "2021-08-19T21:44:43Z",
          "updatedAt": "2021-08-19T21:44:43Z"
        },
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed at 20211004 interim, ready to merge after adding some additional detail about when to use one or the other.",
          "createdAt": "2021-10-04T14:53:04Z",
          "updatedAt": "2021-10-04T14:53:04Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM0NzMyMTAw",
          "commit": {
            "abbreviatedOid": "8a39486"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-20T07:05:51Z",
          "updatedAt": "2021-08-20T07:13:56Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Something seems to be missing here.",
              "createdAt": "2021-08-20T07:05:51Z",
              "updatedAt": "2021-08-20T07:13:56Z"
            },
            {
              "originalPosition": 109,
              "body": "```suggestion\r\n      `confirmed_transcript_hash`, and `group_context_extensions` fields from\r\n```",
              "createdAt": "2021-08-20T07:12:23Z",
              "updatedAt": "2021-08-20T07:13:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzUwNjg0ODI0",
          "commit": {
            "abbreviatedOid": "8a39486"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-09T18:23:06Z",
          "updatedAt": "2021-09-09T18:23:06Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "\"interim transcript hash\", apparently.",
              "createdAt": "2021-09-09T18:23:06Z",
              "updatedAt": "2021-09-09T18:23:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4tRQW-",
          "commit": {
            "abbreviatedOid": "dc9a186"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-21T09:14:32Z",
          "updatedAt": "2021-09-21T09:14:32Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4t18MH",
          "commit": {
            "abbreviatedOid": "dc9a186"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-01T15:36:04Z",
          "updatedAt": "2021-10-01T15:36:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 480,
      "id": "MDExOlB1bGxSZXF1ZXN0NzE2MjkxOTkx",
      "title": "Improve extensibility of Proposals",
      "url": "https://github.com/mlswg/mls-protocol/pull/480",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@psyoptix pointed out to me some improvements that could be made in the extensibility of proposals.  This PR makes a few changes to smooth out deployment of new proposals:\r\n\r\n* Extends `ProposalType` to two bytes, creates an IANA registry, and reserves some space for private use\r\n* Extends the `capabilities` extension so that clients can indicate which proposal types they support\r\n* Forbids committers from including proposals that some people don't support",
      "createdAt": "2021-08-19T22:03:48Z",
      "updatedAt": "2021-10-04T18:02:20Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "e374686f64915720914f3f663c98b47530edc039",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "vendor-space",
      "headRefOid": "fc217c7ae29d7bfd6754074849ffc04167a9303e",
      "closedAt": "2021-10-04T18:02:20Z",
      "mergedAt": "2021-10-04T18:02:20Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "32014e605898b23b10622d8074958861ffe002b1"
      },
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "Just for context: This PR addresses the second part of #473.",
          "createdAt": "2021-10-01T15:40:46Z",
          "updatedAt": "2021-10-01T15:40:46Z"
        },
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed. Looks good.",
          "createdAt": "2021-10-04T14:40:00Z",
          "updatedAt": "2021-10-04T14:40:00Z"
        },
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed at 20211004 interim, merge.",
          "createdAt": "2021-10-04T14:52:39Z",
          "updatedAt": "2021-10-04T14:52:39Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM0NzM5MjYy",
          "commit": {
            "abbreviatedOid": "fc217c7"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good to me!",
          "createdAt": "2021-08-20T07:16:39Z",
          "updatedAt": "2021-08-20T07:16:39Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4t19IP",
          "commit": {
            "abbreviatedOid": "fc217c7"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-01T15:39:46Z",
          "updatedAt": "2021-10-01T15:39:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 481,
      "id": "MDExOlB1bGxSZXF1ZXN0NzE2MzIyNjg2",
      "title": "Constrain proposal in External Commit",
      "url": "https://github.com/mlswg/mls-protocol/pull/481",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #443 ",
      "createdAt": "2021-08-19T23:12:45Z",
      "updatedAt": "2021-10-11T19:25:36Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "e277f4187aa8e2af9da5b57fbbf7b909faf1edc8",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "constrain-external-commit",
      "headRefOid": "73e0ad7154c8d3f108460489ab22e974231f4277",
      "closedAt": "2021-10-11T19:25:36Z",
      "mergedAt": "2021-10-11T19:25:36Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "2bc4ae1f4ba1a4fe81852e101e17ac0550897a91"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@br-hale @kkohbrok r?",
          "createdAt": "2021-08-19T23:13:05Z",
          "updatedAt": "2021-08-19T23:13:05Z"
        },
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed at 20211004 interim, remove resynch with a single op (external join + remove in one op).\r\n\r\n@bifurcation research why resynch was dropped.",
          "createdAt": "2021-10-04T15:13:57Z",
          "updatedAt": "2021-10-04T15:13:57Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM0NTc3NDUz",
          "commit": {
            "abbreviatedOid": "6276990"
          },
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-20T00:43:48Z",
          "updatedAt": "2021-08-20T00:43:48Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I am not adverse to a resync option. However, this was in the original PR for PSKs, discussed by the group then removed. At that time it was called \"recover\" (original WG brief) and later \"resumption\". There was fairly extensive discussion on it, so we should probably double-check what was kept/removed and why in the mailinglist and meeting notes before re-introducing this. @kkohbrok do you recall why the WG moved against that?",
              "createdAt": "2021-08-20T00:43:48Z",
              "updatedAt": "2021-08-20T00:54:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM0NTgwODAy",
          "commit": {
            "abbreviatedOid": "6276990"
          },
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-20T00:53:58Z",
          "updatedAt": "2021-08-20T00:53:59Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "We would need to require that the prior identity (if there was prior membership) is removed. The proposer should do this - so maybe mandating a \"must\" for including a remove proposal if resyncing. Basically, the group should not end up with duplication of the identity (and potential backdoor). It is also inefficient for healing as Alice needs to replace keys at both nodes if both of the \"Alice\" identities are allowed to stay.\r\n\r\nThis is presents a question for handling sub-identities (if Alice has multiple devices and the identity is linked to Alice vs. a device). In that case an Add proposal for extra devices could include a PSK derived from the group, but the group will never know which device Alice is using (since the identity is the same). So what is the assumption here with respect to multi-device handling? ",
              "createdAt": "2021-08-20T00:53:58Z",
              "updatedAt": "2021-08-20T00:53:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM0NTgzMTMz",
          "commit": {
            "abbreviatedOid": "6276990"
          },
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-20T01:01:31Z",
          "updatedAt": "2021-08-20T01:01:31Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Actually (after tracing through PRs/issue comments) the \"resumption\" part was kept as a separate key from the key schedule, but downgraded from use as group \"recovery\" and applied strictly to branch/reinit. PR #421 shows the changed text. I recall the decision being made in the WG after discussion, with reasons presented by @raphaelrobert and @bifurcation. I do not recall the reasons, unfortunately, but maybe someone else does. ",
              "createdAt": "2021-08-20T01:01:31Z",
              "updatedAt": "2021-08-20T16:48:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM0NzQ3Mzk4",
          "commit": {
            "abbreviatedOid": "6276990"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-20T07:27:46Z",
          "updatedAt": "2021-08-20T07:30:01Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "I believe PR #476 would allow us to check both user _and_ device identity. But of course this depends on how the application implements multi-device. They could user a different `identity` for each device, or a different `endpoint_id` or both.",
              "createdAt": "2021-08-20T07:27:46Z",
              "updatedAt": "2021-08-20T07:30:01Z"
            },
            {
              "originalPosition": 15,
              "body": "I'm afraid, I can't recall the reasons either. I still think this might be useful to have, though.",
              "createdAt": "2021-08-20T07:29:05Z",
              "updatedAt": "2021-08-20T07:30:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4t1-6O",
          "commit": {
            "abbreviatedOid": "4121e93"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-10-01T15:47:19Z",
          "updatedAt": "2021-10-01T15:48:14Z",
          "comments": [
            {
              "originalPosition": 80,
              "body": "Maybe worth noting that resumption secrets can be optionally used to mitigate the signature key compromise in the \"resync\" scenario.",
              "createdAt": "2021-10-01T15:47:19Z",
              "updatedAt": "2021-10-01T15:48:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4uEfSJ",
          "commit": {
            "abbreviatedOid": "73e0ad7"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-06T15:54:45Z",
          "updatedAt": "2021-10-06T15:54:45Z",
          "comments": [
            {
              "originalPosition": 80,
              "body": "This is suggested (with trade-offs) in the latest commit.",
              "createdAt": "2021-10-06T15:54:45Z",
              "updatedAt": "2021-10-06T15:54:45Z"
            }
          ]
        }
      ]
    },
    {
      "number": 483,
      "id": "MDExOlB1bGxSZXF1ZXN0NzE2MzI1NjA0",
      "title": "Remove OPEN ISSUEs and TODOs",
      "url": "https://github.com/mlswg/mls-protocol/pull/483",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Most of these were stale; see comments for more specifics.  I opened #482 as a general issue arising from the final TODO.",
      "createdAt": "2021-08-19T23:20:13Z",
      "updatedAt": "2021-10-04T18:40:48Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "e374686f64915720914f3f663c98b47530edc039",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "open-issues",
      "headRefOid": "f1b49e7c8ef3400f88802d3a26d3107c96a65daa",
      "closedAt": "2021-10-04T18:40:48Z",
      "mergedAt": "2021-10-04T18:40:48Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "28195f529017a726f6f3c34700176f6e3f44f9ae"
      },
      "comments": [
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed at 20211004 interim, will merge after adding text in comment.\r\n\r\n@kkohbrok create new issue for multiple PSKs and PR for cascading HKDF.",
          "createdAt": "2021-10-04T15:27:34Z",
          "updatedAt": "2021-10-04T15:27:34Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM0NTQ3MzAw",
          "commit": {
            "abbreviatedOid": "75bfe61"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-19T23:21:19Z",
          "updatedAt": "2021-09-09T18:20:33Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "There's no notion of a PSK lifetime in the spec, so I'm not sure what this one is talking about.",
              "createdAt": "2021-08-19T23:21:19Z",
              "updatedAt": "2021-09-09T18:20:33Z"
            },
            {
              "originalPosition": 20,
              "body": "Same here for \"security level\".",
              "createdAt": "2021-08-19T23:21:40Z",
              "updatedAt": "2021-09-09T18:20:33Z"
            },
            {
              "originalPosition": 30,
              "body": "A combination algorithm is given above.  If we don't believe it has this property, we should fix it.",
              "createdAt": "2021-08-19T23:22:03Z",
              "updatedAt": "2021-09-09T18:20:33Z"
            },
            {
              "originalPosition": 40,
              "body": "Nobody has asked for this feature, and it can be added in an extension.",
              "createdAt": "2021-08-19T23:22:27Z",
              "updatedAt": "2021-09-09T18:20:33Z"
            },
            {
              "originalPosition": 50,
              "body": "The text already talks about keeping key/nonce pairs (not secrets), which is the right way to do it.  Beyond that, there's not much to say; reordering policy is up to the application.",
              "createdAt": "2021-08-19T23:23:24Z",
              "updatedAt": "2021-09-09T18:20:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4tROp4",
          "commit": {
            "abbreviatedOid": "75bfe61"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-21T09:07:32Z",
          "updatedAt": "2021-09-21T09:12:47Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "It's not in the spec per-se, but external PSKs can have a lifetime (as mentioned in the paragraph above) and this TODO suggests that we might want to clarify that there is a difference in the security guarantees of injecting a PSK vs. doing an update, depending on the lifetime of the PSK.",
              "createdAt": "2021-09-21T09:07:32Z",
              "updatedAt": "2021-09-21T09:12:47Z"
            },
            {
              "originalPosition": 20,
              "body": "\"security level\" is actually mentioned in the spec as a property of the ciphersuite.",
              "createdAt": "2021-09-21T09:08:38Z",
              "updatedAt": "2021-09-21T09:12:47Z"
            },
            {
              "originalPosition": 30,
              "body": "I don't think the security of the algorithm above an be reduced to a \"standard assumption\". This would be what the nKDF approach by @chrisbrzuska was for. I believe we discussed this in the group as a general approach for the key schedule, but then decided against it. There is a (somewhat) standard assumption for doing this with two keys (which we need for key schedule security), but I don't think anyone has claimed this for `n` keys.",
              "createdAt": "2021-09-21T09:12:09Z",
              "updatedAt": "2021-09-21T09:12:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4t1gmx",
          "commit": {
            "abbreviatedOid": "75bfe61"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-01T13:55:31Z",
          "updatedAt": "2021-10-01T13:55:31Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Proposed additional paragraph: \r\n\r\n> Unlike the key pairs injected in an Update or Commit, which always freshly generated, PSKs may be pre-distributed and stored.  This creates the risk that a PSK may be compromised in the process of distribution and storage.   The security that the group gets from injecting a PSK thus depends on both the entropy of the PSK and the risk of compromise.  These factors are outside of the scope of this document, but should be considered by application designers relying on PSKs.",
              "createdAt": "2021-10-01T13:55:31Z",
              "updatedAt": "2021-10-01T13:55:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4t1gsg",
          "commit": {
            "abbreviatedOid": "75bfe61"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-01T13:55:53Z",
          "updatedAt": "2021-10-01T13:55:53Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "This should be addressed by the below proposed paragraph.",
              "createdAt": "2021-10-01T13:55:53Z",
              "updatedAt": "2021-10-01T13:55:53Z"
            }
          ]
        }
      ]
    },
    {
      "number": 484,
      "id": "MDExOlB1bGxSZXF1ZXN0NzE2MzMzMjcz",
      "title": "Clarify node vs. leaf indices",
      "url": "https://github.com/mlswg/mls-protocol/pull/484",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #432 ",
      "createdAt": "2021-08-19T23:43:02Z",
      "updatedAt": "2021-10-04T19:50:48Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "e374686f64915720914f3f663c98b47530edc039",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "node-type",
      "headRefOid": "a9ab8f675e0a050a606fa05e66f5b9ceb29a1382",
      "closedAt": "2021-10-04T19:50:48Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed at 20211004 interim, will be reworked to remove leaf indices. And, be consistent through I-D.",
          "createdAt": "2021-10-04T15:35:23Z",
          "updatedAt": "2021-10-04T15:35:23Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Replaced by #487 ",
          "createdAt": "2021-10-04T19:50:48Z",
          "updatedAt": "2021-10-04T19:50:48Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM0NzQxMjM2",
          "commit": {
            "abbreviatedOid": "d54dcfe"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "This certainly helps making thinks a bit clearer. I'd still feel better if we got rid of the notion of a \"leaf index\" entirely, though.",
          "createdAt": "2021-08-20T07:19:32Z",
          "updatedAt": "2021-08-20T07:23:26Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "Could you elaborate what hat are \"i\" and \"n\" supposed to mean here? Or are those just typos?",
              "createdAt": "2021-08-20T07:19:32Z",
              "updatedAt": "2021-08-20T07:23:26Z"
            },
            {
              "originalPosition": 130,
              "body": "Maybe mark the `sender` field in `MLSSenderData` as of type `// leaf index`?",
              "createdAt": "2021-08-20T07:20:57Z",
              "updatedAt": "2021-08-20T07:23:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzUwNjgxNjQx",
          "commit": {
            "abbreviatedOid": "d54dcfe"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-09T18:19:24Z",
          "updatedAt": "2021-09-09T18:19:25Z",
          "comments": [
            {
              "originalPosition": 130,
              "body": "Good idea.  I think this paragraph is unnecessary anyway.",
              "createdAt": "2021-09-09T18:19:24Z",
              "updatedAt": "2021-09-09T18:19:25Z"
            }
          ]
        }
      ]
    },
    {
      "number": 487,
      "id": "PR_kwDOBoyH6c4sqIva",
      "title": "Remove the notion of a 'leaf index'",
      "url": "https://github.com/mlswg/mls-protocol/pull/487",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "After discussion at the interim 2021-10-04, there seemed to be agreement to move from having two sets of indices (leaf and node indices) to just using node indices.  The main impact of this is that wherever there is a node index in the protocol that is only ever supposed to refer to a leaf node (`Remove.removed`, `GroupInfo.signer_index`, `MLSPlaintext.sender.sender`, `PublicGroupState.signer_index`), the recipient of the message needs to verify that the node index is actually a leaf.  However, implementations already needed to check that these fields were populated leaves, so the change should be minor.\r\n\r\nImplementations that were using typed message structures to separate node and leaf indices can continue to use those types to assure that validation is done.  They'll just have to multiply by two on serialize and divide on deserialize if they use leaf indices as before internally.\r\n\r\nThere are also a couple of small, unrelated, \"drive-by\" fixes in here:\r\n* Clean up of notation in the ratchet tree section\r\n* Including PublicGroupState signer index in signature (in parallel with GroupInfo)\r\n\r\nReplaces #484 \r\nFixes #432 ",
      "createdAt": "2021-10-04T19:32:25Z",
      "updatedAt": "2021-10-11T19:11:28Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "28195f529017a726f6f3c34700176f6e3f44f9ae",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "only-node-index",
      "headRefOid": "508e8a302a631969285d31140f0887441312006c",
      "closedAt": "2021-10-11T19:11:21Z",
      "mergedAt": "2021-10-11T19:11:21Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "c54fedf5191c0a427a12e8fc257d4841eff22d63"
      },
      "comments": [
        {
          "author": "rohan-wire",
          "authorAssociation": "NONE",
          "body": "I think we should still use \"node index\" instead of just \"index\" for clarity.",
          "createdAt": "2021-10-05T13:37:59Z",
          "updatedAt": "2021-10-05T13:37:59Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "NONE",
          "body": "I am concerned that concatenating the children to get the name of a node becomes awkward with blank nodes. As we already have the node index, why not just use it to identify non-leaf nodes?\r\n~~~~~\r\n           7 (root)\r\n           /      \\\r\n          /        \\\r\n         /          \\\r\n      3              11\r\n    /    \\          /  \\\r\n   /      \\        /    |\r\n  1       5       9     |\r\n / \\     / \\     / \\    |\r\nA   B   _   D   E   F   G\r\n\r\n                    1 1 1\r\n0 1 2 3 4 5 6 7 8 9 0 1 2\r\n~~~~~\r\n\r\nThis prevents node 5 from being D or _D\r\n",
          "createdAt": "2021-10-05T13:44:41Z",
          "updatedAt": "2021-10-05T13:44:41Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fair enough.  It also helps emphasize that parent nodes are of a different character than leaf nodes.  Just pushed a commit with numeric parent node labels and otherwise improved ASCII art.",
          "createdAt": "2021-10-05T14:34:36Z",
          "updatedAt": "2021-10-05T14:34:36Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4t9Ix6",
          "commit": {
            "abbreviatedOid": "efa1dd8"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-05T05:49:49Z",
          "updatedAt": "2021-10-05T05:49:49Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4uMwzY",
          "commit": {
            "abbreviatedOid": "7a28c80"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "LGTM in general! It might be worth specifying in the tree math section that the number of leaves in a tree is `(n_nodes + 1) / 2`, where `n_nodes` is the total number of nodes in the tree. Some functions like `root` take the number of leaves as an argument and this might now be confusing.",
          "createdAt": "2021-10-08T14:38:00Z",
          "updatedAt": "2021-10-08T14:38:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 488,
      "id": "PR_kwDOBoyH6c4sqMdF",
      "title": "Add group_context_extensions proposal ID",
      "url": "https://github.com/mlswg/mls-protocol/pull/488",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Accidental omission in #479 ",
      "createdAt": "2021-10-04T19:56:47Z",
      "updatedAt": "2021-10-04T19:57:51Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "2eb85927d4159c59c4b5ca1efc2de9142ddaa282",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "group-context-extensions",
      "headRefOid": "570320df72c932e80109a8296efd94c2f242e35d",
      "closedAt": "2021-10-04T19:57:51Z",
      "mergedAt": "2021-10-04T19:57:51Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "b7a741e3d2b48252d3f005274d93d2e4212bcf12"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 489,
      "id": "PR_kwDOBoyH6c4sqSFX",
      "title": "Add RequiredCapabilities extension",
      "url": "https://github.com/mlswg/mls-protocol/pull/489",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR adds a RequiredCapabilities extension that allows the members of a group to impose a requirement that new joiners support certain capabilities.  The extension is carried in the GroupContext and verified at Add time (including on external commits).\r\n\r\nIn the interim 2021-10-04, we briefly discussed whether this mechanism needed to be included in the core protocol.  Because of its interactions with Add and GroupContextExtensions proposals, it seems worth having in the main protocol.\r\n\r\nFixes #485 ",
      "createdAt": "2021-10-04T20:26:48Z",
      "updatedAt": "2021-10-11T19:25:20Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "b7a741e3d2b48252d3f005274d93d2e4212bcf12",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "required-extensions",
      "headRefOid": "7f4be72694eea252f54cddab1fb0b141e47a7c4f",
      "closedAt": "2021-10-11T19:25:20Z",
      "mergedAt": "2021-10-11T19:25:19Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "fb1043e8699af9562a1ba0a6d0d0210072c252bf"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4uM5TW",
          "commit": {
            "abbreviatedOid": "bd1a633"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-08T15:09:35Z",
          "updatedAt": "2021-10-08T15:15:40Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "```suggestion\r\nall members of the group.  For new members, it is enforced by existing members during the\r\n```",
              "createdAt": "2021-10-08T15:09:35Z",
              "updatedAt": "2021-10-08T15:15:40Z"
            }
          ]
        }
      ]
    },
    {
      "number": 490,
      "id": "PR_kwDOBoyH6c4sqTVa",
      "title": "Use cascaded KDF instead of concatenation to consolidate PSKs",
      "url": "https://github.com/mlswg/mls-protocol/pull/490",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In #483, @kkohbrok noted that the concatenation approach used to combine multiple PSKs is not well validated.  At the 2021-10-04 interim, we discussed moving from this approach to a \"cascaded HKDF\" approach, with the idea of doing the same thing here as the main key schedule.  This PR implements that suggestion.\r\n\r\nOne nice implication of the algorithm here is that when there are no PSKs, it produces the zero vector as a degenerate case.  So you could implement it pretty cleanly:\r\n\r\n```\r\npsk_secret = 0\r\nfor psk in psks:\r\n    psk_secret = kdf.extract(psk_secret, extract_expand_psk(psk))\r\n\r\n# Inject psk_secret into key schedule\r\n```",
      "createdAt": "2021-10-04T20:34:00Z",
      "updatedAt": "2021-10-11T19:02:20Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "b7a741e3d2b48252d3f005274d93d2e4212bcf12",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "cascade-hkdf",
      "headRefOid": "3e677773c60836d901c6ed431a342e7b2cd94ce6",
      "closedAt": "2021-10-11T19:02:20Z",
      "mergedAt": "2021-10-11T19:02:20Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "16d8d64a06a7dbc469c90b09d821e00140eed11a"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixes #493 ",
          "createdAt": "2021-10-11T14:29:57Z",
          "updatedAt": "2021-10-11T14:29:57Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4t9Hp0",
          "commit": {
            "abbreviatedOid": "20801e5"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Looks good with a small proposed addition.",
          "createdAt": "2021-10-05T05:40:04Z",
          "updatedAt": "2021-10-05T05:44:41Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\npsk_input_[i] = ExpandWithLabel(psk_extracted_[i], sprintf(\"derived psk %i\", i), PSKLabel, KDF.Nh)\r\n```\r\nTo err on the side of caution, I'd like to bake the structure of the cascade into the keys themselves. This ensures that you can't \"extend\" a cascade by taking the result of a cascade and use it to start a new one. Not something that would happen in the wild, I think, but it makes proofs easier and doesn't cost anything. The simple implementation you suggest would still work, you just have to add a counter.\r\n\r\n(Not sure if the suggested line above is probably not what we want in the spec, but I think you understand what I mean.)",
              "createdAt": "2021-10-05T05:40:05Z",
              "updatedAt": "2021-10-05T05:44:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4t-1lq",
          "commit": {
            "abbreviatedOid": "20801e5"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T13:28:44Z",
          "updatedAt": "2021-10-05T13:28:44Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "`n` and `i` are actually already included here, via the PSKLabel struct.  So I think we already have this property.",
              "createdAt": "2021-10-05T13:28:44Z",
              "updatedAt": "2021-10-05T13:28:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4t_P0b",
          "commit": {
            "abbreviatedOid": "20801e5"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T14:47:31Z",
          "updatedAt": "2021-10-05T14:47:31Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Ah, you are right, of course. Feel free to mark as resolved.",
              "createdAt": "2021-10-05T14:47:31Z",
              "updatedAt": "2021-10-05T14:48:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4uGiO5",
          "commit": {
            "abbreviatedOid": "20801e5"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-07T05:44:56Z",
          "updatedAt": "2021-10-07T05:44:56Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4uNMUP",
          "commit": {
            "abbreviatedOid": "20801e5"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-08T16:30:33Z",
          "updatedAt": "2021-10-08T16:30:33Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4uRaVu",
          "commit": {
            "abbreviatedOid": "3e67777"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "One brief comment, otherwise looks good!",
          "createdAt": "2021-10-11T14:38:02Z",
          "updatedAt": "2021-10-11T14:38:52Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "... of length `KDF.n`. (?)",
              "createdAt": "2021-10-11T14:38:03Z",
              "updatedAt": "2021-10-11T14:38:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4uRde9",
          "commit": {
            "abbreviatedOid": "3e67777"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-11T14:49:25Z",
          "updatedAt": "2021-10-11T14:49:26Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "We specify the length just a couple of paragraphs above (\"Here `0` represents...\"), so I thought it was clear enough to leave it out here.",
              "createdAt": "2021-10-11T14:49:25Z",
              "updatedAt": "2021-10-11T14:49:26Z"
            }
          ]
        }
      ]
    },
    {
      "number": 491,
      "id": "PR_kwDOBoyH6c4srU9H",
      "title": "Use key package hash to index clients in message structs",
      "url": "https://github.com/mlswg/mls-protocol/pull/491",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR changes the message structs such that clients are now represented by the following struct instead of leaf indices:\r\n\r\n```\r\nstruct {\r\n    opaque sender_identity;\r\n    opaque sender_endpoint_id;\r\n} Client\r\n```\r\n\r\nI called the struct `Client`, as opposed to `Member` or `GroupMember`, since there are places where group membership first needs to be verified. Let me know what your thoughts are! \r\n\r\nFixes #486.",
      "createdAt": "2021-10-05T06:38:15Z",
      "updatedAt": "2021-10-11T19:21:47Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "c54fedf5191c0a427a12e8fc257d4841eff22d63",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "identity_in_msg_structs",
      "headRefOid": "ab1e23ae57a7699e097fea160268bcdc7d19c09d",
      "closedAt": "2021-10-11T19:21:47Z",
      "mergedAt": "2021-10-11T19:21:47Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "df3d41e4b6a02401b0a9d9d08bad1c81de8bc60f"
      },
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I've made another pass, integrating a lot of your feedback and suggestions. I did not touch the proposal processing restriction yet. We could mandate that one can't update and then remove, but I think a cleaner way would be to say that the KeyPackageID always refers to the tree of the last epoch, not the provisional tree. Let me know what you think!",
          "createdAt": "2021-10-07T10:06:00Z",
          "updatedAt": "2021-10-07T10:06:00Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4t-_9s",
          "commit": {
            "abbreviatedOid": "002cf1b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T14:00:22Z",
          "updatedAt": "2021-10-05T14:09:35Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "The bloat induced by this makes me pretty sad, and relying on just these two fields seems a little brittle.\r\n\r\nAs an alternative, what about using a hash of the leaf KeyPackage?:\r\n* We only care about exact equality of these things, so we could use a hash of these values.  That also has the benefit of revealing less information on the wire.\r\n* We only care about populated leaves, which contain a KeyPackage\r\n* We already need `KeyPackage.hash()` for purposes of building/processing Welcome messages\r\n\r\nThat would get you down to the more compact:\r\n\r\n```\r\nuint8 KeyPackageID<0..255>;\r\n```\r\n\r\nI would be slightly happier if it were a fixed-length value and shorter than a hash output.  It's tempting to propose truncating the hash down to 128 bits, which seems unlikely to result in collisions in any practical scenario.  If it is fixed-length, you could have a nice compact value:\r\n\r\n```\r\nuint8 KeyPackageID[16];\r\n```",
              "createdAt": "2021-10-05T14:00:22Z",
              "updatedAt": "2021-10-05T14:09:35Z"
            },
            {
              "originalPosition": 12,
              "body": "I don't think this quite works.  Remember that we have multiple sender types to accommodate: `member`, `preconfigured`, and `new_member`.  This covers the `member` case.  We should probably have a switch/variant struct here (probably always should have).\r\n\r\n```\r\nstruct {\r\n    SenderType sender_type;\r\n    switch (sender_type) {\r\n        case member:        Client client;\r\n        case preconfigured: opaque key_id<0..255>;\r\n        case new_member:    struct{};\r\n    }\r\n} Sender;\r\n```\r\n",
              "createdAt": "2021-10-05T14:05:27Z",
              "updatedAt": "2021-10-05T14:09:35Z"
            },
            {
              "originalPosition": 34,
              "body": "```suggestion\r\nMUST verify that the `Client` indicated in the `sender` field is a member of the\r\n```",
              "createdAt": "2021-10-05T14:07:05Z",
              "updatedAt": "2021-10-05T14:09:35Z"
            },
            {
              "originalPosition": 12,
              "body": "Note that you can still use `Client` in MLSSenderData, because that always corresponds to the `member` case.",
              "createdAt": "2021-10-05T14:07:42Z",
              "updatedAt": "2021-10-05T14:09:35Z"
            },
            {
              "originalPosition": 92,
              "body": "I actually think the old wording is clearer.  In general, I would still talk about these `Client` values as indices, since you need to look up leaves in the tree to get credentials, signature keys, etc.",
              "createdAt": "2021-10-05T14:09:18Z",
              "updatedAt": "2021-10-05T14:09:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4t_DXL",
          "commit": {
            "abbreviatedOid": "002cf1b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T14:10:42Z",
          "updatedAt": "2021-10-05T14:10:43Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Note also that if we make a smaller-than-hash-KeyPackage-ID thing here, we should also use it in Welcome.",
              "createdAt": "2021-10-05T14:10:42Z",
              "updatedAt": "2021-10-05T14:10:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4uBzoZ",
          "commit": {
            "abbreviatedOid": "002cf1b"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-06T06:06:52Z",
          "updatedAt": "2021-10-06T06:06:52Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "I like the idea, although I'm always a bit skeptical when it comes to shortening hashes. In this case it doesn't serve much of a security purpose, but I'd still prefer the full hash.",
              "createdAt": "2021-10-06T06:06:52Z",
              "updatedAt": "2021-10-06T06:06:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4uB0kB",
          "commit": {
            "abbreviatedOid": "002cf1b"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-06T06:13:15Z",
          "updatedAt": "2021-10-06T06:13:16Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Any suggestions for a name, though? The KeyPackage hash does not really represent the client anymore, but rather the client's presence in this particular group. (Calling it `MemberId` for now, although I thought there were cases where the specified party is not (yet) a member.)",
              "createdAt": "2021-10-06T06:13:16Z",
              "updatedAt": "2021-10-06T06:17:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4uB00V",
          "commit": {
            "abbreviatedOid": "002cf1b"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-06T06:14:56Z",
          "updatedAt": "2021-10-06T06:14:56Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Good point! I'll change it as suggested.",
              "createdAt": "2021-10-06T06:14:56Z",
              "updatedAt": "2021-10-06T06:14:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4uELPP",
          "commit": {
            "abbreviatedOid": "0e1675b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-06T15:10:48Z",
          "updatedAt": "2021-10-06T15:10:48Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "I kind of like `KeyPackageID`, as above.",
              "createdAt": "2021-10-06T15:10:48Z",
              "updatedAt": "2021-10-06T15:10:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4uEL_D",
          "commit": {
            "abbreviatedOid": "0e1675b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-06T15:13:04Z",
          "updatedAt": "2021-10-06T15:33:35Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "It would be cleaner just to add something like the following to the end of the `{{key-packages}}`:\r\n\r\nWhen it is necessary to refer to KeyPackage, protocol messages incorporate a KeyPackageHash:\r\n\r\n```\r\nopaque KeyPackageHash<0..255>;\r\n```\r\n\r\nThis value is the hash of the KeyPackage, using the hash indicated by the `cipher_suite` field.  KeyPackage hashes are used in a Welcome message to indicate which KeyPackage is being used to include the new member.  Since members of a group are uniquely identified by their leaf KeyPackages, messages within a group use the hash of this key package to refer group members, e.g., to specify the target of a Remove proposal or the signer of an MLSPlaintext.",
              "createdAt": "2021-10-06T15:25:30Z",
              "updatedAt": "2021-10-06T15:33:35Z"
            },
            {
              "originalPosition": 6,
              "body": "Then we should clean up the `Welcome` section so that the `EncryptedGroupSecrets` refers to `KeyPackageHash` and the corresponding text is more succinct.",
              "createdAt": "2021-10-06T15:26:27Z",
              "updatedAt": "2021-10-06T15:33:35Z"
            },
            {
              "originalPosition": 6,
              "body": "In any case, I don't think this extra layer of `struct` wrapping is needed.",
              "createdAt": "2021-10-06T15:26:44Z",
              "updatedAt": "2021-10-06T15:33:35Z"
            },
            {
              "originalPosition": 48,
              "body": "Nit: I would not use backticks around MemberId / KeyPackageHash / whatever.  (The style rule I'm generally trying to follow is that words with initial caps are not backticked, while lowercase words are.)",
              "createdAt": "2021-10-06T15:27:56Z",
              "updatedAt": "2021-10-06T15:33:35Z"
            },
            {
              "originalPosition": 76,
              "body": "I would revert this change.  I think \"the removed leaf\" is clearer.",
              "createdAt": "2021-10-06T15:28:22Z",
              "updatedAt": "2021-10-06T15:33:35Z"
            },
            {
              "originalPosition": 76,
              "body": "You could also break this out into three steps:\r\n\r\n* Identify a leaf node containing a key package matching `removed`.  Let `removed_index` be the node index of this leaf node.\r\n* Replace the leaf node at `index` with a blank node\r\n* Blank the intermediate nodes along the path from `index` to the root",
              "createdAt": "2021-10-06T15:30:02Z",
              "updatedAt": "2021-10-06T15:33:35Z"
            },
            {
              "originalPosition": 141,
              "body": "\"leaf node index\"",
              "createdAt": "2021-10-06T15:33:25Z",
              "updatedAt": "2021-10-06T15:33:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4uEevp",
          "commit": {
            "abbreviatedOid": "0e1675b"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-06T15:52:53Z",
          "updatedAt": "2021-10-06T15:52:54Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Sounds like a good approach. I'll also note, that while we use a KeyPackage hash to identify members, these hashes change when the key package is updated, whereas the identity of the member does not. This could lead to errors, for example, when processing a `remove` right after an `update` for the same member was processed. I'm not entirely sure that's actually possible, but maybe you understand my concern. I don't want people to thing that KeyPackage hashes are static mappings to members.",
              "createdAt": "2021-10-06T15:52:53Z",
              "updatedAt": "2021-10-06T15:52:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4uEgVJ",
          "commit": {
            "abbreviatedOid": "0e1675b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-06T15:58:17Z",
          "updatedAt": "2021-10-06T15:58:17Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Good point.  And to make it worse, we have the following:\r\n\r\n> Update proposals are applied first, followed by Remove proposals\r\n\r\nMaybe we should just declare that a single Commit containing an Update and a Remove for the same leaf is invalid.",
              "createdAt": "2021-10-06T15:58:17Z",
              "updatedAt": "2021-10-06T15:58:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4uGioF",
          "commit": {
            "abbreviatedOid": "0e1675b"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T05:48:28Z",
          "updatedAt": "2021-10-07T05:48:28Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "That would make sense, since updating and then immediately removing is rather pointless. Alternatively, we could make the KeyPackageID relative to the tree of the last epoch.",
              "createdAt": "2021-10-07T05:48:28Z",
              "updatedAt": "2021-10-07T05:48:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4uGkAt",
          "commit": {
            "abbreviatedOid": "0e1675b"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T05:59:54Z",
          "updatedAt": "2021-10-07T05:59:55Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "> In any case, I don't think this extra layer of `struct` wrapping is needed.\r\n\r\nThe advantage of keeping the struct layer is that the type is more expressive. If we don't have the struct, we end up with, for example, \r\n\r\n```\r\n~~~~~\r\nstruct {\r\n     opaque removed<0..255>;\r\n} Remove;\r\n~~~~~\r\n```\r\nwithout any indication what `removed` actually is. ",
              "createdAt": "2021-10-07T05:59:55Z",
              "updatedAt": "2021-10-07T05:59:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4uIhuV",
          "commit": {
            "abbreviatedOid": "ce48f19"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T14:26:58Z",
          "updatedAt": "2021-10-07T14:26:58Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "We are getting a little deep in the minutiae of TLS syntax expression, but I was thinking you could do something like:\r\n\r\n```\r\nopaque KeyPackageHash<0..255>;\r\n\r\nstruct {\r\n    KeyPackageHash removed;\r\n} Remove;\r\n```\r\n\r\nBut since there's no actual overhead to the struct wrapping, I'm fine to keep it.",
              "createdAt": "2021-10-07T14:26:58Z",
              "updatedAt": "2021-10-07T14:26:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4uIidv",
          "commit": {
            "abbreviatedOid": "ce48f19"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T14:29:04Z",
          "updatedAt": "2021-10-07T14:29:04Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "> That would make sense, since updating and then immediately removing is rather pointless. Alternatively, we could make the KeyPackageID relative to the tree of the last epoch.\r\n\r\nThe latter suggestion seems a little neater to me.  It avoids the need for more complex validation of the proposal list.  It does requires you keep a reference to the old tree (or at least a `KeyPackageID -> node index` map), but that doesn't seem as  bad to me.",
              "createdAt": "2021-10-07T14:29:04Z",
              "updatedAt": "2021-10-07T14:29:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4uI2sn",
          "commit": {
            "abbreviatedOid": "ce48f19"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T15:30:19Z",
          "updatedAt": "2021-10-07T15:42:18Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "```suggestion\r\n* Replace the leaf node at `removed_index` with a blank node\r\n\r\n* Blank the intermediate nodes along the path from `removed_index` to the root\r\n```",
              "createdAt": "2021-10-07T15:30:20Z",
              "updatedAt": "2021-10-07T15:42:18Z"
            },
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nstruct {\r\n    opaque key_package_hash<0..255>;\r\n} KeyPackageID\r\n```\r\n\r\nStill some issues here:\r\n1. It would be good if we could use a phrase other than \"ID\" here, because we already have the `key_id` extension.  KeyPackageHash if you want to be concrete, or KeyPackageRef if you want to be parallel with ProposalOrRef (which also refers to objects by hash).\r\n2. You don't define what this value is.  You need to specify that it is the hash of the KP with the ciphersuite.\r\n3. You haven't updated EncryptedGroupSecrets to use this instead of its own struct.  \r\n\r\nFor (2), suggest adding the following to the \"Key Packages\" section:\r\n\r\nWhen it is necessary to refer to KeyPackage, protocol messages incorporate a KeyPackageID:\r\n\r\n```suggestion\r\nstruct {\r\n    opaque key_package_hash<0..255>;\r\n} KeyPackageID\r\n```\r\n\r\nThis value is the hash of the KeyPackage, using the hash indicated by the cipher_suite field. KeyPackage hashes are used in a Welcome message to indicate which KeyPackage is being used to include the new member. Since members of a group are uniquely identified by their leaf KeyPackages, messages within a group use the hash of this key package to refer group members, e.g., to specify the target of a Remove proposal or the signer of an MLSPlaintext.",
              "createdAt": "2021-10-07T15:37:45Z",
              "updatedAt": "2021-10-07T15:42:18Z"
            },
            {
              "originalPosition": 73,
              "body": "```suggestion\r\n* Identify a leaf node containing a key package matching `removed`.  This \r\n  lookup MUST be done on the tree before any non-Remove proposals have\r\n  been applied (the \"old\" tree in the terminology of {{commit}}), since \r\n  proposals such as Update can change the KeyPackage stored at a leaf. \r\n  Let `removed_index` be the node index of this leaf node.\r\n```",
              "createdAt": "2021-10-07T15:41:31Z",
              "updatedAt": "2021-10-07T15:42:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4uLAqo",
          "commit": {
            "abbreviatedOid": "d7be495"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-08T06:30:39Z",
          "updatedAt": "2021-10-08T06:30:39Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Thanks for the suggestions! Regarding (1): Do I understand correctly, that you want to rename `KeyPackageID`? While I agree that `KeyPackageID` could be confused with the `key_id` extension, if anything, I think we should rename `key_id` to `external_key_id`. Even in the `KeyPackage Identifiers` section it states that KeyPackages are identified by their hash and that `key_id` is a way to have some extra, external identifier for a key package. So the canonical KeyPackageID should be the hash.",
              "createdAt": "2021-10-08T06:30:39Z",
              "updatedAt": "2021-10-08T06:30:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4uMjSx",
          "commit": {
            "abbreviatedOid": "10953ef"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks for the work on this @kkohbrok.  Looks good to me!",
          "createdAt": "2021-10-08T13:54:20Z",
          "updatedAt": "2021-10-08T13:54:20Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4uNN4V",
          "commit": {
            "abbreviatedOid": "10953ef"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "I think `EncryptedGroupSecrets` could also benefit from this:\r\n\r\n```\r\nstruct {\r\n  KeyPackageID new_member<1..255>;\r\n  HPKECiphertext encrypted_group_secrets;\r\n} EncryptedGroupSecrets;\r\n```\r\n\r\nBefore we merge this, it would be good to try and implement it first. We lose the 1:1 mapping with indices because of the hash and that might lead to UB potentially.",
          "createdAt": "2021-10-08T16:38:09Z",
          "updatedAt": "2021-10-08T16:42:25Z",
          "comments": [
            {
              "originalPosition": 178,
              "body": "This re-introduces leaf node indices.",
              "createdAt": "2021-10-08T16:38:09Z",
              "updatedAt": "2021-10-08T16:42:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4uRRcD",
          "commit": {
            "abbreviatedOid": "f28460a"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-11T14:06:22Z",
          "updatedAt": "2021-10-11T14:06:22Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4uRRzH",
          "commit": {
            "abbreviatedOid": "f28460a"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-11T14:07:40Z",
          "updatedAt": "2021-10-11T14:07:40Z",
          "comments": [
            {
              "originalPosition": 178,
              "body": "I understood \"leaf node index\" to mean \"the node index of this leaf node\".  This may be confusing for those of us who still have the idea of \"leaf indices\" in cache, but for new readers (and once our cache expires), it seems clear.",
              "createdAt": "2021-10-11T14:07:40Z",
              "updatedAt": "2021-10-11T14:07:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4uRTC1",
          "commit": {
            "abbreviatedOid": "f28460a"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-11T14:12:07Z",
          "updatedAt": "2021-10-11T14:12:07Z",
          "comments": []
        }
      ]
    },
    {
      "number": 492,
      "id": "PR_kwDOBoyH6c4stH5E",
      "title": "Add a 'reserved' field to WireFormat",
      "url": "https://github.com/mlswg/mls-protocol/pull/492",
      "state": "MERGED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The `WireFormat` `enum` was not aligned with other enums in that it did not contain the mandatory `reserved` field.",
      "createdAt": "2021-10-05T16:07:55Z",
      "updatedAt": "2021-10-08T22:19:51Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "b7a741e3d2b48252d3f005274d93d2e4212bcf12",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "wireformat-fix",
      "headRefOid": "ba39087ab50579a0294313f06eb22524453fc40d",
      "closedAt": "2021-10-06T15:08:28Z",
      "mergedAt": "2021-10-06T15:08:28Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "e277f4187aa8e2af9da5b57fbbf7b909faf1edc8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4uBFzE",
          "commit": {
            "abbreviatedOid": "ba39087"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-05T22:23:04Z",
          "updatedAt": "2021-10-05T22:23:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 494,
      "id": "PR_kwDOBoyH6c4s5M3S",
      "title": "Don't require PublicGroupState for external init",
      "url": "https://github.com/mlswg/mls-protocol/pull/494",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "There is really no benefit in requiring the whole PublicGroupState, inclucing signer and signature. Instead, this complicates things, since upon receiving a commit with an external init, the client has to fetch the PGS that was used for the external init, since they need it to compute the external init secret.\r\n\r\nFrom what I can see, the only thing we really gain from using the signed PGS is a degree of attribution, where upon an external init, every group member knows who authored the PGS that was used for the external init. Feel free to disagree, but I don't think that's a property we really need here.\r\n\r\nThis PR makes it such that the `PublicGroupStateTBS` is used to compute the external init secret instead of the `PublicGroupState`.",
      "createdAt": "2021-10-07T13:33:23Z",
      "updatedAt": "2021-10-11T19:02:50Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "e277f4187aa8e2af9da5b57fbbf7b909faf1edc8",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "improve_ext_init",
      "headRefOid": "428d50efd2cfcb8e8c38ae8aba72fe36beb9bd86",
      "closedAt": "2021-10-11T19:02:50Z",
      "mergedAt": "2021-10-11T19:02:50Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "323ea9418d38b3964345903184d49fa0794df9c9"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "IIUC the idea here is that the recipient of an external commit has what they need to compute everything in the PublicGroupStateTBS, but not the PublicGroupState (with signature).  So if the context is PublicGroupState, the receiver has to be provided the specific PGS that the joiner is using, but if the context is just PublicGroupStateTBS, then they can just recompute it locally.\r\n\r\nIt's a good idea, but unfortunately, it doesn't actually work.  PublicGroupStateTBS still has an `other_extensions` field, which holds any data that the creator of the PublicGroupState wants to send to the external joiner -- and the other members of the group may or may not be aware of.\r\n\r\nI would suggest that adding the PublicGroupState isn't actually necessary here.  PublicGroupState is analogous to GroupInfo, and we don't put GroupInfo into the transcript.  Instead, the group agreement properties of the key schedule guard against a rogue GroupInfo creator putting false information in.  The same applies here.  If we look at the fields in PublicGroupState, everything up to `group_context_extensions` is covered by the GroupContext agreement, as is `external_pub` (since a different public key will lead to a different `init_secret`).  So for both GroupInfo and PublicGroupState, the only field the sender can manipulate is `other_extensions`, which is the intended semantic of the field; indeed, it has no other semantic than \"anything the sender wants to put here\".\r\n\r\nNet of all that, I would suggest we just leave the `info` input to `SetupBaseS` empty.\r\n\r\n(Conveniently, this matches what [mlspp does today](https://github.com/cisco/mlspp/blob/99748b808919be687f560ae55a4c781b0014ea2b/src/key_schedule.cpp#L497), which is why our development/testing didn't catch this problem.  Thanks for reading more carefully, @kkohbrok!)",
          "createdAt": "2021-10-07T14:22:38Z",
          "updatedAt": "2021-10-07T14:22:38Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "Good point about the `other_extensions` field. You could argue that members should roughly agree on what should go in there, but there is no guarantee that they can recreate the exact content down to the last byte locally.",
          "createdAt": "2021-10-08T14:21:30Z",
          "updatedAt": "2021-10-08T14:21:30Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4uIQmc",
          "commit": {
            "abbreviatedOid": "f2be874"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-07T13:35:42Z",
          "updatedAt": "2021-10-07T13:35:42Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4uIgWY",
          "commit": {
            "abbreviatedOid": "f2be874"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T14:22:59Z",
          "updatedAt": "2021-10-07T14:23:38Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nkem_output, context = SetupBaseS(external_pub, \"\")\r\n```",
              "createdAt": "2021-10-07T14:22:59Z",
              "updatedAt": "2021-10-07T14:23:38Z"
            },
            {
              "originalPosition": 14,
              "body": "```suggestion\r\ncontext = SetupBaseR(kem_output, external_priv, \"\")\r\n```",
              "createdAt": "2021-10-07T14:23:13Z",
              "updatedAt": "2021-10-07T14:23:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4uMrml",
          "commit": {
            "abbreviatedOid": "428d50e"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-08T14:21:42Z",
          "updatedAt": "2021-10-08T14:21:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 495,
      "id": "PR_kwDOBoyH6c4s8y1W",
      "title": "Affiliation change",
      "url": "https://github.com/mlswg/mls-protocol/pull/495",
      "state": "MERGED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-10-08T15:17:38Z",
      "updatedAt": "2021-10-08T22:20:16Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "e277f4187aa8e2af9da5b57fbbf7b909faf1edc8",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "raphaelrobert-affiliation",
      "headRefOid": "6730b1c22878e6afe6c95f215b04797f22e2d853",
      "closedAt": "2021-10-08T15:49:41Z",
      "mergedAt": "2021-10-08T15:49:41Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "87035094cc4ccd38c975d9fb0a688758a55495d3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4uNDGv",
          "commit": {
            "abbreviatedOid": "6730b1c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-08T15:49:35Z",
          "updatedAt": "2021-10-08T15:49:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 496,
      "id": "PR_kwDOBoyH6c4tCRVP",
      "title": "Normalize the description of the zero vector",
      "url": "https://github.com/mlswg/mls-protocol/pull/496",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Right now, the vector `0` is described in a couple of ways.  This PR standardizes on \"of length `KDF.Nh`\".",
      "createdAt": "2021-10-11T19:33:55Z",
      "updatedAt": "2021-10-11T19:34:49Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "2bc4ae1f4ba1a4fe81852e101e17ac0550897a91",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "nh",
      "headRefOid": "e7b1426de2092ddbecc9653c140da661d8f3df31",
      "closedAt": "2021-10-11T19:34:48Z",
      "mergedAt": "2021-10-11T19:34:48Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "7d4cbc4e5c9bb835649ec7a3b8ef29c2edb6be8e"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 497,
      "id": "PR_kwDOBoyH6c4tCUoV",
      "title": "Add changelog for draft-12",
      "url": "https://github.com/mlswg/mls-protocol/pull/497",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-10-11T19:59:32Z",
      "updatedAt": "2021-10-11T20:02:10Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "7d4cbc4e5c9bb835649ec7a3b8ef29c2edb6be8e",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "changelog-12",
      "headRefOid": "384d08ba52a19524201805a4a75a392fdb347b54",
      "closedAt": "2021-10-11T20:02:10Z",
      "mergedAt": "2021-10-11T20:02:10Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "fefeaf0a5ae3c4daebcacf8ac752aefebf867842"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 501,
      "id": "PR_kwDOBoyH6c4tfxic",
      "title": "Add ciphersuite field to `PublicGroupStateTBS`",
      "url": "https://github.com/mlswg/mls-protocol/pull/501",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #498.",
      "createdAt": "2021-10-21T13:54:01Z",
      "updatedAt": "2021-11-19T20:22:47Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "fefeaf0a5ae3c4daebcacf8ac752aefebf867842",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "add_ciphersuite_to_pgs",
      "headRefOid": "d5b5954a813852b20a90aba1b41edb8283bfe097",
      "closedAt": "2021-11-19T20:22:47Z",
      "mergedAt": "2021-11-19T20:22:47Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "0aa8fce7086292984c40d55c629d99ef0c78a881"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4v6dq0",
          "commit": {
            "abbreviatedOid": "0f6fb0e"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "Good point! The protocol version was also missing. New joiners learn this from the `Welcome` message normally, that's why it wasn't included in the `GroupInfo` again.\r\n\r\nThe protocol version should also be repeated in the `PublicGroupState`.",
          "createdAt": "2021-11-11T14:26:42Z",
          "updatedAt": "2021-11-11T14:29:35Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\n    ProtocolVersion version = mls10;\r\n    CipherSuite cipher_suite;\r\n```",
              "createdAt": "2021-11-11T14:26:42Z",
              "updatedAt": "2021-11-11T14:29:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4v6kgK",
          "commit": {
            "abbreviatedOid": "0f6fb0e"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-11T14:50:55Z",
          "updatedAt": "2021-11-11T14:50:56Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Can't the ProtocolVersion be inferred from the Ciphersuite?",
              "createdAt": "2021-11-11T14:50:55Z",
              "updatedAt": "2021-11-11T14:50:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4wYLab",
          "commit": {
            "abbreviatedOid": "0f6fb0e"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-19T20:21:24Z",
          "updatedAt": "2021-11-19T20:21:24Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "No.  That's why they're separate fields in KeyPackage.",
              "createdAt": "2021-11-19T20:21:24Z",
              "updatedAt": "2021-11-19T20:21:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4wYLqk",
          "commit": {
            "abbreviatedOid": "d5b5954"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-11-19T20:22:41Z",
          "updatedAt": "2021-11-19T20:22:41Z",
          "comments": []
        }
      ]
    },
    {
      "number": 507,
      "id": "PR_kwDOBoyH6c4uiF4t",
      "title": "Getting rid of the array representation",
      "url": "https://github.com/mlswg/mls-protocol/pull/507",
      "state": "CLOSED",
      "author": "franziskuskiefer",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Filing this on behalf of @TWal after discussions with @kkohbrok and @karthikbhargavan.\r\n\r\nThe idea behind it is that the array representation is only one possible implementation for the tree. This PR removes the reliance on nodes indices to address nodes in the tree.\r\n\r\nI'll leave it to @TWal to write a more detailed description.",
      "createdAt": "2021-11-15T13:20:37Z",
      "updatedAt": "2021-12-07T14:51:39Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "fefeaf0a5ae3c4daebcacf8ac752aefebf867842",
      "headRepository": "TWal/mls-protocol",
      "headRefName": "twal_tree_math",
      "headRefOid": "7b4704ef4b79ec7e80f5ebc690620eadcad32723",
      "closedAt": "2021-12-07T14:49:31Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you Franziskus!\r\n\r\nThe array representation is used in three places:\r\n- in the tree hash (section 7.6),\r\n- in the secret tree (section 8.3) and in the ratchet (section 8.4),\r\n- in the ratchet_tree extension (section 11.3).\r\n\r\nIn the tree hash, we remove the node index in `ParentNodeTreeHashInput`, but keep a leaf index in `LeafNodeHashInput`. The leaf index is actually not needed if we only use the tree hash of the root, but if the protocol evolves later to use tree hashes of subtrees, it is actually important since they give information about where the subtree is located in the whole tree.\r\n\r\nIn the secret tree, we replace the node indices in the KDF by some \"left\" and \"right\" information which are sufficient.\r\n\r\nFor the ratchet_tree extension, we state that the order in which the nodes are serialized is the in-order traversal of the tree.\r\n\r\nThis allows us to remove the whole tree-math section.",
          "createdAt": "2021-11-16T10:27:59Z",
          "updatedAt": "2021-11-16T10:27:59Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "One thing that I noticed working on #513 -- On Remove we truncate the tree to remove unused leaves from the right side.  That algorithm is clear when we're talking about an array representation; just find the rightmost non-blank leaf and remove every node (leaf or not) to the right of that index.  It seems like we should redefine that algorithm with this change.",
          "createdAt": "2021-11-19T22:58:22Z",
          "updatedAt": "2021-11-19T22:58:22Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Suggested text for truncation:\r\n\r\n* Truncate the tree:\r\n    * Remove any blank leaf nodes to the right of the rightmost non-blank leaf\r\n    * Perform the following steps until all parent nodes have two children:\r\n        * If an intermediate node has no children, remove it\r\n        * If an intermediate node N has one child C, remove the node and place C into the same child role with regard to N.\r\n        * If the root node R of the tree has only one child C, remove R and assign C as the root of the tree\r\n\r\nFor example, suppose we had a tree with six leaves, of which (0, 1, 2, 5) were populated, (3, 4) blank, and in this situation a Remove was issued for the member at leaf 5.  Then the Remove would result in the following changes to the tree, resulting in a tree with three leaves, with root node `V`:\r\n\r\n~~~~~\r\n                         X                                    X\r\n                   ______|___                           ______|___\r\n                  /          \\       Blank             /          \\  \r\nStart:           V           |       path             V           |  \r\n               __|__         |       =====>         __|__         |  \r\n              /     \\        |                     /     \\        | \r\n             U       W       Y                    U       W       Y  \r\n            / \\     / \\     / \\                  / \\     / \\     / \\ \r\n           A   B   C   _   _   F                A   B   C   _   _   F\r\n\r\n\r\n                         _                                    _\r\nRemove             ______|___                           ______|   \r\nblank             /          \\       No                /             \r\nleaves           V           |       children         V              \r\n=====>         __|__         |       =====>         __|__            \r\n              /     \\        |                     /     \\          \r\n             U       W       _                    U       W          \r\n            / \\     /                            / \\     / \\         \r\n           A   B   C                            A   B   C   _        \r\n\r\n\r\n                                                               \r\nOne                                                               \r\nchild                                One                             \r\nroot             V                   child            V              \r\n=====>         __|__                 =====>         __|_             \r\n              /     \\                              /    \\           \r\n             U       W                            U     |            \r\n            / \\     /                            / \\    |            \r\n           A   B   C                            A   B   C            \r\n~~~~~\r\n\r\nNote that if a batch of Removes is being processed, the truncation operation can be done once after all paths have been blanked.",
          "createdAt": "2021-11-21T15:09:29Z",
          "updatedAt": "2021-11-21T15:09:29Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "We may need a similar description of how you extend the tree to the right on Add.  I think the algorithm to add a leaf node `N` would be:\r\n\r\n* We say that the subtree rooted at a node is \"full\" if the number of leaves under it is a power of 2.\r\n* Let X = the parent of the rightmost leaf.  While X is full and X is not the root, let X = parent(X)\r\n* If X is the root, add a new root node Y with left child X and right child N\r\n* If X is not the root (and thus X is not full):\r\n    * Let L = left(X) and R = right(X)\r\n    * Set right(X) to a new node with left child R and right child N\r\n \r\nIt might be better to put these algorithms up in the tree section, as opposed to down here in the protocol.",
          "createdAt": "2021-11-21T15:21:56Z",
          "updatedAt": "2021-11-21T15:21:56Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "It makes me a little sad that these are so much more complicated than \"truncate the array\" and \"add two slots to the array\".  I guess I can understand the desire to make clear what happens to the logical tree, but it seems like we're introducing a lot of complexity.",
          "createdAt": "2021-11-21T15:23:36Z",
          "updatedAt": "2021-11-21T15:23:36Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The Add algorithm doesn't work on the following tree:\r\n\r\n          V  \r\n        __|_ \r\n       /    \\\r\n      U     |\r\n     / \\    |\r\n    A   B   C\r\n\r\nAfter the While, we would have X = V and take the \"If X is the root\" step, which is wrong because X is not full.\r\n\r\nHere is a corrected Add algorithm:\r\n- Let X = the parent of the rightmost leaf. While X is full and X is not the root, let X = parent(X)\r\n- If X is not full:\r\n  - Let L = left(X) and R = right(X)\r\n  - Set right(X) to a new node with left child R and right child N\r\n- If X is full (and thus X is the root): add a new root node Y with left child X and right child N\r\n\r\nI'm wondering if these algorithms are really necessary. It doesn't hurt to include them as an example on how to do things, but I think we can do simpler explanations using the fact that there is a unique left-balanced tree shape for every number of leaves.\r\n\r\nInformally, we could say:\r\n- for Add: \"add enough blank parent node to have a valid left-balanced tree with n+1 leaves\"\r\n- for Remove: \"remove all leaves to the right of the right-most non-blank leaf, and remove parents nodes to have a valid left-balanced tree\".\r\n\r\nI think explaining what is the expected output of the procedure, rather than explaining one way to do the procedure is easier to understand.\r\n\r\n> It makes me a little sad that these are so much more complicated than \"truncate the array\" and \"add two slots to the array\". I guess I can understand the desire to make clear what happens to the logical tree, but it seems like we're introducing a lot of complexity.\r\n\r\nIt looks like added complexity, but for a new reader trying to understand MLS, I think it is easier to understand changes on the tree explained this way than understanding what happens to the tree when we do modifications on the underlying array representation.",
          "createdAt": "2021-11-22T13:45:14Z",
          "updatedAt": "2021-11-22T13:45:14Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@TWal \r\n\r\n> I'm wondering if these algorithms are really necessary. It doesn't hurt to include them as an example on how to do things, but I think we can do simpler explanations using the fact that there is a unique left-balanced tree shape for every number of leaves.\r\n\r\nThat defines the *structure* of the tree, but not the *content* of the leaves.  We need to do both, so we need the transformation algorithms.  (In principle, you could write it starting from the structure, mapping old tree to new, but it would be an even more invasive rewrite.)\r\n\r\n",
          "createdAt": "2021-11-30T23:09:21Z",
          "updatedAt": "2021-11-30T23:09:21Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, to build some intuition here, I tried implementing a non-array-based variant tree structure that maintained the right structure.  [Quick draft in Go](https://go.dev/play/p/d6MW1vlc0oa).\r\n\r\nThe bad news is: I'm pretty convinced that there's no intuitive way to just say \"make the unique left-balanced tree with these contents\".  At best, we would need some way to define \"Corresponding nodes\" so that things could be copied over, which ultimately just turns into reinventing node indices.\r\n\r\nThe good news is: The above Go code validates two algorithms for extending and truncating the tree by one node, and they're pretty simple.  The add algorithm is effectively what @TWal proposed; the remove algorithm just excises and patches around the rightmost leaf's parent node.\r\n\r\nIt seems like we need to either add the algorithms or give up and close the PR.\r\n\r\n@TWal @franziskuskiefer -- preferences between those two options?\r\n\r\n",
          "createdAt": "2021-12-02T00:49:52Z",
          "updatedAt": "2021-12-02T00:49:52Z"
        },
        {
          "author": "franziskuskiefer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> It seems like we need to either add the algorithms or give up and close the PR.\r\n\r\nI'm not entirely decided on this. I agree with @TWal that the array representation isn't very intuitive for new readers and it's an implementation detail that's not good for the readability of the spec.\r\nOn the other hand do the algorithms get a pretty unwieldy and I'm not sure if they're really easier to understand than the array representation. And with the algorithms in the spec they aren't much better than the array representation in telling implementations what to do.\r\n\r\nIn an implementation of MLS that doesn't use the array representation underneath it is pretty easy to compute leaf indices for the few places they are needed.  So maybe another option is to leave the array representation in and only take the changes from this PR that remove the node index.\r\nIf the spec makes clear that the array representation is only one way of implementing the tree we could get the best of both worlds, a simple description of the left balanced tree without telling everyone what to implement as well as algorithms that only require leaf indices that can be easily retrieved from other implementations.\r\n",
          "createdAt": "2021-12-02T08:50:01Z",
          "updatedAt": "2021-12-02T08:50:01Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I propose the following definition for \"correspond\":\r\n\r\n    A node n1 in a tree t1 corresponds to a node n2 in a tree t2\r\n    iff. the index of their leftmost leaf is the same, and they have the same height\r\n\r\nThis definition seems simple enough, while exactly capturing what nodes \"are the same\" in t1 and t2. It introduces the concept of \"height\" which is not currently defined in MLS, but I think it's fine.\r\nAlso, we can easily see that with this definition, two nodes \"correspond\" iff. they have the same node index in the array representation.\r\n\r\nIn fact, we can have the following alternate definition:\r\n\r\n    A node n1 in a tree t1 corresponds to a node n2 in a tree t2\r\n    iff. they have the same position in the in-order traversal\r\n\r\nThis is somewhat equivalent to re-introducing node-indexes, but in any case I find this definition less easy to understand than the first one.\r\n\r\nMy preferences are the following:\r\n1. Only give a declarative description for Add and Remove, introducing the previous definition, and maybe put the algorithms in the implementation document.\r\n2. Give the declarative description in a non-formal way (e.g. without defining \"corresponds\") and say afterward in the appendix \"okay, here is the real algorithm which is the ground truth about what you should do\".\r\n3. Franziskus' proposition.\r\n\r\nI prefer the first option, because then the intuition of the readers would actually be what is the ground truth. People working with trees are happy because they can work with a simple description on trees, and people working with arrays are happy because the \"corresponds\" definition is equivalent to \"n1 corresponds to n2 iff. they have the same node index\".\r\n\r\nThen I prefer the second option, because I still think the tree algorithms are easier to understand than the bit-tricks used in tree math. With this option, the readers could gain an intuition about what happens to the tree using the declarative description, then read the \"ground truth\" algorithms and convince themselves that they indeed do what their intuition said. This option is great for people working with trees, but is a bit disappointing for people working with arrays.\r\n\r\nThen the third option keep things as they are now, but implementations are not forced to implement tree math if they want to use another tree representation. This option is great for people working with arrays, but is a disappointing for people working with trees.\r\n\r\nI'd like to go with the first option, since it is the only one where tree people and array people are happy. What do you think? @franziskuskiefer @bifurcation ",
          "createdAt": "2021-12-02T15:57:53Z",
          "updatedAt": "2021-12-02T15:57:53Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I think @franziskuskiefer is on the right track here -- let's phrase the structure of the tree in terms of node indices but be really clear that nodes don't have to use an array implementation.  So we would do something like:\r\n\r\n* Keep node indices\r\n* Truncate algorithm (in {{remove}}):\r\n    * Identify the rightmost non-blank leaf node\r\n    * Remove all nodes from the tree with an index higher than the rightmost non-blank leaf\r\n* Extend algorithm (in {{add}}):\r\n    * Let `n` be the index of the rightmost leaf node\r\n    * Add a blank parent node with index `n+1` and a blank leaf node with index `n+2`\r\n    * As a result, node `n+1` will have node `n+2` as its right child, and its left child and parent will be defined by the left-balanced binary tree structure.\r\n\r\n@TWal - Could you live with that?  It's sort of implicitly declarative, since node indexing encodes the left-balanced binary tree structure.\r\n\r\nNow that we have the tree-wise algorithms, it actually seems like a fine idea to add them in an appendix, parallel to the tree math appendix.  Then we could have a note in the Ratchet Tree section that says \"if you want to use node indices to compute relations, see that appendix for some helpful detail; if you want to use pointers, see the other one\".  That would make it abundantly clear that indices don't prescribe implementation.  I'll write a PR for that.",
          "createdAt": "2021-12-03T14:21:59Z",
          "updatedAt": "2021-12-03T14:23:07Z"
        },
        {
          "author": "franziskuskiefer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Getting the link based description in is a great first step.\r\nThe other change that's uncontroversial I think is to make clear throughout the spec that there are two different (obvious) ways of implementing the tree.\r\n\r\nThen I we are left with one more question\r\n> Keep node indices\r\n\r\nWith the two changes mentioned above I don't have strong feelings on this. Either way is fine with me. Only working with leaf indices instead of node indices is the more generic description, but also creates some churn in the algorithms that is also security relevant.",
          "createdAt": "2021-12-06T10:31:27Z",
          "updatedAt": "2021-12-06T10:31:27Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Right, that's why I'm inclined to keep node indices -- Avoid churning the algorithms (since they seem to have been clear enough for at least two interoperable implementations), while making clear that any algorithm that produces the same tree is acceptable.",
          "createdAt": "2021-12-06T14:39:48Z",
          "updatedAt": "2021-12-06T14:39:48Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this since we seem to be converging on #522.",
          "createdAt": "2021-12-07T14:49:31Z",
          "updatedAt": "2021-12-07T14:49:31Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4wIrzd",
          "commit": {
            "abbreviatedOid": "54a2b97"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I can understand the impulse here, and I think this is probably OK, especially for the ratchet tree parts.  The main concern I have is whether this leaves us with something clearly enough specified that the secret tree will work interoperably.  Maybe @psyoptix could opine here?",
          "createdAt": "2021-11-16T16:55:07Z",
          "updatedAt": "2021-11-16T20:59:08Z",
          "comments": [
            {
              "originalPosition": 169,
              "body": "Just to confirm that I understand: You are removing the context `N` from the derivation.  The idea is that that's OK because the index is \"baked into\" `tree_node_[N]_secret` by virtue of the sequence of \"left\"/\"right\" derivations by which it was derived?",
              "createdAt": "2021-11-16T16:55:07Z",
              "updatedAt": "2021-11-16T20:59:08Z"
            },
            {
              "originalPosition": 193,
              "body": "```suggestion\r\n    ExpandWithLabel(Secret, Label, Generation, Length)\r\n\r\nWhere Generation is encoded as a uint32.\r\n```",
              "createdAt": "2021-11-16T16:56:19Z",
              "updatedAt": "2021-11-16T20:59:08Z"
            },
            {
              "originalPosition": 225,
              "body": "\"the leaf with node `N`\" doesn't really parse for me.  Suggest \"the leaf node `L`\", removing \"with\" and using `L` as elsewhere.",
              "createdAt": "2021-11-16T16:58:01Z",
              "updatedAt": "2021-11-16T20:59:08Z"
            },
            {
              "originalPosition": 322,
              "body": "We probably need to provide more elaboration here to be explicit about the relations, and that probably requires re-importing a little bit of the tree math.  Suggested:\r\n\r\nThe nodes are listed in the order specified by a left-to-right in-order traversal of the rachet tree.  Each node is listed between its left subtree and its right subtree.  The leaves of the tree are stored in even-numbered entries in the array (the leaf with index `L` in array position `2*L`).  The root node of the tree is at position `2^k - 1` of the array, where `k` is the largest number such that `2^k` is smaller than the length of the array.  Intermediate parent nodes can be identified by performing the same calculation to the subarrays to the left and right of the root, following something like the following algorithm:\r\n\r\n```\r\n# Assuming a class Node that has left and right members\r\ndef subtree_root(nodes):\r\n    # If there is only one node in the array return it\r\n    if len(nodes) == 1:\r\n        return Node(nodes[0])\r\n\r\n    # Otherwise, the length of the array MUST be odd\r\n    if len(nodes) % 2 == 0:\r\n        raise Exception(\"Malformed node array {}\", len(nodes))\r\n    \r\n    # Identify the root of the subtree\r\n    k = 1\r\n    while (1 << k) < len(nodes):\r\n       k += 1\r\n    R = (1 << (k-1)) - 1\r\n    root = Node(nodes[R])\r\n    root.left = subtree_root(nodes[:R])\r\n    root.right = subtree_root(nodes[(R+1):])\r\n    return root\r\n```\r\n\r\nThe example tree in {{tree-computation-terminology}} would be represented as an array of nodes in the following form, where `R` represents the \"subtree root\" for a given subarray of the node array:\r\n\r\n```\r\n              7\r\n        ______|______\r\n       /             \\\r\n      3              11\r\n    __|__           __|\r\n   /     \\         /   \\\r\n  1       5       9     |\r\n / \\     / \\     / \\    |\r\nA   B   C   D   E   F   G\r\n\r\n                    1 1 1\r\n0 1 2 3 4 5 6 7 8 9 0 1 2\r\n<-----------> P <------->\r\n<---> P <--->   <---> P -\r\n- P -   - P -   - P -\r\n```",
              "createdAt": "2021-11-16T20:45:59Z",
              "updatedAt": "2021-11-16T20:59:08Z"
            },
            {
              "originalPosition": 333,
              "body": "I might keep this appendix, but change the emphasis:\r\n\r\n# Array-Based Tree Representation\r\n\r\nThe ratchet tree extension defined in {{ratchet-tree-extension}} provides a way to transport a ratchet tree as an array of nodes, such that relationships among the nodes correspond to certain numerical relationships between the indices of the nodes in the array.  These numerical relationship can be used to enable an array-based in-memory representation (in addition to the on-the-wire representation) or to facilitate decoding of the wire-format array into another in-memory representation.  In this appendix, we provide provide Python example code for computing several common relationships among nodes, for example mapping between parents and left/right children.",
              "createdAt": "2021-11-16T20:53:32Z",
              "updatedAt": "2021-11-16T20:59:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4wMaAy",
          "commit": {
            "abbreviatedOid": "54a2b97"
          },
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-17T13:04:35Z",
          "updatedAt": "2021-11-17T13:04:35Z",
          "comments": [
            {
              "originalPosition": 169,
              "body": "That's right!",
              "createdAt": "2021-11-17T13:04:35Z",
              "updatedAt": "2021-11-17T13:04:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4wMfao",
          "commit": {
            "abbreviatedOid": "9dfd741"
          },
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-17T13:24:21Z",
          "updatedAt": "2021-11-17T13:24:21Z",
          "comments": [
            {
              "originalPosition": 225,
              "body": "Fixed it in a new commit.",
              "createdAt": "2021-11-17T13:24:21Z",
              "updatedAt": "2021-11-17T13:24:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4wMjtt",
          "commit": {
            "abbreviatedOid": "9dfd741"
          },
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-17T13:39:20Z",
          "updatedAt": "2021-11-17T13:39:21Z",
          "comments": [
            {
              "originalPosition": 322,
              "body": "It looks good, however I think the `R` (that \"represents the subtree root\") and the `P` in the drawing should be the same letter?",
              "createdAt": "2021-11-17T13:39:20Z",
              "updatedAt": "2021-11-17T13:39:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4wMmFL",
          "commit": {
            "abbreviatedOid": "9dfd741"
          },
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-17T13:47:34Z",
          "updatedAt": "2021-11-17T13:47:34Z",
          "comments": [
            {
              "originalPosition": 322,
              "body": "Also I suggest the following change to the code, so that the `k` in the code and the `k` in the text above it are the same:\r\n```\r\n    k = 0\r\n    while (1 << (k+1)) < len(nodes):\r\n       k += 1\r\n    R = (1 << k) - 1",
              "createdAt": "2021-11-17T13:47:34Z",
              "updatedAt": "2021-11-17T13:47:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4wMoBH",
          "commit": {
            "abbreviatedOid": "9dfd741"
          },
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-17T13:53:55Z",
          "updatedAt": "2021-11-17T13:53:55Z",
          "comments": [
            {
              "originalPosition": 333,
              "body": "Keeping it with a different emphasis seems fine, however I think it would better be located in a separate \"implementation recommendation\" document and not in the \"protocol\" document?",
              "createdAt": "2021-11-17T13:53:55Z",
              "updatedAt": "2021-11-17T13:53:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4wYL7W",
          "commit": {
            "abbreviatedOid": "9dfd741"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-19T20:24:07Z",
          "updatedAt": "2021-11-19T20:24:08Z",
          "comments": [
            {
              "originalPosition": 333,
              "body": "I can live with that.  @kkohbrok I think you were going to start an \"implementation considerations\" document?",
              "createdAt": "2021-11-19T20:24:07Z",
              "updatedAt": "2021-11-19T20:24:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4wYNek",
          "commit": {
            "abbreviatedOid": "9dfd741"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "@TWal If you could add the ratchet tree description I provided, I'm OK to merge this.",
          "createdAt": "2021-11-19T20:33:02Z",
          "updatedAt": "2021-11-19T20:33:02Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4wZRWt",
          "commit": {
            "abbreviatedOid": "9dfd741"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-21T14:55:31Z",
          "updatedAt": "2021-11-21T14:55:31Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I would consider using single letters, from the end of the alphabet, for these.  For example:\r\n\r\n```\r\n              X\r\n        ______|______\r\n       /             \\\r\n      V               Z\r\n    __|__           __|\r\n   /     \\         /   \\\r\n  U       W       Y     |\r\n / \\     / \\     / \\    |\r\nA   B   C   D   E   F   G\r\n```",
              "createdAt": "2021-11-21T14:55:31Z",
              "updatedAt": "2021-11-21T14:56:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4wbruE",
          "commit": {
            "abbreviatedOid": "d8e279b"
          },
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-22T13:55:32Z",
          "updatedAt": "2021-11-22T13:55:33Z",
          "comments": [
            {
              "originalPosition": 322,
              "body": "I added the description you provided, and additionally replaced `1 << k` by `2**k` as I think it is more readable.",
              "createdAt": "2021-11-22T13:55:32Z",
              "updatedAt": "2021-11-22T13:55:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4wbtin",
          "commit": {
            "abbreviatedOid": "7b4704e"
          },
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-22T14:01:44Z",
          "updatedAt": "2021-11-22T14:01:44Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "That's indeed better like this, I commited it.",
              "createdAt": "2021-11-22T14:01:44Z",
              "updatedAt": "2021-11-22T14:01:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4w7cwF",
          "commit": {
            "abbreviatedOid": "7b4704e"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Marking this as \"Request changes\" until we get algorithms in place for truncate and add.\r\n\r\n@TWal - Maybe as a compromise, we could do something like the following:\r\n\r\n1. Present brief truncate and add algorithms of roughly the following form:\r\n    * Truncate or extend the list of leaf nodes\r\n    * Construct the unique left-balanced binary tree on the leaves, where each nodes' value is the value of the corresponding node in the old tree.\r\n2. Present the full algorithms in an appendix\r\n\r\nThe key thing here is that truncate only deletes nodes and add only adds blank nodes, so there's not a ton of complexity in specifying the content of the nodes.  (Basically, we take the content of nodes from the old tree and the structure from the new.)  The thing that makes me queasy here is \"corresponding node\", since we don't have a definition for that.  Suggestions welcome.",
          "createdAt": "2021-12-01T22:59:25Z",
          "updatedAt": "2021-12-01T22:59:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 508,
      "id": "PR_kwDOBoyH6c4uitKX",
      "title": "Add value for required_capabilities extension",
      "url": "https://github.com/mlswg/mls-protocol/pull/508",
      "state": "MERGED",
      "author": "franziskuskiefer",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-11-15T16:18:22Z",
      "updatedAt": "2021-11-19T20:20:21Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "fefeaf0a5ae3c4daebcacf8ac752aefebf867842",
      "headRepository": "franziskuskiefer/mls-protocol",
      "headRefName": "patch-5",
      "headRefOid": "3c240274dd2bebb0d96eba3a3bba00e844343863",
      "closedAt": "2021-11-19T20:20:21Z",
      "mergedAt": "2021-11-19T20:20:21Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "bbab27dbd82adcde5a7d61b6ee1d6db36be8ec73"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4wYLJS",
          "commit": {
            "abbreviatedOid": "3c24027"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-11-19T20:20:16Z",
          "updatedAt": "2021-11-19T20:20:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 509,
      "id": "PR_kwDOBoyH6c4unpqC",
      "title": "Be explicit that Credentials can attest to multiple identities",
      "url": "https://github.com/mlswg/mls-protocol/pull/509",
      "state": "OPEN",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The specification currently assumes that a Credential provides a singular identity for a client, when in reality that is not the case.  For example, X509Credential can provide a whole collection of identities, and it's up to the application to decide if its preferred identity is among them.  Just like in TLS, a server can send a cert with 100 domains, but the TLS client knows which one it's looking for.\r\n\r\nThis PR refactors the parts of the spec that refer to identity to be consistent with this idea.  The main impacts are to processing of Update and Remove-within-External-Commit, both cases in which you want the new KeyPackage to logically represent the same identity as the old one.\r\n\r\nThis PR also removes the `endpoint_id` field from KeyPackage.  Since we now reference KeyPackages by KeyPackageID, there's no longer a need for a separate identifier.  (Unless we want an identifier that's stable across epochs, but (a) it's not clear to me that that is needed in general and (b) it can easily be added in an extension, as in fact we have done in Webex.)",
      "createdAt": "2021-11-16T22:20:20Z",
      "updatedAt": "2021-12-17T06:43:15Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "2de18dce6939cf7cbb619d5824e2560c6e5efd57",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "ref-id",
      "headRefOid": "ee54cbd5a57945416dc73248694b1f318977ab6e",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "How appropriate that this is PR (X.)#509 !",
          "createdAt": "2021-11-16T22:20:45Z",
          "updatedAt": "2021-11-16T22:21:34Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The advantage of keeping an `endpoint_id` is that we can mandate in the spec that it can't change across epochs. While if we have a proprietary extension that contains an identifier, every implementation would have to be aware of that extension and enforce that it doesn't change across updates. So I'd be in favor of keeping it.",
          "createdAt": "2021-11-25T09:42:10Z",
          "updatedAt": "2021-11-25T09:42:10Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "This softens the requirements quite a bit, namely:\r\n - There is no more requirement for identities to be unique across the group, e.g. Alice can double-join the tree by occupying two leaves, simply by issuing an Update.\r\n -  An identity can completely change in the course of an Update if the application allows it. \r\n\r\nI'm worried the proposed solution can lead to UB, when clients try to remove a certain member that potentially occupies more than one leaf.",
          "createdAt": "2021-12-01T15:14:39Z",
          "updatedAt": "2021-12-01T15:14:39Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@kkohbrok - We already have an identifier that is stable across epochs -- the leaf index!  We don't have a use for it now (as evidenced by the `KeyPackageID` PR), but it's still there.\r\n\r\n@raphaelrobert - I don't think those concerns hold up.  There's no new risk of double-join; a client can only present an identity for which it can obtain a Credential that is acceptable to other clients.  If a client presents a legitimate identity twice, that's not harm; it might be multiple devices, which we can still uniquely reference by KeyPackageID.  If a client can get Credentials for identities they don't own, that's a bug in the authentication system, not MLS.\r\n\r\nAs far as identities completely changing -- one could consider that a feature, not a bug.  TLS has had to go to [a fair bit of trouble](https://datatracker.ietf.org/doc/draft-ietf-tls-exported-authenticator/) to allow servers to assert additional identities over the course of a connection.  It seems like we have an elegant solution to the problem here.  Applications can of course always be stricter.",
          "createdAt": "2021-12-01T18:13:19Z",
          "updatedAt": "2021-12-01T18:13:19Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It's stable across epochs until you remove the party in that leaf and add another one into it. \r\n\r\nThe options that have been suggested are the following:\r\n- leaf index: is not tied to any particular identity/key package\r\n- key package (id/hash): potentially changes across epochs\r\n- identity in the credential: not unique per group \r\n\r\nNone of these variables/indices/identifiers really does the trick of uniquely and consistently (across epochs) identifying a client in a group. The endpoint id/identity tuple does all of the above. We don't have to use it in message structs, where the key package ids are just fine, as messages are tied to an epoch anyway. I'm just in favor of keeping the endpoint id so it can serve as a consistent identifier for group members for use by the application.",
          "createdAt": "2021-12-01T20:20:43Z",
          "updatedAt": "2021-12-01T20:20:43Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@kkohbrok - I can live with re-adding `endpoint_id`.  I can imagine scenarios where it would be troublesome, but in the worst case, you just fill in some long random junk there.  I have re-added.\r\n\r\nAny other issues, or are we good to merge?",
          "createdAt": "2021-12-06T17:01:33Z",
          "updatedAt": "2021-12-06T17:01:33Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm ok with this approach, but I think this changes the concept of identity enought that we should not merge this without previous discussion either in a meeting or on the mailing list. Is there an interim planned before the WGLC?",
          "createdAt": "2021-12-07T13:48:55Z",
          "updatedAt": "2021-12-07T13:50:02Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "There is no interim planned.  I'll send a ping to the mailing list.",
          "createdAt": "2021-12-07T14:28:40Z",
          "updatedAt": "2021-12-07T14:28:40Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I thought about this some more and I managed to convince myself that the `endpoint_id` is not strictly needed. Not having it however puts a higher burden on either the implementation or on the AS to track changes across epochs in order to ensure continuity. \r\nIn practical terms, the only constant thing about member X is that it occupies leaf node i between the time it was added and removed (regardless of updates during that time). If however X gets removed and a new member Y gets added at the same leaf node, i now references Y and not X, which makes leaf node indices useless across epochs.\r\n\r\nFor me this means one of the following two things must be true:\r\n\r\n a) Implementations emulate the concept of an `endpoint_id`. They assign it to a member at the point in time when the member gets added and delete it when the member gets removed. In between the two events, this `endpoint_id` is used as the only unique identifier for a member.\r\n \r\n b) We put more load on the AS and mandate the AS must be able to correlate two KeyPackages from two different epochs to ascertain the two KeyPackages belong to the same user. For example, member X gets added in epoch A, and updates its KeyPackage (including its credential, HPKE init key, and signature key) in epoch B. The AS must then be able to tell in epoch C whether it's still the same member X or a new member Y, just by looking at the two KeyPackages.",
          "createdAt": "2021-12-07T15:08:24Z",
          "updatedAt": "2021-12-07T15:08:24Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@raphaelrobert Yeah, I think I'm about in the same place as you.  As I think I've said before, to use MLS in Webex, we needed to add a KeyPackage extension for the application unique identifer anyway.  With `endpoint_id`, we could have just used that field.\r\n\r\nBut note that the PR has already been updated to re-add `endpoint_id`.  So are you good with the PR in its current state?",
          "createdAt": "2021-12-07T15:21:00Z",
          "updatedAt": "2021-12-07T15:21:00Z"
        },
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Zooming out on this problem, I will make a couple remarks about options for identifying parties. First, it seems that the above alternatives (and adding some not discussed) can generally be grouped into one of the following categories (for these, 'persistence' implies over the duration of the session/group, and 'directly authenticated' implies either as a credential or an identifier signed through use of a credential):\r\n\r\n1. endpoint identifiers change across epochs and directly authenticated along with that change\r\n2. endpoint identifiers are persistent across epochs and directly authenticated once\r\n3. endpoint identifiers are not persistent across epochs, but directly authenticated only once \r\n4. endpoint identifiers are persistent across epochs, but unauthenticated\r\n\r\nI note the above differentiators, since the role of endpoint identifiers begins to factor in when assessing E2EE. @chelseakomlo and I are working on some of the 'ends' aspect of E2EE and I think the current PR change could prove non-trivial with respect to justifying E2EE in MLS. Option 3 is what Signal does and, throughout the development of MLS, Signal as been used as a guidepost for 'at least equivalent' security. Naturally, if credentials are used directly, we meet Option 2 or 1, dependent on handling. Please correct me if I am wrong, but it appears that the current PR would lead us into Option 4.\r\n\r\nI support keeping credentials, at least in the sense of keys. Actually, in this respect, it is a little confusing with regard the issue with x509. Since early on, \"credential\" in MLS has been used as denoting a signature key, not a certificate that may contain more. Maybe I am not quite seeing the issue as to why the application cannot handle interpreting the certificate as separate to the credential in the spec.\r\n\r\n \r\n",
          "createdAt": "2021-12-10T23:30:02Z",
          "updatedAt": "2021-12-10T23:30:02Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@br-hale Strongly disagree with 'Since early on, \"credential\" in MLS has been used as denoting a signature key, not a certificate that may contain more.'  The notion of a Credential has always included at least an identifier as well as the signature key, in order to address the Unknown Key Share / Identity Misbinding attacks that occur in Signal and elsewhere.  If you put that together with the idea that Credentials are verifiable using some AS, you basically arrive at certificates.\r\n\r\nIn your taxonomy, only option (1) actually works for MLS, assuming that by \"endpoint identifiers\", you mean the authenticated ones, and not just the opaque `endpoint_id`, which just has to be unique.  Option (4) is clearly unacceptable, because the whole point of these identifiers is that they're authenticated by the AS.  Options (2) and (3) don't make sense because members can be added to the group and need to be able to authenticate the other members when they join (so \"directly authenticate once\" doesn't work).  Note that MLS is unlike Signal in that the membership is multi-party and dynamic, and that we seek to address UKS issues that Signal explicitly disclaims.\r\n\r\n> @chelseakomlo and I are working on some of the 'ends' aspect of E2EE and I think the current PR change could prove non-trivial with respect to justifying E2EE in MLS.\r\n\r\nCould you describe more what the issue is here?  Just because the endpoints can change the set of identities they express doesn't seem like it undermines the notion of E2EE.",
          "createdAt": "2021-12-14T16:08:27Z",
          "updatedAt": "2021-12-14T16:08:27Z"
        },
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@bifurcation I agree that option (1) is what is needed for MLS. The discussion above seems to advocate for a variant of option (4) though. This variant question also seems to be the crux of the matter @kkohbrok was pointing out above, so if something is being miscommunicated here it would help if you could clarify that, i.e. that we are at least on the same page regarding (1) being the goal. The 'Signal alignment' only holds as a baseline, i.e. if you are advocating for (4) then I would say that we can and should do better. The claim about options (2) and (3) is incorrect though, since direct authentication occurs at time of group join. \r\n\r\nTo avoid diverging down side discussion points and to keep this PR decision on track, it is essential to establish clarity on the claim that MLS (with the current PR) would be able to offer option (1). Copying from @kkohbrok notes above, we have that (quote):\r\n- leaf index: is not tied to any particular identity/key package\r\n- key package (id/hash): potentially changes across epochs\r\n- identity in the credential: not unique per group\r\n(end quote)\r\n\r\nand as @bifurcation you say, the opaque endpoint_id is by no means sufficient. By elimination, this does not leave many options. So what aspect are you referring ref. \"the authenticated ones\"? I.e. what persistent or rotated endpoint identifier is there which consistently links authenticity throughout the lifespan of the group? Anything that is not persistent is insufficient as is anything that is authenticated in a disconnected manner (e.g. can be replaced and authenticated with a new key that is not linked to the prior one). \r\n",
          "createdAt": "2021-12-15T02:45:56Z",
          "updatedAt": "2021-12-15T02:45:56Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@br-hale What I mean by \"the authenticated ones\" is the identifier(s) in the Credential, in the KeyPackage, which are supposed to be authenticated with the AS.  To be specific: For BasicCredential, the `identity` field, and for X509Credential, identifiers in the `subject` or `subjectAltName` fields.\r\n\r\nSo yes, we have a number of identifiers for endpoints:\r\n\r\n1. Identifiers in credentials (as above)\r\n2. Leaf index: Unique within a group; constant for a member's lifetime in the group, by virtue of tree math\r\n3. `endpoint_id`: Unique within a group; constant for a member's lifetime in the group, by fiat\r\n4. KeyPackageID (==hash): Unique within a group; changes on Commit/Update by the member\r\n\r\nThe point of this PR is just to clarify that the identifiers authenticated in credentials are neither unique within a group nor constant across Commit/Update by the member.  (And to clarify what must remain constant across Commit/Update.)  Does that seem problematic to you?",
          "createdAt": "2021-12-15T15:59:12Z",
          "updatedAt": "2021-12-15T15:59:12Z"
        },
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The issue of credentials not being unique or constant is at the heart of this. Other items here are not authenticated or are reliant on those credentials and therefore the consistency of e.g. the leaf index does not actually imply consistency of identity. \r\n\r\nIf credentials were not unique/constant in the sense that a prior one signs off on the next one, then we would inherit consistency from that (which is different from the case here). Similarly, if a single root identity (\"identity\") were to forward to other sub-identities, then there is consistency in the meaning of identity. \r\n\r\nWhat we have here is a backdoor on switching out identities which would be allowed by the spec - yes, they are subcomponents of a credential, but any sender is not actually assured of which identity they are conversing with. For example, Alice may trust a domain name / email address from Bob, but when that switches part-way through the conversation, there is no opt-out point or notification to Alice. There is considerable drift available to Bob (either unintentionally or maliciously) that could occur without knowledge from other group members. This is noticeably different from the case that Bob simply maliciously forwards messages externally, as the drift occurs internally to the group.",
          "createdAt": "2021-12-17T06:43:15Z",
          "updatedAt": "2021-12-17T06:43:15Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 510,
      "id": "PR_kwDOBoyH6c4uny9j",
      "title": "Use smaller, fixed-size hash-based identifiers",
      "url": "https://github.com/mlswg/mls-protocol/pull/510",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #506 \r\nFixes #504",
      "createdAt": "2021-11-16T22:43:47Z",
      "updatedAt": "2021-12-01T18:21:19Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "fefeaf0a5ae3c4daebcacf8ac752aefebf867842",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "hash-id",
      "headRefOid": "3c337444df2d889deb27994ea349cde3ed7a48d5",
      "closedAt": "2021-12-01T18:21:19Z",
      "mergedAt": "2021-12-01T18:21:18Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "f9de42c97223a99a9587a9fc92f8b748a9beb2d7"
      },
      "comments": [
        {
          "author": "franziskuskiefer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixes #504",
          "createdAt": "2021-11-17T07:59:45Z",
          "updatedAt": "2021-11-17T07:59:45Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4wLJwW",
          "commit": {
            "abbreviatedOid": "3c33744"
          },
          "author": "franziskuskiefer",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-17T07:57:24Z",
          "updatedAt": "2021-11-17T07:57:43Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Should the `Commit` section then use `ProposalRef` rathen than `opaque hash<0..255>` for the `reference`?",
              "createdAt": "2021-11-17T07:57:25Z",
              "updatedAt": "2021-11-17T07:57:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4wMvNw",
          "commit": {
            "abbreviatedOid": "3c33744"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-17T14:14:55Z",
          "updatedAt": "2021-11-17T14:14:56Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "This is done via the changes to ProposalOrRef further down.",
              "createdAt": "2021-11-17T14:14:56Z",
              "updatedAt": "2021-11-17T14:14:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4wMwqX",
          "commit": {
            "abbreviatedOid": "3c33744"
          },
          "author": "franziskuskiefer",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-17T14:19:23Z",
          "updatedAt": "2021-11-17T14:19:23Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Ah missed that, never mind \ud83e\udd26\ud83c\udffb ",
              "createdAt": "2021-11-17T14:19:23Z",
              "updatedAt": "2021-11-17T14:19:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4wnX0F",
          "commit": {
            "abbreviatedOid": "3c33744"
          },
          "author": "franziskuskiefer",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-11-25T07:20:25Z",
          "updatedAt": "2021-11-25T07:20:25Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4w5YEA",
          "commit": {
            "abbreviatedOid": "3c33744"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-12-01T14:40:54Z",
          "updatedAt": "2021-12-01T14:40:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 511,
      "id": "PR_kwDOBoyH6c4un28S",
      "title": "Remove the requirement for Add in external commit",
      "url": "https://github.com/mlswg/mls-protocol/pull/511",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #505 ",
      "createdAt": "2021-11-16T23:10:47Z",
      "updatedAt": "2021-12-01T18:21:53Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "fefeaf0a5ae3c4daebcacf8ac752aefebf867842",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "no-add-ext-commit",
      "headRefOid": "5a244893cd48393d091743f9533da1eb15326e84",
      "closedAt": "2021-12-01T18:21:52Z",
      "mergedAt": "2021-12-01T18:21:52Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "aba6ccfc29f8ed368121f0985620e51e0aba3e2b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4w5YlZ",
          "commit": {
            "abbreviatedOid": "5a24489"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Approved, but see my comment in https://github.com/mlswg/mls-protocol/issues/505#issuecomment-974637916",
          "createdAt": "2021-12-01T14:42:30Z",
          "updatedAt": "2021-12-01T14:42:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 512,
      "id": "PR_kwDOBoyH6c4uymDz",
      "title": "Remove explicit version pin on HPKE",
      "url": "https://github.com/mlswg/mls-protocol/pull/512",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "HPKE is in the RFC Editor queue, so there shouldn't be any further changes.\r\n\r\nFixes #500 ",
      "createdAt": "2021-11-19T20:39:01Z",
      "updatedAt": "2021-11-30T22:51:50Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "0aa8fce7086292984c40d55c629d99ef0c78a881",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "hpke-version",
      "headRefOid": "d371e31e8fc737a6823f9f6a38372b89b6d4d9d6",
      "closedAt": "2021-11-30T22:51:50Z",
      "mergedAt": "2021-11-30T22:51:49Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "944ad181dfec5915ade68ec5ba484933b3247ef0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4wY3Jk",
          "commit": {
            "abbreviatedOid": "d371e31"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-11-20T11:51:17Z",
          "updatedAt": "2021-11-20T11:51:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 513,
      "id": "PR_kwDOBoyH6c4uywxD",
      "title": "Two editorial issues",
      "url": "https://github.com/mlswg/mls-protocol/pull/513",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #447 \r\nFixes #468 ",
      "createdAt": "2021-11-19T22:06:36Z",
      "updatedAt": "2021-12-01T18:22:27Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "944ad181dfec5915ade68ec5ba484933b3247ef0",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "editorial",
      "headRefOid": "f95b9d1d96fc4598aaa42e1ad11bfa0118ac2e05",
      "closedAt": "2021-12-01T18:22:26Z",
      "mergedAt": "2021-12-01T18:22:26Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "2de18dce6939cf7cbb619d5824e2560c6e5efd57"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4wY3M5",
          "commit": {
            "abbreviatedOid": "5f86ddd"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-11-20T11:54:13Z",
          "updatedAt": "2021-11-20T11:58:39Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "```suggestion\r\nThis remove operation allows MLS to efficiently achieve\r\n```",
              "createdAt": "2021-11-20T11:54:13Z",
              "updatedAt": "2021-11-20T11:58:39Z"
            },
            {
              "originalPosition": 20,
              "body": "```suggestion\r\npost-compromise security.  In an Update proposal or a full Commit message, an old, possibly\r\n```",
              "createdAt": "2021-11-20T11:54:38Z",
              "updatedAt": "2021-11-20T11:58:40Z"
            },
            {
              "originalPosition": 49,
              "body": "```suggestion\r\nprivate keys of the tree held by each participant would be as follows, where `_`\r\n```",
              "createdAt": "2021-11-20T11:55:41Z",
              "updatedAt": "2021-11-20T11:58:40Z"
            },
            {
              "originalPosition": 96,
              "body": "Thi reintroduces HPKE draft-08. I guess #512 should be merged after this PR.",
              "createdAt": "2021-11-20T11:58:19Z",
              "updatedAt": "2021-11-20T11:58:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4w2rpm",
          "commit": {
            "abbreviatedOid": "f95b9d1"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-30T22:54:32Z",
          "updatedAt": "2021-11-30T22:54:33Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "I merged #512 so this got fixed as a conflict resolution.",
              "createdAt": "2021-11-30T22:54:33Z",
              "updatedAt": "2021-11-30T22:54:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4w5ZA2",
          "commit": {
            "abbreviatedOid": "f95b9d1"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-12-01T14:43:47Z",
          "updatedAt": "2021-12-01T14:43:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 514,
      "id": "PR_kwDOBoyH6c4uyzzj",
      "title": "384 Ciphersuite Addition",
      "url": "https://github.com/mlswg/mls-protocol/pull/514",
      "state": "MERGED",
      "author": "br-hale",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #503 ",
      "createdAt": "2021-11-19T22:30:12Z",
      "updatedAt": "2021-12-01T18:22:10Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "0aa8fce7086292984c40d55c629d99ef0c78a881",
      "headRepository": "br-hale/mls-protocol",
      "headRefName": "master",
      "headRefOid": "5f6b5f272a7ef641a34772d232a70c604cd9e7d6",
      "closedAt": "2021-12-01T18:22:10Z",
      "mergedAt": "2021-12-01T18:22:10Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "43a6dcdbc04aeff809e460e3773b25a19be08ade"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4wYh9J",
          "commit": {
            "abbreviatedOid": "57c5883"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "@br-hale I may have been over-optimistic when I said this was a one-line PR :)  Could you please update the tables below the change you made? You need a row of the following form:\r\n\r\n```\r\n| Value  | KEM    | KDF    | AEAD   | Hash   | Signature              |\r\n|:-------|:-------|:-------|:-------|:-------|:-----------------------|\r\n| 0x0007 | 0x0011 | 0x0002 | 0x0002 | SHA384 | ecdsa_secp384r1_sha384 |\r\n```\r\n\r\n... and to update this text:\r\n\r\n>  In the ciphersuites defined above, \"SHA256\" and \"SHA512\" refer to the SHA-256 and SHA-512 functions defined in {{SHS}}.\r\n\r\nWith those two changes, I think this is good to merge.",
          "createdAt": "2021-11-19T22:46:29Z",
          "updatedAt": "2021-11-19T22:51:32Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\n| 0x0007          | MLS10_256_DHKEMP384_AES256GCM_SHA384_P384.            | Y           | RFC XXXX  |\r\n```",
              "createdAt": "2021-11-19T22:46:29Z",
              "updatedAt": "2021-11-19T22:51:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4wYj5A",
          "commit": {
            "abbreviatedOid": "eda75ba"
          },
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-19T23:05:05Z",
          "updatedAt": "2021-11-19T23:05:05Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "You committed to a one-line change! \r\nNo problem - changes made, as well as a typo correction that was lingering in the spec.",
              "createdAt": "2021-11-19T23:05:05Z",
              "updatedAt": "2021-11-19T23:05:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4w2rKJ",
          "commit": {
            "abbreviatedOid": "5f6b5f2"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-11-30T22:51:29Z",
          "updatedAt": "2021-11-30T22:51:29Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4w5Zpq",
          "commit": {
            "abbreviatedOid": "5f6b5f2"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "If this is needed for the reasons mentioned in the issue, I have no objections.",
          "createdAt": "2021-12-01T14:45:42Z",
          "updatedAt": "2021-12-01T14:45:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 515,
      "id": "PR_kwDOBoyH6c4uzS2Z",
      "title": "Add protocol version to PGS",
      "url": "https://github.com/mlswg/mls-protocol/pull/515",
      "state": "MERGED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This is a follow-up to #501 (which was merged before all comments were addressed).",
      "createdAt": "2021-11-20T11:39:00Z",
      "updatedAt": "2021-12-01T06:51:45Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "0aa8fce7086292984c40d55c629d99ef0c78a881",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "pgs-follow-up",
      "headRefOid": "e8a6d08f6f64c09cc1cc297265da3d2c2239de3c",
      "closedAt": "2021-11-30T22:50:25Z",
      "mergedAt": "2021-11-30T22:50:25Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "3e35dbb41921826ad98c2fdb71cf9340146be0b8"
      },
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sorry for chiming in so late, but isn't this redundant, as the version is included in the ciphersuite? Same for the `Welcome` message.",
          "createdAt": "2021-12-01T06:51:45Z",
          "updatedAt": "2021-12-01T06:51:45Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4w2q-B",
          "commit": {
            "abbreviatedOid": "e8a6d08"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-11-30T22:50:15Z",
          "updatedAt": "2021-11-30T22:50:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 517,
      "id": "PR_kwDOBoyH6c4vN01T",
      "title": "Recommend against self-Update proposals in Commit",
      "url": "https://github.com/mlswg/mls-protocol/pull/517",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #516 ",
      "createdAt": "2021-11-30T23:26:49Z",
      "updatedAt": "2021-12-01T13:44:42Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "944ad181dfec5915ade68ec5ba484933b3247ef0",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "no-self-update",
      "headRefOid": "e6fc5b5e1c6db41c83d8662c7d753ea00f75fcb2",
      "closedAt": "2021-12-01T13:44:41Z",
      "mergedAt": "2021-12-01T13:44:41Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "22511303091bc68165a5208686ad252837f96b3e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4w2035",
          "commit": {
            "abbreviatedOid": "e6fc5b5"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-12-01T00:02:17Z",
          "updatedAt": "2021-12-01T00:02:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 518,
      "id": "PR_kwDOBoyH6c4vN3Iw",
      "title": "Consolidate resumption PSK cases",
      "url": "https://github.com/mlswg/mls-protocol/pull/518",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #502 ",
      "createdAt": "2021-11-30T23:49:26Z",
      "updatedAt": "2021-12-15T16:30:30Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "944ad181dfec5915ade68ec5ba484933b3247ef0",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "consolidate-psk",
      "headRefOid": "a03e84ac1226797c6740eb584a3484d618489b68",
      "closedAt": "2021-12-15T16:30:30Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Comments in associated #502 discussion.",
          "createdAt": "2021-12-10T22:26:09Z",
          "updatedAt": "2021-12-10T22:26:09Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing in favor of #525 ",
          "createdAt": "2021-12-15T16:30:30Z",
          "updatedAt": "2021-12-15T16:30:30Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4xaE--",
          "commit": {
            "abbreviatedOid": "a03e84a"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-12-10T13:55:58Z",
          "updatedAt": "2021-12-10T13:55:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 519,
      "id": "PR_kwDOBoyH6c4vQTbr",
      "title": "Forbid self-Update entirely",
      "url": "https://github.com/mlswg/mls-protocol/pull/519",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #516 ",
      "createdAt": "2021-12-01T15:06:27Z",
      "updatedAt": "2021-12-01T18:13:54Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "22511303091bc68165a5208686ad252837f96b3e",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "no-self-update-2",
      "headRefOid": "073cfc62b2084fbe45e56c67f8a347a743daec4f",
      "closedAt": "2021-12-01T18:13:54Z",
      "mergedAt": "2021-12-01T18:13:54Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "7ae42740abd5576b45a11ecbf378d38a95fe993b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4w6dSd",
          "commit": {
            "abbreviatedOid": "073cfc6"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-12-01T17:59:53Z",
          "updatedAt": "2021-12-01T17:59:53Z",
          "comments": []
        }
      ]
    },
    {
      "number": 520,
      "id": "PR_kwDOBoyH6c4vQznm",
      "title": "Revamp overview sections",
      "url": "https://github.com/mlswg/mls-protocol/pull/520",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "First part of fixing #409 ",
      "createdAt": "2021-12-01T17:06:11Z",
      "updatedAt": "2021-12-15T16:29:35Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "22511303091bc68165a5208686ad252837f96b3e",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "doc-structure",
      "headRefOid": "023f047737d63e2a3a05f2ae8bbe2082587bc2fb",
      "closedAt": "2021-12-15T16:29:35Z",
      "mergedAt": "2021-12-15T16:29:35Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "500f8d670bc73c7e276209ffbc0dd2b0758f452a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4xOx_s",
          "commit": {
            "abbreviatedOid": "3654dc6"
          },
          "author": "zouhuan1215",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "some comments on the overview section from a beginner's point of view.",
          "createdAt": "2021-12-08T02:44:01Z",
          "updatedAt": "2021-12-09T13:15:18Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "`MLS message` is undefined.  How about `..... message carrying information about group operations` ?",
              "createdAt": "2021-12-08T02:44:01Z",
              "updatedAt": "2021-12-09T13:15:18Z"
            },
            {
              "originalPosition": 18,
              "body": "I'm not sure if it is proper to further explain the `proposal`, `commit`, and `welcome` messages used in the handshake protocols here. ",
              "createdAt": "2021-12-08T02:49:13Z",
              "updatedAt": "2021-12-09T13:15:18Z"
            },
            {
              "originalPosition": 55,
              "body": "DS is explained much clear in this way \ud83c\udf7b ",
              "createdAt": "2021-12-08T03:00:21Z",
              "updatedAt": "2021-12-09T13:15:18Z"
            },
            {
              "originalPosition": 115,
              "body": "I love this figure. It explains the relationship of various trees and ratchets much clear. From the beginner's point of view, I think it would be nice to add more functional behavior specifications of the ratchet trees and secret trees here. ",
              "createdAt": "2021-12-08T03:11:49Z",
              "updatedAt": "2021-12-09T13:15:18Z"
            },
            {
              "originalPosition": 115,
              "body": "I'm not sure if I understand MLS correctly: in the handshake protocol, the ratchet tree (as described in section 5) allows group members to efficiently agree on a shared `epoch_secret`; in the application protocol, the secret tree (section 8.3) initiated by `encryption_secret` allows each member to have its own sending secret $s$, furthermore, to achieve forward secrecy, a symmetric key ratchet (section 8.4 and 8.5) initiated by $s$ is maintained per group member. ",
              "createdAt": "2021-12-08T03:26:47Z",
              "updatedAt": "2021-12-09T13:15:18Z"
            },
            {
              "originalPosition": 120,
              "body": "It seems like that the `KeyPackage` and `PublicGroupState` **objects** are not at the same level as the other three **messages**. For example, the `KeyPackage` of a newly added member will be included in an `Add Proposal` message and `PublicGroupState` of the current epoch will be included in a `Welcome` message. ",
              "createdAt": "2021-12-08T06:55:09Z",
              "updatedAt": "2021-12-09T13:15:18Z"
            },
            {
              "originalPosition": 134,
              "body": "It might be more clearer to explain the creation of an MLS message explicitly. For example:\r\n\r\n*To prepare a Proposal message, Commit message or an Application message sent to other members, the sender needs to perform two steps: (1) determine the message content; (2) embed the message content into a common message framing structure. Different message types have different content fields to be filled, as shown in Section 11.1 for proposal messages, Section 11.2 for commit messages. With filled up message content,  the message framing section (Section 9) speficies ways to authenticate and encrypt the message content, as well as ways to assemble the possibly encrypted message content, its authenticate tags and other associated data into an MLS message.*\r\n\r\n*When a member receives an MLS message, it performs two steps accordingly: (1) verifies, decrypts and extracts the message content from the message framing; (2) processes the message content. e.g., if the message content type is Application data, it just forwards the decrypted content to the application; if the message is a Proposal, it may cache this Proposal for future commit; if the message is a Commit, it extracts the committed proposals, applies these proposals to updating its current cryptographic state in order to keep a consistent groups state with the committer.* ",
              "createdAt": "2021-12-08T08:59:38Z",
              "updatedAt": "2021-12-09T13:15:18Z"
            },
            {
              "originalPosition": 134,
              "body": "How about the `Welcome message` ? It seems like that the `Welcome message` is not arranged in the `message framing`?",
              "createdAt": "2021-12-08T09:00:57Z",
              "updatedAt": "2021-12-09T13:15:18Z"
            },
            {
              "originalPosition": 162,
              "body": "Not all commit messages have their corresponding Welcome messages. Only Commit message that commits Add proposals has corresponding Welcome messages?",
              "createdAt": "2021-12-08T11:35:16Z",
              "updatedAt": "2021-12-09T13:15:18Z"
            },
            {
              "originalPosition": 93,
              "body": "`A group represents a linear sequence of epochs` seems somewhat weird to me \ud83d\ude05 ",
              "createdAt": "2021-12-08T11:47:34Z",
              "updatedAt": "2021-12-09T13:15:18Z"
            },
            {
              "originalPosition": 93,
              "body": "The following sentences are from Tijana Klimovic master thesis: [Modular Design of the Messaging\r\nLayer Security (MLS) Protocol](https://ethz.ch/content/dam/ethz/special-interest/infk/inst-infsec/appliedcrypto/education/theses/Modular_Design_of_the_Messaging_Layer_Security__MLS__TijanaKlimovic.pdf)\r\n\r\n*The time frame within which the group members use the same group data to perform sends and receives of application data is called an epoch. Each epoch has a so called epoch number associated to\r\nit, which is equal to the number of commits processed since the group\u2019s creation until this epoch started. Within each epoch, each group member also has their own local message counter, responsible for counting the number of messages sent by this group member within the epoch.*",
              "createdAt": "2021-12-08T12:26:38Z",
              "updatedAt": "2021-12-09T13:15:18Z"
            },
            {
              "originalPosition": 93,
              "body": "How about this?\r\n\r\n*The time frame within which the group members use the same group data to perform sends and receives of application data is called an epoch. The group will enter into a new epoch once group changes (e.g., add/remove/update a member). When a Commit message indicating group changes have taken effect is processed, the epoch number associated to current epoch will increment by 1. In each epoch, a set of authenticated members agree on an epoch secret and MLS assures that only the members in the current epoch have access to the epoch secret. To achieves this, each group member privately maintains a ratchet tree which allows group members to efficiently agree on a shared new epoch secret once group changes. To reflect group changes in the epoch_secret, each group member first applies the Commit message to update its own ratchet tree. Using this updated ratchet tree, group members can compute a shared secret commit_secret which is consistent across the group. With this consistent commit_secret, the epoch secret for this new epoch can be computed via key schedule. From this epoch secret, members derive further shared secrets for this new epoch which will be used for message encryption, group membership authentication, etc. Specifically, within each epoch, each group member has their own local message counter, responsible for counting the number of messages sent by this group member and received from other members within the epoch. To achieve forward-secrecy of messages within the epoch, each group member privately maintains a Secret Tree which initializes the sending and receiving state for the group member as well as symmetric key ratchets to track the sending and receiving state.*",
              "createdAt": "2021-12-09T03:23:49Z",
              "updatedAt": "2021-12-09T13:15:18Z"
            },
            {
              "originalPosition": 257,
              "body": "`A member can update this message by ......` what does `this message` refer to? Or `A member can update its corresponding leaf secret by .......`?",
              "createdAt": "2021-12-09T11:42:35Z",
              "updatedAt": "2021-12-09T13:15:18Z"
            },
            {
              "originalPosition": 257,
              "body": "To say the `leaf secret` of a `member`, it is better to explicitly declare that `a member is associated with a leaf node in the ratchet tree and only this member knows the secret of the leaf node` in the previous Ratchet Tree part.",
              "createdAt": "2021-12-09T11:47:19Z",
              "updatedAt": "2021-12-09T13:15:18Z"
            },
            {
              "originalPosition": 261,
              "body": "I think the core idea of *ratchet tree* is the same as the *sender key*. i.e., when committing a new group change, the committer will re-sample a new group secret $gs$ for the group. But the difficult part is how do the committer efficiently distributes $gs$ to other group members. In *sender key*, the committer simply encrypts $gs$ $N$ times (where N is the number of group members in this group) using each member's public key and delivers each $gs$'s ciphertext to its corresponding group member. In *ratchet tree*, group members are organized into a tree and each member is associated with a leaf node in the tree (i.e., there are $N$ leaf nodes). Furthermore, *ratchet tree* ensures that the secret key of a non-leaf node is known to the members whose corresponding leaf nodes are in the subtree rooted at that non-leaf node. In particular, the secret key of the root node is known by all group members. When the committer needs to distribute the newly sampled group secret $gs$ to the leaf nodes under a non-leaf node $k$, the committer can use the public key of $k$ to encrypt $gs$ instead of individually encrypting $gs$ using each leaf node's public keys. In this way, the ratchet tree achieves a more efficient group key distribution.",
              "createdAt": "2021-12-09T13:10:44Z",
              "updatedAt": "2021-12-09T13:15:18Z"
            },
            {
              "originalPosition": 261,
              "body": "In ratchet tree, the the group secret $gs$ can be viewed as the `secret` of the root node. To sample a new group secret (i.e., the root node secret $rs$) for the group, the committer first updates the ratchet tree by resampling a new leaf secret for its corresponding leaf node. With the updated ratchet tree, the root node secret $rs$ is updated. When distributing this updated ratchet tree to other group members, the committer needs to keep the `tree invariant`, that is, `the secret of a non-leaf node $k$ should be known by all leaf nodes under $k$`.",
              "createdAt": "2021-12-09T13:11:08Z",
              "updatedAt": "2021-12-09T13:15:18Z"
            },
            {
              "originalPosition": 261,
              "body": "To remove a member $m$, the committer simply does not send any information of the updated ratchet tree to $m$, so that $m$ won't know the updated group secret $gs$. \r\nFor post-compromise security, that is, for a client $s$ to quickly recover from a compromised state (e.g., its corresponding leaf secret $ls$ is leaked to an attacker), the client $c$ can send a Commit message asking for resampling its leaf secret as $ls'$. As long as the updated leaf secret $ls'$ is unknown to the attacker, the attacker cannot learn any information regarding the newly updated group secret $gs'$. ",
              "createdAt": "2021-12-09T13:13:32Z",
              "updatedAt": "2021-12-09T13:15:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4xpurS",
          "commit": {
            "abbreviatedOid": "3654dc6"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-15T16:03:36Z",
          "updatedAt": "2021-12-15T16:03:36Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Updated to refer to Proposal/Commit.  I think it's fine to use them here before their definitions.",
              "createdAt": "2021-12-15T16:03:36Z",
              "updatedAt": "2021-12-15T16:03:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4xpvcD",
          "commit": {
            "abbreviatedOid": "3654dc6"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-15T16:06:08Z",
          "updatedAt": "2021-12-15T16:06:08Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "That understanding is correct!",
              "createdAt": "2021-12-15T16:06:08Z",
              "updatedAt": "2021-12-15T16:06:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4xpwA8",
          "commit": {
            "abbreviatedOid": "3654dc6"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-15T16:07:57Z",
          "updatedAt": "2021-12-15T16:07:58Z",
          "comments": [
            {
              "originalPosition": 120,
              "body": "KeyPackage is a little unique in that it is both something that is handled by the application and something that appears within other objects (like `Add` and `Commit`). Other things that are handled by the application are don't appear within other objects (`PublicGroupState`, but also `Welcome`, `MLSPlaintext`, and `MLSCiphertext`)",
              "createdAt": "2021-12-15T16:07:57Z",
              "updatedAt": "2021-12-15T16:07:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4xpxjL",
          "commit": {
            "abbreviatedOid": "3654dc6"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-15T16:13:02Z",
          "updatedAt": "2021-12-15T16:13:02Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "Your proposed text is a bit more detail that I'd like for this section.  But I have revised to clarify that MLSPlaintext/Ciphertext are for messages *within* a group, where as KeyPackage/Welcome/PublicGroupState are *outside* a group.",
              "createdAt": "2021-12-15T16:13:02Z",
              "updatedAt": "2021-12-15T16:13:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4xpyS6",
          "commit": {
            "abbreviatedOid": "3654dc6"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-15T16:15:29Z",
          "updatedAt": "2021-12-15T16:15:30Z",
          "comments": [
            {
              "originalPosition": 162,
              "body": "Technically, you can generate a Welcome message with no recipients, in which case you can have a Welcome corresponding to every Commit.  But I can see how that's confusing at this level.  Revised to say \"each Commit that adds member(s) to the group\".",
              "createdAt": "2021-12-15T16:15:29Z",
              "updatedAt": "2021-12-15T16:15:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4xpztp",
          "commit": {
            "abbreviatedOid": "3654dc6"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-15T16:20:11Z",
          "updatedAt": "2021-12-15T16:20:11Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "Agree that this is unclear.  Flipped it around to start with groups and say that a group's history is divided into a linear sequence of epochs. ",
              "createdAt": "2021-12-15T16:20:11Z",
              "updatedAt": "2021-12-15T16:20:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4xp0bj",
          "commit": {
            "abbreviatedOid": "3654dc6"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-15T16:22:32Z",
          "updatedAt": "2021-12-15T16:22:33Z",
          "comments": [
            {
              "originalPosition": 257,
              "body": "`can update this message` -- this is just a typo, and we shouldn't mention leaf secrets here.  Reworded.\r\n\r\n",
              "createdAt": "2021-12-15T16:22:32Z",
              "updatedAt": "2021-12-15T16:22:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4xp2It",
          "commit": {
            "abbreviatedOid": "3654dc6"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-15T16:27:54Z",
          "updatedAt": "2021-12-15T16:27:55Z",
          "comments": [
            {
              "originalPosition": 261,
              "body": "The differences to sender keys are larger than you say.  With sender keys, each sender has an independent key `k_i`; there is no shared group state.  To remove someone (including PCS updates), each sender needs to distribute a new key `k'_i` to the remaining `N-1` participants.  This results in `(N-1)^2` messages of size `O(1)`.\r\n\r\nIn MLS, because there is shared group state, you only need some entropy that is not sent to the evicted member, as you say.  So you only need a single message of size `O(N-1)` in the worst case and `O(log(N-1))` with a populated tree.",
              "createdAt": "2021-12-15T16:27:54Z",
              "updatedAt": "2021-12-15T16:27:55Z"
            }
          ]
        }
      ]
    },
    {
      "number": 521,
      "id": "PR_kwDOBoyH6c4vXl8j",
      "title": "Add algorithms for link-based trees",
      "url": "https://github.com/mlswg/mls-protocol/pull/521",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed in #507, having algorithms for a \"link-based\" representation of the tree would help emphasize that the array-based tree representation is not required.  This PR adds them in an appendix.",
      "createdAt": "2021-12-03T15:58:09Z",
      "updatedAt": "2021-12-06T16:39:27Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "2de18dce6939cf7cbb619d5824e2560c6e5efd57",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "algo",
      "headRefOid": "919234f014a9fd611eb643d058d07e8fd3e8c0a9",
      "closedAt": "2021-12-06T16:39:27Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "cc @TWal @franziskuskiefer ",
          "createdAt": "2021-12-03T15:58:25Z",
          "updatedAt": "2021-12-03T15:58:25Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Subsumed by #522 ",
          "createdAt": "2021-12-06T16:39:27Z",
          "updatedAt": "2021-12-06T16:39:27Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4xGcb3",
          "commit": {
            "abbreviatedOid": "919234f"
          },
          "author": "franziskuskiefer",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "lgtm",
          "createdAt": "2021-12-06T10:23:41Z",
          "updatedAt": "2021-12-06T10:24:18Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Do we need both, pseudo code and python code? I'd be fine with the python code only and some of this as comments if you feel like it.",
              "createdAt": "2021-12-06T10:23:41Z",
              "updatedAt": "2021-12-06T10:24:18Z"
            }
          ]
        }
      ]
    },
    {
      "number": 522,
      "id": "PR_kwDOBoyH6c4vctWX",
      "title": "Generalize tree extend/truncate algorithms",
      "url": "https://github.com/mlswg/mls-protocol/pull/522",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR builds on #507 and #521.  It adds the following:\r\n\r\n* An explicit note in `Ratchet Tree Terminology` that implementations may use any representation\r\n* A general description of how nodes are added to / removed from the tree\r\n* Specific algorithms for \"array-based trees\" and \"link-based trees\"\r\n\r\n(I also made a few minor editorial revisions.)\r\n\r\n@TWal @franziskuskiefer - I think this hits the right balance of specificity and generality.  Interested in your thoughts here.",
      "createdAt": "2021-12-06T16:30:14Z",
      "updatedAt": "2021-12-15T16:30:09Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "2de18dce6939cf7cbb619d5824e2560c6e5efd57",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "descriptive",
      "headRefOid": "05fdeee5ad6cd808d774b7ccd46e77d46284d8a2",
      "closedAt": "2021-12-15T16:30:08Z",
      "mergedAt": "2021-12-15T16:30:08Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "6754a8edc9d77c902643d37a519b9a546ab00b4e"
      },
      "comments": [
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This looks good!\r\n\r\nIf I am understanding everything well, the normative description for extention / truncation is the section \"Adding and Removing Leaves\", which is a tree-based description?\r\n",
          "createdAt": "2021-12-07T11:45:04Z",
          "updatedAt": "2021-12-07T11:45:04Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4xKryF",
          "commit": {
            "abbreviatedOid": "3533678"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-12-07T07:41:33Z",
          "updatedAt": "2021-12-07T07:41:33Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4xLu0X",
          "commit": {
            "abbreviatedOid": "3533678"
          },
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-07T11:38:59Z",
          "updatedAt": "2021-12-07T11:39:00Z",
          "comments": [
            {
              "originalPosition": 348,
              "body": "```suggestion\r\nempty leaf to the right, etc. If no empty leaf exists, the tree is extended to\r\n```",
              "createdAt": "2021-12-07T11:38:59Z",
              "updatedAt": "2021-12-07T11:39:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4xK6nu",
          "commit": {
            "abbreviatedOid": "3533678"
          },
          "author": "franziskuskiefer",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-07T08:35:46Z",
          "updatedAt": "2021-12-07T11:39:16Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "`CD` -> `Z`?",
              "createdAt": "2021-12-07T08:35:47Z",
              "updatedAt": "2021-12-07T11:39:16Z"
            },
            {
              "originalPosition": 135,
              "body": "I think this description can lead to confusion. This reads as if only the right most member in the tree could be removed from the group, i.e. removing a member from a group is equal to truncating the tree.",
              "createdAt": "2021-12-07T08:39:06Z",
              "updatedAt": "2021-12-07T11:39:16Z"
            },
            {
              "originalPosition": 348,
              "body": "\"If no empty leaf exists\"",
              "createdAt": "2021-12-07T09:37:37Z",
              "updatedAt": "2021-12-07T11:39:16Z"
            },
            {
              "originalPosition": 417,
              "body": "KeyPackageRef",
              "createdAt": "2021-12-07T11:33:33Z",
              "updatedAt": "2021-12-07T11:39:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4xMNye",
          "commit": {
            "abbreviatedOid": "3533678"
          },
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-07T13:39:08Z",
          "updatedAt": "2021-12-07T14:28:31Z",
          "comments": [
            {
              "originalPosition": 167,
              "body": "It is a bit weird because it is not clear that `D` is a blank leaf. But then we also have to blank Z and Y if we really want to represent what happens in the protocol. And in the example afterward we would also need to blank C.\r\n\r\nI'm not sure what is the best thing to do here, but there can definitely be a confusion here (somehow the same as the one pointed by @franziskuskiefer)",
              "createdAt": "2021-12-07T13:39:08Z",
              "updatedAt": "2021-12-07T14:28:31Z"
            },
            {
              "originalPosition": 632,
              "body": "```suggestion\r\n        X = self.root.rightmost_leaf()\r\n        assert(X.value == \"_\") # We can only truncate blank leaves\r\n```",
              "createdAt": "2021-12-07T13:53:55Z",
              "updatedAt": "2021-12-07T14:28:31Z"
            },
            {
              "originalPosition": 145,
              "body": "I suggest giving names to make it easier to read. Also add emphasis that there is a unique way to incorporate the new parent in the tree that keeps it left-balanced (-> \" [\u2026] as the only appropriate node [\u2026]\").\r\n\r\n```suggestion\r\nTo add a new leaf: Add leaf L as the new rightmost leaf of the tree.  Add\r\na blank parent node P whose right child is L.  P is attached to the\r\ntree as the right child of the only appropriate node to make the updated tree\r\nleft-balanced (or set it as a new root).  The former right child of the P's\r\nparent becomes P's left child (or the old root becomes the P's left child if\r\nP is the new root).\r\n```",
              "createdAt": "2021-12-07T14:10:47Z",
              "updatedAt": "2021-12-07T14:28:31Z"
            },
            {
              "originalPosition": 159,
              "body": "I also suggest giving names to nodes. Also removing \"(formerly the parent itself)\" because I don't see what that means.\r\nIn the first example, the leaf is D, the parent is Z, the parent's parent is Y, so the sentence says that Y's right child is now Z's left child (so C). I don't get what \"former parent\" means here.\r\n```suggestion\r\nTo remove the rightmost leaf: Remove the rightmost leaf node L and its parent\r\nnode P.  If P was the root of the tree, P's left child\r\nis now the root of the tree.  Otherwise, set the right child of P's parent\r\nto be the P's left child.\r\n```",
              "createdAt": "2021-12-07T14:26:44Z",
              "updatedAt": "2021-12-07T14:28:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4xMfqA",
          "commit": {
            "abbreviatedOid": "3533678"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-07T14:32:51Z",
          "updatedAt": "2021-12-07T14:32:52Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "```suggestion\r\n* The resolution of root node is the list \\[A, Z, C\\]\r\n```",
              "createdAt": "2021-12-07T14:32:51Z",
              "updatedAt": "2021-12-07T14:32:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4xMgJw",
          "commit": {
            "abbreviatedOid": "3533678"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-07T14:34:22Z",
          "updatedAt": "2021-12-07T14:34:24Z",
          "comments": [
            {
              "originalPosition": 135,
              "body": "```suggestion\r\nnecessary to add and remove leaves of the tree in order to reflect changes to the\r\nmembership of the group (see {{add}} and {{remove}}).  Leaves are always added and removed at the\r\n```",
              "createdAt": "2021-12-07T14:34:23Z",
              "updatedAt": "2021-12-07T14:34:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4xMhXi",
          "commit": {
            "abbreviatedOid": "3533678"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-07T14:37:59Z",
          "updatedAt": "2021-12-07T14:38:00Z",
          "comments": [
            {
              "originalPosition": 167,
              "body": "`D` isn't necessarily a blank leaf.   In principle, one can remove the rightmost leaf even if it's populated.  This section is just describing the structure modifications; the later sections deal with what's in the tree when it gets update.",
              "createdAt": "2021-12-07T14:38:00Z",
              "updatedAt": "2021-12-07T14:38:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4xMhqW",
          "commit": {
            "abbreviatedOid": "3533678"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-07T14:38:50Z",
          "updatedAt": "2021-12-07T14:38:51Z",
          "comments": [
            {
              "originalPosition": 417,
              "body": "```suggestion\r\n      the member with KeyPackageRef `GroupInfo.signer`. Set the private key for\r\n```",
              "createdAt": "2021-12-07T14:38:50Z",
              "updatedAt": "2021-12-07T14:38:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4xMjFV",
          "commit": {
            "abbreviatedOid": "3533678"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-07T14:43:08Z",
          "updatedAt": "2021-12-07T14:43:57Z",
          "comments": [
            {
              "originalPosition": 458,
              "body": "```suggestion\r\n\r\n(Note that this is the same ordering of nodes as in the array-based tree representation\r\ndescribed in {{array-based-trees}}.  The algorithms in that section may be used to \r\nsimplify decoding this extension into other representations.)\r\n\r\n```",
              "createdAt": "2021-12-07T14:43:08Z",
              "updatedAt": "2021-12-07T14:43:57Z"
            },
            {
              "originalPosition": 458,
              "body": "```suggestion\r\n\r\n(Note that this is the same ordering of nodes as in the array-based tree representation\r\ndescribed in {{array-based-trees}}.  The algorithms in that section may be used to \r\nsimplify decoding this extension into other representations.)\r\n\r\n```",
              "createdAt": "2021-12-07T14:43:56Z",
              "updatedAt": "2021-12-07T14:43:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4xMj2R",
          "commit": {
            "abbreviatedOid": "3533678"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-07T14:45:18Z",
          "updatedAt": "2021-12-07T14:45:18Z",
          "comments": [
            {
              "originalPosition": 632,
              "body": "As above, not true that we can only truncate blank leaves.",
              "createdAt": "2021-12-07T14:45:18Z",
              "updatedAt": "2021-12-07T14:45:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4xMqd8",
          "commit": {
            "abbreviatedOid": "3925732"
          },
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-07T15:04:49Z",
          "updatedAt": "2021-12-07T15:04:58Z",
          "comments": [
            {
              "originalPosition": 178,
              "body": "Even if this only describe the structure modification, I think it is valuable to give hints to the reader that in practice only blank leaves will be removed. If here the reader thinks that we can truncate any leaf and only afterward the reader discovers that only blank leaves can be truncated, I think it can be confusing.\r\nAlso it might look like a violation of the tree invariant, since in the second tree, D knows Y's secret without being its descendant.\r\n\r\n```suggestion\r\n\r\nNote: in the rest of the protocol, the rightmost leaf will be removed only when it is blank.\r\n\r\n```",
              "createdAt": "2021-12-07T15:04:49Z",
              "updatedAt": "2021-12-07T15:04:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4xPYM-",
          "commit": {
            "abbreviatedOid": "05fdeee"
          },
          "author": "franziskuskiefer",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks lgtm now",
          "createdAt": "2021-12-08T08:06:21Z",
          "updatedAt": "2021-12-08T08:06:21Z",
          "comments": []
        }
      ]
    },
    {
      "number": 523,
      "id": "PR_kwDOBoyH6c4vgvGO",
      "title": "Move `wire_format` to a separate tagged-union structure MLSMessage",
      "url": "https://github.com/mlswg/mls-protocol/pull/523",
      "state": "OPEN",
      "author": "TWal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The current use of `wire_format` is a bit weird to me: it is the first value of both `MLSPlaintext` and `MLSCiphertext` which allows the implementations to differentiate between them. Then it looks like it should be implemented as a regular tagged union, which is what this pull request does.\r\n\r\nThis does not imply any changes to existing implementations.\r\n\r\nOne thing that this pull-request changes is that `MLSPlaintext` is forced to have `wire_format = mls_plaintext`, but I don't see why it would have any other values in this case?",
      "createdAt": "2021-12-07T16:50:20Z",
      "updatedAt": "2021-12-17T16:40:20Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "6754a8edc9d77c902643d37a519b9a546ab00b4e",
      "headRepository": "TWal/mls-protocol",
      "headRefName": "twal_wire_format",
      "headRefOid": "839aa87dab229251cb9dd94bfcd5dd6c555d7c40",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I think this problematic, because it implies that the wire format of an `MLSPlaintext` is always `mls_plaintext` (which is true for the final format on the wire, but not when handling things internally). Since the wire format is part of `MLSPlaintextTBS`, this would be confusing for a decrypted `MLSCiphertext` for example. The way it is now is also really nice from an implementation standpoint, because the wire format field essentially tracks whether an `MLSPlaintext` was previously an `MLSCiphertext`.",
          "createdAt": "2021-12-10T14:03:38Z",
          "updatedAt": "2021-12-10T14:03:38Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you, now I understand better why `MLSPlaintext` doesn't have `wire_format = mls_plaintext` like in `MLSCiphertext`.\r\n\r\nI didn't think that `MLSCiphertext` were decoded to a `MLSPlaintext`. In fact, the document never mentions this, however it mentions the converse at the end of section 9.0 (but doesn't talk about `wire_format` though).\r\nIn the rest of the document, messages are named as `MLSPlaintext` (e.g. \"The MLSPlaintext MUST be signed\" and not \"The message MUST be signed\"), so implicitly `MLSCiphertext` have been converted to `MLSPlaintext` (which is a bit weird I think, especially regarding the `membership_tag` that exists in `MLSPlaintext` and not in `MLSCiphertext`).\r\n\r\nI think it would be valuable to refactor the part of the document related to message framing to remove such ambiguities.\r\n\r\nThe easiest way would be to be explicit about the conversion between `MLSPlaintext` and `MLSCiphertext`.\r\n\r\nI spent a lot of time thinking about the nicest way to handle these structures when I implemented these things in the F* implementation of MLS, and I think it could lead to a refactorization of this document.\r\n\r\nWe can define the content of a message (so really, meta-data + the real content) like this:\r\n\r\n    struct {\r\n        opaque group_id<0..255>;\r\n        uint64 epoch;\r\n        Sender sender;\r\n        opaque authenticated_data<0..2^32-1>;\r\n    \r\n        ContentType content_type;\r\n        select (MLSPlaintext.content_type) {\r\n            case application:\r\n              opaque application_data<0..2^32-1>;\r\n    \r\n            case proposal:\r\n              Proposal proposal;\r\n    \r\n            case commit:\r\n              Commit commit;\r\n        }\r\n    } MLSMessageContent;\r\n\r\nAnd the authentication of a message like this:\r\n\r\n    struct {\r\n        opaque signature<0..2^16-1>;\r\n        optional<MAC> confirmation_tag;\r\n    } MLSMessageAuth;\r\n\r\nIf you have a `MLSMessageContent`, you can compute `MLSMessageAuth` (using a signing key, `confirmation_key`, `interim_transcript_hash` and `GroupContext`).\r\nThis would be done by filling correctly the structures `MLSMessageContentTBS` and `MLSMessageContentTBM` (previously `MLSPlaintextTB.`)\r\n\r\nYou can then do the following conversions:\r\n* `MLSPlaintext` to `(MLSMessageContent, MLSMessageAuth)`\r\n* `(MLSMessageContent, MLSMessageAuth)` to `MLSPlaintext` (using `membership_key` and `GroupContext` to compute `membership_tag`)\r\n* `MLSCiphertext` to `(MLSMessageContent, MLSMessageAuth)` (using `sender_data_secret`, and the current state of the Secret Tree)\r\n* `(MLSMessageContent, MLSMessageAuth)` to `MLSCiphertext` (using `sender_data_secret`, and the current state of the Secret Tree)\r\n\r\nThen the rest of the document can then talk about `MLSMessageContent` instead of `MLSPlaintext`.\r\n\r\nI would understand if you want to do the minimal possible changes, however I think doing this kind of big refactor would make this document a lot easier to understand for a first-time reader.\r\n",
          "createdAt": "2021-12-10T16:24:46Z",
          "updatedAt": "2021-12-10T16:24:46Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@TWal - That proposal actually seems like it could make the programming easier, in addition to making the text clearer.  I would be game for a PR if you'd like to write one up.\r\n\r\nGoing back to the original point about `wire_format`: Note that the signature in the MLSMessageAuth is specific to a wire format, so the conversions you note might not be quite as decoupled as you think.  But you still end up with something nicer than what we have today. \r\n\r\n```\r\n# Signing + Encryption\r\n\r\nMLSMessageContent \r\n  --(GroupContext, wire_format, sig_priv, confirmation_key)--> \r\n  (wire_format, MLSMessageContent, MLSMessageAuth)\r\n\r\n  * Compute message signature\r\n  * Update confirmed transcript hash\r\n  * Compute confirmation tag\r\n  * Update interim transcript hash\r\n\r\n\r\n(mls_plaintext, MLSMessageContent, MLSMessageAuth) \r\n  --(GroupContext, membership_key)--> \r\n  MLSPlaintext\r\n\r\n  * Compute membership_tag\r\n  * Assemble MLSPlaintext\r\n\r\n\r\n(mls_ciphertext, MLSMessageContent, MLSMessageAuth) \r\n  --(sender_data_secret, Secret Tree)-->\r\n  MLSCiphertext\r\n\r\n  * Encode and encrypt content\r\n  * Encode and encrypt sender data\r\n  * Assemble MLSCiphertext\r\n\r\n\r\n# Decryption + Verification\r\n\r\nMLSPlaintext \r\n  --(GroupContext, membership_key)-->\r\n  (mls_plaintext, MLSMessageContent, MLSMessageAuth)\r\n\r\n  * Verify membership_tag\r\n  * Parse MLSPlaintext into MLSMessageContent, MLSMessageAuth\r\n\r\n\r\nMLSCiphertext\r\n  --(sender_data_secret, Secret Tree)-->\r\n  (mls_ciphertext, MLSMessageContent, MLSMessageAuth)\r\n\r\n  * Decrypt and decode sender data\r\n  * Decrypt and decode content\r\n  * Parse MLSCiphertext and decrypted values into MLSMessageContent, MLSMessageAuth\r\n\r\n\r\n(wire_format, MLSMessageContent, MLSMessageAuth)\r\n  --(GroupContext, wire_format, sig_pub, confirmation_key)-->\r\n  MLSMessageContent\r\n\r\n  * Verify message signature\r\n  * Update confirmed transcript hash\r\n  * Verify confirmation tag\r\n  * Update interim transcript hash\r\n```",
          "createdAt": "2021-12-14T20:06:07Z",
          "updatedAt": "2021-12-14T20:06:07Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Okay, I'll start working on a PR that uses this decomposition!",
          "createdAt": "2021-12-16T16:37:42Z",
          "updatedAt": "2021-12-16T16:37:42Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I'm not against attempting to refactor this. It has grown organically over time and could certainly benefit from a holistic overhaul. (@TWal not that you omitted the membership tag in your proposal above)",
          "createdAt": "2021-12-16T18:11:24Z",
          "updatedAt": "2021-12-16T18:11:24Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I made a first draft on how the Message Framing section would look like after the refactor. If you agree about these changes I'll change the mentions to `MLSPlaintext` everywhere in the document. What do you think about it? I'm not used to write RFC-like documents so I'm not 100% sure about the formulation I used.\r\n\r\n@raphaelrobert the membership tag is present only in the plaintext and not is the ciphertext, so is it is not part of `MLSMessageAuth`, but only part of `MLSPlaintext`.",
          "createdAt": "2021-12-17T16:40:20Z",
          "updatedAt": "2021-12-17T16:40:20Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 524,
      "id": "PR_kwDOBoyH6c4v0_cY",
      "title": "Careful truncation",
      "url": "https://github.com/mlswg/mls-protocol/pull/524",
      "state": "OPEN",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As @kkohbrok noted [on the mailing list](https://mailarchive.ietf.org/arch/msg/mls/P8CiOeQy3lev7s5vbnaRkPwRa1Q/), the current truncation algorithm breaks parent hashes.  This PR implements the \"careful truncation\" algorithm he proposes.",
      "createdAt": "2021-12-14T14:45:18Z",
      "updatedAt": "2021-12-16T20:22:05Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "2de18dce6939cf7cbb619d5824e2560c6e5efd57",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "ph-trunc",
      "headRefOid": "15d265dc830e8a7848937f1f63ef91d17ed5d131",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4xkqqA",
          "commit": {
            "abbreviatedOid": "43c82e5"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-14T15:50:55Z",
          "updatedAt": "2021-12-14T15:50:56Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "If the parent node is the root node, it can be removed even if it is non-blank, since removing the root node doesn't destroy any valid parent hash chains.",
              "createdAt": "2021-12-14T15:50:56Z",
              "updatedAt": "2021-12-14T15:50:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4xlBIt",
          "commit": {
            "abbreviatedOid": "16add2e"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-14T16:59:35Z",
          "updatedAt": "2021-12-14T16:59:35Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Good point.  Updated to reflect this.",
              "createdAt": "2021-12-14T16:59:35Z",
              "updatedAt": "2021-12-14T16:59:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4xlZvo",
          "commit": {
            "abbreviatedOid": "16add2e"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-12-14T18:31:00Z",
          "updatedAt": "2021-12-14T18:31:00Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4xvAWk",
          "commit": {
            "abbreviatedOid": "16add2e"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-16T17:34:12Z",
          "updatedAt": "2021-12-16T17:34:13Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\n  as all of the following conditions hold (since non-blank intermediate nodes hold\r\n```",
              "createdAt": "2021-12-16T17:34:12Z",
              "updatedAt": "2021-12-16T17:34:13Z"
            }
          ]
        }
      ]
    },
    {
      "number": 525,
      "id": "PR_kwDOBoyH6c4v5flh",
      "title": "Tighten up branch and reinit; define ResumptionPSKUsage",
      "url": "https://github.com/mlswg/mls-protocol/pull/525",
      "state": "OPEN",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR reflects further discussion on #502 and replaces #518.  The high-level impacts are:\r\n\r\n* Add clearer, more prescriptive definitions of the re-init and branch operations\r\n* Use a single syntax for all resumption PSKs, but also have a `usage` parameter to distinguish cases\r\n* Allow an `application` usage to cover any other cases defined by applications\r\n\r\nOnce #520 lands, we should also add some text to the protocol overview to describe these operations.  Pasting some text here for usage in that future PR...\r\n\r\n```\r\n## Relationships Between Epochs\r\n\r\nA group comprises a single linear sequence of epochs. However, it can sometimes\r\nbe useful to express relationships between epochs, either within a group or\r\nacross groups.  MLS derives a resumption pre-shared key (PSK) from each epoch to\r\nallow a entropy extracted from one epoch to be injected into a future epoch,\r\neffectively creating a causal link between the two epochs.\r\n\r\nMLS supports two ways to tie a new group to an existing group. Re-initialization\r\ncloses one group and creates a new group comprising the same members with\r\ndifferent parameters. Branching starts a new group with a subset of the original\r\ngroup's participants (with no effect on the original group).  In both cases,\r\nthe new group is linked to the old group via a resumption PSK.\r\n\r\n~~~~~\r\nepoch_A_[n-1]\r\n     |\r\n     |\r\n     |<-- ReInit\r\n     |\r\n     V\r\nepoch_A_[n]           epoch_B_[0]\r\n     .                     |\r\n     .  PSK(usage=reinit)  |\r\n     .....................>|\r\n                           |\r\n                           V\r\n                      epoch_B_[1]\r\n~~~~~\r\n{: title=\"Reinitializing a group\" }\r\n\r\n\r\n~~~~~\r\nepoch_A_[n-1]\r\n     |\r\n     |\r\n     |<-- ReInit\r\n     |\r\n     V\r\nepoch_A_[n]           epoch_B_[0]\r\n     |                     |\r\n     |  PSK(usage=branch)  |\r\n     |....................>|\r\n     |                     |\r\n     V                     V\r\nepoch_A_[n+1]         epoch_B_[1]\r\n~~~~~\r\n{: title=\"Branching a group\" }\r\n\r\nApplications may also choose to use resumption PSKs to link epochs in other\r\nways.  For example, the following figure shows a case where a resumption PSK\r\nfrom epoch `n` is injected into epoch `n+k`.  This demonstrates that the members\r\nof the group at epoch `n+k` were also members at epoch `n` (irrespective of any\r\nchanges to these members' keys due to Updates or Commits.\r\n\r\n~~~~~\r\nepoch_A_[n-1]\r\n     |\r\n     |\r\n     |<-- ReInit\r\n     |\r\n     V\r\nepoch_A_[n]\r\n     |                     \r\n     |  PSK(usage=application)  \r\n     |.....................\r\n     |                    . \r\n     |                    . \r\n    ...                  ...\r\n     |                    . \r\n     |                    . \r\n     V                    .\r\nepoch_A_[n+k-1]           .\r\n     |                    . \r\n     |                    . \r\n     |<.................... \r\n     |                      \r\n     V                     \r\nepoch_A_[n+k]       \r\n~~~~~\r\n{: title=\"Reinjecting entropy from an earlier epoch\" }\r\n```",
      "createdAt": "2021-12-15T15:45:11Z",
      "updatedAt": "2021-12-17T06:16:33Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "2de18dce6939cf7cbb619d5824e2560c6e5efd57",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "psk-usages",
      "headRefOid": "5b9590b55b09085fd2e7affb3a765f8943f02b75",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One question regarding the diagram in the PR description. In the re-init case, shouldn't the \"B\" group start at epoch `n+1`? At least that's what the PR specifies in the spec.",
          "createdAt": "2021-12-16T07:20:05Z",
          "updatedAt": "2021-12-16T07:20:05Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think the re-init diagram is fine because the spec says\r\n\r\n    The `epoch` in the Welcome message MUST be 1\r\n\r\nHowever in the branch case (and application case) diagram I don't think there should be a ReInit proposal? (At least it is not said in the spec).\r\n\r\nAlso, it is not entirely clear how to construct a `PreSharedKeyID` in the branch case (or application case): what values should have `psk_group_id` and `psk_epoch`?",
          "createdAt": "2021-12-16T13:32:51Z",
          "updatedAt": "2021-12-16T13:32:51Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah, sorry I misread. You are right and the re-init diagram is fine the way it is.",
          "createdAt": "2021-12-16T13:55:29Z",
          "updatedAt": "2021-12-16T13:55:29Z"
        },
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Minor typo in the text above: \"allow a entropy\" -> \"allow entropy\".",
          "createdAt": "2021-12-17T06:16:33Z",
          "updatedAt": "2021-12-17T06:16:33Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4xsV07",
          "commit": {
            "abbreviatedOid": "5b9590b"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Looks good! Although I'm not sure in the branching keys we want to have the exact same key packages as in the main group.",
          "createdAt": "2021-12-16T07:01:28Z",
          "updatedAt": "2021-12-16T07:04:48Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "Do we really want the KeyPackages to be identical? This seems to constitute key-reuse across groups. This is where a (identity,endpoint_id) tuple would come in handy ;-) But I think going with the new multi-identity credentials, we could mandate here that the application has to ensure that the participants in the new group are a subset of the participants in the old group",
              "createdAt": "2021-12-16T07:01:28Z",
              "updatedAt": "2021-12-16T07:04:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4xvGQv",
          "commit": {
            "abbreviatedOid": "5b9590b"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "I think this looks fine generally (just one comment)",
          "createdAt": "2021-12-16T17:57:54Z",
          "updatedAt": "2021-12-16T18:01:16Z",
          "comments": [
            {
              "originalPosition": 143,
              "body": "I wonder if we can be a bit more firm on the fact that the Welcome message should be provided at the same time as the Commit. Because if not, there's an attack vector where malicious members can shut down a group without an obvious way to recover from it.",
              "createdAt": "2021-12-16T17:57:54Z",
              "updatedAt": "2021-12-16T18:01:16Z"
            }
          ]
        }
      ]
    },
    {
      "number": 526,
      "id": "PR_kwDOBoyH6c4v8b_5",
      "title": "Unambiguous signatures",
      "url": "https://github.com/mlswg/mls-protocol/pull/526",
      "state": "OPEN",
      "author": "TWal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Signatures as specified in the MLS protocol document are ambiguous, in the sense that signatures produced for one purpose in the protocol can be (maliciously) used in a different place of the protocol.\r\nIndeed, we found that for example, a `KeyPackage` can have the same serialization as `MLSPlaintextTBS`, which proves that one signature could be accepted for different structures.\r\n\r\nThe collisions we have found so far are quite artificial, so it is not super clear how to exploit this, but at least it makes it impossible to have provable security.\r\n\r\nThe solution is pretty simple, we simply prefix each signed value with a label, in a fashion similar to `ExpandWithLabel`.\r\nThat way, when calling `SignWithLabel` you can give the structure name in the `Label` argument.",
      "createdAt": "2021-12-16T11:56:57Z",
      "updatedAt": "2021-12-18T18:52:01Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "6754a8edc9d77c902643d37a519b9a546ab00b4e",
      "headRepository": "TWal/mls-protocol",
      "headRefName": "twal_signature",
      "headRefOid": "4c0c8bfaa0c5e4eb3adad656b6fd02479598d0bd",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Something that is still bothering me is the `MLSPlaintextTBS` structure:\r\n\r\n    struct {\r\n        select (MLSPlaintextTBS.sender.sender_type) {\r\n            case member:\r\n                GroupContext context;\r\n    \r\n            case preconfigured:\r\n            case new_member:\r\n                struct{};\r\n        }\r\n    \r\n        WireFormat wire_format;\r\n        opaque group_id<0..255>;\r\n        uint64 epoch;\r\n        Sender sender;\r\n        opaque authenticated_data<0..2^32-1>;\r\n    \r\n        ContentType content_type;\r\n        select (MLSPlaintextTBS.content_type) {\r\n            case application:\r\n              opaque application_data<0..2^32-1>;\r\n    \r\n            case proposal:\r\n              Proposal proposal;\r\n    \r\n            case commit:\r\n              Commit commit;\r\n        }\r\n    } MLSPlaintextTBS;\r\n\r\nSince the first `select` is done on a field defined after it, this structure is not parsable. We could say that's not a problem since we only need to serialize it, but for security purposes I would recommend to put it at the end, like this:\r\n\r\n    struct {\r\n        WireFormat wire_format;\r\n        opaque group_id<0..255>;\r\n        uint64 epoch;\r\n        Sender sender;\r\n        opaque authenticated_data<0..2^32-1>;\r\n    \r\n        ContentType content_type;\r\n        select (MLSPlaintextTBS.content_type) {\r\n            case application:\r\n              opaque application_data<0..2^32-1>;\r\n    \r\n            case proposal:\r\n              Proposal proposal;\r\n    \r\n            case commit:\r\n              Commit commit;\r\n        }\r\n\r\n        select (MLSPlaintextTBS.sender.sender_type) {\r\n            case member:\r\n                GroupContext context;\r\n    \r\n            case preconfigured:\r\n            case new_member:\r\n                struct{};\r\n        }\r\n    } MLSPlaintextTBS;\r\n\r\nWhat do you think about it?\r\n",
          "createdAt": "2021-12-16T13:18:46Z",
          "updatedAt": "2021-12-16T13:18:46Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "Nice one! Crafting collisions is probably not straightforward, but eliminating the the risk altogether is the way to go.",
          "createdAt": "2021-12-16T18:14:19Z",
          "updatedAt": "2021-12-16T18:14:19Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It is actually quite easy to craft collisions, I made a script do find them: https://github.com/TWal/TLSCollisionFinder\r\n(I wanted to check whether there was accidentally a way do disambiguate the structures)",
          "createdAt": "2021-12-18T18:52:00Z",
          "updatedAt": "2021-12-18T18:52:00Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4xtoAJ",
          "commit": {
            "abbreviatedOid": "666e267"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Great catch and a neat solution!",
          "createdAt": "2021-12-16T12:46:34Z",
          "updatedAt": "2021-12-16T12:46:34Z",
          "comments": []
        }
      ]
    },
    {
      "number": 527,
      "id": "PR_kwDOBoyH6c4v8na2",
      "title": "Stronger parent hashes for authenticated identities",
      "url": "https://github.com/mlswg/mls-protocol/pull/527",
      "state": "OPEN",
      "author": "TWal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Our proposal\r\n============\r\n\r\nThe parent hash construction currently authenticates only the public keys in the ratchet tree and does not protect other tree contents, notably the credentials at the leaves.\r\nConsequently, a malicious member can tamper with the credentials before sending a Welcome package to a new member, even if it cannot tamper with the public keys.\r\n\r\nInstead of using the tree resolution in the parent hash computation, we propose to use the tree hash.\r\n\r\nThe last time this was discussed on the list, it was agreed that it would be better to use tree hashes from a security point of view, but it was felt that complexity-wise that the recipient of a Welcome message would have to do O(n^2) work.\r\nA more thorough analysis shows that processing a Welcome message can be done in O(n*log(log(n))).\r\nThe result is that each signature captures the full tree contents including leaf credentials, which provides better authentication guarantees for member identities.\r\n\r\nEfficient algorithm to process a Commit\r\n=======================================\r\n\r\nWhen processing Commits, the implementation can store the tree hashes of every subtree.\r\nThat way, with n being the number of leaves, you can process each proposal in O(log(n)) and each UpdatePath in O(log(n)).\r\nThen you can check the parent hash when processing a Commit in O(p*log(n)) where p is the number of proposals.\r\n\r\nEfficient (enough) algorithm to process a Welcome\r\n=================================================\r\n\r\nWhen processing a Welcome message, we need to do the parent hash verification procedure.\r\nTo do it with the new parent hash, we need to compute tree hashes of subtrees at the last time they were updated.\r\nThis can be done using the following modified tree hash:\r\n\r\n    OldTreeHash(leaf, excluded_leaves) = Hash(leaf) if leaf not in excluded_leaves\r\n    OldTreeHash(leaf, excluded_leaves) = Hash(blank leaf) if leaf in excluded_leaves\r\n    OldTreeHash(node, excluded_leaves) = Hash(node.content | OldTreeHash(node.left, left_excluded_leaves) | OldTreeHash(node.right, right_excluded_leaves))\r\n    where left_excluded_leaves = leaves that are in excluded_leaves and in node.left (same for right_excluded_leaves).\r\n    and `excluded_leaves` are removed from `node.content.unmerged_leaves`.\r\n\r\nThen we can compute the parent hash for a node `N` with child `C` and sibling `S` using `OldTreeHash(S, N.content.unmerged_leaves)`: this old tree hash don't change when Adds are applied to the tree.\r\n\r\nIn the next paragraph, we will see that we can compute the parent hash for every node in `O(n*log(n))`.\r\n\r\nLet `h` be the height of the tree (so `h = log(n)`). There are `O(2^{h-i})` nodes at height `i`, and computing the parent hash for a node at height `i` is done in `O(2^i)`.\r\nHence, the complexity for the parent hash verification procedure is:\r\n\r\n      \\sum_{i=1}^h O(2^i 2^{h-i})\r\n    = \\sum_{i=1}^h O(2^h)\r\n    = O(h 2^h)\r\nAnd since `h = log(n)`, the complexity is `O(n*log(n))`.\r\n\r\nEfficient algorithm to process a Welcome\r\n========================================\r\n\r\nImagine we have the following tree:\r\n\r\n                  W\r\n            ______|______\r\n           /             \\\r\n          U               Y [E, G]\r\n        __|__           __|__\r\n       /     \\         /     \\\r\n      T       V       X [E]   Z [G, H]\r\n     / \\     / \\     / \\     / \\\r\n    A   B   C   D   E   F   G   H\r\n\r\nFor each node `N`, `OldTreeHash(N, excluded_leaves)` will be called with different values for `excluded_leaves`.\r\n\r\nFor example, if the sibling is always the right child, then:\r\n- `OldTreeHash(H, .)` will be called with 1 time with `. = [H]` (when computing the parent hash of `Z`) and 2 times with `. = []` (when computing the parent hash of `Y` and `W`)\r\n- `OldTreeHash(Z, .)` will be called with 1 time with `. = [G]` (when computing the parent hash of `Y`) and 1 time with `. = []` (when computing the parent hash of `W`)\r\n\r\nIf the sibling is always the left child, then:\r\n- `OldTreeHash(A, .)` will be called 3 times with `. = []` (when computing the parent hash of `T`, `U`, `W`)\r\n- `OldTreeHash(T, .)` will be called 2 times with `. = []` (when computing the parent hash of `U`, `W`)\r\n\r\nWe can see that some values are computed several times, which means that the whole computation could be sped up using memoization.\r\n\r\nTo estimate the speedup, we will estimate with how many values for `excluded_leaves` is called `OldTreeHash(N, .)` for each node `N`. Summing up these values will give a complexity, which will be `O(n*log(log(n)))`.\r\n\r\nLet `node.parent[k]` be the `k`th parent of `node`, and `node.leaves` be the set of leaves in the subtree rooted at `node`.\r\nThen, each call of `OldTreeHash(node, excluded_leaves)` will have `excluded_leaves = Intersection(node.parent[k].unmerged_leaves, node.leaves)` for some `k`.\r\nLet's note this set `excluded_leaves_k`.\r\nThe tree has the invariant that if `i <= j` then `excluded_leaves_j` is a subset of `excluded_leaves_i` (i.e. the sets `excluded_leaves_k` are decreasing).\r\n\r\nLet d be the depth of `node` (with the root being at depth 1). Then, the set `excluded_leaves_set := {excluded_leaves_1, ..., excluded_leaves_{d-1}}` corresponds to the values for `excluded_leaves` in the calls to `OldTreeHash(N, .)`.\r\n\r\nFirst bound: `|excluded_leaves_set| <= d-1 <= d` because it is defined using `d-1` values.\r\nSecond bound: `|excluded_leaves_set| <= 2^{h-d}+1` because `|excluded_leaves_0| <= 2^{h-d}` and the sets `excluded_leaves_k` are decreasing.\r\nTherefore: for a node at depth d, `|excluded_leaves_set| <= min(d, 2^{h-d}+1)`\r\n\r\nThe complexity to do the parent hash verification procedure is therefore in `O(sum_{i=1}^h 2^i min(i, 2^{h-i}+1))`.\r\n\r\nLet's estimate this complexity more explicitly:\r\n\r\n       sum_{i=1}^h 2^i min(i, 2^{h-i}+1)\r\n    <= (sum_{i=1}^t i 2^i) + (sum_{i=t+1}^h 2^i (2^{h-i}+1)) [for all t]\r\n    =  (2 (t-1) 2^t + 2) + ((h-t) 2^h + 2^{h+1} - 2^{t+1}) [for all t]\r\n\r\nFor the first inequality, we split the sum in two parts and use `min(i, 2^{h-i}+1) <= i` in the left part and `min(i, 2^{h-i}+1) <= 2^{h-i}+1` in the right part.\r\nFor the second equality, it can be derived using the formula for geometric sum.\r\n\r\nIf we take `t = h - log(h)`, we can compute that the left part is `O(2^h)` and the right part is `O(log(h)*2^h)`.\r\n\r\nTherefore, the parent hash verification procedure complexity is `O(log(h)*2^h) = O(n*log(log(n)))`.\r\n\r\nOne might say that adding memoization has a cost and isn't in O(1), but here it is: using the fact that `excluded_leaves_k` are decreasing, if you process the tree in a bottom-up or top-down way, you only have to compare the length of the current `excluded_leaves` to the length of the previous one, and it tells you if you need to recompute the tree hash.\r\n\r\nThe current parent hash is not super fast\r\n=========================================\r\n\r\nIn the worst case, if most internal nodes are blank, then computing the parent hash for a node is in O(size of its subtree), which give an O(n*log(n)) complexity as we saw in the section about the naive algorithm.\r\n\r\nWhen processing a Commit, if most of the internal nodes are blank, then computing the new parent hashes is in O(n) which is quite slow.",
      "createdAt": "2021-12-16T12:54:02Z",
      "updatedAt": "2021-12-16T18:28:54Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "6754a8edc9d77c902643d37a519b9a546ab00b4e",
      "headRepository": "TWal/mls-protocol",
      "headRefName": "twal_parent_hash",
      "headRefOid": "1b258b36729258c939a8cf43e07f21d1da32a9ce",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "@psyoptix Since you worked on this last, it would be great if you could have a look at this.",
          "createdAt": "2021-12-16T18:28:54Z",
          "updatedAt": "2021-12-16T18:28:54Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 529,
      "id": "PR_kwDOBoyH6c4v_0jh",
      "title": "Refactor Group Joining and fix External Inits",
      "url": "https://github.com/mlswg/mls-protocol/pull/529",
      "state": "OPEN",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR refactors the two sections on Group Joining (via Welcome and via External Init) by changing the `GroupInfo` struct that can be used for both cases. The `external_pub` used in the course of an External Init is added as an optional field. This PR also:\r\n\r\n- removes the redundant ProtocolVersion in the GroupInfo\r\n- adds a GroupInfoTBS struct to follow the convention of specifying a TBS struct for signed messages\r\n- implicitly, the `confirmed_transcript_hash` and `confirmation_tag` is now used for external inits instead of the `interim_transcript_hash`, which was not sufficient to create a valid commit",
      "createdAt": "2021-12-17T10:53:40Z",
      "updatedAt": "2021-12-17T10:59:26Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "6754a8edc9d77c902643d37a519b9a546ab00b4e",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "refactor_pgs_and_welcome",
      "headRefOid": "b970e193c9ef66a0e3cd7ae430cb0614924e27b5",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 532,
      "id": "PR_kwDOBoyH6c4wThM0",
      "title": "Get rid of explicit protocol version fields",
      "url": "https://github.com/mlswg/mls-protocol/pull/532",
      "state": "OPEN",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In all instances that I could find in the spec, the `ProtocolVersion` is redundant, as it appears alongside the `ciphersuite, which implies an MLS version. This PR thus removes explicit handling of MLS versions outside of ciphersuite concerns.",
      "createdAt": "2021-12-27T14:05:44Z",
      "updatedAt": "2021-12-27T14:08:36Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "6754a8edc9d77c902643d37a519b9a546ab00b4e",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "protocol-versions",
      "headRefOid": "6f5f452cf5eb07ae01d76487f99f44a30b5128bf",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 533,
      "id": "PR_kwDOBoyH6c4wj668",
      "title": "Fix typo in EncryptedGroupSecrets",
      "url": "https://github.com/mlswg/mls-protocol/pull/533",
      "state": "OPEN",
      "author": "TWal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR fixes a typo in `EncryptedGroupSecrets` introduced by PR #491 .",
      "createdAt": "2022-01-05T13:50:09Z",
      "updatedAt": "2022-01-05T13:50:09Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "6754a8edc9d77c902643d37a519b9a546ab00b4e",
      "headRepository": "TWal/mls-protocol",
      "headRefName": "twal_encrypted_group_secret_typo",
      "headRefOid": "930686892f16fe8d9ba48d043c6be3b9df0f1969",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    }
  ]
}